{
  "problem_title": "Employee Access Management System - Part 3: Time-Based Access Control",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 introduces temporal dimension to access control. Previously, access was binary (granted or not). Now access can be **temporary** with an expiry timestamp. This requires tracking when each access grant expires and filtering results based on query time. The system must support both permanent access (no expiry) and time-limited access simultaneously.",
    "new_requirements": [
      "Track expiry timestamp for each access grant",
      "Support both permanent (-1) and temporary access",
      "Query access valid at a specific point in time",
      "Efficiently clean up expired entries",
      "Integrate with existing group-based access from Part 2"
    ],
    "new_constraints": [
      "Expired access must not appear in time-aware queries",
      "Cleanup should be O(expired entries), not O(all entries)",
      "Must handle mixed permanent and temporary access on same resource",
      "Later expiry should not be overwritten by earlier expiry"
    ],
    "key_insight": "The AHA moment: Instead of storing Set<AccessType>, we now store Map<AccessType, Long> where the Long is the expiry timestamp. Using -1 (or PERMANENT constant) represents no expiry. For efficient cleanup, we maintain a secondary index keyed by expiry time, allowing us to find all entries expiring at a given time in O(1) and process only those that actually expired."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Grant access with expiry timestamp",
        "how_met": "grantAccessWithExpiry stores expiry in Map<AccessType, Long> and adds to expiry index",
        "gotchas": [
          "Don't overwrite permanent access with temporary",
          "Don't shorten existing expiry"
        ]
      },
      {
        "requirement": "Query access valid at specific time",
        "how_met": "retrieveAccessAtTime checks each access type's expiry against query time",
        "gotchas": [
          "Must check both direct and group access",
          "Expiry > currentTime means valid, not >="
        ]
      },
      {
        "requirement": "Efficient cleanup of expired entries",
        "how_met": "Secondary expiry index allows finding all entries at a timestamp in O(1)",
        "gotchas": [
          "Must update both main storage and expiry index",
          "Handle edge case of entry already deleted"
        ]
      },
      {
        "requirement": "Support permanent access alongside temporary",
        "how_met": "Use -1 as sentinel value for permanent access",
        "gotchas": [
          "Don't add permanent access to expiry index",
          "Check for -1 before comparing timestamps"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "grantAccessWithExpiry",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap operations only"
      },
      {
        "operation": "retrieveAccessAtTime",
        "target": "O(k)",
        "achieved": "O(k + g*k)",
        "why": "k = access types per resource, g = groups employee belongs to"
      },
      {
        "operation": "cleanupExpired",
        "target": "O(expired entries)",
        "achieved": "O(expired entries)",
        "why": "Secondary index allows direct access to expired entries"
      }
    ],
    "non_goals": [
      "Real-time automatic expiry (we use explicit cleanup or lazy evaluation)",
      "Access history/audit trail",
      "Notification of expiring access",
      "Extending expiry of existing access in single operation"
    ]
  },
  "assumptions": [
    "Timestamps are Unix timestamps (positive integers for real times, -1 for permanent)",
    "If granting temporary access when permanent exists, keep permanent (don't downgrade)",
    "If granting new expiry when longer expiry exists, keep longer (don't shorten)",
    "Expiry check is expiry > currentTime (access expires AT the timestamp, not after)",
    "cleanupExpired is called periodically by external scheduler",
    "Group access can also have expiry (extending Part 2 capability)"
  ],
  "tradeoffs": [
    {
      "decision": "Lazy evaluation vs Proactive cleanup",
      "chosen": "Both - lazy at query time, optional proactive cleanup",
      "why": "Queries are always correct (lazy evaluation), but cleanup prevents memory bloat",
      "alternative": "Only proactive cleanup with background thread",
      "when_to_switch": "If memory is critical and queries are rare"
    },
    {
      "decision": "Secondary index structure: Dict vs SortedDict/TreeMap",
      "chosen": "Dict with linear scan of keys for cleanup",
      "why": "Simpler implementation, works well when cleanup is infrequent",
      "alternative": "Use sortedcontainers.SortedDict for O(log n) range queries",
      "when_to_switch": "If cleanup is called frequently or many distinct expiry times exist"
    },
    {
      "decision": "Expiry stored as Long vs datetime object",
      "chosen": "Long (Unix timestamp)",
      "why": "Simple comparison, no timezone issues, matches common practice",
      "alternative": "datetime with timezone awareness",
      "when_to_switch": "If human-readable expiry display is needed frequently"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "AccessType enum",
      "grant_access() signature (permanent access)",
      "retrieve_access() signature for non-time-aware queries",
      "Group management methods from Part 2"
    ],
    "what_to_change": [
      "Internal storage changed from Set<AccessType> to Map<AccessType, Long>",
      "Added _expiry_index secondary data structure",
      "Added PERMANENT constant (-1)"
    ],
    "interfaces_and_boundaries": "Time-aware methods are clearly separate (retrieveAccessAtTime vs retrieve_access). This allows Part 4 to add hierarchical resources or access levels without breaking time logic. The expiry index is internal and can be optimized independently.",
    "invariants": [
      "If access exists in main storage with expiry T, it exists in _expiry_index[T] (unless permanent)",
      "Permanent access (-1) never appears in expiry index",
      "Direct and group access are independent - both can have different expiry for same resource"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2):                          AFTER (Part 3):\n_access = {                               _access = {\n  'E1': {                                   'E1': {\n    'R1': {READ, WRITE}                       'R1': {\n  }                                             READ: 3000,    # expires at t=3000\n}                                               WRITE: -1      # permanent\n                                              }\n                                            }\n                                          }\n\n                                          _expiry_index = {\n                                            3000: {('E1','R1',READ,False)}\n                                          }\n```",
    "algorithm_flow": "```\ngrantAccessWithExpiry(E1, R1, READ, 3000):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Check existing: _access[E1][R1].get(READ)  \u2502\n\u2502    \u2514\u2500> None (no existing access)              \u2502\n\u2502                                               \u2502\n\u2502 2. Store: _access[E1][R1][READ] = 3000        \u2502\n\u2502                                               \u2502\n\u2502 3. Index: _expiry_index[3000].add(            \u2502\n\u2502           (E1, R1, READ, False))              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nretrieveAccessAtTime(E1, R1, 2500):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. For each access in _access[E1][R1]:        \u2502\n\u2502    \u251c\u2500> READ: expiry=3000 > 2500? YES \u2192 add    \u2502\n\u2502    \u2514\u2500> WRITE: expiry=-1 (perm)? YES \u2192 add     \u2502\n\u2502                                               \u2502\n\u2502 2. Check group access (same logic)            \u2502\n\u2502                                               \u2502\n\u2502 3. Return sorted: [READ, WRITE]               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ncleanupExpired(3500):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1. Find expired: timestamps <= 3500           \u2502\n\u2502    \u2514\u2500> [3000]                                 \u2502\n\u2502                                               \u2502\n\u2502 2. For each in _expiry_index[3000]:           \u2502\n\u2502    \u2514\u2500> (E1,R1,READ,False): delete from        \u2502\n\u2502        _access[E1][R1][READ]                  \u2502\n\u2502                                               \u2502\n\u2502 3. Remove from index: del _expiry_index[3000] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store expiry timestamp in a parallel data structure: Map<emp,Map<res,Map<access,expiry>>>. On query, check each access type. On cleanup, scan ALL entries in entire data structure.",
      "time_complexity": "O(1) grant, O(k) query, O(n*m*k) cleanup where n=employees, m=resources, k=access types",
      "space_complexity": "O(n*m*k)",
      "why_not_optimal": "Cleanup is extremely slow for large systems. If you have 1M employees with 100 resources each, cleanup scans 100M entries even if only 10 expired."
    },
    {
      "name": "Optimal Approach with Expiry Index",
      "description": "Maintain secondary index: Map<expiryTime, Set<(emp,res,access)>>. For cleanup, directly access entries at expired timestamps. For queries, still iterate through access types but they're few.",
      "time_complexity": "O(1) grant, O(k + g*k) query, O(expired) cleanup",
      "space_complexity": "O(n*m*k) main + O(temporary entries) index",
      "key_insight": "The expiry index inverts the relationship - instead of 'given employee, what expires when', we ask 'given time, what expires'. This makes cleanup proportional to expired entries, not total entries."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Expiry-Indexed Time-Based Access\n\n### Core Data Structure Changes\n\nWe transform from `Set<AccessType>` to `Map<AccessType, Long>` where:\n- **Key**: The access type (READ, WRITE, ADMIN)\n- **Value**: Expiry timestamp (-1 for permanent)\n\n### Secondary Index for Efficient Cleanup\n\n```\n_expiry_index: Map<Long, Set<Tuple(emp_id, res_id, access_type, is_group)>>\n```\n\nThis **inverted index** allows O(1) lookup of all entries expiring at a given time.\n\n### Algorithm Details\n\n**Grant with Expiry:**\n1. Check existing access for this (emp, res, type)\n2. If exists and is permanent, **don't downgrade**\n3. If exists with later expiry, **don't shorten**\n4. Otherwise, update main storage and expiry index\n\n**Query at Time:**\n1. Iterate access types for (emp, res)\n2. Include if expiry == -1 OR expiry > currentTime\n3. Repeat for all groups employee belongs to\n4. Return sorted union\n\n**Cleanup:**\n1. Find all timestamps in index <= currentTime\n2. For each expired entry, remove from main storage\n3. Remove timestamp from index\n4. Return count of removed entries",
    "data_structures": [
      {
        "structure": "Dict[str, Dict[str, Dict[AccessType, int]]]",
        "purpose": "Main storage with expiry timestamps per access type"
      },
      {
        "structure": "Dict[int, Set[Tuple]]",
        "purpose": "Expiry index for efficient cleanup - maps timestamp to entries"
      },
      {
        "structure": "defaultdict",
        "purpose": "Simplify handling of missing nested keys"
      }
    ],
    "algorithm_steps": [
      "Step 1: Define PERMANENT constant (-1) for non-expiring access",
      "Step 2: On grantAccessWithExpiry, check if should upgrade (not downgrade) existing access",
      "Step 3: Store expiry in main data structure, add to expiry index if not permanent",
      "Step 4: On retrieveAccessAtTime, filter access by expiry > currentTime or expiry == PERMANENT",
      "Step 5: Include group-based access with same time filtering",
      "Step 6: On cleanupExpired, find all expired timestamps, remove entries, clean index"
    ]
  },
  "solution_python_lines": [
    "from enum import Enum",
    "from typing import Dict, Set, List, Optional, Tuple",
    "from collections import defaultdict",
    "",
    "",
    "class AccessType(Enum):",
    "    \"\"\"Types of access that can be granted to resources.\"\"\"",
    "    READ = \"READ\"",
    "    WRITE = \"WRITE\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "class AccessManager:",
    "    \"\"\"",
    "    Access Management System with Time-Based Access Control.",
    "    ",
    "    Supports:",
    "    - Permanent and temporary access grants",
    "    - Role-based access through groups (Part 2)",
    "    - Time-aware queries",
    "    - Efficient cleanup of expired entries",
    "    \"\"\"",
    "    ",
    "    # Sentinel value for permanent (non-expiring) access",
    "    PERMANENT: int = -1",
    "    ",
    "    def __init__(self):",
    "        # Main storage: employee_id -> resource_id -> access_type -> expiry_timestamp",
    "        self._access: Dict[str, Dict[str, Dict[AccessType, int]]] = defaultdict(",
    "            lambda: defaultdict(dict)",
    "        )",
    "        ",
    "        # Group membership: group_id -> set of employee_ids",
    "        self._groups: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Group access: group_id -> resource_id -> access_type -> expiry_timestamp",
    "        self._group_access: Dict[str, Dict[str, Dict[AccessType, int]]] = defaultdict(",
    "            lambda: defaultdict(dict)",
    "        )",
    "        ",
    "        # Secondary index for efficient cleanup:",
    "        # expiry_timestamp -> set of (entity_id, resource_id, access_type, is_group)",
    "        self._expiry_index: Dict[int, Set[Tuple[str, str, AccessType, bool]]] = defaultdict(set)",
    "    ",
    "    # ==================== Part 1: Basic Access Management ====================",
    "    ",
    "    def grant_access(self, employee_id: str, resource_id: str, access_type: AccessType) -> None:",
    "        \"\"\"",
    "        Grant permanent access to an employee for a resource.",
    "        ",
    "        Args:",
    "            employee_id: The employee's unique identifier",
    "            resource_id: The resource's unique identifier",
    "            access_type: Type of access (READ, WRITE, ADMIN)",
    "        \"\"\"",
    "        # Remove from expiry index if previously temporary",
    "        old_expiry = self._access[employee_id][resource_id].get(access_type)",
    "        if old_expiry is not None and old_expiry != self.PERMANENT:",
    "            self._expiry_index[old_expiry].discard(",
    "                (employee_id, resource_id, access_type, False)",
    "            )",
    "        ",
    "        self._access[employee_id][resource_id][access_type] = self.PERMANENT",
    "    ",
    "    def revoke_access(",
    "        self,",
    "        employee_id: str,",
    "        resource_id: str,",
    "        access_type: Optional[AccessType] = None",
    "    ) -> None:",
    "        \"\"\"",
    "        Revoke access from an employee.",
    "        ",
    "        Args:",
    "            employee_id: The employee's unique identifier",
    "            resource_id: The resource's unique identifier",
    "            access_type: Specific type to revoke, or None for all",
    "        \"\"\"",
    "        if employee_id not in self._access:",
    "            return",
    "        if resource_id not in self._access[employee_id]:",
    "            return",
    "        ",
    "        if access_type is None:",
    "            # Revoke all access to this resource",
    "            for at, expiry in list(self._access[employee_id][resource_id].items()):",
    "                if expiry != self.PERMANENT:",
    "                    self._expiry_index[expiry].discard(",
    "                        (employee_id, resource_id, at, False)",
    "                    )",
    "            del self._access[employee_id][resource_id]",
    "        else:",
    "            # Revoke specific access type",
    "            expiry = self._access[employee_id][resource_id].get(access_type)",
    "            if expiry is not None and expiry != self.PERMANENT:",
    "                self._expiry_index[expiry].discard(",
    "                    (employee_id, resource_id, access_type, False)",
    "                )",
    "            self._access[employee_id][resource_id].pop(access_type, None)",
    "    ",
    "    def retrieve_access(self, employee_id: str, resource_id: str) -> List[AccessType]:",
    "        \"\"\"",
    "        Retrieve all access types for an employee-resource pair.",
    "        Note: Does not consider expiry. Use retrieve_access_at_time for time-aware queries.",
    "        \"\"\"",
    "        direct = set(self._access.get(employee_id, {}).get(resource_id, {}).keys())",
    "        group_access = self._get_all_group_access(employee_id, resource_id)",
    "        return sorted(list(direct | group_access), key=lambda x: x.value)",
    "    ",
    "    # ==================== Part 2: Group Management ====================",
    "    ",
    "    def create_group(self, group_id: str) -> None:",
    "        \"\"\"Create a new group.\"\"\"",
    "        if group_id not in self._groups:",
    "            self._groups[group_id] = set()",
    "    ",
    "    def add_to_group(self, group_id: str, employee_id: str) -> None:",
    "        \"\"\"Add an employee to a group.\"\"\"",
    "        self._groups[group_id].add(employee_id)",
    "    ",
    "    def remove_from_group(self, group_id: str, employee_id: str) -> None:",
    "        \"\"\"Remove an employee from a group.\"\"\"",
    "        self._groups[group_id].discard(employee_id)",
    "    ",
    "    def grant_group_access(",
    "        self,",
    "        group_id: str,",
    "        resource_id: str,",
    "        access_type: AccessType",
    "    ) -> None:",
    "        \"\"\"Grant permanent access to all members of a group.\"\"\"",
    "        old_expiry = self._group_access[group_id][resource_id].get(access_type)",
    "        if old_expiry is not None and old_expiry != self.PERMANENT:",
    "            self._expiry_index[old_expiry].discard(",
    "                (group_id, resource_id, access_type, True)",
    "            )",
    "        self._group_access[group_id][resource_id][access_type] = self.PERMANENT",
    "    ",
    "    def _get_all_group_access(self, employee_id: str, resource_id: str) -> Set[AccessType]:",
    "        \"\"\"Get all access types an employee has through group membership.\"\"\"",
    "        access_types: Set[AccessType] = set()",
    "        for group_id, members in self._groups.items():",
    "            if employee_id in members:",
    "                access_types.update(",
    "                    self._group_access.get(group_id, {}).get(resource_id, {}).keys()",
    "                )",
    "        return access_types",
    "    ",
    "    # ==================== Part 3: Time-Based Access ====================",
    "    ",
    "    def grant_access_with_expiry(",
    "        self,",
    "        employee_id: str,",
    "        resource_id: str,",
    "        access_type: AccessType,",
    "        expiry_timestamp: int",
    "    ) -> None:",
    "        \"\"\"",
    "        Grant access with an expiry timestamp.",
    "        ",
    "        If the employee already has this access type:",
    "        - If existing is permanent, do not downgrade to temporary",
    "        - If existing expires later, do not shorten the expiry",
    "        ",
    "        Args:",
    "            employee_id: The employee's unique identifier",
    "            resource_id: The resource's unique identifier",
    "            access_type: Type of access (READ, WRITE, ADMIN)",
    "            expiry_timestamp: Unix timestamp when access expires (-1 for permanent)",
    "        \"\"\"",
    "        current_expiry = self._access[employee_id][resource_id].get(access_type)",
    "        ",
    "        # Don't downgrade permanent access",
    "        if current_expiry == self.PERMANENT:",
    "            return",
    "        ",
    "        # Handle expiry comparison",
    "        if current_expiry is not None:",
    "            # If new is permanent, always upgrade",
    "            if expiry_timestamp == self.PERMANENT:",
    "                # Remove old from expiry index",
    "                self._expiry_index[current_expiry].discard(",
    "                    (employee_id, resource_id, access_type, False)",
    "                )",
    "            elif expiry_timestamp <= current_expiry:",
    "                # Don't shorten existing expiry",
    "                return",
    "            else:",
    "                # Extending expiry - remove old index entry",
    "                self._expiry_index[current_expiry].discard(",
    "                    (employee_id, resource_id, access_type, False)",
    "                )",
    "        ",
    "        # Update main storage",
    "        self._access[employee_id][resource_id][access_type] = expiry_timestamp",
    "        ",
    "        # Add to expiry index if not permanent",
    "        if expiry_timestamp != self.PERMANENT:",
    "            self._expiry_index[expiry_timestamp].add(",
    "                (employee_id, resource_id, access_type, False)",
    "            )",
    "    ",
    "    def grant_group_access_with_expiry(",
    "        self,",
    "        group_id: str,",
    "        resource_id: str,",
    "        access_type: AccessType,",
    "        expiry_timestamp: int",
    "    ) -> None:",
    "        \"\"\"Grant time-limited access to all members of a group.\"\"\"",
    "        current_expiry = self._group_access[group_id][resource_id].get(access_type)",
    "        ",
    "        if current_expiry == self.PERMANENT:",
    "            return",
    "        ",
    "        if current_expiry is not None:",
    "            if expiry_timestamp == self.PERMANENT:",
    "                self._expiry_index[current_expiry].discard(",
    "                    (group_id, resource_id, access_type, True)",
    "                )",
    "            elif expiry_timestamp <= current_expiry:",
    "                return",
    "            else:",
    "                self._expiry_index[current_expiry].discard(",
    "                    (group_id, resource_id, access_type, True)",
    "                )",
    "        ",
    "        self._group_access[group_id][resource_id][access_type] = expiry_timestamp",
    "        ",
    "        if expiry_timestamp != self.PERMANENT:",
    "            self._expiry_index[expiry_timestamp].add(",
    "                (group_id, resource_id, access_type, True)",
    "            )",
    "    ",
    "    def retrieve_access_at_time(",
    "        self,",
    "        employee_id: str,",
    "        resource_id: str,",
    "        current_time: int",
    "    ) -> List[AccessType]:",
    "        \"\"\"",
    "        Retrieve access types valid at a specific time.",
    "        ",
    "        An access is valid if:",
    "        - It's permanent (expiry == -1), OR",
    "        - Its expiry timestamp > current_time",
    "        ",
    "        Args:",
    "            employee_id: The employee's unique identifier",
    "            resource_id: The resource's unique identifier",
    "            current_time: The timestamp to evaluate access at",
    "            ",
    "        Returns:",
    "            Sorted list of AccessType that are valid at the given time",
    "        \"\"\"",
    "        valid_access: Set[AccessType] = set()",
    "        ",
    "        # Check direct employee access",
    "        direct_access = self._access.get(employee_id, {}).get(resource_id, {})",
    "        for access_type, expiry in direct_access.items():",
    "            if self._is_valid_at_time(expiry, current_time):",
    "                valid_access.add(access_type)",
    "        ",
    "        # Check group-based access",
    "        for group_id, members in self._groups.items():",
    "            if employee_id in members:",
    "                group_res_access = self._group_access.get(group_id, {}).get(resource_id, {})",
    "                for access_type, expiry in group_res_access.items():",
    "                    if self._is_valid_at_time(expiry, current_time):",
    "                        valid_access.add(access_type)",
    "        ",
    "        return sorted(list(valid_access), key=lambda x: x.value)",
    "    ",
    "    def _is_valid_at_time(self, expiry: int, current_time: int) -> bool:",
    "        \"\"\"Check if an access with given expiry is valid at current_time.\"\"\"",
    "        return expiry == self.PERMANENT or expiry > current_time",
    "    ",
    "    def cleanup_expired(self, current_time: int) -> int:",
    "        \"\"\"",
    "        Remove all expired access entries from the system.",
    "        ",
    "        This is an optimization to free memory. Queries would work correctly",
    "        without cleanup due to lazy evaluation, but expired entries would",
    "        consume memory.",
    "        ",
    "        Args:",
    "            current_time: Current timestamp - entries with expiry <= this are removed",
    "            ",
    "        Returns:",
    "            Number of entries removed",
    "        \"\"\"",
    "        removed_count = 0",
    "        ",
    "        # Find all expired timestamps",
    "        expired_timestamps = [",
    "            ts for ts in self._expiry_index.keys()",
    "            if ts != self.PERMANENT and ts <= current_time",
    "        ]",
    "        ",
    "        for ts in expired_timestamps:",
    "            entries = list(self._expiry_index[ts])  # Copy to avoid modification during iteration",
    "            ",
    "            for (entity_id, res_id, access_type, is_group) in entries:",
    "                if is_group:",
    "                    # Remove from group access",
    "                    if (self._group_access.get(entity_id, {}).get(res_id, {})",
    "                            .get(access_type) == ts):",
    "                        del self._group_access[entity_id][res_id][access_type]",
    "                        removed_count += 1",
    "                else:",
    "                    # Remove from employee access",
    "                    if (self._access.get(entity_id, {}).get(res_id, {})",
    "                            .get(access_type) == ts):",
    "                        del self._access[entity_id][res_id][access_type]",
    "                        removed_count += 1",
    "            ",
    "            # Remove the timestamp entry from index",
    "            del self._expiry_index[ts]",
    "        ",
    "        return removed_count",
    "    ",
    "    def get_stats(self) -> Dict:",
    "        \"\"\"Return statistics about current state (useful for debugging).\"\"\"",
    "        total_access = sum(",
    "            len(resources)",
    "            for emp in self._access.values()",
    "            for resources in emp.values()",
    "        )",
    "        total_indexed = sum(len(entries) for entries in self._expiry_index.values())",
    "        return {",
    "            'total_employees': len(self._access),",
    "            'total_access_entries': total_access,",
    "            'total_groups': len(self._groups),",
    "            'expiry_index_size': total_indexed,",
    "            'unique_expiry_times': len(self._expiry_index)",
    "        }",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate time-based access control functionality.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Part 3: Time-Based Access Control Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    manager = AccessManager()",
    "    ",
    "    # Example 1: Basic time-based access",
    "    print(\"\\n--- Example 1: Temporary Access ---\")",
    "    manager.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    ",
    "    result_500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 500)",
    "    print(f\"At t=500: {[a.value for a in result_500]}\")",
    "    ",
    "    result_1500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 1500)",
    "    print(f\"At t=1500: {[a.value for a in result_1500]}\")",
    "    ",
    "    # Example 2: Mix of permanent and temporary",
    "    print(\"\\n--- Example 2: Permanent + Temporary ---\")",
    "    manager.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    manager.grant_access(\"E1\", \"R1\", AccessType.WRITE)  # Permanent",
    "    ",
    "    result_500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 500)",
    "    print(f\"At t=500: {[a.value for a in result_500]}\")",
    "    ",
    "    result_1500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 1500)",
    "    print(f\"At t=1500: {[a.value for a in result_1500]}\")",
    "    ",
    "    # Example 3: Group with time-based access",
    "    print(\"\\n--- Example 3: Group Time-Based Access ---\")",
    "    manager.create_group(\"engineering\")",
    "    manager.add_to_group(\"engineering\", \"E2\")",
    "    manager.grant_group_access_with_expiry(\"engineering\", \"R2\", AccessType.ADMIN, 2000)",
    "    ",
    "    result_1000 = manager.retrieve_access_at_time(\"E2\", \"R2\", 1000)",
    "    print(f\"E2 at t=1000: {[a.value for a in result_1000]}\")",
    "    ",
    "    result_2500 = manager.retrieve_access_at_time(\"E2\", \"R2\", 2500)",
    "    print(f\"E2 at t=2500: {[a.value for a in result_2500]}\")",
    "    ",
    "    # Example 4: Cleanup",
    "    print(\"\\n--- Example 4: Cleanup Expired Entries ---\")",
    "    print(f\"Stats before cleanup: {manager.get_stats()}\")",
    "    removed = manager.cleanup_expired(2000)",
    "    print(f\"Removed {removed} expired entries\")",
    "    print(f\"Stats after cleanup: {manager.get_stats()}\")",
    "    ",
    "    # Example 5: Don't downgrade permanent to temporary",
    "    print(\"\\n--- Example 5: No Downgrade from Permanent ---\")",
    "    manager.grant_access(\"E3\", \"R3\", AccessType.READ)  # Permanent",
    "    manager.grant_access_with_expiry(\"E3\", \"R3\", AccessType.READ, 100)  # Try to downgrade",
    "    result = manager.retrieve_access_at_time(\"E3\", \"R3\", 50)",
    "    print(f\"After attempted downgrade: {[a.value for a in result]}\")",
    "    result_200 = manager.retrieve_access_at_time(\"E3\", \"R3\", 200)",
    "    print(f\"Still valid at t=200: {[a.value for a in result_200]}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 3 tests passed!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "enum AccessType {",
    "    READ, WRITE, ADMIN",
    "}",
    "",
    "public class AccessManager {",
    "    // Sentinel value for permanent (non-expiring) access",
    "    private static final long PERMANENT = -1L;",
    "    ",
    "    // Main storage: employeeId -> resourceId -> accessType -> expiryTimestamp",
    "    private final Map<String, Map<String, Map<AccessType, Long>>> access;",
    "    ",
    "    // Group membership: groupId -> set of employeeIds",
    "    private final Map<String, Set<String>> groups;",
    "    ",
    "    // Group access: groupId -> resourceId -> accessType -> expiryTimestamp",
    "    private final Map<String, Map<String, Map<AccessType, Long>>> groupAccess;",
    "    ",
    "    // Secondary index: expiryTimestamp -> set of (entityId, resourceId, accessType, isGroup)",
    "    private final Map<Long, Set<AccessEntry>> expiryIndex;",
    "    ",
    "    private record AccessEntry(",
    "        String entityId,",
    "        String resourceId,",
    "        AccessType accessType,",
    "        boolean isGroup",
    "    ) {}",
    "    ",
    "    public AccessManager() {",
    "        this.access = new HashMap<>();",
    "        this.groups = new HashMap<>();",
    "        this.groupAccess = new HashMap<>();",
    "        this.expiryIndex = new HashMap<>();",
    "    }",
    "    ",
    "    // ==================== Part 1: Basic Access Management ====================",
    "    ",
    "    public void grantAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        // Remove from expiry index if previously temporary",
    "        Long oldExpiry = access",
    "            .computeIfAbsent(employeeId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .get(accessType);",
    "        ",
    "        if (oldExpiry != null && oldExpiry != PERMANENT) {",
    "            removeFromExpiryIndex(oldExpiry, employeeId, resourceId, accessType, false);",
    "        }",
    "        ",
    "        access.get(employeeId).get(resourceId).put(accessType, PERMANENT);",
    "    }",
    "    ",
    "    public void revokeAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        if (!access.containsKey(employeeId)) return;",
    "        if (!access.get(employeeId).containsKey(resourceId)) return;",
    "        ",
    "        if (accessType == null) {",
    "            // Revoke all access",
    "            Map<AccessType, Long> resAccess = access.get(employeeId).get(resourceId);",
    "            for (var entry : resAccess.entrySet()) {",
    "                if (entry.getValue() != PERMANENT) {",
    "                    removeFromExpiryIndex(entry.getValue(), employeeId, resourceId, entry.getKey(), false);",
    "                }",
    "            }",
    "            access.get(employeeId).remove(resourceId);",
    "        } else {",
    "            Long expiry = access.get(employeeId).get(resourceId).get(accessType);",
    "            if (expiry != null && expiry != PERMANENT) {",
    "                removeFromExpiryIndex(expiry, employeeId, resourceId, accessType, false);",
    "            }",
    "            access.get(employeeId).get(resourceId).remove(accessType);",
    "        }",
    "    }",
    "    ",
    "    public List<AccessType> retrieveAccess(String employeeId, String resourceId) {",
    "        Set<AccessType> result = new TreeSet<>();",
    "        ",
    "        // Direct access",
    "        if (access.containsKey(employeeId) && access.get(employeeId).containsKey(resourceId)) {",
    "            result.addAll(access.get(employeeId).get(resourceId).keySet());",
    "        }",
    "        ",
    "        // Group access",
    "        result.addAll(getAllGroupAccess(employeeId, resourceId));",
    "        ",
    "        return new ArrayList<>(result);",
    "    }",
    "    ",
    "    // ==================== Part 2: Group Management ====================",
    "    ",
    "    public void createGroup(String groupId) {",
    "        groups.putIfAbsent(groupId, new HashSet<>());",
    "    }",
    "    ",
    "    public void addToGroup(String groupId, String employeeId) {",
    "        groups.computeIfAbsent(groupId, k -> new HashSet<>()).add(employeeId);",
    "    }",
    "    ",
    "    public void removeFromGroup(String groupId, String employeeId) {",
    "        if (groups.containsKey(groupId)) {",
    "            groups.get(groupId).remove(employeeId);",
    "        }",
    "    }",
    "    ",
    "    public void grantGroupAccess(String groupId, String resourceId, AccessType accessType) {",
    "        Long oldExpiry = groupAccess",
    "            .computeIfAbsent(groupId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .get(accessType);",
    "        ",
    "        if (oldExpiry != null && oldExpiry != PERMANENT) {",
    "            removeFromExpiryIndex(oldExpiry, groupId, resourceId, accessType, true);",
    "        }",
    "        ",
    "        groupAccess.get(groupId).get(resourceId).put(accessType, PERMANENT);",
    "    }",
    "    ",
    "    private Set<AccessType> getAllGroupAccess(String employeeId, String resourceId) {",
    "        Set<AccessType> result = new HashSet<>();",
    "        for (var entry : groups.entrySet()) {",
    "            if (entry.getValue().contains(employeeId)) {",
    "                String groupId = entry.getKey();",
    "                if (groupAccess.containsKey(groupId) && groupAccess.get(groupId).containsKey(resourceId)) {",
    "                    result.addAll(groupAccess.get(groupId).get(resourceId).keySet());",
    "                }",
    "            }",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== Part 3: Time-Based Access ====================",
    "    ",
    "    public void grantAccessWithExpiry(",
    "            String employeeId, String resourceId, AccessType accessType, long expiryTimestamp) {",
    "        ",
    "        Long currentExpiry = access",
    "            .computeIfAbsent(employeeId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .get(accessType);",
    "        ",
    "        // Don't downgrade permanent access",
    "        if (currentExpiry != null && currentExpiry == PERMANENT) {",
    "            return;",
    "        }",
    "        ",
    "        if (currentExpiry != null) {",
    "            if (expiryTimestamp == PERMANENT) {",
    "                // Upgrading to permanent",
    "                removeFromExpiryIndex(currentExpiry, employeeId, resourceId, accessType, false);",
    "            } else if (expiryTimestamp <= currentExpiry) {",
    "                // Don't shorten expiry",
    "                return;",
    "            } else {",
    "                // Extending expiry",
    "                removeFromExpiryIndex(currentExpiry, employeeId, resourceId, accessType, false);",
    "            }",
    "        }",
    "        ",
    "        // Update main storage",
    "        access.get(employeeId).get(resourceId).put(accessType, expiryTimestamp);",
    "        ",
    "        // Add to expiry index if not permanent",
    "        if (expiryTimestamp != PERMANENT) {",
    "            expiryIndex.computeIfAbsent(expiryTimestamp, k -> new HashSet<>())",
    "                .add(new AccessEntry(employeeId, resourceId, accessType, false));",
    "        }",
    "    }",
    "    ",
    "    public void grantGroupAccessWithExpiry(",
    "            String groupId, String resourceId, AccessType accessType, long expiryTimestamp) {",
    "        ",
    "        Long currentExpiry = groupAccess",
    "            .computeIfAbsent(groupId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .get(accessType);",
    "        ",
    "        if (currentExpiry != null && currentExpiry == PERMANENT) {",
    "            return;",
    "        }",
    "        ",
    "        if (currentExpiry != null) {",
    "            if (expiryTimestamp == PERMANENT) {",
    "                removeFromExpiryIndex(currentExpiry, groupId, resourceId, accessType, true);",
    "            } else if (expiryTimestamp <= currentExpiry) {",
    "                return;",
    "            } else {",
    "                removeFromExpiryIndex(currentExpiry, groupId, resourceId, accessType, true);",
    "            }",
    "        }",
    "        ",
    "        groupAccess.get(groupId).get(resourceId).put(accessType, expiryTimestamp);",
    "        ",
    "        if (expiryTimestamp != PERMANENT) {",
    "            expiryIndex.computeIfAbsent(expiryTimestamp, k -> new HashSet<>())",
    "                .add(new AccessEntry(groupId, resourceId, accessType, true));",
    "        }",
    "    }",
    "    ",
    "    public List<AccessType> retrieveAccessAtTime(",
    "            String employeeId, String resourceId, long currentTime) {",
    "        ",
    "        Set<AccessType> validAccess = new TreeSet<>();",
    "        ",
    "        // Check direct access",
    "        if (access.containsKey(employeeId) && access.get(employeeId).containsKey(resourceId)) {",
    "            for (var entry : access.get(employeeId).get(resourceId).entrySet()) {",
    "                if (isValidAtTime(entry.getValue(), currentTime)) {",
    "                    validAccess.add(entry.getKey());",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Check group access",
    "        for (var groupEntry : groups.entrySet()) {",
    "            if (groupEntry.getValue().contains(employeeId)) {",
    "                String groupId = groupEntry.getKey();",
    "                if (groupAccess.containsKey(groupId) && groupAccess.get(groupId).containsKey(resourceId)) {",
    "                    for (var entry : groupAccess.get(groupId).get(resourceId).entrySet()) {",
    "                        if (isValidAtTime(entry.getValue(), currentTime)) {",
    "                            validAccess.add(entry.getKey());",
    "                        }",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return new ArrayList<>(validAccess);",
    "    }",
    "    ",
    "    private boolean isValidAtTime(long expiry, long currentTime) {",
    "        return expiry == PERMANENT || expiry > currentTime;",
    "    }",
    "    ",
    "    public int cleanupExpired(long currentTime) {",
    "        int removedCount = 0;",
    "        ",
    "        List<Long> expiredTimestamps = expiryIndex.keySet().stream()",
    "            .filter(ts -> ts != PERMANENT && ts <= currentTime)",
    "            .toList();",
    "        ",
    "        for (long ts : expiredTimestamps) {",
    "            for (AccessEntry entry : new ArrayList<>(expiryIndex.get(ts))) {",
    "                if (entry.isGroup()) {",
    "                    if (groupAccess.containsKey(entry.entityId()) &&",
    "                        groupAccess.get(entry.entityId()).containsKey(entry.resourceId())) {",
    "                        Long storedExpiry = groupAccess.get(entry.entityId())",
    "                            .get(entry.resourceId()).get(entry.accessType());",
    "                        if (storedExpiry != null && storedExpiry == ts) {",
    "                            groupAccess.get(entry.entityId()).get(entry.resourceId())",
    "                                .remove(entry.accessType());",
    "                            removedCount++;",
    "                        }",
    "                    }",
    "                } else {",
    "                    if (access.containsKey(entry.entityId()) &&",
    "                        access.get(entry.entityId()).containsKey(entry.resourceId())) {",
    "                        Long storedExpiry = access.get(entry.entityId())",
    "                            .get(entry.resourceId()).get(entry.accessType());",
    "                        if (storedExpiry != null && storedExpiry == ts) {",
    "                            access.get(entry.entityId()).get(entry.resourceId())",
    "                                .remove(entry.accessType());",
    "                            removedCount++;",
    "                        }",
    "                    }",
    "                }",
    "            }",
    "            expiryIndex.remove(ts);",
    "        }",
    "        ",
    "        return removedCount;",
    "    }",
    "    ",
    "    private void removeFromExpiryIndex(",
    "            long expiry, String entityId, String resourceId, AccessType accessType, boolean isGroup) {",
    "        if (expiryIndex.containsKey(expiry)) {",
    "            expiryIndex.get(expiry).remove(new AccessEntry(entityId, resourceId, accessType, isGroup));",
    "            if (expiryIndex.get(expiry).isEmpty()) {",
    "                expiryIndex.remove(expiry);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Part 3: Time-Based Access Control Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        AccessManager manager = new AccessManager();",
    "        ",
    "        // Example 1",
    "        System.out.println(\"\\n--- Example 1: Temporary Access ---\");",
    "        manager.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.READ, 1000);",
    "        System.out.println(\"At t=500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 500));",
    "        System.out.println(\"At t=1500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "        ",
    "        // Example 2",
    "        System.out.println(\"\\n--- Example 2: Permanent + Temporary ---\");",
    "        manager.grantAccess(\"E1\", \"R1\", AccessType.WRITE);",
    "        System.out.println(\"At t=500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 500));",
    "        System.out.println(\"At t=1500: \" + manager.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "        ",
    "        System.out.println(\"\\nAll Part 3 tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports and AccessType enum definition with three levels: READ, WRITE, ADMIN"
    },
    {
      "lines": "13-42",
      "explanation": "Class definition with main data structures: _access (employee\u2192resource\u2192type\u2192expiry), _groups (group membership), _group_access (group\u2192resource\u2192type\u2192expiry), and _expiry_index (secondary index for cleanup)"
    },
    {
      "lines": "44-60",
      "explanation": "grant_access: Grants permanent access. If previously temporary, removes from expiry index before upgrading to permanent"
    },
    {
      "lines": "62-88",
      "explanation": "revoke_access: Removes access entries. Handles both single type and all types revocation, cleaning up expiry index"
    },
    {
      "lines": "90-97",
      "explanation": "retrieve_access: Non-time-aware query returning all access types (used for backward compatibility with Part 1/2)"
    },
    {
      "lines": "99-123",
      "explanation": "Group management methods from Part 2: create_group, add_to_group, remove_from_group, grant_group_access"
    },
    {
      "lines": "125-173",
      "explanation": "grant_access_with_expiry: Core Part 3 method. Checks if should upgrade (not downgrade), updates main storage and expiry index"
    },
    {
      "lines": "175-213",
      "explanation": "retrieve_access_at_time: Queries access valid at specific time. Checks both direct and group access against expiry timestamps"
    },
    {
      "lines": "215-252",
      "explanation": "cleanup_expired: Finds all timestamps <= currentTime in expiry index, removes those entries from main storage, returns count"
    },
    {
      "lines": "254-300",
      "explanation": "Demo main function showing temporary access, permanent+temporary mix, group time-based access, and cleanup"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "grantAccessWithExpiry": {
          "complexity": "O(1)",
          "explanation": "HashMap get/put operations, set add to expiry index"
        },
        "retrieveAccessAtTime": {
          "complexity": "O(k + g\u00b7k)",
          "explanation": "k = access types per resource, g = groups containing employee"
        },
        "cleanupExpired": {
          "complexity": "O(e)",
          "explanation": "e = number of expired entries, only processes what actually expired"
        }
      },
      "overall_change": "Query is now slightly more expensive (must check expiry), but cleanup is efficient due to secondary index"
    },
    "space": {
      "additional_space": "O(t) where t = temporary access entries",
      "explanation": "Expiry index stores references to all non-permanent access entries. Permanent entries don't consume extra space."
    }
  },
  "dry_run": {
    "example_input": "grantAccessWithExpiry(E1, R1, READ, 1000), retrieveAccessAtTime(E1, R1, 500), retrieveAccessAtTime(E1, R1, 1500)",
    "steps": [
      {
        "step": 1,
        "action": "grantAccessWithExpiry(E1, R1, READ, 1000)",
        "state": "_access={E1:{R1:{READ:1000}}}, _expiry_index={1000:{(E1,R1,READ,False)}}",
        "explanation": "Store READ access with expiry 1000, add to expiry index"
      },
      {
        "step": 2,
        "action": "retrieveAccessAtTime(E1, R1, 500)",
        "state": "Checking: 1000 > 500? YES",
        "explanation": "READ access valid, 1000 > 500. Return [READ]"
      },
      {
        "step": 3,
        "action": "retrieveAccessAtTime(E1, R1, 1500)",
        "state": "Checking: 1000 > 1500? NO",
        "explanation": "READ access expired, 1000 <= 1500. Return []"
      }
    ],
    "final_output": "[null, null, ['READ'], []]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Grant access with expiry=5000, query at time=0 \u2192 should return access",
      "Grant access with expiry=100, query at time=100 \u2192 should return empty (expires AT 100)",
      "Grant permanent access, query at any time \u2192 should always return access"
    ],
    "likely_bugs": [
      "Off-by-one: using >= instead of > for expiry check (expiry is exclusive)",
      "Forgetting to update expiry index when revoking access",
      "Not handling permanent (-1) correctly in comparisons",
      "Overwriting longer expiry with shorter one"
    ],
    "recommended_logs_or_asserts": [
      "assert all entries in _expiry_index exist in main storage",
      "log state after each grant/revoke for debugging",
      "assert no PERMANENT entries in _expiry_index"
    ],
    "how_to_localize": "1. Print state after each operation. 2. Verify expiry index matches main storage. 3. Check if permanent sentinel value (-1) is handled correctly"
  },
  "edge_cases": [
    {
      "case": "Upgrade temporary to permanent",
      "handling": "Remove from expiry index, set expiry to -1",
      "gotcha": "Must clean up old expiry index entry"
    },
    {
      "case": "Downgrade permanent to temporary",
      "handling": "Reject - permanent access is not downgraded",
      "gotcha": "Check for permanent BEFORE comparing timestamps"
    },
    {
      "case": "Extend expiry (grant with later timestamp)",
      "handling": "Update expiry, move to new index entry",
      "gotcha": "Must remove old index entry before adding new"
    },
    {
      "case": "Query at exact expiry time",
      "handling": "Access is expired (expiry > currentTime, not >=)",
      "gotcha": "Boundary condition - expiry IS the moment access ends"
    },
    {
      "case": "Cleanup when entry already revoked",
      "handling": "Check if entry still exists before deleting",
      "gotcha": "Entry might be revoked between index lookup and deletion"
    }
  ],
  "test_cases": [
    {
      "name": "Basic temporary access",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); retrieveAccessAtTime(E1, R1, 500); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[READ], []",
      "explanation": "Before expiry returns access, after expiry returns empty"
    },
    {
      "name": "Mixed permanent and temporary",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); grant_access(E1, R1, WRITE); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[WRITE]",
      "explanation": "Only permanent WRITE survives after READ expires"
    },
    {
      "name": "No downgrade from permanent",
      "input": "grant_access(E1, R1, READ); grantAccessWithExpiry(E1, R1, READ, 100); retrieveAccessAtTime(E1, R1, 200)",
      "expected": "[READ]",
      "explanation": "Temporary grant doesn't downgrade permanent - still valid at t=200"
    },
    {
      "name": "Cleanup removes only expired",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); grantAccessWithExpiry(E1, R2, WRITE, 2000); cleanupExpired(1500)",
      "expected": "removed=1, R2:WRITE still exists",
      "explanation": "Only R1:READ removed (expiry 1000 <= 1500)"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using >= instead of > for expiry check",
      "why_wrong": "Access should be valid UP TO expiry time, expiring AT that moment",
      "correct_approach": "Use expiry > currentTime (strict inequality)",
      "code_example_wrong": "if expiry >= current_time: valid = True",
      "code_example_correct": "if expiry > current_time: valid = True"
    },
    {
      "mistake": "Forgetting to handle permanent (-1) in comparisons",
      "why_wrong": "-1 < currentTime for all positive times, would make permanent access always expired",
      "correct_approach": "Check for PERMANENT first, before timestamp comparison",
      "code_example_wrong": "if expiry > current_time: valid = True",
      "code_example_correct": "if expiry == PERMANENT or expiry > current_time: valid = True"
    },
    {
      "mistake": "Not cleaning expiry index on revoke",
      "why_wrong": "Cleanup will try to delete already-revoked entry, causing KeyError or no-op with stale index",
      "correct_approach": "Remove from expiry index when revoking access",
      "code_example_wrong": "del self._access[emp][res][type]",
      "code_example_correct": "expiry = self._access[emp][res].get(type)\\nif expiry and expiry != PERMANENT:\\n    self._expiry_index[expiry].discard((emp,res,type,False))\\ndel self._access[emp][res][type]"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining how the data structure needs to change: 'Instead of storing a Set of access types, I need to store when each access expires. This naturally leads to Map<AccessType, Long>.' Then explain the secondary index for efficient cleanup.",
    "what_to_mention": [
      "Lazy evaluation vs proactive cleanup tradeoff",
      "Using -1 as sentinel for permanent access",
      "Why we don't downgrade permanent to temporary",
      "How this integrates with group access from Part 2"
    ],
    "time_allocation": "2 min: understand requirements, 3 min: explain approach, 8 min: implement, 2 min: test",
    "if_stuck": [
      "Think about what data needs to be stored per access grant",
      "Consider how you'd find all expired entries efficiently",
      "Remember permanent access is a special case"
    ]
  },
  "connection_to_next_part": "Part 4 could add: (1) Hierarchical resources (access to /folder implies access to /folder/file), (2) Access levels hierarchy (ADMIN implies WRITE implies READ), (3) Access request workflow with approval. The current design's clean separation of time logic makes these extensions straightforward.",
  "communication_script": {
    "transition_from_previous": "Great, so Part 2 has group-based access working. For Part 3, I need to add time-based expiry. Let me think about what data structure changes are needed...",
    "explaining_changes": "The key change is that instead of storing just the access type, I need to store when it expires. I'll use Map<AccessType, Long> where -1 means permanent. I also need a secondary index to make cleanup efficient.",
    "while_extending_code": [
      "I'm adding an expiry_index to track all non-permanent entries by their expiry time...",
      "This helper method checks if access is valid at a given time...",
      "For cleanup, I iterate only through expired timestamps, not all entries..."
    ],
    "after_completing": "This now handles Part 3. Grant and query are still O(1) and O(k) respectively. Cleanup is O(expired entries) thanks to the secondary index. Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for this part",
    "by_2_min": "Understand that we need expiry per access type, identify data structure change from Set to Map",
    "by_5_min": "Explain approach including secondary index for cleanup, start modifying code",
    "by_10_min": "Core implementation done: grantAccessWithExpiry and retrieveAccessAtTime working",
    "warning_signs": "If still planning at 5 min, just start with simple version (no cleanup optimization). If cleanup is too complex, mention you'd add secondary index and move on."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 group logic has issues, isolate them. Say: 'Let me first get time-based access working for direct access, then integrate with groups.'",
    "if_new_requirement_unclear": "Ask: 'When access expires at timestamp T, is it valid at T or does it expire at T?' (Answer: expires at T, so valid only when time < T)",
    "if_running_behind": "Skip the cleanup method initially. Say: 'Queries work correctly with lazy evaluation. I'd add cleanup for memory optimization but that's secondary.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Identifying that Set<AccessType> \u2192 Map<AccessType, Long> is the core change",
      "Proactively discussing the expiry index for O(expired) cleanup",
      "Handling the 'don't downgrade permanent' edge case without prompting",
      "Mentioning lazy vs eager cleanup tradeoff",
      "Extending group access to also support expiry"
    ]
  },
  "pattern_recognition": {
    "pattern": "Event Scheduling / Timestamp Indexing",
    "indicators": [
      "Time-based validity",
      "Need to query at specific point in time",
      "Need to efficiently find entries by time"
    ],
    "similar_problems": [
      "LC 729 - My Calendar I",
      "Meeting Room problems",
      "LRU/TTL Cache implementations",
      "Rate Limiter with sliding window"
    ],
    "template": "When you need to track when things happen/expire: (1) Store timestamp with data, (2) Use secondary index if you need efficient time-based lookups, (3) Handle 'no expiry' as special sentinel value"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'time-based access', I immediately think about storing expiry timestamps",
      "why": "Need to know when each grant expires to evaluate validity at query time"
    },
    {
      "step": 2,
      "thought": "Using -1 or MAX_VALUE for permanent is a classic sentinel pattern",
      "why": "Avoids null checks and works cleanly with comparisons"
    },
    {
      "step": 3,
      "thought": "Cleanup efficiency suggests we need an inverted index by time",
      "why": "Without it, we'd scan all entries just to find the few that expired"
    },
    {
      "step": 4,
      "thought": "We should not downgrade permanent to temporary",
      "why": "Security principle - don't accidentally reduce access level"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend existing code cleanly without rewriting?",
      "Do you recognize the need for secondary indexing?",
      "Can you handle time-based edge cases (boundary, permanent)?"
    ],
    "bonus_points": [
      "Discussing lazy vs eager cleanup tradeoff",
      "Mentioning that permanent access shouldn't be downgraded",
      "Extending group access to also be time-based",
      "Clean code organization with helper methods"
    ],
    "red_flags": [
      "Rewriting Part 2 code from scratch",
      "O(all entries) cleanup with no index",
      "Incorrect boundary handling for expiry time",
      "Forgetting to integrate with groups"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate boilerplate for new data structures",
      "Let it help with the cleanup iteration logic"
    ],
    "what_not_to_do": [
      "Don't let AI decide whether to use eager vs lazy cleanup",
      "Understand the expiry index purpose before accepting code"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Silently changing Part 2 code without explanation",
      "Not asking about expiry semantics (is it inclusive or exclusive?)"
    ],
    "technical": [
      "Forgetting permanent access in expiry check",
      "O(n) cleanup scan",
      "Not updating expiry index on revoke"
    ],
    "communication": [
      "Not explaining why secondary index is needed",
      "Skipping test of the new functionality"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "grantAccessWithExpiry stores expiry correctly",
      "retrieveAccessAtTime filters by time correctly",
      "Permanent access (-1) always passes time check",
      "Expiry index is updated on grant and revoke",
      "cleanupExpired only processes actually expired entries",
      "Group access also respects time if extended"
    ],
    "quick_code_review": [
      "PERMANENT constant defined and used consistently",
      "No duplicate code between employee and group time logic",
      "Helper method for _is_valid_at_time",
      "Type hints on all new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Background scheduler for automatic cleanup",
      "Metrics: expired_count, cleanup_duration, pending_expirations",
      "Logging of access grants with expiry for audit trail",
      "Alert when cleanup queue gets too large"
    ],
    "why_not_in_interview": "Focus on core algorithm and data structure. Mention these verbally as production considerations.",
    "how_to_mention": "Say: 'In production, I'd add a background job for periodic cleanup and metrics to track expiration patterns.'"
  },
  "generated_at": "2026-01-18T18:34:00.249888",
  "_meta": {
    "problem_id": "employee_access_management",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}