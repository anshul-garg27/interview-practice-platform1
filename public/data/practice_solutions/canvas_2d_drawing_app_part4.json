{
  "problem_title": "2D Canvas / Drawing Application - Part 4: Undo/Redo Support",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 adds the **Command Pattern** to enable undo/redo functionality. Instead of directly modifying canvas state, each operation now creates a Command object that encapsulates: (1) the action to perform, (2) the state needed to reverse it, and (3) methods to execute and undo. Two stacks manage the undo/redo history, allowing users to reverse any sequence of operations.",
    "new_requirements": [
      "undo() method to reverse the most recent operation",
      "redo() method to re-apply the most recently undone operation",
      "All previous operations (create, move, delete, z-order) must be undoable",
      "New operations must clear the redo stack",
      "Empty stack operations are no-ops"
    ],
    "new_constraints": [
      "Commands must store enough state to fully reverse their effects",
      "Z-order position must be preserved when undoing delete operations",
      "Shape IDs must remain consistent through undo/redo cycles",
      "Counter values should not re-increment on redo"
    ],
    "key_insight": "Each Command must capture a 'snapshot' of the affected state BEFORE execution. For MoveCommand, this is the old position. For DeleteCommand, this is the shape object AND its z-order index. For z-order commands, it's the original index in the z-order list. This 'before state' is what undo() restores."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "undo() reverses the most recent operation",
        "how_met": "Pop from undo stack, call command.undo(), push to redo stack",
        "gotchas": [
          "Must restore z-order position for deletes, not just add shape back"
        ]
      },
      {
        "requirement": "redo() re-applies the most recently undone operation",
        "how_met": "Pop from redo stack, call command.execute(), push to undo stack",
        "gotchas": [
          "execute() must be idempotent regarding counter increments - only increment on first call"
        ]
      },
      {
        "requirement": "New operation clears redo stack",
        "how_met": "_execute_command() calls self._redo_stack.clear() after adding to undo stack",
        "gotchas": [
          "This must happen for ALL operations, not just creates"
        ]
      },
      {
        "requirement": "Preserve shape ID through undo/redo",
        "how_met": "Store shape_id in CreateCommand on first execute; reuse on redo",
        "gotchas": [
          "Don't increment counter on redo - check if shape_id already exists"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "undo",
        "target": "O(1) + operation cost",
        "achieved": "O(1) + O(n) for z-order",
        "why": "Pop from stack is O(1), undo operation cost depends on the command type"
      },
      {
        "operation": "redo",
        "target": "O(1) + operation cost",
        "achieved": "O(1) + O(n) for z-order",
        "why": "Pop from stack is O(1), execute cost depends on command type"
      }
    ],
    "non_goals": [
      "Persisting undo history across sessions",
      "Limiting undo stack size (memory management)",
      "Batching multiple operations into single undo",
      "Selective undo (undoing specific operation, not just most recent)"
    ]
  },
  "assumptions": [
    "Undo/redo on empty stack silently does nothing (no exceptions)",
    "No concurrent modifications to canvas during undo/redo",
    "Shape IDs once assigned are never reused for different shapes",
    "All operations are atomic - no partial execution states"
  ],
  "tradeoffs": [
    {
      "decision": "Command stores references vs deep copies",
      "chosen": "Store references for shapes",
      "why": "Shapes are mutable but we control all mutations through commands",
      "alternative": "Deep copy shapes in commands",
      "when_to_switch": "If shapes could be modified outside command system"
    },
    {
      "decision": "Single execute() vs separate execute()/redo() methods",
      "chosen": "Single execute() with first-call detection",
      "why": "Simpler interface, less code duplication",
      "alternative": "Separate redo() method",
      "when_to_switch": "If execute and redo have significantly different logic"
    },
    {
      "decision": "Commands reference Canvas vs pass state",
      "chosen": "Commands hold Canvas reference",
      "why": "Simpler command construction, commands can access all needed state",
      "alternative": "Pass all needed state to command constructor",
      "when_to_switch": "If commands need to be serializable/transferable"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Command interface (execute/undo methods)",
      "Public Canvas API signatures",
      "_execute_command() pattern for all mutating operations"
    ],
    "what_to_change": [
      "Added _undo_stack and _redo_stack to Canvas",
      "All mutating methods now create Command objects",
      "Shape classes added get_position/set_position for uniform handling"
    ],
    "interfaces_and_boundaries": "New commands can be added by implementing Command interface. Canvas._execute_command() handles stack management uniformly, so new operations just need to create appropriate Command objects.",
    "invariants": [
      "After undo(), the canvas state equals state before the undone operation",
      "redo_stack is empty after any new (non-undo) operation",
      "len(undo_stack) + len(redo_stack) = total operations - undone operations that had new ops after"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3):                    AFTER (Part 4):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Canvas        \u2502              \u2502      Canvas        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 _shapes: Dict      \u2502              \u2502 _shapes: Dict      \u2502\n\u2502 _z_order: List     \u2502              \u2502 _z_order: List     \u2502\n\u2502 _rect_counter: int \u2502              \u2502 _rect_counter: int \u2502\n\u2502 _circ_counter: int \u2502              \u2502 _circ_counter: int \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502 _undo_stack: List  \u2502 \u2190 NEW\n                                    \u2502 _redo_stack: List  \u2502 \u2190 NEW\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                              \u25bc\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502  Command Objects   \u2502\n                                    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n                                    \u2502 CreateRectCommand  \u2502\n                                    \u2502 CreateCircCommand  \u2502\n                                    \u2502 MoveShapeCommand   \u2502\n                                    \u2502 DeleteShapeCommand \u2502\n                                    \u2502 BringToFrontCmd    \u2502\n                                    \u2502 SendToBackCmd      \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nOPERATION FLOW:\n\n1. User calls createRectangle(0,0,50,50)\n   \u2502\n   \u25bc\n2. Create CreateRectCommand(canvas, 0, 0, 50, 50)\n   \u2502\n   \u25bc\n3. command.execute()\n   \u251c\u2500\u2500 First call: _rect_counter++ \u2192 shape_id = \"rect_1\"\n   \u251c\u2500\u2500 Create Rectangle object\n   \u251c\u2500\u2500 Add to _shapes and _z_order\n   \u2514\u2500\u2500 Return \"rect_1\"\n   \u2502\n   \u25bc\n4. Push command to _undo_stack\n5. Clear _redo_stack\n6. Return \"rect_1\" to user\n\nUNDO FLOW:\n\n1. User calls undo()\n   \u2502\n   \u25bc\n2. Pop command from _undo_stack\n   \u2502\n   \u25bc\n3. command.undo()\n   \u251c\u2500\u2500 Remove shape from _shapes\n   \u2514\u2500\u2500 Remove from _z_order\n   \u2502\n   \u25bc\n4. Push command to _redo_stack\n\nREDO FLOW:\n\n1. User calls redo()\n   \u2502\n   \u25bc\n2. Pop command from _redo_stack\n   \u2502\n   \u25bc\n3. command.execute()\n   \u251c\u2500\u2500 Second call: shape_id already set, skip counter++\n   \u251c\u2500\u2500 Add existing shape back to _shapes\n   \u2514\u2500\u2500 Add to _z_order\n   \u2502\n   \u25bc\n4. Push command to _undo_stack\n```"
  },
  "approaches": [
    {
      "name": "Naive: Store Full Canvas Snapshots",
      "description": "Before each operation, deep copy entire canvas state. Undo restores previous snapshot.",
      "time_complexity": "O(n) per operation where n = number of shapes",
      "space_complexity": "O(n * m) where m = number of operations",
      "why_not_optimal": "Extremely memory inefficient - stores entire canvas state for every operation. For 1000 shapes and 1000 operations, stores 1M shape copies. Also doesn't scale with number of shape attributes."
    },
    {
      "name": "Optimal: Command Pattern with Delta Storage",
      "description": "Each command stores only the minimal state needed to reverse its specific operation. CreateCommand stores the created shape. MoveCommand stores old position. DeleteCommand stores deleted shape and z-index.",
      "time_complexity": "O(1) stack operations + O(n) for z-order operations",
      "space_complexity": "O(m) where m = number of operations, each command stores O(1) state",
      "key_insight": "Store the DELTA (what changed), not the entire state. This is the essence of the Command Pattern - encapsulating an operation with everything needed to execute AND reverse it."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Command Pattern Implementation\n\n### Core Concept\nThe **Command Pattern** encapsulates a request as an object, allowing you to:\n1. **Parameterize** objects with operations\n2. **Queue** or log operations\n3. **Support undoable** operations\n\n### Key Design Decisions\n\n**1. Command Interface**\nEvery command implements `execute()` and `undo()`. This uniform interface allows the Canvas to manage any operation without knowing its specifics.\n\n**2. State Capture**\nEach command captures state **before** execution:\n- `CreateCommand`: Stores created shape and ID (for redo)\n- `MoveCommand`: Stores old_x, old_y\n- `DeleteCommand`: Stores deleted shape AND z-order index\n- `BringToFront/SendToBack`: Stores original z-index\n\n**3. First-Execute Detection**\nCommands distinguish first execution from redo by checking if state is already captured (e.g., `if self.shape_id is None`). This prevents counter re-increment on redo.\n\n**4. Stack Management**\n- New operation: push to undo_stack, **clear** redo_stack\n- Undo: pop from undo_stack, call undo(), push to redo_stack\n- Redo: pop from redo_stack, call execute(), push to undo_stack",
    "data_structures": [
      {
        "structure": "List[Command] _undo_stack",
        "purpose": "LIFO stack of executed commands awaiting potential undo"
      },
      {
        "structure": "List[Command] _redo_stack",
        "purpose": "LIFO stack of undone commands awaiting potential redo"
      },
      {
        "structure": "Command (abstract)",
        "purpose": "Interface defining execute() and undo() contract"
      },
      {
        "structure": "Concrete Commands",
        "purpose": "One class per operation type, each storing its specific undo state"
      }
    ],
    "algorithm_steps": [
      "Step 1: Define Command interface with execute() \u2192 Any and undo() \u2192 None",
      "Step 2: Create concrete command class for each operation type",
      "Step 3: In each command's execute(), capture 'before' state on first call only",
      "Step 4: In each command's undo(), restore the captured 'before' state",
      "Step 5: Canvas._execute_command() wraps all operations: execute, push to undo, clear redo",
      "Step 6: Canvas.undo() pops from undo, calls undo(), pushes to redo",
      "Step 7: Canvas.redo() pops from redo, calls execute(), pushes to undo"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Dict, List, Optional, Any, Tuple",
    "import math",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes on the canvas.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains_point(self, x: int, y: int) -> bool:",
    "        \"\"\"Check if the given point lies within this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_position(self) -> Tuple[int, int]:",
    "        \"\"\"Get the current position (reference point) of the shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def set_position(self, x: int, y: int) -> None:",
    "        \"\"\"Set the position (reference point) of the shape.\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"Rectangle defined by top-left corner (x, y), width, and height.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "    ",
    "    def contains_point(self, x: int, y: int) -> bool:",
    "        return (self.x <= x <= self.x + self.width and",
    "                self.y <= y <= self.y + self.height)",
    "    ",
    "    def get_position(self) -> Tuple[int, int]:",
    "        return (self.x, self.y)",
    "    ",
    "    def set_position(self, x: int, y: int) -> None:",
    "        self.x = x",
    "        self.y = y",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"Circle defined by center point (center_x, center_y) and radius.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "    ",
    "    def contains_point(self, x: int, y: int) -> bool:",
    "        dx = x - self.center_x",
    "        dy = y - self.center_y",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "    ",
    "    def get_position(self) -> Tuple[int, int]:",
    "        return (self.center_x, self.center_y)",
    "    ",
    "    def set_position(self, x: int, y: int) -> None:",
    "        self.center_x = x",
    "        self.center_y = y",
    "",
    "",
    "# ============== COMMAND PATTERN ==============",
    "",
    "class Command(ABC):",
    "    \"\"\"Abstract Command interface for undo/redo support.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def execute(self) -> Any:",
    "        \"\"\"Execute the command. Returns operation result.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def undo(self) -> None:",
    "        \"\"\"Undo the command, restoring previous state.\"\"\"",
    "        pass",
    "",
    "",
    "class CreateRectangleCommand(Command):",
    "    \"\"\"Command to create a rectangle on the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', x: int, y: int, width: int, height: int):",
    "        self.canvas = canvas",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "        self.shape_id: Optional[str] = None",
    "        self.shape: Optional[Rectangle] = None",
    "    ",
    "    def execute(self) -> str:",
    "        # Only create new ID on first execution (not redo)",
    "        if self.shape_id is None:",
    "            self.canvas._rect_counter += 1",
    "            self.shape_id = f\"rect_{self.canvas._rect_counter}\"",
    "            self.shape = Rectangle(self.shape_id, self.x, self.y, self.width, self.height)",
    "        self.canvas._shapes[self.shape_id] = self.shape",
    "        self.canvas._z_order.append(self.shape_id)",
    "        return self.shape_id",
    "    ",
    "    def undo(self) -> None:",
    "        if self.shape_id and self.shape_id in self.canvas._shapes:",
    "            del self.canvas._shapes[self.shape_id]",
    "            self.canvas._z_order.remove(self.shape_id)",
    "",
    "",
    "class CreateCircleCommand(Command):",
    "    \"\"\"Command to create a circle on the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', center_x: int, center_y: int, radius: int):",
    "        self.canvas = canvas",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "        self.shape_id: Optional[str] = None",
    "        self.shape: Optional[Circle] = None",
    "    ",
    "    def execute(self) -> str:",
    "        if self.shape_id is None:",
    "            self.canvas._circle_counter += 1",
    "            self.shape_id = f\"circle_{self.canvas._circle_counter}\"",
    "            self.shape = Circle(self.shape_id, self.center_x, self.center_y, self.radius)",
    "        self.canvas._shapes[self.shape_id] = self.shape",
    "        self.canvas._z_order.append(self.shape_id)",
    "        return self.shape_id",
    "    ",
    "    def undo(self) -> None:",
    "        if self.shape_id and self.shape_id in self.canvas._shapes:",
    "            del self.canvas._shapes[self.shape_id]",
    "            self.canvas._z_order.remove(self.shape_id)",
    "",
    "",
    "class MoveShapeCommand(Command):",
    "    \"\"\"Command to move a shape to a new position.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str, new_x: int, new_y: int):",
    "        self.canvas = canvas",
    "        self.shape_id = shape_id",
    "        self.new_x = new_x",
    "        self.new_y = new_y",
    "        self.old_x: Optional[int] = None",
    "        self.old_y: Optional[int] = None",
    "    ",
    "    def execute(self) -> None:",
    "        shape = self.canvas._shapes.get(self.shape_id)",
    "        if not shape:",
    "            return",
    "        # Store old position only on first execute",
    "        if self.old_x is None:",
    "            self.old_x, self.old_y = shape.get_position()",
    "        shape.set_position(self.new_x, self.new_y)",
    "    ",
    "    def undo(self) -> None:",
    "        shape = self.canvas._shapes.get(self.shape_id)",
    "        if shape and self.old_x is not None:",
    "            shape.set_position(self.old_x, self.old_y)",
    "",
    "",
    "class DeleteShapeCommand(Command):",
    "    \"\"\"Command to delete a shape from the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self.canvas = canvas",
    "        self.shape_id = shape_id",
    "        self.deleted_shape: Optional[Shape] = None",
    "        self.z_index: Optional[int] = None",
    "    ",
    "    def execute(self) -> bool:",
    "        if self.shape_id not in self.canvas._shapes:",
    "            return False",
    "        # Store shape and z-order position for undo",
    "        self.deleted_shape = self.canvas._shapes[self.shape_id]",
    "        self.z_index = self.canvas._z_order.index(self.shape_id)",
    "        del self.canvas._shapes[self.shape_id]",
    "        self.canvas._z_order.remove(self.shape_id)",
    "        return True",
    "    ",
    "    def undo(self) -> None:",
    "        if self.deleted_shape and self.z_index is not None:",
    "            self.canvas._shapes[self.shape_id] = self.deleted_shape",
    "            self.canvas._z_order.insert(self.z_index, self.shape_id)",
    "",
    "",
    "class BringToFrontCommand(Command):",
    "    \"\"\"Command to bring a shape to the front (highest z-order).\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self.canvas = canvas",
    "        self.shape_id = shape_id",
    "        self.old_z_index: Optional[int] = None",
    "    ",
    "    def execute(self) -> None:",
    "        if self.shape_id not in self.canvas._shapes:",
    "            return",
    "        if self.old_z_index is None:",
    "            self.old_z_index = self.canvas._z_order.index(self.shape_id)",
    "        self.canvas._z_order.remove(self.shape_id)",
    "        self.canvas._z_order.append(self.shape_id)",
    "    ",
    "    def undo(self) -> None:",
    "        if self.old_z_index is not None and self.shape_id in self.canvas._shapes:",
    "            self.canvas._z_order.remove(self.shape_id)",
    "            self.canvas._z_order.insert(self.old_z_index, self.shape_id)",
    "",
    "",
    "class SendToBackCommand(Command):",
    "    \"\"\"Command to send a shape to the back (lowest z-order).\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self.canvas = canvas",
    "        self.shape_id = shape_id",
    "        self.old_z_index: Optional[int] = None",
    "    ",
    "    def execute(self) -> None:",
    "        if self.shape_id not in self.canvas._shapes:",
    "            return",
    "        if self.old_z_index is None:",
    "            self.old_z_index = self.canvas._z_order.index(self.shape_id)",
    "        self.canvas._z_order.remove(self.shape_id)",
    "        self.canvas._z_order.insert(0, self.shape_id)",
    "    ",
    "    def undo(self) -> None:",
    "        if self.old_z_index is not None and self.shape_id in self.canvas._shapes:",
    "            self.canvas._z_order.remove(self.shape_id)",
    "            self.canvas._z_order.insert(self.old_z_index, self.shape_id)",
    "",
    "",
    "# ============== CANVAS CLASS ==============",
    "",
    "class Canvas:",
    "    \"\"\"",
    "    2D Canvas supporting shapes with full undo/redo functionality.",
    "    ",
    "    Implements the Command Pattern where each operation is encapsulated",
    "    in a Command object that can execute and undo itself.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._shapes: Dict[str, Shape] = {}",
    "        self._z_order: List[str] = []  # Bottom to top ordering",
    "        self._rect_counter: int = 0",
    "        self._circle_counter: int = 0",
    "        self._undo_stack: List[Command] = []",
    "        self._redo_stack: List[Command] = []",
    "    ",
    "    def _execute_command(self, command: Command) -> Any:",
    "        \"\"\"Execute a command and manage undo/redo stacks.\"\"\"",
    "        result = command.execute()",
    "        self._undo_stack.append(command)",
    "        self._redo_stack.clear()  # New operation clears redo history",
    "        return result",
    "    ",
    "    # ============== CREATE OPERATIONS ==============",
    "    ",
    "    def createRectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        \"\"\"Create a rectangle and return its ID.\"\"\"",
    "        command = CreateRectangleCommand(self, x, y, width, height)",
    "        return self._execute_command(command)",
    "    ",
    "    def createCircle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        \"\"\"Create a circle and return its ID.\"\"\"",
    "        command = CreateCircleCommand(self, center_x, center_y, radius)",
    "        return self._execute_command(command)",
    "    ",
    "    # ============== QUERY OPERATIONS ==============",
    "    ",
    "    def getShapeAt(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"Return the topmost shape at point (x, y), or None.\"\"\"",
    "        for shape_id in reversed(self._z_order):",
    "            if self._shapes[shape_id].contains_point(x, y):",
    "                return shape_id",
    "        return None",
    "    ",
    "    # ============== MODIFY OPERATIONS ==============",
    "    ",
    "    def moveShape(self, shape_id: str, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move shape to new position. No-op if shape doesn't exist.\"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = MoveShapeCommand(self, shape_id, new_x, new_y)",
    "        self._execute_command(command)",
    "    ",
    "    def deleteShape(self, shape_id: str) -> bool:",
    "        \"\"\"Delete a shape. Returns True if deleted, False if not found.\"\"\"",
    "        if shape_id not in self._shapes:",
    "            return False",
    "        command = DeleteShapeCommand(self, shape_id)",
    "        return self._execute_command(command)",
    "    ",
    "    # ============== Z-ORDER OPERATIONS ==============",
    "    ",
    "    def bringToFront(self, shape_id: str) -> None:",
    "        \"\"\"Bring shape to front (highest z-order).\"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = BringToFrontCommand(self, shape_id)",
    "        self._execute_command(command)",
    "    ",
    "    def sendToBack(self, shape_id: str) -> None:",
    "        \"\"\"Send shape to back (lowest z-order).\"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = SendToBackCommand(self, shape_id)",
    "        self._execute_command(command)",
    "    ",
    "    # ============== UNDO/REDO OPERATIONS ==============",
    "    ",
    "    def undo(self) -> None:",
    "        \"\"\"Undo the most recent operation. No-op if nothing to undo.\"\"\"",
    "        if not self._undo_stack:",
    "            return",
    "        command = self._undo_stack.pop()",
    "        command.undo()",
    "        self._redo_stack.append(command)",
    "    ",
    "    def redo(self) -> None:",
    "        \"\"\"Redo the most recently undone operation. No-op if nothing to redo.\"\"\"",
    "        if not self._redo_stack:",
    "            return",
    "        command = self._redo_stack.pop()",
    "        command.execute()",
    "        self._undo_stack.append(command)",
    "    ",
    "    # ============== DEBUG HELPERS ==============",
    "    ",
    "    def _debug_state(self) -> str:",
    "        \"\"\"Return debug string showing current canvas state.\"\"\"",
    "        shapes = [f\"{sid}: {type(self._shapes[sid]).__name__}\" for sid in self._z_order]",
    "        return f\"Shapes: {shapes}, Undo: {len(self._undo_stack)}, Redo: {len(self._redo_stack)}\"",
    "",
    "",
    "# ============== DEMONSTRATION ==============",
    "",
    "def main():",
    "    print(\"=\" * 60)",
    "    print(\"2D Canvas with Undo/Redo - Command Pattern Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    canvas = Canvas()",
    "    ",
    "    # Example 1: Basic undo/redo of create",
    "    print(\"\\n--- Example 1: Create + Undo + Redo ---\")",
    "    rect_id = canvas.createRectangle(0, 0, 50, 50)",
    "    print(f\"Created: {rect_id}\")",
    "    print(f\"Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.undo()",
    "    print(f\"After undo - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.redo()",
    "    print(f\"After redo - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    # Example 2: Undo move operation",
    "    print(\"\\n--- Example 2: Move + Undo ---\")",
    "    canvas.moveShape(rect_id, 100, 100)",
    "    print(f\"After move - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    print(f\"After move - Shape at (125,125): {canvas.getShapeAt(125, 125)}\")",
    "    ",
    "    canvas.undo()",
    "    print(f\"After undo move - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    print(f\"After undo move - Shape at (125,125): {canvas.getShapeAt(125, 125)}\")",
    "    ",
    "    # Example 3: Undo delete",
    "    print(\"\\n--- Example 3: Delete + Undo ---\")",
    "    canvas.deleteShape(rect_id)",
    "    print(f\"After delete - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.undo()",
    "    print(f\"After undo delete - Shape at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    # Example 4: Z-order undo",
    "    print(\"\\n--- Example 4: Z-Order + Undo ---\")",
    "    circle_id = canvas.createCircle(25, 25, 30)",
    "    print(f\"Created overlapping circle: {circle_id}\")",
    "    print(f\"Topmost at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.sendToBack(circle_id)",
    "    print(f\"After sendToBack - Topmost at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.undo()",
    "    print(f\"After undo sendToBack - Topmost at (25,25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    # Example 5: New operation clears redo",
    "    print(\"\\n--- Example 5: New Operation Clears Redo ---\")",
    "    canvas.undo()  # Undo circle creation",
    "    print(f\"After undo circle - State: {canvas._debug_state()}\")",
    "    ",
    "    canvas.createCircle(50, 50, 10)  # New operation",
    "    print(f\"After new circle - Redo stack size: {len(canvas._redo_stack)}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All examples completed successfully!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "// ============== SHAPE CLASSES ==============",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    ",
    "    public Shape(String id) {",
    "        this.id = id;",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public abstract boolean containsPoint(int x, int y);",
    "    public abstract int[] getPosition();",
    "    public abstract void setPosition(int x, int y);",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    ",
    "    public Rectangle(String id, int x, int y, int width, int height) {",
    "        super(id);",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(int px, int py) {",
    "        return px >= x && px <= x + width && py >= y && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public int[] getPosition() { return new int[]{x, y}; }",
    "    ",
    "    @Override",
    "    public void setPosition(int x, int y) {",
    "        this.x = x;",
    "        this.y = y;",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private int centerX, centerY, radius;",
    "    ",
    "    public Circle(String id, int centerX, int centerY, int radius) {",
    "        super(id);",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(int x, int y) {",
    "        int dx = x - centerX;",
    "        int dy = y - centerY;",
    "        return dx * dx + dy * dy <= radius * radius;",
    "    }",
    "    ",
    "    @Override",
    "    public int[] getPosition() { return new int[]{centerX, centerY}; }",
    "    ",
    "    @Override",
    "    public void setPosition(int x, int y) {",
    "        this.centerX = x;",
    "        this.centerY = y;",
    "    }",
    "}",
    "",
    "// ============== COMMAND INTERFACE ==============",
    "",
    "interface Command {",
    "    Object execute();",
    "    void undo();",
    "}",
    "",
    "// ============== CONCRETE COMMANDS ==============",
    "",
    "class CreateRectangleCommand implements Command {",
    "    private Canvas canvas;",
    "    private int x, y, width, height;",
    "    private String shapeId;",
    "    private Rectangle shape;",
    "    ",
    "    public CreateRectangleCommand(Canvas canvas, int x, int y, int width, int height) {",
    "        this.canvas = canvas;",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (shapeId == null) {",
    "            shapeId = \"rect_\" + canvas.incrementRectCounter();",
    "            shape = new Rectangle(shapeId, x, y, width, height);",
    "        }",
    "        canvas.addShapeInternal(shapeId, shape);",
    "        return shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (shapeId != null) {",
    "            canvas.removeShapeInternal(shapeId);",
    "        }",
    "    }",
    "}",
    "",
    "class CreateCircleCommand implements Command {",
    "    private Canvas canvas;",
    "    private int centerX, centerY, radius;",
    "    private String shapeId;",
    "    private Circle shape;",
    "    ",
    "    public CreateCircleCommand(Canvas canvas, int centerX, int centerY, int radius) {",
    "        this.canvas = canvas;",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (shapeId == null) {",
    "            shapeId = \"circle_\" + canvas.incrementCircleCounter();",
    "            shape = new Circle(shapeId, centerX, centerY, radius);",
    "        }",
    "        canvas.addShapeInternal(shapeId, shape);",
    "        return shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (shapeId != null) {",
    "            canvas.removeShapeInternal(shapeId);",
    "        }",
    "    }",
    "}",
    "",
    "class MoveShapeCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private int newX, newY;",
    "    private Integer oldX, oldY;",
    "    ",
    "    public MoveShapeCommand(Canvas canvas, String shapeId, int newX, int newY) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "        this.newX = newX;",
    "        this.newY = newY;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        Shape shape = canvas.getShapeInternal(shapeId);",
    "        if (shape == null) return null;",
    "        if (oldX == null) {",
    "            int[] pos = shape.getPosition();",
    "            oldX = pos[0];",
    "            oldY = pos[1];",
    "        }",
    "        shape.setPosition(newX, newY);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        Shape shape = canvas.getShapeInternal(shapeId);",
    "        if (shape != null && oldX != null) {",
    "            shape.setPosition(oldX, oldY);",
    "        }",
    "    }",
    "}",
    "",
    "class DeleteShapeCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private Shape deletedShape;",
    "    private Integer zIndex;",
    "    ",
    "    public DeleteShapeCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        deletedShape = canvas.getShapeInternal(shapeId);",
    "        if (deletedShape == null) return false;",
    "        zIndex = canvas.getZIndex(shapeId);",
    "        canvas.removeShapeInternal(shapeId);",
    "        return true;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (deletedShape != null && zIndex != null) {",
    "            canvas.insertShapeAt(shapeId, deletedShape, zIndex);",
    "        }",
    "    }",
    "}",
    "",
    "class BringToFrontCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private Integer oldZIndex;",
    "    ",
    "    public BringToFrontCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (!canvas.hasShape(shapeId)) return null;",
    "        if (oldZIndex == null) {",
    "            oldZIndex = canvas.getZIndex(shapeId);",
    "        }",
    "        canvas.bringToFrontInternal(shapeId);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (oldZIndex != null) {",
    "            canvas.setZIndex(shapeId, oldZIndex);",
    "        }",
    "    }",
    "}",
    "",
    "class SendToBackCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private Integer oldZIndex;",
    "    ",
    "    public SendToBackCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (!canvas.hasShape(shapeId)) return null;",
    "        if (oldZIndex == null) {",
    "            oldZIndex = canvas.getZIndex(shapeId);",
    "        }",
    "        canvas.sendToBackInternal(shapeId);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (oldZIndex != null) {",
    "            canvas.setZIndex(shapeId, oldZIndex);",
    "        }",
    "    }",
    "}",
    "",
    "// ============== CANVAS CLASS ==============",
    "",
    "public class Canvas {",
    "    private Map<String, Shape> shapes = new HashMap<>();",
    "    private List<String> zOrder = new ArrayList<>();",
    "    private int rectCounter = 0;",
    "    private int circleCounter = 0;",
    "    private Deque<Command> undoStack = new ArrayDeque<>();",
    "    private Deque<Command> redoStack = new ArrayDeque<>();",
    "    ",
    "    // Internal methods for commands",
    "    int incrementRectCounter() { return ++rectCounter; }",
    "    int incrementCircleCounter() { return ++circleCounter; }",
    "    ",
    "    void addShapeInternal(String id, Shape shape) {",
    "        shapes.put(id, shape);",
    "        zOrder.add(id);",
    "    }",
    "    ",
    "    void removeShapeInternal(String id) {",
    "        shapes.remove(id);",
    "        zOrder.remove(id);",
    "    }",
    "    ",
    "    Shape getShapeInternal(String id) { return shapes.get(id); }",
    "    boolean hasShape(String id) { return shapes.containsKey(id); }",
    "    int getZIndex(String id) { return zOrder.indexOf(id); }",
    "    ",
    "    void insertShapeAt(String id, Shape shape, int index) {",
    "        shapes.put(id, shape);",
    "        zOrder.add(index, id);",
    "    }",
    "    ",
    "    void setZIndex(String id, int index) {",
    "        zOrder.remove(id);",
    "        zOrder.add(index, id);",
    "    }",
    "    ",
    "    void bringToFrontInternal(String id) {",
    "        zOrder.remove(id);",
    "        zOrder.add(id);",
    "    }",
    "    ",
    "    void sendToBackInternal(String id) {",
    "        zOrder.remove(id);",
    "        zOrder.add(0, id);",
    "    }",
    "    ",
    "    private Object executeCommand(Command cmd) {",
    "        Object result = cmd.execute();",
    "        undoStack.push(cmd);",
    "        redoStack.clear();",
    "        return result;",
    "    }",
    "    ",
    "    // Public API",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        return (String) executeCommand(new CreateRectangleCommand(this, x, y, width, height));",
    "    }",
    "    ",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        return (String) executeCommand(new CreateCircleCommand(this, centerX, centerY, radius));",
    "    }",
    "    ",
    "    public String getShapeAt(int x, int y) {",
    "        for (int i = zOrder.size() - 1; i >= 0; i--) {",
    "            String id = zOrder.get(i);",
    "            if (shapes.get(id).containsPoint(x, y)) {",
    "                return id;",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    public void moveShape(String shapeId, int newX, int newY) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        executeCommand(new MoveShapeCommand(this, shapeId, newX, newY));",
    "    }",
    "    ",
    "    public boolean deleteShape(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return false;",
    "        return (Boolean) executeCommand(new DeleteShapeCommand(this, shapeId));",
    "    }",
    "    ",
    "    public void bringToFront(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        executeCommand(new BringToFrontCommand(this, shapeId));",
    "    }",
    "    ",
    "    public void sendToBack(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        executeCommand(new SendToBackCommand(this, shapeId));",
    "    }",
    "    ",
    "    public void undo() {",
    "        if (undoStack.isEmpty()) return;",
    "        Command cmd = undoStack.pop();",
    "        cmd.undo();",
    "        redoStack.push(cmd);",
    "    }",
    "    ",
    "    public void redo() {",
    "        if (redoStack.isEmpty()) return;",
    "        Command cmd = redoStack.pop();",
    "        cmd.execute();",
    "        undoStack.push(cmd);",
    "    }",
    "    ",
    "    // Demo",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"2D Canvas with Undo/Redo - Java Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        Canvas canvas = new Canvas();",
    "        ",
    "        // Example 1",
    "        System.out.println(\"\\n--- Example 1: Create + Undo + Redo ---\");",
    "        String rectId = canvas.createRectangle(0, 0, 50, 50);",
    "        System.out.println(\"Created: \" + rectId);",
    "        System.out.println(\"Shape at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        canvas.undo();",
    "        System.out.println(\"After undo: \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        canvas.redo();",
    "        System.out.println(\"After redo: \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        // Example 2",
    "        System.out.println(\"\\n--- Example 2: Move + Undo ---\");",
    "        canvas.moveShape(rectId, 100, 100);",
    "        System.out.println(\"After move - at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        System.out.println(\"After move - at (125,125): \" + canvas.getShapeAt(125, 125));",
    "        ",
    "        canvas.undo();",
    "        System.out.println(\"After undo - at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        System.out.println(\"\\nAll tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-5",
      "explanation": "Import ABC for abstract classes and typing utilities"
    },
    {
      "lines": "7-23",
      "explanation": "Shape base class with abstract methods for polymorphic handling"
    },
    {
      "lines": "26-45",
      "explanation": "Rectangle implementation with position getter/setter"
    },
    {
      "lines": "48-68",
      "explanation": "Circle implementation with center-based position handling"
    },
    {
      "lines": "73-84",
      "explanation": "Command interface defining the contract for all operations"
    },
    {
      "lines": "87-106",
      "explanation": "CreateRectangleCommand - stores shape for undo, only increments counter on first execute"
    },
    {
      "lines": "109-128",
      "explanation": "CreateCircleCommand - same pattern as rectangle"
    },
    {
      "lines": "131-152",
      "explanation": "MoveShapeCommand - captures old position on first execute, uses it for undo"
    },
    {
      "lines": "155-175",
      "explanation": "DeleteShapeCommand - stores BOTH shape AND z-index for proper restoration"
    },
    {
      "lines": "178-198",
      "explanation": "BringToFrontCommand - stores original z-index"
    },
    {
      "lines": "201-221",
      "explanation": "SendToBackCommand - mirrors BringToFront with opposite direction"
    },
    {
      "lines": "227-237",
      "explanation": "Canvas constructor - adds undo/redo stacks to existing state"
    },
    {
      "lines": "239-244",
      "explanation": "_execute_command - the key pattern: execute, push to undo, clear redo"
    },
    {
      "lines": "272-287",
      "explanation": "undo/redo methods - move commands between stacks"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "undo": {
          "complexity": "O(1) + O(command)",
          "explanation": "Stack pop is O(1), then depends on command's undo() which is O(n) for z-order operations"
        },
        "redo": {
          "complexity": "O(1) + O(command)",
          "explanation": "Same as undo - stack operations are O(1), command execution varies"
        }
      },
      "overall_change": "No change to existing operation complexities. undo/redo add constant overhead to each operation (creating Command object). Stack operations are O(1)."
    },
    "space": {
      "additional_space": "O(m) where m = number of operations",
      "explanation": "Each command stores O(1) state (old position, z-index, or shape reference). With m operations, we store m commands. Memory is released when commands are garbage collected after being popped and not referenced."
    }
  },
  "dry_run": {
    "example_input": "createRectangle(0,0,50,50) \u2192 moveShape(rect_1, 100, 100) \u2192 undo() \u2192 getShapeAt(25,25)",
    "steps": [
      {
        "step": 1,
        "action": "createRectangle(0,0,50,50)",
        "state": "shapes={rect_1}, z_order=[rect_1], undo=[CreateCmd], redo=[]",
        "explanation": "Create rect_1 at origin, push CreateCommand to undo stack"
      },
      {
        "step": 2,
        "action": "moveShape(rect_1, 100, 100)",
        "state": "rect_1.pos=(100,100), undo=[CreateCmd, MoveCmd(old=0,0)], redo=[]",
        "explanation": "Move command captures old_pos=(0,0), then moves shape"
      },
      {
        "step": 3,
        "action": "undo()",
        "state": "rect_1.pos=(0,0), undo=[CreateCmd], redo=[MoveCmd]",
        "explanation": "Pop MoveCmd, call undo() restoring pos to (0,0), push to redo"
      },
      {
        "step": 4,
        "action": "getShapeAt(25,25)",
        "state": "unchanged",
        "explanation": "Point (25,25) is inside rect at (0,0) with size 50x50 \u2192 returns rect_1"
      }
    ],
    "final_output": "rect_1 (shape is back at original position after undo)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create \u2192 undo \u2192 getShapeAt should return None",
      "Create \u2192 undo \u2192 redo \u2192 getShapeAt should return shape ID",
      "New operation after undo should clear redo stack"
    ],
    "likely_bugs": [
      "Counter incrementing on redo (should only increment once)",
      "Not storing z-index for delete undo",
      "Not clearing redo stack on new operation",
      "Storing position AFTER move instead of before"
    ],
    "recommended_logs_or_asserts": [
      "assert len(undo_stack) == expected after each operation",
      "log command type and captured state when created",
      "assert shape position equals expected after undo"
    ],
    "how_to_localize": "If undo doesn't work correctly: (1) Check if command was pushed to stack, (2) Check if undo() was called, (3) Check if 'before' state was captured correctly, (4) Verify state restoration logic"
  },
  "edge_cases": [
    {
      "case": "Undo with empty stack",
      "handling": "No-op (early return)",
      "gotcha": "Don't throw exception"
    },
    {
      "case": "Redo with empty stack",
      "handling": "No-op (early return)",
      "gotcha": "Don't throw exception"
    },
    {
      "case": "Redo after new operation",
      "handling": "Redo stack is cleared, so redo is no-op",
      "gotcha": "Must clear redo on ALL new operations"
    },
    {
      "case": "Multiple undos then redo",
      "handling": "Each undo pushes to redo, redo pops from redo",
      "gotcha": "Stack order preserved"
    },
    {
      "case": "Undo delete restores z-order",
      "handling": "Insert at saved z-index",
      "gotcha": "Don't just append - must insert at correct position"
    },
    {
      "case": "Move non-existent shape",
      "handling": "No-op, don't add to undo stack",
      "gotcha": "Check existence before creating command"
    }
  ],
  "test_cases": [
    {
      "name": "Basic create undo/redo",
      "input": "createRect \u2192 undo \u2192 getShapeAt \u2192 redo \u2192 getShapeAt",
      "expected": "[rect_1, null, None, null, rect_1]",
      "explanation": "Shape removed by undo, restored by redo"
    },
    {
      "name": "Move undo restores position",
      "input": "createRect(0,0,50,50) \u2192 move(100,100) \u2192 undo \u2192 getShapeAt(25,25)",
      "expected": "rect_1",
      "explanation": "After undo, shape back at original position"
    },
    {
      "name": "New op clears redo",
      "input": "create \u2192 undo \u2192 create \u2192 redo \u2192 getShapeAt(first)",
      "expected": "None for first shape location",
      "explanation": "Second create cleared redo stack, can't redo first create"
    },
    {
      "name": "Delete undo preserves z-order",
      "input": "create A \u2192 create B \u2192 delete A \u2192 undo \u2192 getShapeAt(overlap)",
      "expected": "B (on top)",
      "explanation": "A restored at original z-index (below B)"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Incrementing counter on redo",
      "why_wrong": "Creates new ID like rect_2 instead of reusing rect_1",
      "correct_approach": "Check if shape_id is already set before incrementing",
      "code_example_wrong": "def execute(self):\\n    self.canvas._rect_counter += 1\\n    self.shape_id = f'rect_{self.canvas._rect_counter}'",
      "code_example_correct": "def execute(self):\\n    if self.shape_id is None:\\n        self.canvas._rect_counter += 1\\n        self.shape_id = f'rect_{self.canvas._rect_counter}'"
    },
    {
      "mistake": "Not storing z-index for delete",
      "why_wrong": "Undo adds shape at end (top) instead of original position",
      "correct_approach": "Store z_order.index(shape_id) before deletion",
      "code_example_wrong": "def undo(self):\\n    self.canvas._shapes[self.shape_id] = self.deleted_shape\\n    self.canvas._z_order.append(self.shape_id)",
      "code_example_correct": "def undo(self):\\n    self.canvas._shapes[self.shape_id] = self.deleted_shape\\n    self.canvas._z_order.insert(self.z_index, self.shape_id)"
    },
    {
      "mistake": "Storing position after move",
      "why_wrong": "Captures new position as 'old', undo does nothing",
      "correct_approach": "Capture position BEFORE calling set_position()",
      "code_example_wrong": "def execute(self):\\n    shape.set_position(self.new_x, self.new_y)\\n    self.old_x, self.old_y = shape.get_position()",
      "code_example_correct": "def execute(self):\\n    self.old_x, self.old_y = shape.get_position()\\n    shape.set_position(self.new_x, self.new_y)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by naming the Command Pattern. Draw the two stacks. Explain that each command captures the 'before' state. Then implement systematically: interface first, then each command type.",
    "what_to_mention": [
      "This is the classic Command Pattern - mention GOF design patterns",
      "Key insight: store DELTA not full state",
      "Uniform interface allows Canvas to handle any command generically",
      "Easily extensible for new operations"
    ],
    "time_allocation": "2 min: explain pattern and stacks. 8 min: implement commands. 2 min: verify with example",
    "if_stuck": [
      "Think: what info do I need to REVERSE this operation?",
      "For delete: need both the shape AND where it was",
      "Draw the stack state at each step"
    ]
  },
  "connection_to_next_part": "Part 5 might add: (1) Composite commands (group multiple shapes), (2) Selective undo (undo specific operation), (3) Persistent undo across sessions, (4) Maximum undo limit with command coalescing. The Command Pattern foundation makes all these extensible.",
  "communication_script": {
    "transition_from_previous": "Great, Part 3 handles z-ordering. For Part 4's undo/redo, I'll implement the **Command Pattern**. This is the classic solution for undoable operations.",
    "explaining_changes": "The key change is that instead of directly modifying state, each operation creates a Command object. The command captures the 'before' state, executes the operation, and knows how to reverse it. I'll add two stacks to manage undo/redo history.",
    "while_extending_code": [
      "First, let me define the Command interface with execute() and undo()",
      "Now I'll create a command class for each operation type",
      "For MoveCommand, I need to store the old position before moving",
      "For DeleteCommand, I must also store the z-index",
      "The Canvas now wraps all operations with _execute_command()"
    ],
    "after_completing": "Now all operations are undoable. undo() and redo() are O(1) plus the cost of the operation itself. The Command Pattern makes this very extensible - adding new operations just requires a new Command class."
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Recognize Command Pattern, explain two-stack approach",
    "by_5_min": "Command interface defined, start on concrete commands",
    "by_10_min": "Most command classes done, Canvas changes started",
    "by_15_min": "Implementation complete, testing with examples",
    "warning_signs": "If still designing at 5 min, simplify. Start with CreateCommand only, add others incrementally."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 3 has bugs, fix them first. Say: 'Let me verify the base operations work before adding undo.'",
    "if_new_requirement_unclear": "Ask: 'Should undo on a failed operation (e.g., delete non-existent) still add to undo stack?' (Answer: No)",
    "if_running_behind": "Implement CreateCommand and MoveCommand fully first. Mention that Delete and z-order commands follow the same pattern and would store their respective state."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mention this is the classic GOF Command Pattern",
      "Discuss how Command Pattern also enables: macros, transaction logging, network operations",
      "Note that memory could be bounded with max stack size + command coalescing",
      "Mention that real apps like Photoshop use this exact pattern"
    ]
  },
  "pattern_recognition": {
    "pattern": "Command Pattern (Behavioral Design Pattern)",
    "indicators": [
      "Need to undo/redo operations",
      "Operations need to be queued, logged, or stored",
      "Operations need to be reversible",
      "Need uniform interface for diverse operations"
    ],
    "similar_problems": [
      "Text Editor with Undo",
      "Transaction Management System",
      "Game State Save/Load",
      "Photoshop History Panel"
    ],
    "template": "```\\nclass Command:\\n    def execute(self) -> Result: pass\\n    def undo(self) -> None: pass\\n\\nclass Invoker:\\n    def __init__(self):\\n        self.undo_stack = []\\n        self.redo_stack = []\\n    \\n    def execute(self, cmd):\\n        result = cmd.execute()\\n        self.undo_stack.append(cmd)\\n        self.redo_stack.clear()\\n        return result\\n    \\n    def undo(self):\\n        if self.undo_stack:\\n            cmd = self.undo_stack.pop()\\n            cmd.undo()\\n            self.redo_stack.append(cmd)\\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'undo/redo', I immediately think Command Pattern",
      "why": "This is THE classic use case for Command Pattern - encapsulating operations as objects"
    },
    {
      "step": 2,
      "thought": "Each command needs to store the 'delta' or 'before state'",
      "why": "To reverse an operation, you need to know what it changed"
    },
    {
      "step": 3,
      "thought": "Two stacks: undo and redo",
      "why": "Undo pops from undo to redo, redo does the reverse"
    },
    {
      "step": 4,
      "thought": "New operation clears redo stack",
      "why": "After doing something new, the 'future' (redo history) is invalid"
    },
    {
      "step": 5,
      "thought": "Commands need Canvas reference",
      "why": "They need to modify Canvas state in both execute() and undo()"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize the Command Pattern?",
      "Can you identify what state each command needs to store?",
      "Do you handle the undo/redo stack mechanics correctly?",
      "Is your code extensible for new operations?"
    ],
    "bonus_points": [
      "Mentioning this is GOF Command Pattern",
      "Discussing memory implications of storing commands",
      "Noting that execute() must be idempotent for redo",
      "Clean separation between Command interface and concrete commands"
    ],
    "red_flags": [
      "Storing full canvas snapshots (O(n) per operation)",
      "Not clearing redo stack on new operation",
      "Mixing undo logic with canvas state management",
      "Not recognizing the pattern"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate boilerplate Command classes",
      "Use AI for syntax of abstract classes/interfaces",
      "Ask AI to implement a second command after you do the first"
    ],
    "what_not_to_do": [
      "Don't let AI decide what state each command stores",
      "Don't accept without understanding why first-execute detection is needed",
      "Review stack manipulation logic carefully"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the pattern",
      "Not drawing the two-stack diagram",
      "Silent while implementing"
    ],
    "technical": [
      "Using full canvas snapshots instead of deltas",
      "Forgetting to clear redo on new operation",
      "Not storing z-index for delete",
      "Storing 'after' state instead of 'before'"
    ],
    "communication": [
      "Not mentioning this is Command Pattern",
      "Not explaining what state each command stores",
      "Forgetting to trace through an example"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does CreateCommand not re-increment counter on redo?",
      "Does DeleteCommand store and restore z-index?",
      "Does new operation clear redo stack?",
      "Are empty stack undo/redo no-ops?",
      "Traced through one full example?"
    ],
    "quick_code_review": [
      "All commands implement both execute() and undo()",
      "Canvas._execute_command() used for all mutations",
      "Consistent use of Optional for possibly-None state",
      "Type hints on all new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Maximum undo stack size with LRU eviction",
      "Command coalescing (combine rapid successive moves)",
      "Serialization for persistent undo across sessions",
      "Logging/metrics for command execution",
      "Thread safety for concurrent canvas access"
    ],
    "why_not_in_interview": "Focus on core Command Pattern; these are scaling concerns",
    "how_to_mention": "Say: 'In production, I'd add a max stack size to prevent memory issues, and possibly serialize commands for persistent history.'"
  },
  "generated_at": "2026-01-18T21:26:25.001543",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}