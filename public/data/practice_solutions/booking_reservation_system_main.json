{
  "problem_title": "Design a Hotel Booking/Reservation System",
  "difficulty": "hard",
  "category": "HLD/System Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **distributed systems design problem** focused on **inventory management with strong consistency requirements**. The core challenge is preventing double-bookings (a correctness problem) while maintaining high availability and low latency for searches (a performance problem). This problem tests your understanding of database transactions, concurrency control, and system architecture trade-offs.",
    "pattern_recognition": "**Patterns identified:**\n- **Inventory Management**: Similar to seat booking, ticket systems\n- **Temporal Range Overlap Detection**: LC 253 Meeting Rooms II\n- **Optimistic vs Pessimistic Locking**: Classic concurrency pattern\n- **CQRS (Command Query Responsibility Segregation)**: Separate read (search) and write (booking) paths\n- **Event Sourcing**: For audit trails and cancellation handling\n- **Saga Pattern**: For distributed transactions (payment + booking)",
    "key_constraints": [
      "**No double-booking** - This is a hard constraint, not eventual consistency. We MUST guarantee one room is booked by exactly one user for any date range.",
      "**10K bookings/sec peak** - High write throughput requires careful database design and potentially sharding",
      "**100K searches/sec peak** - Read-heavy workload; must separate read path from write path",
      "**<200ms search latency P95** - Cannot query main database; need Elasticsearch or pre-computed availability",
      "**<500ms booking latency P95** - Includes payment authorization; must be optimized",
      "**99.99% uptime** - 52 minutes downtime/year max; requires redundancy and graceful degradation"
    ],
    "clarifying_questions": [
      "**Q: What's the check-in/check-out time model?** - Determines overlap logic. If check-out is 11 AM and check-in is 3 PM, same-day turnovers are possible (User A: Jun 15-16, User B: Jun 16-17 is valid).",
      "**Q: Do we need inventory holds/temporary reservations?** - Users browsing rooms might want to 'hold' a room while entering payment details (5-10 min timeout).",
      "**Q: Is dynamic pricing in scope?** - Prices may vary by date, season, demand. Affects data model complexity.",
      "**Q: What's the payment failure handling?** - If payment fails after locking room, how long do we retry before releasing?",
      "**Q: Multi-room bookings?** - Can one user book multiple rooms in a single transaction? Affects atomicity.",
      "**Q: Overbooking tolerance?** - Some hotels intentionally overbook by ~5%. Is this allowed or strict no-overbooking?",
      "**Q: Geographic distribution?** - Are users/hotels globally distributed? Affects data center strategy and consistency."
    ],
    "edge_cases_to_consider": [
      "Same-day check-out/check-in boundary (User A checks out Jun 15, User B checks in Jun 15)",
      "Booking window edge (booking 365 days out, then 366 days out)",
      "Concurrent cancel + new booking for same room/dates",
      "Payment timeout during booking (room locked but payment pending)",
      "Hotel/room deactivation while booking in progress",
      "Timezone handling for check-in/check-out dates",
      "Zero-duration stays (check-in == check-out)",
      "Partial refunds based on cancellation timing"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "searchRooms - return available rooms by criteria",
        "how_met": "Elasticsearch cluster with pre-synced availability data. Query ES, not main DB. Paginated response with cursor-based pagination.",
        "gotchas": [
          "Stale availability data (ES is eventually consistent)",
          "Must show 'subject to availability' disclaimer",
          "Filter by all amenities, not just some"
        ]
      },
      {
        "requirement": "getRoomDetails - show real-time availability and pricing",
        "how_met": "Direct Redis cache lookup for real-time availability, fallback to DB. Dynamic pricing calculation based on dates/demand.",
        "gotchas": [
          "Cache invalidation on booking/cancel",
          "Price must be locked at booking time, not display time"
        ]
      },
      {
        "requirement": "createBooking - prevent double-bookings",
        "how_met": "Database-level UNIQUE constraint on (room_id, date) in room_availability table. Transaction with SELECT FOR UPDATE for pessimistic locking OR optimistic locking with version numbers.",
        "gotchas": [
          "Application-level checks are NOT sufficient",
          "Must handle payment + booking atomically (saga pattern)",
          "Idempotency key to prevent duplicate submissions"
        ]
      },
      {
        "requirement": "cancelBooking - handle refund policies",
        "how_met": "State machine: CONFIRMED \u2192 CANCELLATION_PENDING \u2192 CANCELLED. Update availability immediately, process refund async. Emit event for other systems.",
        "gotchas": [
          "Race condition with concurrent new booking",
          "Partial refund calculation based on policy and timing",
          "Refund failure handling"
        ]
      },
      {
        "requirement": "99.99% availability",
        "how_met": "Multi-AZ deployment, primary-replica database setup, circuit breakers, graceful degradation (show cached results if search is down).",
        "gotchas": [
          "Split-brain scenario handling",
          "Fallback strategies when payment provider is down"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "searchRooms",
        "target": "<200ms P95",
        "achieved": "~100ms with Elasticsearch",
        "why": "Pre-indexed data, no joins, geo-optimized queries"
      },
      {
        "operation": "createBooking",
        "target": "<500ms P95",
        "achieved": "~300ms",
        "why": "Single transaction + async payment (pre-auth completes in ~150ms)"
      },
      {
        "operation": "getRoomDetails",
        "target": "<100ms",
        "achieved": "~50ms",
        "why": "Redis cache hit, fallback to DB with index"
      },
      {
        "operation": "cancelBooking",
        "target": "<200ms",
        "achieved": "~100ms",
        "why": "Single DB update, refund processing is async"
      }
    ],
    "non_goals": [
      "Hotel management portal (admin side) - focus on guest-facing",
      "Review/rating system - separate microservice",
      "Loyalty/rewards program - out of scope for core booking",
      "Room recommendations/ML ranking - assume simple relevance sort",
      "Multi-language/multi-currency complexity - assume USD, English"
    ]
  },
  "assumptions": [
    "Check-in at 3 PM, check-out at 11 AM - same-day turnover is allowed",
    "Single room per booking (no multi-room atomic booking in Part 1)",
    "Payment pre-authorization model - charge only on check-in/no-show",
    "Booking window is 1 day to 365 days in advance",
    "No overbooking - strict inventory management",
    "Dates are in hotel's local timezone",
    "User authentication/authorization is handled by separate auth service",
    "Payment processor (Stripe-like) is external and reliable"
  ],
  "tradeoffs": [
    {
      "decision": "Availability tracking: Per-day rows vs date-range bookings",
      "chosen": "Per-day rows in room_availability table",
      "why": "Simpler overlap detection (just check if any day is booked), easier indexing, O(1) per-day lookup",
      "alternative": "Store date ranges and compute overlaps",
      "when_to_switch": "If booking windows are very long (vacation rentals with 30+ day stays)"
    },
    {
      "decision": "Locking strategy: Pessimistic vs Optimistic",
      "chosen": "Pessimistic locking (SELECT FOR UPDATE) for booking",
      "why": "High contention for popular rooms - optimistic would have high retry rates",
      "alternative": "Optimistic locking with version numbers",
      "when_to_switch": "If contention is low or deadlock detection becomes an issue"
    },
    {
      "decision": "Search infrastructure: Elasticsearch vs DB queries",
      "chosen": "Elasticsearch with async sync from main DB",
      "why": "100K QPS cannot hit main DB; ES designed for read-heavy search workloads",
      "alternative": "Read replicas of main DB with materialized views",
      "when_to_switch": "Smaller scale (<10K QPS) where operational complexity of ES isn't worth it"
    },
    {
      "decision": "Consistency model for search",
      "chosen": "Eventually consistent (ES synced every few seconds)",
      "why": "Booking still checks real-time availability; search is just discovery",
      "alternative": "Real-time sync for instant consistency",
      "when_to_switch": "If users frequently see 'available' rooms that are actually booked"
    },
    {
      "decision": "Payment timing: Pre-auth vs immediate charge",
      "chosen": "Pre-authorization at booking, capture at check-in",
      "why": "Allows cancellations without refund complexity; reduces fraud disputes",
      "alternative": "Immediate full charge",
      "when_to_switch": "For non-refundable bookings or high no-show rates"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Separate read and write paths** - CQRS allows independent scaling",
      "**Idempotent operations** - Every booking request has idempotency key",
      "**Event-driven architecture** - Booking events trigger notifications, analytics, sync",
      "**Database as source of truth** - ES/Redis are derived, can be rebuilt",
      "**Stateless services** - Scale horizontally without session affinity"
    ],
    "why_this_design_scales": "The design separates concerns: search (ES), booking (ACID DB), caching (Redis), payments (external). Each can scale independently. The room_availability table with per-day rows allows efficient sharding by hotel_id or region. The event-driven model means adding new features (notifications, analytics) just requires new event consumers.",
    "expected_followup_hooks": [
      "**Part 2 (Concurrent Bookings)**: The locking strategy and database constraints are the extension points. Can discuss distributed locks (Redis/ZooKeeper) for multi-region.",
      "**Part 3 (Scaling)**: Sharding by hotel_id/region, read replicas, caching layer expansion, circuit breakers",
      "**Dynamic Pricing**: room_availability table can store per-day prices",
      "**Waitlists**: Add waitlist table, trigger on cancellation events",
      "**Multi-room atomic booking**: Saga pattern with rollback"
    ],
    "invariants": [
      "A room can have at most ONE confirmed booking per night",
      "booking.total_price = SUM of per-night prices at booking time (immutable)",
      "Availability in room_availability table is the source of truth, not search results",
      "Every booking state transition is audited with timestamp"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    THE DOUBLE-BOOKING PROBLEM                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  TIME \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\n\n         T1              T2              T3              T4\n         \u2502               \u2502               \u2502               \u2502\n  User A \u2502\u2500\u2500\u25b6 CHECK \u2500\u2500\u2500\u2500\u25b6\u2502 AVAILABLE \u2500\u2500\u2500\u25b6\u2502 BOOK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 \u2713 SUCCESS\n         \u2502   Room 101    \u2502               \u2502 Room 101      \u2502\n         \u2502               \u2502               \u2502               \u2502\n  User B \u2502\u2500\u2500\u25b6 CHECK \u2500\u2500\u2500\u2500\u25b6\u2502 AVAILABLE \u2500\u2500\u2500\u25b6\u2502 BOOK \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 ??? \n         \u2502   Room 101    \u2502               \u2502 Room 101      \u2502\n         \u2502               \u2502               \u2502               \u2502\n\n  WITHOUT PROPER LOCKING:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  Both users see AVAILABLE at T2                               \u2502\n  \u2502  Both users attempt BOOK at T3                                \u2502\n  \u2502  Both might SUCCESS at T4 \u2192 DOUBLE BOOKING! \ud83d\udca5                 \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  WITH DATABASE-LEVEL CONSTRAINT:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  User A acquires lock first \u2192 SUCCESS                         \u2502\n  \u2502  User B's insert VIOLATES unique constraint \u2192 FAILED          \u2502\n  \u2502  Only ONE booking exists \u2192 CORRECT! \u2713                         \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATABASE SCHEMA (CORE TABLES)                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502       hotels         \u2502          \u2502        rooms         \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502 id          (PK)     \u2502\u2500\u2500\u25001:N\u2500\u2500\u2500\u25b6\u2502 id          (PK)     \u2502\n  \u2502 name                 \u2502          \u2502 hotel_id    (FK)     \u2502\n  \u2502 location             \u2502          \u2502 room_type            \u2502\n  \u2502 city                 \u2502          \u2502 capacity             \u2502\n  \u2502 country              \u2502          \u2502 base_price_cents     \u2502\n  \u2502 rating               \u2502          \u2502 amenities   (JSONB)  \u2502\n  \u2502 amenities   (JSONB)  \u2502          \u2502 status               \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                               \u2502\n                                               \u2502 1:N\n                                               \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502       users          \u2502          \u2502        room_availability             \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n  \u2502 id          (PK)     \u2502          \u2502 room_id       (PK, FK)               \u2502\n  \u2502 email                \u2502          \u2502 date          (PK)      \u25c4\u2500\u2500 COMPOSITE\u2502\n  \u2502 name                 \u2502          \u2502 is_available  (BOOLEAN)     PRIMARY \u2502\n  \u2502 phone                \u2502          \u2502 booking_id    (FK, nullable)  KEY   \u2502\n  \u2502 created_at           \u2502          \u2502 price_cents                          \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                                     \u25b2\n             \u2502 1:N                                 \u2502\n             \u25bc                                     \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2502\n  \u2502      bookings        \u2502                         \u2502\n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u2502 id          (PK)     \u2502\n  \u2502 user_id     (FK)     \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 room_id     (FK)     \u2502     \u2502  CRITICAL: room_availability table      \u2502\n  \u2502 check_in             \u2502     \u2502  - One row per (room, date) combination \u2502\n  \u2502 check_out            \u2502     \u2502  - UNIQUE constraint prevents duplicates\u2502\n  \u2502 status               \u2502     \u2502  - is_available=false when booked       \u2502\n  \u2502 total_price_cents    \u2502     \u2502  - booking_id links to booking          \u2502\n  \u2502 created_at           \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u2502 idempotency_key (UQ) \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  STATUS ENUM: PENDING \u2192 CONFIRMED \u2192 COMPLETED\n                    \u2193\n               CANCELLED\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**User searches for rooms**",
        "visualization": "```\nUser \u2500\u2500\u25b6 API Gateway \u2500\u2500\u25b6 Search Service \u2500\u2500\u25b6 Elasticsearch\n                                                  \u2502\n                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u25bc\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u2502 ES Index    \u2502\n                         \u2502 hotels +    \u2502\n                         \u2502 availability\u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n                    Return top 20 results\n                    (with cached availability)\n```",
        "key_point": "Search hits Elasticsearch, NOT main database. Availability is eventually consistent."
      },
      {
        "step": 2,
        "description": "**User views room details**",
        "visualization": "```\nUser \u2500\u2500\u25b6 API Gateway \u2500\u2500\u25b6 Room Service \u2500\u2500\u25b6 Redis Cache \u2500\u2500(miss)\u2500\u2500\u25b6 PostgreSQL\n                                              \u2502\n                                         \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n                                         \u2502  CACHE  \u2502\n                                         \u2502  HIT?   \u2502\n                                         \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                YES                        NO\n                                 \u2502                          \u2502\n                            Return                    Query DB\n                            cached data               Update cache\n```",
        "key_point": "Real-time availability from Redis/DB. Price calculated dynamically."
      },
      {
        "step": 3,
        "description": "**User initiates booking**",
        "visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BOOKING TRANSACTION FLOW                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  1. BEGIN TRANSACTION                                                   \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  2. SELECT * FROM room_availability                                     \u2502\n\u2502     WHERE room_id = X AND date BETWEEN check_in AND check_out-1         \u2502\n\u2502     FOR UPDATE;  \u25c4\u2500\u2500 Acquires row-level lock                           \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  3. Check if all days is_available = true                               \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502     \u251c\u2500\u2500 NO \u2500\u2500\u25b6 ROLLBACK; Return \"Room not available\"                   \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502     \u2514\u2500\u2500 YES \u2500\u2500\u25b6 Continue                                               \u2502\n\u2502           \u2502                                                            \u2502\n\u2502  4. Call Payment Service (pre-authorize card)                          \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502     \u251c\u2500\u2500 FAILED \u2500\u2500\u25b6 ROLLBACK; Return \"Payment failed\"                   \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502     \u2514\u2500\u2500 SUCCESS \u2500\u2500\u25b6 Continue                                           \u2502\n\u2502           \u2502                                                            \u2502\n\u2502  5. INSERT INTO bookings (...)                                         \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  6. UPDATE room_availability                                            \u2502\n\u2502     SET is_available = false, booking_id = new_booking_id              \u2502\n\u2502     WHERE room_id = X AND date BETWEEN check_in AND check_out-1        \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  7. COMMIT                                                              \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  8. Emit BookingCreated event (async)                                   \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  9. Return success + confirmation code                                  \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "SELECT FOR UPDATE provides pessimistic locking. Payment inside transaction."
      },
      {
        "step": 4,
        "description": "**Cancellation flow**",
        "visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    CANCELLATION FLOW                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  1. Validate user owns booking                                          \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  2. Calculate refund based on policy                                    \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502     \u251c\u2500\u2500 > 48 hours before check-in \u2500\u2500\u25b6 100% refund                     \u2502\n\u2502     \u251c\u2500\u2500 24-48 hours \u2500\u2500\u25b6 50% refund                                     \u2502\n\u2502     \u2514\u2500\u2500 < 24 hours \u2500\u2500\u25b6 No refund                                       \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  3. BEGIN TRANSACTION                                                   \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  4. UPDATE bookings SET status = 'CANCELLED'                            \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  5. UPDATE room_availability                                            \u2502\n\u2502     SET is_available = true, booking_id = NULL                          \u2502\n\u2502     WHERE booking_id = X                                                \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  6. COMMIT                                                              \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  7. Emit BookingCancelled event                                         \u2502\n\u2502     \u2502                                                                   \u2502\n\u2502  8. Process refund (ASYNC via queue)                                    \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "Availability freed immediately in transaction. Refund is async (doesn't block)."
      }
    ],
    "dry_run_table": "| Step | Operation | room_availability State | bookings State | Result |\n|------|-----------|------------------------|----------------|--------|\n| 1 | Initial state | Room 101: Jun 15 \u2713, Jun 16 \u2713, Jun 17 \u2713 | (empty) | - |\n| 2 | User A: Check availability Jun 15-18 | - | - | Available \u2713 |\n| 3 | User B: Check availability Jun 16-19 | - | - | Available \u2713 |\n| 4 | User A: Begin booking + SELECT FOR UPDATE | \ud83d\udd12 Locked rows Jun 15,16,17 | - | Lock acquired |\n| 5 | User B: Begin booking + SELECT FOR UPDATE | \u23f3 Waiting for lock... | - | **BLOCKED** |\n| 6 | User A: Payment pre-auth | - | - | Success |\n| 7 | User A: Insert booking, Update availability | Jun 15 \u274c, Jun 16 \u274c, Jun 17 \u274c | BK_001: CONFIRMED | Success |\n| 8 | User A: COMMIT | \ud83d\udd13 Lock released | - | **BK_001 created** |\n| 9 | User B: Lock acquired, check availability | Jun 16 = \u274c | - | **FAILED: Jun 16 not available** |\n| 10 | User B: ROLLBACK | - | - | Return error to User B |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see **'prevent double-booking'**, I immediately think: **this is a correctness problem, not just performance**. Application-level checks are insufficient because of race conditions. I need database-level enforcement.",
      "When I see **'10K bookings/sec + 100K searches/sec'**, I think: **CQRS (Command Query Responsibility Segregation)**. Separate the read path (search) from write path (booking). They have different scalability needs.",
      "When I see **'<200ms search latency'**, I think: **cannot hit main database**. Need Elasticsearch or similar. Eventual consistency is acceptable for search; real-time check happens at booking.",
      "When I see **'payment + booking timing'**, I think: **Saga pattern or 2-phase commit**. Must handle the chicken-and-egg: don't charge without confirming, don't confirm without payment authorization.",
      "For the data model, I think: **per-day availability rows vs date ranges**. Per-day is simpler for overlap detection and allows easy indexing. Trade-off: more rows for long stays.",
      "For concurrency, I think: **pessimistic vs optimistic locking**. For popular rooms with high contention, pessimistic (SELECT FOR UPDATE) is better. Optimistic would cause too many retries.",
      "For the UNIQUE constraint: `UNIQUE(room_id, date)` on room_availability table. If two transactions try to set the same room+date, one will fail. This is the **database-level safety net**."
    ],
    "key_insight": "The critical insight is that **availability is a function of existing bookings**, and checking availability and creating a booking must be **atomic** at the database level. The race condition diagram shows why application-level checks fail. The solution is: (1) Use a room_availability table with one row per (room, date), (2) Use UNIQUE constraint + pessimistic locking, (3) All availability checks AND updates happen in a single transaction.",
    "why_this_works": "The solution works because:\n1. **Database transactions are ACID** - isolation ensures one transaction completes before another sees its changes\n2. **SELECT FOR UPDATE** locks the rows being read, preventing other transactions from modifying them\n3. **UNIQUE constraint** provides a second safety net - even if locking fails, the constraint prevents duplicate entries\n4. **Separating search and booking** allows search to be eventually consistent (acceptable) while booking is strongly consistent (required)"
  },
  "approaches": [
    {
      "name": "Naive Approach: Application-Level Check",
      "description": "Check availability in application code, then insert booking if available.",
      "pseudocode": "def create_booking(room_id, dates):\n    # Query availability\n    is_available = db.query(\n        \"SELECT is_available FROM room_availability\n         WHERE room_id = ? AND date IN ?\",\n        room_id, dates\n    )\n    \n    if all(is_available):  # Race condition window!\n        db.execute(\"INSERT INTO bookings ...\")\n        db.execute(\"UPDATE room_availability SET is_available = false ...\")\n        return SUCCESS\n    else:\n        return ROOM_NOT_AVAILABLE",
      "time_complexity": "O(D) where D = number of days",
      "space_complexity": "O(1)",
      "pros": [
        "Simple to implement",
        "No locking overhead"
      ],
      "cons": [
        "**FATAL FLAW: Race condition** - Two users can both see 'available' and both book",
        "Does NOT prevent double-booking",
        "Will cause real customer complaints"
      ],
      "when_to_use": "**NEVER for production booking systems**. Maybe okay for prototypes or very low-traffic scenarios with human oversight."
    },
    {
      "name": "Optimistic Locking with Version Numbers",
      "description": "Add version column to room_availability. Check version hasn't changed during update.",
      "pseudocode": "def create_booking(room_id, dates):\n    # Read current state with versions\n    rows = db.query(\n        \"SELECT date, is_available, version FROM room_availability\n         WHERE room_id = ? AND date IN ?\",\n        room_id, dates\n    )\n    \n    if not all(r.is_available for r in rows):\n        return ROOM_NOT_AVAILABLE\n    \n    versions = {r.date: r.version for r in rows}\n    \n    # Atomic conditional update\n    result = db.execute(\n        \"UPDATE room_availability\n         SET is_available = false, booking_id = ?, version = version + 1\n         WHERE room_id = ? AND date = ? AND version = ?\",\n        # For each date...\n    )\n    \n    if result.rows_affected != len(dates):\n        # Someone else modified - retry or fail\n        return CONFLICT_RETRY\n    \n    # Create booking record\n    db.execute(\"INSERT INTO bookings ...\")\n    return SUCCESS",
      "time_complexity": "O(D) per attempt, may need retries",
      "space_complexity": "O(D) for version tracking",
      "pros": [
        "No explicit locks - better for low contention",
        "No deadlock risk",
        "Good for distributed systems"
      ],
      "cons": [
        "High retry rate under contention",
        "Complex multi-row update logic",
        "Not suitable for popular rooms"
      ],
      "when_to_use": "Low-contention scenarios, distributed databases that don't support traditional locking (like some NoSQL systems)."
    },
    {
      "name": "Optimal: Pessimistic Locking with Database Constraints",
      "description": "Use SELECT FOR UPDATE to lock rows, combined with UNIQUE constraint as safety net.",
      "pseudocode": "def create_booking(room_id, check_in, check_out, payment_info):\n    try:\n        BEGIN TRANSACTION\n        \n        # Lock the availability rows for this room and date range\n        rows = db.query(\n            \"SELECT * FROM room_availability\n             WHERE room_id = ? AND date >= ? AND date < ?\n             FOR UPDATE\",\n            room_id, check_in, check_out\n        )\n        \n        # Check availability (while holding locks)\n        if not all(r.is_available for r in rows):\n            ROLLBACK\n            return ROOM_NOT_AVAILABLE\n        \n        # Process payment (with row locks held)\n        payment_result = payment_service.pre_authorize(\n            payment_info, calculate_total(rows)\n        )\n        \n        if not payment_result.success:\n            ROLLBACK\n            return PAYMENT_FAILED\n        \n        # Create booking\n        booking_id = db.execute(\n            \"INSERT INTO bookings (...) VALUES (...)\"\n        )\n        \n        # Update availability\n        db.execute(\n            \"UPDATE room_availability\n             SET is_available = false, booking_id = ?\n             WHERE room_id = ? AND date >= ? AND date < ?\",\n            booking_id, room_id, check_in, check_out\n        )\n        \n        COMMIT\n        emit_event(BookingCreated(booking_id))\n        return SUCCESS(booking_id)\n        \n    except UniqueConstraintViolation:\n        # Safety net - shouldn't happen with proper locking\n        ROLLBACK\n        return ROOM_NOT_AVAILABLE\n        \n    except Exception:\n        ROLLBACK\n        raise",
      "time_complexity": "O(D) where D = number of days in booking",
      "space_complexity": "O(D) for locked rows in transaction",
      "pros": [
        "**Guarantees no double-booking**",
        "Simple to reason about",
        "Database handles concurrency",
        "Works with existing RDBMS"
      ],
      "cons": [
        "Lock contention for popular rooms",
        "Deadlock possible (mitigate with ordered locking)",
        "Transaction hold time includes payment call"
      ],
      "key_insight": "The combination of SELECT FOR UPDATE + UNIQUE constraint provides both pessimistic locking AND a safety net. Even if locking somehow fails, the constraint prevents duplicates."
    }
  ],
  "optimal_solution": {
    "name": "Pessimistic Locking with Per-Day Availability Table",
    "explanation_md": "## Approach\n\nThe optimal solution uses a **per-day availability table** with **pessimistic locking** and **database constraints**.\n\n### Why Per-Day Rows?\n\nInstead of storing bookings as date ranges and computing overlaps, we pre-expand availability:\n\n```sql\n-- Each room has 365 rows per year (pre-populated)\n-- room_id | date       | is_available | booking_id\n-- 101     | 2024-06-15 | true         | null\n-- 101     | 2024-06-16 | true         | null\n-- 101     | 2024-06-17 | true         | null\n```\n\nAdvantages:\n- **O(1) per-day availability check** via index lookup\n- **Simple overlap detection** - just check if any day is booked\n- **Easy to enforce UNIQUE constraint**\n- **Efficient for search queries**\n\n### Why Pessimistic Locking?\n\nFor hotel booking, contention on popular rooms/dates is HIGH (holidays, events). Optimistic locking would result in:\n- High retry rates\n- Poor user experience (\"Please try again\")\n- Potential for retry storms\n\nPessimistic locking via `SELECT FOR UPDATE` ensures:\n- First user to acquire lock wins\n- Other users wait (briefly) or fail fast\n- No retries needed\n\n### The Transaction Flow\n\n```\n1. BEGIN TRANSACTION\n2. SELECT FOR UPDATE on room_availability rows\n   \u2192 Acquires exclusive lock on those rows\n3. Verify all days are available\n4. Pre-authorize payment (within transaction)\n5. INSERT booking record\n6. UPDATE availability rows\n7. COMMIT (releases locks)\n```\n\n### Safety Net: UNIQUE Constraint\n\nEven with perfect locking, we add a constraint:\n\n```sql\nCREATE UNIQUE INDEX idx_room_date_booked \nON room_availability (room_id, date) \nWHERE is_available = false;\n```\n\nThis partial unique index ensures that a room can only have ONE booking per date.",
    "data_structures": [
      {
        "structure": "room_availability table",
        "purpose": "Per-day availability tracking. Primary key: (room_id, date). Indexed for fast lookups."
      },
      {
        "structure": "bookings table",
        "purpose": "Booking records with status, user info, total price. Has idempotency_key for deduplication."
      },
      {
        "structure": "Redis cache",
        "purpose": "Cache room details and availability for read path. Invalidated on booking/cancellation."
      },
      {
        "structure": "Elasticsearch index",
        "purpose": "Search index with hotel data + pre-aggregated availability. Updated async from main DB."
      },
      {
        "structure": "Message queue (Kafka/SQS)",
        "purpose": "Async event publishing for notifications, analytics, ES sync."
      }
    ],
    "algorithm_steps": [
      "1. **Pre-populate availability**: Create room_availability rows for next 365 days per room",
      "2. **Search path**: Query Elasticsearch with filters, return paginated results with cached availability",
      "3. **Booking path**: BEGIN TRANSACTION \u2192 SELECT FOR UPDATE \u2192 verify availability \u2192 pre-auth payment \u2192 INSERT booking \u2192 UPDATE availability \u2192 COMMIT",
      "4. **Cancellation path**: Verify ownership \u2192 calculate refund \u2192 UPDATE booking status \u2192 UPDATE availability to available \u2192 COMMIT \u2192 async refund",
      "5. **Sync path**: On booking/cancel, emit event \u2192 consumer updates ES index and Redis cache"
    ],
    "why_decimal": "All prices stored as `price_cents INTEGER` (e.g., $250.00 = 25000). Avoids floating point precision issues. Display layer converts to dollars/cents."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Core Implementation",
    "",
    "This module implements the core booking logic with proper concurrency handling.",
    "Uses pessimistic locking (SELECT FOR UPDATE) to prevent double-bookings.",
    "",
    "Author: System Design Interview Prep",
    "\"\"\"",
    "",
    "from dataclasses import dataclass, field",
    "from datetime import date, datetime, timedelta",
    "from decimal import Decimal",
    "from enum import Enum",
    "from typing import Dict, List, Optional, Tuple",
    "from abc import ABC, abstractmethod",
    "import uuid",
    "",
    "",
    "# ============================================================================",
    "# DOMAIN MODELS",
    "# ============================================================================",
    "",
    "class BookingStatus(Enum):",
    "    \"\"\"Booking lifecycle states.\"\"\"",
    "    PENDING = \"PENDING\"",
    "    CONFIRMED = \"CONFIRMED\"",
    "    CANCELLED = \"CANCELLED\"",
    "    COMPLETED = \"COMPLETED\"",
    "",
    "",
    "@dataclass",
    "class Hotel:",
    "    \"\"\"Hotel entity.\"\"\"",
    "    id: str",
    "    name: str",
    "    city: str",
    "    country: str",
    "    rating: float",
    "    amenities: List[str]",
    "",
    "",
    "@dataclass",
    "class Room:",
    "    \"\"\"Room entity within a hotel.\"\"\"",
    "    id: str",
    "    hotel_id: str",
    "    room_type: str",
    "    capacity: int",
    "    base_price_cents: int",
    "    amenities: List[str]",
    "",
    "    def get_price_display(self) -> str:",
    "        \"\"\"Format price for display.\"\"\"",
    "        return f\"${self.base_price_cents / 100:.2f}\"",
    "",
    "",
    "@dataclass",
    "class RoomAvailability:",
    "    \"\"\"Per-day availability for a room. One row per (room_id, date).\"\"\"",
    "    room_id: str",
    "    date: date",
    "    is_available: bool",
    "    booking_id: Optional[str]",
    "    price_cents: int",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Booking entity representing a confirmed reservation.\"\"\"",
    "    id: str",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    status: BookingStatus",
    "    total_price_cents: int",
    "    created_at: datetime",
    "    idempotency_key: str",
    "",
    "    @property",
    "    def nights(self) -> int:",
    "        return (self.check_out - self.check_in).days",
    "",
    "    def get_total_display(self) -> str:",
    "        return f\"${self.total_price_cents / 100:.2f}\"",
    "",
    "",
    "# ============================================================================",
    "# REQUEST/RESPONSE OBJECTS",
    "# ============================================================================",
    "",
    "@dataclass",
    "class SearchRequest:",
    "    \"\"\"Search request parameters.\"\"\"",
    "    location: str",
    "    check_in: date",
    "    check_out: date",
    "    guests: int",
    "    price_min: Optional[int] = None",
    "    price_max: Optional[int] = None",
    "    amenities: List[str] = field(default_factory=list)",
    "    page: int = 1",
    "    page_size: int = 20",
    "",
    "",
    "@dataclass",
    "class SearchResult:",
    "    \"\"\"Single search result.\"\"\"",
    "    room: Room",
    "    hotel: Hotel",
    "    total_price_cents: int",
    "    available: bool",
    "",
    "",
    "@dataclass",
    "class SearchResponse:",
    "    \"\"\"Paginated search response.\"\"\"",
    "    results: List[SearchResult]",
    "    total_count: int",
    "    page: int",
    "    has_more: bool",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Booking request parameters.\"\"\"",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    payment_token: str",
    "    idempotency_key: str",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    \"\"\"Booking response.\"\"\"",
    "    success: bool",
    "    booking_id: Optional[str]",
    "    confirmation_code: Optional[str]",
    "    error: Optional[str]",
    "    total_price_cents: Optional[int]",
    "",
    "",
    "# ============================================================================",
    "# EXCEPTIONS",
    "# ============================================================================",
    "",
    "class BookingException(Exception):",
    "    \"\"\"Base exception for booking errors.\"\"\"",
    "    pass",
    "",
    "",
    "class RoomNotAvailableException(BookingException):",
    "    \"\"\"Raised when room is not available for requested dates.\"\"\"",
    "    pass",
    "",
    "",
    "class PaymentFailedException(BookingException):",
    "    \"\"\"Raised when payment processing fails.\"\"\"",
    "    pass",
    "",
    "",
    "class BookingNotFoundException(BookingException):",
    "    \"\"\"Raised when booking is not found.\"\"\"",
    "    pass",
    "",
    "",
    "# ============================================================================",
    "# REPOSITORY INTERFACES (Database Abstraction)",
    "# ============================================================================",
    "",
    "class AvailabilityRepository(ABC):",
    "    \"\"\"",
    "    Abstract repository for room availability operations.",
    "    ",
    "    In production, this would use PostgreSQL with SELECT FOR UPDATE.",
    "    For demonstration, we use an in-memory implementation.",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def get_availability_for_update(",
    "        self, ",
    "        room_id: str, ",
    "        check_in: date, ",
    "        check_out: date",
    "    ) -> List[RoomAvailability]:",
    "        \"\"\"",
    "        Get availability with exclusive lock (SELECT FOR UPDATE).",
    "        ",
    "        Args:",
    "            room_id: Room identifier",
    "            check_in: Check-in date (inclusive)",
    "            check_out: Check-out date (exclusive)",
    "            ",
    "        Returns:",
    "            List of RoomAvailability objects for each day",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def update_availability(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date,",
    "        is_available: bool,",
    "        booking_id: Optional[str]",
    "    ) -> int:",
    "        \"\"\"Update availability for date range. Returns rows affected.\"\"\"",
    "        pass",
    "",
    "",
    "class BookingRepository(ABC):",
    "    \"\"\"Abstract repository for booking operations.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def create_booking(self, booking: Booking) -> str:",
    "        \"\"\"Create a new booking. Returns booking ID.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_booking(self, booking_id: str) -> Optional[Booking]:",
    "        \"\"\"Get booking by ID.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_by_idempotency_key(self, key: str) -> Optional[Booking]:",
    "        \"\"\"Find existing booking by idempotency key.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def update_status(self, booking_id: str, status: BookingStatus) -> bool:",
    "        \"\"\"Update booking status.\"\"\"",
    "        pass",
    "",
    "",
    "# ============================================================================",
    "# IN-MEMORY IMPLEMENTATIONS (For Demonstration)",
    "# ============================================================================",
    "",
    "class InMemoryAvailabilityRepository(AvailabilityRepository):",
    "    \"\"\"",
    "    In-memory implementation of availability repository.",
    "    ",
    "    NOTE: In production, this would use PostgreSQL with proper locking:",
    "    ",
    "        SELECT * FROM room_availability",
    "        WHERE room_id = $1 AND date >= $2 AND date < $3",
    "        FOR UPDATE;",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Key: (room_id, date), Value: RoomAvailability",
    "        self._availability: Dict[Tuple[str, date], RoomAvailability] = {}",
    "        self._locks: Dict[str, bool] = {}  # Simulated row locks",
    "    ",
    "    def initialize_room(self, room_id: str, price_cents: int, days_ahead: int = 365):",
    "        \"\"\"Pre-populate availability for a room.\"\"\"",
    "        today = date.today()",
    "        for i in range(days_ahead):",
    "            d = today + timedelta(days=i)",
    "            self._availability[(room_id, d)] = RoomAvailability(",
    "                room_id=room_id,",
    "                date=d,",
    "                is_available=True,",
    "                booking_id=None,",
    "                price_cents=price_cents",
    "            )",
    "    ",
    "    def get_availability_for_update(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date",
    "    ) -> List[RoomAvailability]:",
    "        \"\"\"Get availability with simulated lock.\"\"\"",
    "        result = []",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key in self._availability:",
    "                result.append(self._availability[key])",
    "            current += timedelta(days=1)",
    "        return result",
    "    ",
    "    def update_availability(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date,",
    "        is_available: bool,",
    "        booking_id: Optional[str]",
    "    ) -> int:",
    "        \"\"\"Update availability for date range.\"\"\"",
    "        updated = 0",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key in self._availability:",
    "                avail = self._availability[key]",
    "                self._availability[key] = RoomAvailability(",
    "                    room_id=room_id,",
    "                    date=current,",
    "                    is_available=is_available,",
    "                    booking_id=booking_id,",
    "                    price_cents=avail.price_cents",
    "                )",
    "                updated += 1",
    "            current += timedelta(days=1)",
    "        return updated",
    "",
    "",
    "class InMemoryBookingRepository(BookingRepository):",
    "    \"\"\"In-memory implementation of booking repository.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._bookings: Dict[str, Booking] = {}",
    "        self._by_idempotency_key: Dict[str, str] = {}",
    "    ",
    "    def create_booking(self, booking: Booking) -> str:",
    "        self._bookings[booking.id] = booking",
    "        self._by_idempotency_key[booking.idempotency_key] = booking.id",
    "        return booking.id",
    "    ",
    "    def get_booking(self, booking_id: str) -> Optional[Booking]:",
    "        return self._bookings.get(booking_id)",
    "    ",
    "    def get_by_idempotency_key(self, key: str) -> Optional[Booking]:",
    "        booking_id = self._by_idempotency_key.get(key)",
    "        return self._bookings.get(booking_id) if booking_id else None",
    "    ",
    "    def update_status(self, booking_id: str, status: BookingStatus) -> bool:",
    "        if booking_id in self._bookings:",
    "            old = self._bookings[booking_id]",
    "            self._bookings[booking_id] = Booking(",
    "                id=old.id,",
    "                user_id=old.user_id,",
    "                room_id=old.room_id,",
    "                check_in=old.check_in,",
    "                check_out=old.check_out,",
    "                status=status,",
    "                total_price_cents=old.total_price_cents,",
    "                created_at=old.created_at,",
    "                idempotency_key=old.idempotency_key",
    "            )",
    "            return True",
    "        return False",
    "",
    "",
    "# ============================================================================",
    "# PAYMENT SERVICE (Simulated)",
    "# ============================================================================",
    "",
    "class PaymentService:",
    "    \"\"\"",
    "    Simulated payment service.",
    "    ",
    "    In production, this would integrate with Stripe/Braintree/etc.",
    "    \"\"\"",
    "    ",
    "    def pre_authorize(self, payment_token: str, amount_cents: int) -> Tuple[bool, str]:",
    "        \"\"\"",
    "        Pre-authorize a payment (hold funds without capturing).",
    "        ",
    "        Returns:",
    "            Tuple of (success, auth_id or error_message)",
    "        \"\"\"",
    "        # Simulate: all payments succeed except tokens starting with 'fail_'",
    "        if payment_token.startswith('fail_'):",
    "            return (False, \"Card declined\")",
    "        ",
    "        auth_id = f\"auth_{uuid.uuid4().hex[:8]}\"",
    "        return (True, auth_id)",
    "    ",
    "    def capture(self, auth_id: str) -> bool:",
    "        \"\"\"Capture a pre-authorized payment.\"\"\"",
    "        return True",
    "    ",
    "    def refund(self, auth_id: str, amount_cents: int) -> Tuple[bool, str]:",
    "        \"\"\"Process refund.\"\"\"",
    "        refund_id = f\"refund_{uuid.uuid4().hex[:8]}\"",
    "        return (True, refund_id)",
    "",
    "",
    "# ============================================================================",
    "# BOOKING SERVICE (Core Business Logic)",
    "# ============================================================================",
    "",
    "class BookingService:",
    "    \"\"\"",
    "    Core booking service implementing the reservation logic.",
    "    ",
    "    This service handles:",
    "    - Availability checking with locking",
    "    - Booking creation with payment integration",
    "    - Cancellation with refund processing",
    "    ",
    "    Key Design Decisions:",
    "    1. Pessimistic locking via SELECT FOR UPDATE",
    "    2. Payment pre-authorization within transaction",
    "    3. Idempotency key to prevent duplicate bookings",
    "    4. Immediate availability update on cancellation",
    "    \"\"\"",
    "    ",
    "    def __init__(",
    "        self,",
    "        availability_repo: AvailabilityRepository,",
    "        booking_repo: BookingRepository,",
    "        payment_service: PaymentService",
    "    ):",
    "        self._availability_repo = availability_repo",
    "        self._booking_repo = booking_repo",
    "        self._payment_service = payment_service",
    "    ",
    "    def create_booking(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Create a new booking with proper concurrency handling.",
    "        ",
    "        Algorithm:",
    "        1. Check for existing booking with same idempotency key",
    "        2. Acquire locks on availability rows (SELECT FOR UPDATE)",
    "        3. Verify all days are available",
    "        4. Pre-authorize payment",
    "        5. Create booking record",
    "        6. Update availability to unavailable",
    "        7. Return confirmation",
    "        ",
    "        Args:",
    "            request: BookingRequest with user, room, dates, payment info",
    "            ",
    "        Returns:",
    "            BookingResponse with success/failure and booking details",
    "        \"\"\"",
    "        # Step 1: Idempotency check",
    "        existing = self._booking_repo.get_by_idempotency_key(request.idempotency_key)",
    "        if existing:",
    "            return BookingResponse(",
    "                success=True,",
    "                booking_id=existing.id,",
    "                confirmation_code=f\"CONF_{existing.id[-6:].upper()}\",",
    "                error=None,",
    "                total_price_cents=existing.total_price_cents",
    "            )",
    "        ",
    "        # Step 2: Get availability with lock",
    "        # In production: SELECT * FROM room_availability ... FOR UPDATE",
    "        availability = self._availability_repo.get_availability_for_update(",
    "            request.room_id,",
    "            request.check_in,",
    "            request.check_out",
    "        )",
    "        ",
    "        # Step 3: Verify all days available",
    "        expected_days = (request.check_out - request.check_in).days",
    "        if len(availability) != expected_days:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking_id=None,",
    "                confirmation_code=None,",
    "                error=\"Room not found or dates invalid\",",
    "                total_price_cents=None",
    "            )",
    "        ",
    "        unavailable_dates = [a.date for a in availability if not a.is_available]",
    "        if unavailable_dates:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking_id=None,",
    "                confirmation_code=None,",
    "                error=f\"Room not available on: {unavailable_dates[0]}\",",
    "                total_price_cents=None",
    "            )",
    "        ",
    "        # Calculate total price",
    "        total_price_cents = sum(a.price_cents for a in availability)",
    "        ",
    "        # Step 4: Pre-authorize payment",
    "        payment_success, payment_result = self._payment_service.pre_authorize(",
    "            request.payment_token,",
    "            total_price_cents",
    "        )",
    "        ",
    "        if not payment_success:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking_id=None,",
    "                confirmation_code=None,",
    "                error=f\"Payment failed: {payment_result}\",",
    "                total_price_cents=None",
    "            )",
    "        ",
    "        # Step 5: Create booking record",
    "        booking_id = f\"BK_{uuid.uuid4().hex[:12].upper()}\"",
    "        booking = Booking(",
    "            id=booking_id,",
    "            user_id=request.user_id,",
    "            room_id=request.room_id,",
    "            check_in=request.check_in,",
    "            check_out=request.check_out,",
    "            status=BookingStatus.CONFIRMED,",
    "            total_price_cents=total_price_cents,",
    "            created_at=datetime.now(),",
    "            idempotency_key=request.idempotency_key",
    "        )",
    "        self._booking_repo.create_booking(booking)",
    "        ",
    "        # Step 6: Update availability",
    "        self._availability_repo.update_availability(",
    "            request.room_id,",
    "            request.check_in,",
    "            request.check_out,",
    "            is_available=False,",
    "            booking_id=booking_id",
    "        )",
    "        ",
    "        # Step 7: Return success",
    "        return BookingResponse(",
    "            success=True,",
    "            booking_id=booking_id,",
    "            confirmation_code=f\"CONF_{booking_id[-6:]}\",",
    "            error=None,",
    "            total_price_cents=total_price_cents",
    "        )",
    "    ",
    "    def cancel_booking(",
    "        self,",
    "        booking_id: str,",
    "        user_id: str",
    "    ) -> Tuple[bool, Optional[int], str]:",
    "        \"\"\"",
    "        Cancel a booking and release availability.",
    "        ",
    "        Returns:",
    "            Tuple of (success, refund_amount_cents, message)",
    "        \"\"\"",
    "        booking = self._booking_repo.get_booking(booking_id)",
    "        ",
    "        if not booking:",
    "            return (False, None, \"Booking not found\")",
    "        ",
    "        if booking.user_id != user_id:",
    "            return (False, None, \"Unauthorized\")",
    "        ",
    "        if booking.status != BookingStatus.CONFIRMED:",
    "            return (False, None, f\"Cannot cancel: status is {booking.status.value}\")",
    "        ",
    "        # Calculate refund based on policy",
    "        days_until_checkin = (booking.check_in - date.today()).days",
    "        if days_until_checkin > 2:",
    "            refund_percent = 100",
    "        elif days_until_checkin >= 1:",
    "            refund_percent = 50",
    "        else:",
    "            refund_percent = 0",
    "        ",
    "        refund_amount = (booking.total_price_cents * refund_percent) // 100",
    "        ",
    "        # Update booking status",
    "        self._booking_repo.update_status(booking_id, BookingStatus.CANCELLED)",
    "        ",
    "        # Release availability immediately",
    "        self._availability_repo.update_availability(",
    "            booking.room_id,",
    "            booking.check_in,",
    "            booking.check_out,",
    "            is_available=True,",
    "            booking_id=None",
    "        )",
    "        ",
    "        # Process refund (in production, this would be async)",
    "        if refund_amount > 0:",
    "            self._payment_service.refund(f\"auth_{booking_id}\", refund_amount)",
    "        ",
    "        return (",
    "            True,",
    "            refund_amount,",
    "            f\"Cancelled with {refund_percent}% refund\"",
    "        )",
    "    ",
    "    def get_booking(self, booking_id: str) -> Optional[Booking]:",
    "        \"\"\"Retrieve booking by ID.\"\"\"",
    "        return self._booking_repo.get_booking(booking_id)",
    "",
    "",
    "# ============================================================================",
    "# DEMONSTRATION",
    "# ============================================================================",
    "",
    "def main():",
    "    \"\"\"",
    "    Demonstrate the booking system with various scenarios.",
    "    \"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"        HOTEL BOOKING SYSTEM - DEMONSTRATION\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Initialize repositories and services",
    "    availability_repo = InMemoryAvailabilityRepository()",
    "    booking_repo = InMemoryBookingRepository()",
    "    payment_service = PaymentService()",
    "    booking_service = BookingService(",
    "        availability_repo,",
    "        booking_repo,",
    "        payment_service",
    "    )",
    "    ",
    "    # Pre-populate room availability",
    "    print(\"\\n[Setup] Initializing room availability...\")",
    "    availability_repo.initialize_room(\"ROOM_NYC_101\", 25000)  # $250/night",
    "    availability_repo.initialize_room(\"ROOM_NYC_102\", 30000)  # $300/night",
    "    print(\"  \u2713 Room ROOM_NYC_101: $250/night\")",
    "    print(\"  \u2713 Room ROOM_NYC_102: $300/night\")",
    "    ",
    "    # ========================================",
    "    # Scenario 1: Successful Booking",
    "    # ========================================",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 1: Successful Booking\")",
    "    print(\"-\" * 70)",
    "    ",
    "    today = date.today()",
    "    check_in = today + timedelta(days=7)",
    "    check_out = today + timedelta(days=10)",
    "    ",
    "    request1 = BookingRequest(",
    "        user_id=\"USER_123\",",
    "        room_id=\"ROOM_NYC_101\",",
    "        check_in=check_in,",
    "        check_out=check_out,",
    "        payment_token=\"tok_visa_4242\",",
    "        idempotency_key=\"req_abc123\"",
    "    )",
    "    ",
    "    print(f\"  Request: User USER_123 booking ROOM_NYC_101\")",
    "    print(f\"  Dates: {check_in} to {check_out} (3 nights)\")",
    "    ",
    "    response1 = booking_service.create_booking(request1)",
    "    ",
    "    if response1.success:",
    "        print(f\"  \u2713 CONFIRMED: {response1.booking_id}\")",
    "        print(f\"    Confirmation: {response1.confirmation_code}\")",
    "        print(f\"    Total: ${response1.total_price_cents / 100:.2f}\")",
    "    else:",
    "        print(f\"  \u2717 FAILED: {response1.error}\")",
    "    ",
    "    # ========================================",
    "    # Scenario 2: Concurrent Booking Conflict",
    "    # ========================================",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 2: Concurrent Booking Conflict\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # User B tries to book overlapping dates",
    "    check_in_b = today + timedelta(days=8)",
    "    check_out_b = today + timedelta(days=12)",
    "    ",
    "    request2 = BookingRequest(",
    "        user_id=\"USER_456\",",
    "        room_id=\"ROOM_NYC_101\",",
    "        check_in=check_in_b,",
    "        check_out=check_out_b,",
    "        payment_token=\"tok_visa_5555\",",
    "        idempotency_key=\"req_def456\"",
    "    )",
    "    ",
    "    print(f\"  Request: User USER_456 booking ROOM_NYC_101\")",
    "    print(f\"  Dates: {check_in_b} to {check_out_b} (overlaps with Scenario 1)\")",
    "    ",
    "    response2 = booking_service.create_booking(request2)",
    "    ",
    "    if response2.success:",
    "        print(f\"  \u2713 CONFIRMED: {response2.booking_id}\")",
    "    else:",
    "        print(f\"  \u2717 CORRECTLY REJECTED: {response2.error}\")",
    "        print(\"    \u2192 System prevented double-booking! \u2713\")",
    "    ",
    "    # ========================================",
    "    # Scenario 3: Idempotency Check",
    "    # ========================================",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 3: Idempotency (Duplicate Request)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # Same idempotency key as request1",
    "    response3 = booking_service.create_booking(request1)",
    "    ",
    "    print(f\"  Request: Duplicate of Scenario 1 (same idempotency key)\")",
    "    if response3.success and response3.booking_id == response1.booking_id:",
    "        print(f\"  \u2713 Returned existing booking: {response3.booking_id}\")",
    "        print(\"    \u2192 No duplicate created! \u2713\")",
    "    ",
    "    # ========================================",
    "    # Scenario 4: Payment Failure",
    "    # ========================================",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 4: Payment Failure\")",
    "    print(\"-\" * 70)",
    "    ",
    "    check_in_c = today + timedelta(days=20)",
    "    check_out_c = today + timedelta(days=22)",
    "    ",
    "    request4 = BookingRequest(",
    "        user_id=\"USER_789\",",
    "        room_id=\"ROOM_NYC_102\",",
    "        check_in=check_in_c,",
    "        check_out=check_out_c,",
    "        payment_token=\"fail_declined\",  # Token that simulates decline",
    "        idempotency_key=\"req_ghi789\"",
    "    )",
    "    ",
    "    print(f\"  Request: User USER_789 with declined card\")",
    "    ",
    "    response4 = booking_service.create_booking(request4)",
    "    ",
    "    if not response4.success:",
    "        print(f\"  \u2717 CORRECTLY FAILED: {response4.error}\")",
    "        print(\"    \u2192 Room remains available for others! \u2713\")",
    "    ",
    "    # ========================================",
    "    # Scenario 5: Cancellation and Rebooking",
    "    # ========================================",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 5: Cancellation and Rebooking\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # Cancel the first booking",
    "    print(f\"  Cancelling booking {response1.booking_id}...\")",
    "    cancel_success, refund_amount, cancel_msg = booking_service.cancel_booking(",
    "        response1.booking_id,",
    "        \"USER_123\"",
    "    )",
    "    ",
    "    if cancel_success:",
    "        print(f\"  \u2713 CANCELLED: {cancel_msg}\")",
    "        print(f\"    Refund: ${refund_amount / 100:.2f}\")",
    "    ",
    "    # Now User B can book those dates",
    "    request5 = BookingRequest(",
    "        user_id=\"USER_456\",",
    "        room_id=\"ROOM_NYC_101\",",
    "        check_in=check_in,",
    "        check_out=check_out,",
    "        payment_token=\"tok_visa_5555\",",
    "        idempotency_key=\"req_jkl012\"",
    "    )",
    "    ",
    "    print(f\"\\n  User USER_456 re-attempting booking...\")",
    "    response5 = booking_service.create_booking(request5)",
    "    ",
    "    if response5.success:",
    "        print(f\"  \u2713 NOW AVAILABLE: {response5.booking_id}\")",
    "        print(f\"    \u2192 Room freed after cancellation! \u2713\")",
    "    ",
    "    # ========================================",
    "    # Summary",
    "    # ========================================",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"        DEMONSTRATION COMPLETE\")",
    "    print(\"=\" * 70)",
    "    print(\"\\nKey Points Demonstrated:\")",
    "    print(\"  1. \u2713 Basic booking flow with payment\")",
    "    print(\"  2. \u2713 Double-booking prevention\")",
    "    print(\"  3. \u2713 Idempotency for duplicate requests\")",
    "    print(\"  4. \u2713 Payment failure handling\")",
    "    print(\"  5. \u2713 Cancellation frees inventory\")",
    "    print()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.LocalDate;",
    "import java.time.LocalDateTime;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "",
    "/**",
    " * Hotel Booking System - Core Implementation (Java)",
    " * ",
    " * Demonstrates proper concurrency handling for reservation systems.",
    " * Uses pessimistic locking pattern to prevent double-bookings.",
    " */",
    "public class HotelBookingSystem {",
    "",
    "    // ========================================================================",
    "    // DOMAIN MODELS",
    "    // ========================================================================",
    "",
    "    public enum BookingStatus {",
    "        PENDING, CONFIRMED, CANCELLED, COMPLETED",
    "    }",
    "",
    "    public record Room(",
    "        String id,",
    "        String hotelId,",
    "        String roomType,",
    "        int capacity,",
    "        int basePriceCents,",
    "        List<String> amenities",
    "    ) {}",
    "",
    "    public record RoomAvailability(",
    "        String roomId,",
    "        LocalDate date,",
    "        boolean isAvailable,",
    "        String bookingId,",
    "        int priceCents",
    "    ) {}",
    "",
    "    public record Booking(",
    "        String id,",
    "        String userId,",
    "        String roomId,",
    "        LocalDate checkIn,",
    "        LocalDate checkOut,",
    "        BookingStatus status,",
    "        int totalPriceCents,",
    "        LocalDateTime createdAt,",
    "        String idempotencyKey",
    "    ) {",
    "        public long getNights() {",
    "            return ChronoUnit.DAYS.between(checkIn, checkOut);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // REQUEST/RESPONSE OBJECTS",
    "    // ========================================================================",
    "",
    "    public record BookingRequest(",
    "        String userId,",
    "        String roomId,",
    "        LocalDate checkIn,",
    "        LocalDate checkOut,",
    "        String paymentToken,",
    "        String idempotencyKey",
    "    ) {}",
    "",
    "    public record BookingResponse(",
    "        boolean success,",
    "        String bookingId,",
    "        String confirmationCode,",
    "        String error,",
    "        Integer totalPriceCents",
    "    ) {",
    "        public static BookingResponse success(String bookingId, int totalPriceCents) {",
    "            return new BookingResponse(",
    "                true, ",
    "                bookingId, ",
    "                \"CONF_\" + bookingId.substring(bookingId.length() - 6),",
    "                null, ",
    "                totalPriceCents",
    "            );",
    "        }",
    "",
    "        public static BookingResponse failure(String error) {",
    "            return new BookingResponse(false, null, null, error, null);",
    "        }",
    "    }",
    "",
    "    public record CancelResponse(",
    "        boolean success,",
    "        Integer refundAmountCents,",
    "        String message",
    "    ) {}",
    "",
    "    // ========================================================================",
    "    // REPOSITORIES (In-Memory Implementation)",
    "    // ========================================================================",
    "",
    "    public static class AvailabilityRepository {",
    "        private final Map<String, RoomAvailability> availability = new ConcurrentHashMap<>();",
    "        private final Object lock = new Object();",
    "",
    "        public void initializeRoom(String roomId, int priceCents, int daysAhead) {",
    "            LocalDate today = LocalDate.now();",
    "            for (int i = 0; i < daysAhead; i++) {",
    "                LocalDate date = today.plusDays(i);",
    "                String key = roomId + \"_\" + date;",
    "                availability.put(key, new RoomAvailability(",
    "                    roomId, date, true, null, priceCents",
    "                ));",
    "            }",
    "        }",
    "",
    "        /**",
    "         * Get availability with simulated locking.",
    "         * In production: SELECT ... FOR UPDATE",
    "         */",
    "        public synchronized List<RoomAvailability> getAvailabilityForUpdate(",
    "                String roomId, LocalDate checkIn, LocalDate checkOut) {",
    "            List<RoomAvailability> result = new ArrayList<>();",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                String key = roomId + \"_\" + current;",
    "                RoomAvailability avail = availability.get(key);",
    "                if (avail != null) {",
    "                    result.add(avail);",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "            return result;",
    "        }",
    "",
    "        public synchronized int updateAvailability(",
    "                String roomId, LocalDate checkIn, LocalDate checkOut,",
    "                boolean isAvailable, String bookingId) {",
    "            int updated = 0;",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                String key = roomId + \"_\" + current;",
    "                RoomAvailability old = availability.get(key);",
    "                if (old != null) {",
    "                    availability.put(key, new RoomAvailability(",
    "                        roomId, current, isAvailable, bookingId, old.priceCents()",
    "                    ));",
    "                    updated++;",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "            return updated;",
    "        }",
    "    }",
    "",
    "    public static class BookingRepository {",
    "        private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "        private final Map<String, String> byIdempotencyKey = new ConcurrentHashMap<>();",
    "",
    "        public String createBooking(Booking booking) {",
    "            bookings.put(booking.id(), booking);",
    "            byIdempotencyKey.put(booking.idempotencyKey(), booking.id());",
    "            return booking.id();",
    "        }",
    "",
    "        public Optional<Booking> getBooking(String bookingId) {",
    "            return Optional.ofNullable(bookings.get(bookingId));",
    "        }",
    "",
    "        public Optional<Booking> getByIdempotencyKey(String key) {",
    "            String bookingId = byIdempotencyKey.get(key);",
    "            return bookingId != null ? Optional.ofNullable(bookings.get(bookingId)) : Optional.empty();",
    "        }",
    "",
    "        public boolean updateStatus(String bookingId, BookingStatus status) {",
    "            Booking old = bookings.get(bookingId);",
    "            if (old != null) {",
    "                bookings.put(bookingId, new Booking(",
    "                    old.id(), old.userId(), old.roomId(),",
    "                    old.checkIn(), old.checkOut(), status,",
    "                    old.totalPriceCents(), old.createdAt(), old.idempotencyKey()",
    "                ));",
    "                return true;",
    "            }",
    "            return false;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // PAYMENT SERVICE (Simulated)",
    "    // ========================================================================",
    "",
    "    public static class PaymentService {",
    "        public record PaymentResult(boolean success, String authIdOrError) {}",
    "",
    "        public PaymentResult preAuthorize(String paymentToken, int amountCents) {",
    "            if (paymentToken.startsWith(\"fail_\")) {",
    "                return new PaymentResult(false, \"Card declined\");",
    "            }",
    "            String authId = \"auth_\" + UUID.randomUUID().toString().substring(0, 8);",
    "            return new PaymentResult(true, authId);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // BOOKING SERVICE (Core Business Logic)",
    "    // ========================================================================",
    "",
    "    public static class BookingService {",
    "        private final AvailabilityRepository availabilityRepo;",
    "        private final BookingRepository bookingRepo;",
    "        private final PaymentService paymentService;",
    "",
    "        public BookingService(",
    "                AvailabilityRepository availabilityRepo,",
    "                BookingRepository bookingRepo,",
    "                PaymentService paymentService) {",
    "            this.availabilityRepo = availabilityRepo;",
    "            this.bookingRepo = bookingRepo;",
    "            this.paymentService = paymentService;",
    "        }",
    "",
    "        /**",
    "         * Create a booking with proper concurrency handling.",
    "         * Uses synchronized block to simulate database-level locking.",
    "         */",
    "        public synchronized BookingResponse createBooking(BookingRequest request) {",
    "            // Step 1: Idempotency check",
    "            Optional<Booking> existing = bookingRepo.getByIdempotencyKey(request.idempotencyKey());",
    "            if (existing.isPresent()) {",
    "                Booking b = existing.get();",
    "                return BookingResponse.success(b.id(), b.totalPriceCents());",
    "            }",
    "",
    "            // Step 2: Get availability with lock",
    "            List<RoomAvailability> availability = availabilityRepo.getAvailabilityForUpdate(",
    "                request.roomId(), request.checkIn(), request.checkOut()",
    "            );",
    "",
    "            // Step 3: Verify all days available",
    "            long expectedDays = ChronoUnit.DAYS.between(request.checkIn(), request.checkOut());",
    "            if (availability.size() != expectedDays) {",
    "                return BookingResponse.failure(\"Room not found or dates invalid\");",
    "            }",
    "",
    "            Optional<LocalDate> unavailableDate = availability.stream()",
    "                .filter(a -> !a.isAvailable())",
    "                .map(RoomAvailability::date)",
    "                .findFirst();",
    "",
    "            if (unavailableDate.isPresent()) {",
    "                return BookingResponse.failure(",
    "                    \"Room not available on: \" + unavailableDate.get()",
    "                );",
    "            }",
    "",
    "            // Calculate total",
    "            int totalPriceCents = availability.stream()",
    "                .mapToInt(RoomAvailability::priceCents)",
    "                .sum();",
    "",
    "            // Step 4: Pre-authorize payment",
    "            PaymentService.PaymentResult paymentResult = ",
    "                paymentService.preAuthorize(request.paymentToken(), totalPriceCents);",
    "",
    "            if (!paymentResult.success()) {",
    "                return BookingResponse.failure(\"Payment failed: \" + paymentResult.authIdOrError());",
    "            }",
    "",
    "            // Step 5: Create booking",
    "            String bookingId = \"BK_\" + UUID.randomUUID().toString().substring(0, 12).toUpperCase();",
    "            Booking booking = new Booking(",
    "                bookingId, request.userId(), request.roomId(),",
    "                request.checkIn(), request.checkOut(),",
    "                BookingStatus.CONFIRMED, totalPriceCents,",
    "                LocalDateTime.now(), request.idempotencyKey()",
    "            );",
    "            bookingRepo.createBooking(booking);",
    "",
    "            // Step 6: Update availability",
    "            availabilityRepo.updateAvailability(",
    "                request.roomId(), request.checkIn(), request.checkOut(),",
    "                false, bookingId",
    "            );",
    "",
    "            return BookingResponse.success(bookingId, totalPriceCents);",
    "        }",
    "",
    "        public CancelResponse cancelBooking(String bookingId, String userId) {",
    "            Optional<Booking> bookingOpt = bookingRepo.getBooking(bookingId);",
    "            ",
    "            if (bookingOpt.isEmpty()) {",
    "                return new CancelResponse(false, null, \"Booking not found\");",
    "            }",
    "",
    "            Booking booking = bookingOpt.get();",
    "            ",
    "            if (!booking.userId().equals(userId)) {",
    "                return new CancelResponse(false, null, \"Unauthorized\");",
    "            }",
    "",
    "            if (booking.status() != BookingStatus.CONFIRMED) {",
    "                return new CancelResponse(false, null, ",
    "                    \"Cannot cancel: status is \" + booking.status());",
    "            }",
    "",
    "            // Calculate refund",
    "            long daysUntilCheckin = ChronoUnit.DAYS.between(LocalDate.now(), booking.checkIn());",
    "            int refundPercent = daysUntilCheckin > 2 ? 100 : (daysUntilCheckin >= 1 ? 50 : 0);",
    "            int refundAmount = (booking.totalPriceCents() * refundPercent) / 100;",
    "",
    "            // Update status and release availability",
    "            bookingRepo.updateStatus(bookingId, BookingStatus.CANCELLED);",
    "            availabilityRepo.updateAvailability(",
    "                booking.roomId(), booking.checkIn(), booking.checkOut(),",
    "                true, null",
    "            );",
    "",
    "            return new CancelResponse(true, refundAmount, ",
    "                \"Cancelled with \" + refundPercent + \"% refund\");",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN - DEMONSTRATION",
    "    // ========================================================================",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"        HOTEL BOOKING SYSTEM - JAVA DEMONSTRATION\");",
    "        System.out.println(\"=\".repeat(70));",
    "",
    "        // Initialize",
    "        AvailabilityRepository availabilityRepo = new AvailabilityRepository();",
    "        BookingRepository bookingRepo = new BookingRepository();",
    "        PaymentService paymentService = new PaymentService();",
    "        BookingService bookingService = new BookingService(",
    "            availabilityRepo, bookingRepo, paymentService",
    "        );",
    "",
    "        availabilityRepo.initializeRoom(\"ROOM_101\", 25000, 365);",
    "        System.out.println(\"\\n[Setup] Room ROOM_101 initialized at $250/night\");",
    "",
    "        // Scenario 1: Successful booking",
    "        System.out.println(\"\\n\" + \"-\".repeat(70));",
    "        System.out.println(\"SCENARIO 1: Successful Booking\");",
    "",
    "        LocalDate checkIn = LocalDate.now().plusDays(7);",
    "        LocalDate checkOut = LocalDate.now().plusDays(10);",
    "",
    "        BookingRequest req1 = new BookingRequest(",
    "            \"USER_123\", \"ROOM_101\", checkIn, checkOut,",
    "            \"tok_visa_4242\", \"req_abc123\"",
    "        );",
    "",
    "        BookingResponse resp1 = bookingService.createBooking(req1);",
    "        System.out.println(\"  Result: \" + (resp1.success() ? \"SUCCESS\" : \"FAILED\"));",
    "        if (resp1.success()) {",
    "            System.out.println(\"  Booking ID: \" + resp1.bookingId());",
    "            System.out.println(\"  Total: $\" + (resp1.totalPriceCents() / 100.0));",
    "        }",
    "",
    "        // Scenario 2: Concurrent booking conflict",
    "        System.out.println(\"\\n\" + \"-\".repeat(70));",
    "        System.out.println(\"SCENARIO 2: Concurrent Booking (Overlapping Dates)\");",
    "",
    "        BookingRequest req2 = new BookingRequest(",
    "            \"USER_456\", \"ROOM_101\", checkIn.plusDays(1), checkOut.plusDays(2),",
    "            \"tok_visa_5555\", \"req_def456\"",
    "        );",
    "",
    "        BookingResponse resp2 = bookingService.createBooking(req2);",
    "        System.out.println(\"  Result: \" + (resp2.success() ? \"SUCCESS\" : \"FAILED\"));",
    "        if (!resp2.success()) {",
    "            System.out.println(\"  Error: \" + resp2.error());",
    "            System.out.println(\"  \u2192 Double-booking prevented! \u2713\");",
    "        }",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"        DEMONSTRATION COMPLETE\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "section": "Imports and Module Docstring",
      "explanation": "We import dataclasses for clean domain models, datetime for date handling, Decimal for currency (though we use cents in this implementation), and ABC for abstract base classes. The module docstring explains the purpose and key design decision (pessimistic locking)."
    },
    {
      "lines": "22-50",
      "section": "Domain Models (BookingStatus, Hotel, Room)",
      "explanation": "Core domain entities using @dataclass for clean, immutable-like structures. BookingStatus enum defines the booking lifecycle. Room includes base_price_cents - we store currency as integers to avoid floating point issues."
    },
    {
      "lines": "52-80",
      "section": "RoomAvailability Model",
      "explanation": "**CRITICAL TABLE**: One row per (room_id, date) combination. This is the key to preventing double-bookings. The is_available flag is the source of truth. booking_id links to the reservation that occupies this date."
    },
    {
      "lines": "82-110",
      "section": "Request/Response DTOs",
      "explanation": "Clean separation of API contracts from internal models. Note BookingRequest has idempotency_key - this is essential for handling network retries without creating duplicate bookings."
    },
    {
      "lines": "112-140",
      "section": "Custom Exceptions",
      "explanation": "Domain-specific exceptions for clear error handling. RoomNotAvailableException vs PaymentFailedException allows the API layer to return appropriate HTTP status codes."
    },
    {
      "lines": "142-200",
      "section": "Repository Interfaces",
      "explanation": "Abstract base classes defining the contract for data access. The key method is get_availability_for_update() - in production, this would execute SELECT ... FOR UPDATE to acquire exclusive row locks."
    },
    {
      "lines": "202-280",
      "section": "In-Memory Repository Implementations",
      "explanation": "Demo implementations using dictionaries. Key point: initialize_room() pre-populates 365 days of availability. In production, this would be a scheduled job or trigger when a new room is added."
    },
    {
      "lines": "282-320",
      "section": "Payment Service",
      "explanation": "Simulated payment integration. pre_authorize() returns (success, auth_id). In production, this would call Stripe/Braintree. Notice: tokens starting with 'fail_' simulate declined cards for testing."
    },
    {
      "lines": "322-450",
      "section": "BookingService.create_booking()",
      "explanation": "**THE CORE LOGIC**: 7-step algorithm:\n1. Check idempotency key for existing booking\n2. Get availability with lock (SELECT FOR UPDATE)\n3. Verify ALL days are available\n4. Pre-authorize payment\n5. Insert booking record\n6. Update availability to unavailable\n7. Return confirmation\n\nSteps 2-6 would be in a single database transaction in production."
    },
    {
      "lines": "452-520",
      "section": "BookingService.cancel_booking()",
      "explanation": "Cancellation flow: Validate ownership, calculate refund based on policy (100%/>48hr, 50%/24-48hr, 0%/<24hr), update booking status, release availability immediately (set is_available=true), process refund async."
    },
    {
      "lines": "522-650",
      "section": "main() Demonstration",
      "explanation": "Five scenarios demonstrating the system:\n1. Successful booking\n2. Concurrent booking conflict (correctly rejected)\n3. Idempotency (duplicate request returns existing booking)\n4. Payment failure (room remains available)\n5. Cancellation frees inventory"
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. First test availability initialization - verify 365 rows created per room\n2. Test single successful booking - verify availability updated\n3. Test overlapping booking - should fail with clear error\n4. Test idempotency - same key returns same booking\n5. Test cancellation - verify availability freed",
    "what_to_print_or_assert": [
      "print(f'Availability before: {availability_repo._availability[(room_id, date)]}')",
      "assert len(availability) == expected_days, f'Expected {expected_days} days, got {len(availability)}'",
      "assert all(a.is_available for a in availability), 'Some days not available'",
      "print(f'Booking created: {booking_id}, total: {total_price_cents}')"
    ],
    "common_failure_modes": [
      "**Off-by-one in date range**: check_out is exclusive, so Jun 15-18 is 3 nights, not 4",
      "**Missing FOR UPDATE**: Without locking, race conditions occur",
      "**Idempotency key reuse**: Same key with different params returns wrong booking",
      "**Payment called before availability check**: Could charge for unavailable room"
    ],
    "how_to_fix_fast": "1. Add verbose logging at each step of create_booking\n2. Print the availability list after fetching\n3. If booking fails, print which date was unavailable\n4. If payment fails, ensure no availability was modified\n5. Use a debugger to step through the transaction"
  },
  "complexity_analysis": {
    "time": {
      "searchRooms": {
        "complexity": "O(log N + K)",
        "explanation": "Elasticsearch query O(log N) + returning K results"
      },
      "getRoomDetails": {
        "complexity": "O(D)",
        "explanation": "D = number of days in range; one lookup per day"
      },
      "createBooking": {
        "complexity": "O(D)",
        "explanation": "D = number of nights; read and update D availability rows"
      },
      "cancelBooking": {
        "complexity": "O(D)",
        "explanation": "Update D availability rows + 1 booking row"
      },
      "overall": "All operations are O(D) where D = booking duration (typically 1-14 nights)"
    },
    "space": {
      "complexity": "O(R \u00d7 365) for availability storage",
      "breakdown": "- Room availability: R rooms \u00d7 365 days = O(R \u00d7 365) rows\n- Bookings: O(B) where B = number of bookings\n- Search index: O(R \u00d7 365) documents in Elasticsearch\n- Cache: O(R) for room details + hot availability",
      "note": "For 10M rooms: 10M \u00d7 365 = 3.65B availability rows. Need sharding by hotel_id or region."
    },
    "can_we_do_better": "The per-day availability model is optimal for correctness and query simplicity. For very long stays (vacation rentals), could use interval trees instead of per-day rows. For search, ES is already near-optimal."
  },
  "dry_run": {
    "example": "User A books ROOM_101 Jun 15-18, then User B tries to book Jun 17-20",
    "trace_table": "| Step | Actor | Operation | room_availability | bookings | Result |\n|------|-------|-----------|-------------------|----------|--------|\n| 1 | System | Initialize | Jun 15-17: \u2713 available | (empty) | Setup complete |\n| 2 | User A | SELECT FOR UPDATE Jun 15-17 | \ud83d\udd12 Locked | - | Rows locked |\n| 3 | User A | Check availability | All \u2713 | - | Proceed |\n| 4 | User A | Payment pre-auth | - | - | Success, auth_123 |\n| 5 | User A | INSERT booking | - | BK_001: CONFIRMED | Created |\n| 6 | User A | UPDATE availability | Jun 15-17: \u274c, BK_001 | BK_001 | Marked unavailable |\n| 7 | User A | COMMIT | \ud83d\udd13 Unlocked | - | **Booking complete** |\n| 8 | User B | SELECT FOR UPDATE Jun 17-19 | Jun 17 = \u274c | - | Got rows |\n| 9 | User B | Check availability | Jun 17 is \u274c | - | **FAILED: unavailable** |\n| 10 | User B | ROLLBACK | - | - | Return error |",
    "final_answer": "User A: BK_001 confirmed for Jun 15-18 ($750)\nUser B: FAILED - Room not available on Jun 17"
  },
  "test_cases": [
    {
      "name": "Basic successful booking",
      "category": "Happy Path",
      "input": "Book ROOM_101, Jun 15-18, valid payment",
      "expected": "SUCCESS, booking_id, total = 3 \u00d7 $250 = $750",
      "explanation": "Standard 3-night booking with valid payment should succeed"
    },
    {
      "name": "Exact overlap rejection",
      "category": "Concurrency",
      "input": "A books Jun 15-18, B tries Jun 15-18 (same dates)",
      "expected": "A: SUCCESS, B: FAILED (room not available)",
      "explanation": "Identical date range conflict - second booking rejected"
    },
    {
      "name": "Partial overlap rejection",
      "category": "Concurrency",
      "input": "A books Jun 15-18, B tries Jun 17-20 (overlaps Jun 17)",
      "expected": "A: SUCCESS, B: FAILED (not available on Jun 17)",
      "explanation": "Even one day overlap causes rejection"
    },
    {
      "name": "Adjacent bookings allowed",
      "category": "Edge Case",
      "input": "A books Jun 15-18 (checkout Jun 18), B books Jun 18-20 (checkin Jun 18)",
      "expected": "A: SUCCESS, B: SUCCESS",
      "explanation": "Check-out date is exclusive, so same-day turnover is valid"
    },
    {
      "name": "Idempotency - duplicate request",
      "category": "Reliability",
      "input": "Same request twice with same idempotency_key",
      "expected": "Same booking_id returned, no duplicate created",
      "explanation": "Network retry shouldn't create duplicate bookings"
    },
    {
      "name": "Payment failure - room stays available",
      "category": "Error Handling",
      "input": "Book with payment_token='fail_declined'",
      "expected": "FAILED, room remains available for others",
      "explanation": "Payment failure should not lock the room"
    },
    {
      "name": "Cancellation frees inventory",
      "category": "Lifecycle",
      "input": "A books, A cancels, B books same dates",
      "expected": "A: book success, cancel success with refund, B: book success",
      "explanation": "Cancelled booking should immediately free dates"
    },
    {
      "name": "Zero-night booking",
      "category": "Edge Case",
      "input": "check_in = check_out = Jun 15",
      "expected": "FAILED or validated as 0 nights",
      "explanation": "Should reject or handle gracefully"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Application-level availability check without database lock",
      "why_wrong": "Race condition: Two threads read 'available', both proceed to book",
      "correct_approach": "Use SELECT FOR UPDATE or database-level UNIQUE constraint",
      "code_wrong": "if db.query('SELECT is_available ...'):  # No lock!\n    db.execute('INSERT booking ...')",
      "code_correct": "rows = db.query('SELECT * ... FOR UPDATE')  # Lock acquired\nif all(r.is_available for r in rows):\n    db.execute('INSERT booking ...')"
    },
    {
      "mistake": "Storing bookings as date ranges without per-day index",
      "why_wrong": "Overlap detection requires scanning all bookings: O(B) per query",
      "correct_approach": "Pre-expand to per-day rows with UNIQUE(room_id, date, is_available=false)",
      "code_wrong": "SELECT * FROM bookings \nWHERE room_id=? \n  AND check_in < ? \n  AND check_out > ?  -- O(N) scan",
      "code_correct": "SELECT * FROM room_availability \nWHERE room_id=? \n  AND date BETWEEN ? AND ?  -- Indexed O(D)"
    },
    {
      "mistake": "Charging payment before confirming availability",
      "why_wrong": "User charged but room already booked - requires refund handling",
      "correct_approach": "Use pre-authorization: authorize within transaction, capture later",
      "code_wrong": "payment.charge()  # Money taken\nif not is_available():  # Oops!\n    payment.refund()  # Complex, slow",
      "code_correct": "if is_available():\n    auth = payment.pre_authorize()  # Funds held\n    create_booking()\n    # Capture on check-in"
    },
    {
      "mistake": "Search queries hitting main database",
      "why_wrong": "100K QPS would overwhelm PostgreSQL; high latency",
      "correct_approach": "Use Elasticsearch with async sync from main DB",
      "code_wrong": "SELECT * FROM rooms r \nJOIN room_availability a ON r.id = a.room_id\nWHERE ...  -- Slow, blocks bookings",
      "code_correct": "# Elasticsearch query\nes.search(index='rooms', body={\n  'query': {'bool': {'filter': [...]}}\n})"
    },
    {
      "mistake": "Off-by-one error in date ranges",
      "why_wrong": "check_out is exclusive; Jun 15-18 is 3 nights, not 4",
      "correct_approach": "Use half-open interval [check_in, check_out)",
      "code_wrong": "for d in range(check_in, check_out + 1):  # +1 is wrong!",
      "code_correct": "current = check_in\nwhile current < check_out:  # Exclusive end\n    process(current)\n    current += timedelta(days=1)"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start, I'd like to clarify a few things to make sure I understand the requirements correctly...",
    "clarifying_questions_to_ask": [
      "What's the check-in/check-out time convention? Can the same day be someone's checkout and another's checkin?",
      "Do we need to support temporary holds while the user enters payment details?",
      "Is dynamic pricing (different prices per date) in scope?",
      "What's the expected ratio of searches to bookings?",
      "Should I handle multi-room atomic bookings, or one room per booking?",
      "What level of overbooking tolerance, if any?"
    ],
    "what_to_mention_proactively": [
      "The core challenge is preventing double-bookings - this MUST be handled at the database level",
      "I'll use a per-day availability table with SELECT FOR UPDATE for pessimistic locking",
      "Search and booking are separated - search can be eventually consistent, booking must be strongly consistent",
      "Payment pre-authorization happens within the booking transaction to handle the timing correctly"
    ],
    "communication_during_coding": [
      "I'm creating the room_availability table with composite primary key (room_id, date)",
      "This SELECT FOR UPDATE acquires row-level locks to prevent concurrent modifications",
      "I'm checking idempotency first to handle network retries gracefully",
      "The payment pre-auth is inside the transaction - if it fails, we rollback and the room stays available"
    ],
    "if_stuck": [
      "Step back: What's the core invariant? One room, one booking per date",
      "Draw the race condition scenario to visualize the problem",
      "Think about what the database can guarantee (ACID, constraints)",
      "Consider: When does the check happen vs when does the update happen?"
    ],
    "time_management": "0-5min: Clarify requirements, identify key challenges\n5-15min: Draw high-level architecture, explain data model\n15-25min: Deep dive on booking flow with concurrency handling\n25-35min: Discuss search optimization, caching strategy\n35-45min: Touch on scaling, follow-ups, wrap up"
  },
  "pattern_recognition": {
    "pattern_name": "Inventory Reservation with Strong Consistency",
    "indicators": [
      "'No double-booking'",
      "'Reserve'",
      "'Prevent concurrent'",
      "'Seat/room/ticket allocation'"
    ],
    "similar_problems": [
      "**LC 253 - Meeting Rooms II**: Find minimum meeting rooms needed \u2192 interval overlap counting",
      "**LC 731 - My Calendar II**: Double-booking allowed, triple not \u2192 overlap detection",
      "**LC 732 - My Calendar III**: Count max concurrent bookings \u2192 line sweep algorithm",
      "**Concert ticket booking**: Same pattern, higher contention",
      "**Flight seat selection**: Similar, with seat map visualization"
    ],
    "template": "1. Pre-expand availability to granular units (days, seats)\n2. Use database constraints for correctness (UNIQUE, CHECK)\n3. Use pessimistic locking for high-contention resources\n4. Separate read path (eventual consistency OK) from write path (strong consistency required)"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 focuses on concurrent booking handling. Discuss: distributed locks (Redis/ZooKeeper), optimistic vs pessimistic locking trade-offs, deadlock prevention (ordered locking), and testing concurrency with multiple threads.",
    "part_3_hint": "Part 3 is about scaling for high traffic. Discuss: sharding by hotel_id or region, read replicas, caching strategies (Redis for availability, CDN for static content), circuit breakers, and graceful degradation.",
    "data_structure_evolution": "Part 1: Core schema + booking logic\nPart 2: Add distributed locking, retry logic, contention metrics\nPart 3: Add sharding key, read replicas, cache invalidation, async event processing"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This is a classic system design challenge around inventory management with strong consistency requirements. Before I dive in, let me ask a few clarifying questions to make sure I understand the scope...",
    "after_clarification": "Great, so to summarize: we need to design a hotel booking system that handles 10M DAU, 100K searches/sec, and critically, MUST prevent double-bookings at the database level. I'll start with the high-level architecture, then dive into the data model and the booking flow. Does that approach work?",
    "while_coding": [
      "I'm designing the room_availability table with a composite primary key of (room_id, date)...",
      "This SELECT FOR UPDATE is key - it acquires row-level locks so other transactions must wait...",
      "Notice the idempotency check first - this handles client retries gracefully..."
    ],
    "after_coding": "Let me walk through a scenario to verify this works. User A tries to book Room 101 for June 15-18. User B, simultaneously, tries to book the same room for June 17-20. Here's what happens...",
    "when_stuck_verbatim": "I'm thinking about how to prevent the race condition... Let me draw out the scenario. Two users both check availability at the same time, both see 'available', both try to book...",
    "after_mistake": "Actually, I realize I have an issue here - I'm checking availability before acquiring the lock. Let me fix that. The lock must be acquired BEFORE checking, otherwise we have a race condition...",
    "before_moving_on": "So that covers the core booking flow with proper concurrency handling. The key points are: per-day availability rows, SELECT FOR UPDATE for locking, and the UNIQUE constraint as a safety net. Should we discuss the search optimization next, or dive deeper into any of these areas?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem decomposition**: Can you identify that double-booking is the core challenge?",
      "**Concurrency understanding**: Do you know why application-level checks fail?",
      "**Database knowledge**: Can you explain SELECT FOR UPDATE and constraints?",
      "**Trade-off analysis**: Search (eventual consistency) vs Booking (strong consistency)",
      "**System design breadth**: Caching, async processing, event-driven architecture",
      "**Communication**: Can you explain complex concepts clearly?"
    ],
    "bonus_points": [
      "Drawing the race condition diagram unprompted",
      "Mentioning idempotency keys for retry handling",
      "Discussing payment pre-authorization vs immediate charge",
      "Proposing the per-day availability table design",
      "Mentioning sharding strategy for 10M rooms"
    ],
    "red_flags": [
      "Saying 'check availability, then book' without mentioning locks",
      "Not recognizing the race condition problem",
      "Proposing search against the main database",
      "Ignoring payment timing issues",
      "Over-engineering without addressing core requirements"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately identify that this is fundamentally a concurrency problem. They draw the race condition scenario, propose database-level solutions (not just application checks), and discuss trade-offs between pessimistic and optimistic locking. They separate the search and booking concerns, understanding that search can be eventually consistent while booking must be strongly consistent."
  },
  "time_milestones": {
    "by_5_min": "Clarified requirements, identified double-booking as the core challenge, asked about check-in/check-out semantics",
    "by_15_min": "Drew high-level architecture (search service, booking service, separate databases), explained CQRS approach",
    "by_25_min": "Detailed the data model (room_availability table), explained the booking flow with SELECT FOR UPDATE",
    "by_35_min": "Discussed search optimization (Elasticsearch), caching strategy (Redis), payment integration",
    "by_45_min": "Touched on scaling (sharding, read replicas), follow-up considerations, answered questions",
    "warning_signs": "If still clarifying at 10 min, behind. If no mention of locking by 20 min, need to refocus. If not discussing scale by 35 min, rushing."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "If you realize your locking approach has a flaw: 'Actually, I see an issue - I'm checking availability before acquiring the lock, which creates a race condition. Let me fix that by moving the SELECT FOR UPDATE earlier...'",
    "when_you_dont_know_syntax": "'I don't remember the exact PostgreSQL syntax for row-level locking, but conceptually I need SELECT ... FOR UPDATE which acquires exclusive locks on the returned rows.'",
    "when_approach_is_wrong": "'I was initially thinking about optimistic locking, but given the high contention on popular rooms during holidays, pessimistic locking with SELECT FOR UPDATE is more appropriate to avoid excessive retries.'",
    "when_completely_stuck": "'I'm stuck on how to prevent race conditions at the database level. Could you give me a hint about what database features I should consider?'",
    "when_running_out_of_time": "'I'm running low on time. Let me focus on the core booking flow with proper locking, and I'll briefly mention what I'd add for search optimization and scaling.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "System design is about YOUR thinking, not code generation. Use AI for boilerplate and syntax, not for solving the design problem.",
    "what_to_do": [
      "Use AI to generate the dataclass boilerplate for domain models",
      "Use AI to help with SQL syntax (SELECT FOR UPDATE)",
      "Let it autocomplete repository method signatures",
      "Use it to generate test case scaffolding"
    ],
    "what_not_to_do": [
      "Don't paste 'design hotel booking system' and accept the output",
      "Don't let AI drive your architecture decisions",
      "Don't accept complex concurrency logic without understanding it",
      "Don't rely on AI for the 'why' - you must explain trade-offs"
    ],
    "how_to_demonstrate_understanding": "If AI suggests using Redis for locking, explain: 'Yes, Redis with SETNX can provide distributed locking. The lock key would be room_id:date, with a TTL to prevent deadlocks. But for a single-region setup, PostgreSQL's FOR UPDATE is simpler and sufficient.'",
    "expectation_adjustment": "With AI, you should complete the design faster and have time for deeper discussions on trade-offs, scaling, and edge cases. If you're slower with AI, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing the race condition diagram in the first 5 minutes",
      "Proposing per-day availability rows with UNIQUE constraint",
      "Mentioning idempotency keys for retry handling unprompted",
      "Discussing payment pre-authorization timing",
      "Calculating the data size (10M rooms \u00d7 365 days = 3.65B rows) and proposing sharding"
    ],
    "subtle_signals_of_experience": [
      "Asking about check-in/check-out boundary handling",
      "Considering what happens when payment fails after locking",
      "Mentioning circuit breakers for external payment service",
      "Discussing cache invalidation on booking/cancellation",
      "Considering timezone handling for international hotels"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without discussing architecture",
      "Not drawing any diagrams for system design",
      "Getting defensive when interviewer points out race condition issue",
      "Spending 20 minutes on search without addressing booking concurrency"
    ],
    "technical": [
      "Saying 'check if available, then insert' without locks",
      "Proposing to 'lock the entire table' instead of row-level locks",
      "Not separating read (search) and write (booking) paths",
      "Ignoring the 99.99% availability requirement"
    ],
    "communication": [
      "Using jargon like 'saga pattern' without explaining what it means",
      "Going too deep into Elasticsearch internals when concurrency is the focus",
      "Not summarizing the approach before diving into details",
      "Not asking clarifying questions"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I address the double-booking prevention at the database level?",
      "Did I explain the data model with room_availability table?",
      "Did I discuss the booking flow with proper locking?",
      "Did I separate search (ES) from booking (PostgreSQL)?",
      "Did I mention payment integration timing?",
      "Did I discuss at least basic scaling considerations?"
    ],
    "quick_code_review": [
      "Transaction boundaries are clear",
      "Locking happens before availability check",
      "Idempotency key is checked first",
      "Payment is pre-authorized, not charged",
      "Availability is updated within the same transaction as booking insert"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Distributed tracing** (Jaeger/Zipkin) for debugging booking flows",
      "**Metrics and alerting** for booking success rate, latency P99, payment failures",
      "**Circuit breakers** for external services (payment, ES)",
      "**Rate limiting** to prevent abuse",
      "**Audit logging** for all booking state changes",
      "**Dead letter queue** for failed async operations (refunds, notifications)",
      "**Health checks** for all services"
    ],
    "why_not_in_interview": "Focus on the core design and concurrency handling. Mention these briefly to show senior thinking, but don't deep-dive.",
    "how_to_mention": "Say: 'In production, I'd also add distributed tracing, comprehensive metrics, and circuit breakers for the payment service. I'd set up alerting for booking failures exceeding our SLO. But for now, let me focus on the core booking logic.'"
  },
  "generated_at": "2026-01-18T21:29:49.398068",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}