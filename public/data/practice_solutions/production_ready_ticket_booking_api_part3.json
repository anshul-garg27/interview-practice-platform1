{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 3: Concurrency and Race Conditions",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 handled authentication and authorization. Part 3 introduces **thread-safety** for high-traffic scenarios. The system now must handle thousands of simultaneous booking attempts without overselling tickets. The critical change is that the naive check-then-update pattern is no longer safe\u2014we need atomic operations that ensure ticket availability checks and decrements happen as a single unit.",
    "new_requirements": [
      "Thread-safe booking via bookTicketsAtomic() method",
      "Simulate and verify concurrent bookings with simulateConcurrentBookings()",
      "Prevent double-selling: only one thread wins when multiple compete for last ticket",
      "Return 409 Conflict for insufficient tickets during race conditions",
      "Maintain data integrity under concurrent load"
    ],
    "new_constraints": [
      "Operations must be atomic: read-check-update as one unit",
      "Must handle N concurrent requests where N >> available tickets",
      "Cannot oversell: final available count must never go negative",
      "Must be deterministic: exactly one winner per contested ticket"
    ],
    "key_insight": "The 'check-then-act' pattern MUST be atomic. In the naive approach, Thread A reads availability, Thread B reads availability, both see tickets available, both decrement\u2014resulting in overselling. The fix is to wrap the entire read-verify-update sequence in a lock (pessimistic) or use version-based conflict detection (optimistic)."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Thread-safe booking with bookTicketsAtomic",
        "how_met": "Uses ReentrantLock per event for fine-grained pessimistic locking. All read-check-update operations happen within the lock.",
        "gotchas": [
          "Must acquire lock BEFORE reading availability, not after",
          "Must release lock in finally block to prevent deadlocks"
        ]
      },
      {
        "requirement": "Concurrent simulation for testing",
        "how_met": "simulateConcurrentBookings uses ThreadPoolExecutor to submit all requests simultaneously and collects results",
        "gotchas": [
          "Ensure threads actually start concurrently using barriers or latches",
          "Order of results may not match order of requests"
        ]
      },
      {
        "requirement": "Prevent overselling",
        "how_met": "Double-check availability INSIDE the lock after acquiring it. Decrement happens atomically with the check.",
        "gotchas": [
          "Checking outside lock then checking inside isn't enough\u2014ONLY the inside check matters"
        ]
      },
      {
        "requirement": "Return 409 Conflict appropriately",
        "how_met": "When lock is acquired but tickets are insufficient (another thread got them first), return 409 with INSUFFICIENT_TICKETS error",
        "gotchas": [
          "Don't confuse with 400 Bad Request\u2014409 specifically means valid request that conflicts with current state"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "bookTicketsAtomic",
        "target": "O(1) + lock wait",
        "achieved": "O(1) + lock wait",
        "why": "HashMap lookup O(1), lock acquisition is the bottleneck under contention"
      },
      {
        "operation": "simulateConcurrentBookings",
        "target": "O(n) where n = requests",
        "achieved": "O(n) parallel",
        "why": "All requests execute concurrently, aggregate results"
      }
    ],
    "non_goals": [
      "Distributed locking (single-process only for interview)",
      "Transaction rollback on partial failures",
      "Queue-based rate limiting (covered in Part 4)",
      "Database-level locking (in-memory only)"
    ]
  },
  "assumptions": [
    "Single-process deployment (no distributed locks needed)",
    "In-memory data structures (no database persistence)",
    "Lock contention is acceptable for interview demo (production would use Redis/DB locks)",
    "Thread pool size is reasonable (won't spawn thousands of OS threads)",
    "Events exist before concurrent bookings are attempted"
  ],
  "tradeoffs": [
    {
      "decision": "Pessimistic vs Optimistic Locking",
      "chosen": "Pessimistic (Lock-based)",
      "why": "Simpler to implement correctly, clearer semantics, guaranteed no conflicts",
      "alternative": "Optimistic (Version-based)",
      "when_to_switch": "High-read/low-write scenarios, distributed systems, or when lock contention is measured to be too high"
    },
    {
      "decision": "Global lock vs Per-event lock",
      "chosen": "Per-event lock",
      "why": "Concurrent bookings for different events don't block each other, maximizes parallelism",
      "alternative": "Global lock",
      "when_to_switch": "If cross-event atomicity is needed (e.g., booking multiple events in one transaction)"
    },
    {
      "decision": "Fail-fast vs Retry on conflict",
      "chosen": "Fail-fast (return 409)",
      "why": "Simpler, clearer for clients, avoids thundering herd retries",
      "alternative": "Server-side retry with backoff",
      "when_to_switch": "If client retry logic is unreliable or network latency makes round-trips expensive"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Response format and status codes",
      "BookingRequest structure",
      "Core validation logic from Part 2",
      "Authentication/Authorization flow"
    ],
    "what_to_change": [
      "Event class gets a Lock object per instance",
      "Booking methods now delegate to atomic versions internally",
      "New LockManager class for managing event locks"
    ],
    "interfaces_and_boundaries": "The TicketAPI class gains a LockManager dependency. All booking operations route through the atomic method. Part 4 (observability) will wrap these methods with logging/metrics decorators without changing the locking logic.",
    "invariants": [
      "available_tickets >= 0 ALWAYS",
      "sum(all bookings) + available_tickets = total_tickets",
      "Lock is always released after acquisition (try-finally)",
      "No deadlocks: single lock per operation, no nested locks"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2 - Not Thread Safe):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nEvent: { available: 1 }\n\nThread A              Thread B\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nread: 1               read: 1\ncheck: 1 >= 1 \u2713       check: 1 >= 1 \u2713\navailable = 0         available = -1  \u2190 BUG!\nBooking created       Booking created \u2190 OVERSOLD!\n\n\nAFTER (Part 3 - Thread Safe):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nEvent: { available: 1, lock: \ud83d\udd12 }\n\nThread A              Thread B\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nacquire lock \ud83d\udd12       \n  read: 1             waiting... \u23f3\n  check: 1 >= 1 \u2713     waiting... \u23f3\n  available = 0       waiting... \u23f3\n  create booking      waiting... \u23f3\nrelease lock \ud83d\udd13       \n                      acquire lock \ud83d\udd12\nSUCCESS (201)           read: 0\n                        check: 0 >= 1 \u2717\n                      release lock \ud83d\udd13\n                      CONFLICT (409)\n```",
    "algorithm_flow": "```\nbookTicketsAtomic(request) Flow:\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Validate Input  \u2502 \u2190 Part 1 validation\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 valid\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Authenticate   \u2502 \u2190 Part 2 auth\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502 authorized\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Get Event Lock \u2502 \u2190 NEW in Part 3\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      CRITICAL SECTION           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 1. Read available tickets \u2502   \u2502\n\u2502  \u2502 2. Check >= requested     \u2502   \u2502\n\u2502  \u2502 3. Decrement available    \u2502   \u2502\n\u2502  \u2502 4. Create booking record  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Release Lock   \u2502 \u2190 ALWAYS (finally)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n    \u25bc         \u25bc\n  201       409\nSUCCESS   CONFLICT\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (No Locking)",
      "description": "Simply add the new methods without any synchronization. bookTicketsAtomic just calls the existing bookTickets method.",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "why_not_optimal": "Race conditions cause overselling. Under concurrent load, multiple threads read the same 'available' count before any decrement, leading to negative inventory. This violates the core business requirement."
    },
    {
      "name": "Global Lock",
      "description": "Use a single global lock for all booking operations. Simple but serializes all requests.",
      "time_complexity": "O(1) + global lock contention",
      "space_complexity": "O(1)",
      "why_not_optimal": "Serializes ALL bookings system-wide. Booking for Event A blocks booking for Event B unnecessarily. Creates a bottleneck under high traffic."
    },
    {
      "name": "Optimal: Per-Event Pessimistic Locking",
      "description": "Maintain a separate lock for each event. Threads competing for the same event block each other, but different events can be booked in parallel. The read-check-update sequence is wrapped in a try-finally to ensure lock release.",
      "time_complexity": "O(1) + per-event lock contention",
      "space_complexity": "O(E) where E = number of events",
      "key_insight": "Fine-grained locking maximizes parallelism while guaranteeing correctness. The lock granularity matches the contention scope\u2014users compete for tickets to specific events, not globally."
    },
    {
      "name": "Alternative: Optimistic Locking with CAS",
      "description": "Add a version field to Event. Before update, read version V. Attempt update only if version still equals V. If version changed, retry or fail.",
      "time_complexity": "O(1) average, O(retries) worst case",
      "space_complexity": "O(E)",
      "key_insight": "Works well when conflicts are rare. Under high contention, many retries occur and pessimistic may be better. Commonly used in databases."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Per-Event Pessimistic Locking\n\n### Core Mechanism\n\nWe implement **fine-grained pessimistic locking** where each event has its own lock. This ensures:\n\n1. **Mutual Exclusion**: Only one thread can modify an event's ticket count at a time\n2. **Parallelism**: Bookings for different events proceed independently\n3. **Correctness**: The read-check-update sequence is atomic\n\n### Key Components\n\n**LockManager**: Manages locks for events. Uses a ConcurrentHashMap (or thread-safe dict) to map event IDs to Lock objects.\n\n**Critical Section**: The code between lock acquisition and release that performs:\n- Read current available tickets\n- Check if enough tickets exist\n- Decrement available count\n- Create booking record\n\n**Try-Finally Pattern**: **CRITICAL** - Lock release MUST be in a finally block to prevent deadlocks on exceptions.\n\n### Why Pessimistic Over Optimistic?\n\nFor ticket booking (especially flash sales):\n- **High contention** on popular events\n- **Low tolerance** for failures (customers expect immediate answer)\n- **Simplicity** matters for correctness\n\nOptimistic locking would cause many CAS failures under flash sale conditions, leading to retry storms.",
    "data_structures": [
      {
        "structure": "threading.Lock (Python) / ReentrantLock (Java)",
        "purpose": "Mutual exclusion for critical section"
      },
      {
        "structure": "Dict[str, Lock] event_locks",
        "purpose": "Per-event lock storage for fine-grained locking"
      },
      {
        "structure": "ThreadPoolExecutor",
        "purpose": "Simulate concurrent bookings for testing"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate input (Part 1) and authenticate/authorize (Part 2)",
      "Step 2: Acquire the lock for the specific event ID",
      "Step 3: Inside lock - read current available tickets",
      "Step 4: Inside lock - check if available >= requested",
      "Step 5: Inside lock - if yes, decrement available and create booking",
      "Step 6: Inside lock - if no, prepare 409 Conflict response",
      "Step 7: Release lock (in finally block)",
      "Step 8: Return success (201) or conflict (409) response"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Part 3: Production-Ready Event Ticket Booking API - Concurrency and Race Conditions",
    "",
    "This module extends Part 2 with thread-safe booking operations using pessimistic locking.",
    "Key features:",
    "- Per-event fine-grained locking",
    "- Atomic read-check-update operations",
    "- Concurrent booking simulation for testing",
    "\"\"\"",
    "",
    "import threading",
    "import uuid",
    "from dataclasses import dataclass, field",
    "from datetime import datetime",
    "from typing import Dict, List, Optional, Any, Set",
    "from enum import Enum",
    "import re",
    "from concurrent.futures import ThreadPoolExecutor, as_completed",
    "import time",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# RESPONSE AND ERROR HANDLING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class ErrorCode(Enum):",
    "    \"\"\"Standardized error codes for API responses.\"\"\"",
    "    VALIDATION_ERROR = \"VALIDATION_ERROR\"",
    "    EVENT_NOT_FOUND = \"EVENT_NOT_FOUND\"",
    "    INSUFFICIENT_TICKETS = \"INSUFFICIENT_TICKETS\"",
    "    BOOKING_NOT_FOUND = \"BOOKING_NOT_FOUND\"",
    "    UNAUTHORIZED = \"UNAUTHORIZED\"",
    "    FORBIDDEN = \"FORBIDDEN\"",
    "    DUPLICATE_BOOKING = \"DUPLICATE_BOOKING\"",
    "    RATE_LIMITED = \"RATE_LIMITED\"",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    \"\"\"Standardized API response object.\"\"\"",
    "    status: int",
    "    body: Dict[str, Any]",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        return {\"status\": self.status, \"body\": self.body}",
    "",
    "",
    "class ResponseBuilder:",
    "    \"\"\"Factory for creating consistent API responses.\"\"\"",
    "    ",
    "    @staticmethod",
    "    def success(data: Any, status: int = 200) -> Response:",
    "        return Response(status=status, body={\"success\": True, \"data\": data})",
    "    ",
    "    @staticmethod",
    "    def created(data: Any) -> Response:",
    "        return Response(status=201, body={\"success\": True, \"data\": data})",
    "    ",
    "    @staticmethod",
    "    def error(code: ErrorCode, message: str, status: int, details: Optional[Dict] = None) -> Response:",
    "        body = {",
    "            \"success\": False,",
    "            \"error\": {",
    "                \"code\": code.value,",
    "                \"message\": message",
    "            }",
    "        }",
    "        if details:",
    "            body[\"error\"][\"details\"] = details",
    "        return Response(status=status, body=body)",
    "    ",
    "    @staticmethod",
    "    def conflict(code: ErrorCode, message: str) -> Response:",
    "        return ResponseBuilder.error(code, message, 409)",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DATA MODELS",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"Event entity with ticket inventory.\"\"\"",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: float",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "    version: int = 0  # For optimistic locking (alternative approach)",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        return {",
    "            \"id\": self.id,",
    "            \"name\": self.name,",
    "            \"date\": self.date.isoformat(),",
    "            \"venue\": self.venue,",
    "            \"totalTickets\": self.total_tickets,",
    "            \"availableTickets\": self.available_tickets,",
    "            \"pricePerTicket\": self.price_per_ticket,",
    "            \"version\": self.version",
    "        }",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Booking entity representing a ticket purchase.\"\"\"",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_price: float",
    "    status: str = \"CONFIRMED\"",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        return {",
    "            \"id\": self.id,",
    "            \"eventId\": self.event_id,",
    "            \"userId\": self.user_id,",
    "            \"numberOfTickets\": self.number_of_tickets,",
    "            \"totalPrice\": self.total_price,",
    "            \"status\": self.status,",
    "            \"createdAt\": self.created_at.isoformat()",
    "        }",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Request object for booking tickets.\"\"\"",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    auth_token: Optional[str] = None",
    "",
    "",
    "@dataclass",
    "class EventRequest:",
    "    \"\"\"Request object for creating an event.\"\"\"",
    "    name: str",
    "    date: str",
    "    venue: str",
    "    total_tickets: int",
    "    price_per_ticket: float",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# PART 3: LOCK MANAGER - Fine-grained locking per event",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class LockManager:",
    "    \"\"\"",
    "    Manages per-event locks for thread-safe operations.",
    "    ",
    "    Uses fine-grained locking strategy:",
    "    - Each event has its own lock",
    "    - Bookings for different events don't block each other",
    "    - Thread-safe lock creation with double-checked locking",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._locks: Dict[str, threading.Lock] = {}",
    "        self._master_lock = threading.Lock()  # For creating new event locks",
    "    ",
    "    def get_lock(self, event_id: str) -> threading.Lock:",
    "        \"\"\"Get or create a lock for the specified event.\"\"\"",
    "        if event_id not in self._locks:",
    "            with self._master_lock:",
    "                # Double-checked locking pattern",
    "                if event_id not in self._locks:",
    "                    self._locks[event_id] = threading.Lock()",
    "        return self._locks[event_id]",
    "    ",
    "    def remove_lock(self, event_id: str) -> None:",
    "        \"\"\"Remove lock when event is deleted.\"\"\"",
    "        with self._master_lock:",
    "            self._locks.pop(event_id, None)",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# INPUT VALIDATION (From Part 1)",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class InputValidator:",
    "    \"\"\"Comprehensive input validation for all API requests.\"\"\"",
    "    ",
    "    MAX_NAME_LENGTH = 200",
    "    MAX_VENUE_LENGTH = 500",
    "    MAX_TICKETS = 100000",
    "    MAX_TICKETS_PER_BOOKING = 10",
    "    MAX_PRICE = 10000.0",
    "    ",
    "    @staticmethod",
    "    def validate_event_request(request: EventRequest) -> List[str]:",
    "        \"\"\"Validate event creation request.\"\"\"",
    "        errors = []",
    "        ",
    "        # Name validation",
    "        if not request.name or not request.name.strip():",
    "            errors.append(\"Event name is required\")",
    "        elif len(request.name) > InputValidator.MAX_NAME_LENGTH:",
    "            errors.append(f\"Event name exceeds {InputValidator.MAX_NAME_LENGTH} characters\")",
    "        ",
    "        # Date validation",
    "        try:",
    "            event_date = datetime.fromisoformat(request.date.replace('Z', '+00:00'))",
    "            if event_date < datetime.now(event_date.tzinfo):",
    "                errors.append(\"Event date must be in the future\")",
    "        except (ValueError, AttributeError):",
    "            errors.append(\"Invalid date format. Use ISO 8601 format\")",
    "        ",
    "        # Venue validation",
    "        if not request.venue or not request.venue.strip():",
    "            errors.append(\"Venue is required\")",
    "        elif len(request.venue) > InputValidator.MAX_VENUE_LENGTH:",
    "            errors.append(f\"Venue exceeds {InputValidator.MAX_VENUE_LENGTH} characters\")",
    "        ",
    "        # Tickets validation",
    "        if request.total_tickets <= 0:",
    "            errors.append(\"Total tickets must be positive\")",
    "        elif request.total_tickets > InputValidator.MAX_TICKETS:",
    "            errors.append(f\"Total tickets exceeds maximum of {InputValidator.MAX_TICKETS}\")",
    "        ",
    "        # Price validation",
    "        if request.price_per_ticket < 0:",
    "            errors.append(\"Price cannot be negative\")",
    "        elif request.price_per_ticket > InputValidator.MAX_PRICE:",
    "            errors.append(f\"Price exceeds maximum of {InputValidator.MAX_PRICE}\")",
    "        ",
    "        return errors",
    "    ",
    "    @staticmethod",
    "    def validate_booking_request(request: BookingRequest) -> List[str]:",
    "        \"\"\"Validate booking request.\"\"\"",
    "        errors = []",
    "        ",
    "        if not request.event_id or not request.event_id.strip():",
    "            errors.append(\"Event ID is required\")",
    "        ",
    "        if not request.user_id or not request.user_id.strip():",
    "            errors.append(\"User ID is required\")",
    "        ",
    "        if request.number_of_tickets <= 0:",
    "            errors.append(\"Number of tickets must be positive\")",
    "        elif request.number_of_tickets > InputValidator.MAX_TICKETS_PER_BOOKING:",
    "            errors.append(f\"Cannot book more than {InputValidator.MAX_TICKETS_PER_BOOKING} tickets at once\")",
    "        ",
    "        return errors",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# AUTHENTICATION & AUTHORIZATION (From Part 2)",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class AuthService:",
    "    \"\"\"Simple authentication and authorization service.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Simulated user database: token -> user_id",
    "        self._tokens: Dict[str, str] = {}",
    "        self._user_roles: Dict[str, Set[str]] = {}",
    "    ",
    "    def register_token(self, token: str, user_id: str, roles: Set[str] = None) -> None:",
    "        \"\"\"Register a token for a user.\"\"\"",
    "        self._tokens[token] = user_id",
    "        self._user_roles[user_id] = roles or {\"user\"}",
    "    ",
    "    def authenticate(self, token: Optional[str]) -> Optional[str]:",
    "        \"\"\"Authenticate token and return user_id if valid.\"\"\"",
    "        if not token:",
    "            return None",
    "        return self._tokens.get(token)",
    "    ",
    "    def authorize(self, user_id: str, required_role: str) -> bool:",
    "        \"\"\"Check if user has required role.\"\"\"",
    "        roles = self._user_roles.get(user_id, set())",
    "        return required_role in roles or \"admin\" in roles",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# MAIN API CLASS",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready Event Ticket Booking API with thread-safe operations.",
    "    ",
    "    Part 3 Features:",
    "    - Per-event fine-grained locking for concurrent booking safety",
    "    - Atomic read-check-update operations",
    "    - Simulation support for concurrent booking testing",
    "    ",
    "    Thread Safety Guarantee:",
    "    - All booking operations use pessimistic locking",
    "    - Event modifications are atomic within lock scope",
    "    - No overselling is possible under any concurrent load",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._events: Dict[str, Event] = {}",
    "        self._bookings: Dict[str, Booking] = {}",
    "        self._user_bookings: Dict[str, List[str]] = {}  # user_id -> [booking_ids]",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        ",
    "        # Part 2: Authentication",
    "        self._auth_service = AuthService()",
    "        ",
    "        # Part 3: Concurrency - Lock manager for thread safety",
    "        self._lock_manager = LockManager()",
    "        self._counter_lock = threading.Lock()  # For ID generation",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # HELPER METHODS",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def _generate_event_id(self) -> str:",
    "        \"\"\"Thread-safe event ID generation.\"\"\"",
    "        with self._counter_lock:",
    "            self._event_counter += 1",
    "            return f\"evt_{self._event_counter:03d}\"",
    "    ",
    "    def _generate_booking_id(self) -> str:",
    "        \"\"\"Thread-safe booking ID generation.\"\"\"",
    "        with self._counter_lock:",
    "            self._booking_counter += 1",
    "            return f\"bkg_{self._booking_counter:03d}\"",
    "    ",
    "    def register_user(self, token: str, user_id: str, roles: Set[str] = None) -> None:",
    "        \"\"\"Register a user token for authentication.\"\"\"",
    "        self._auth_service.register_token(token, user_id, roles)",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # EVENT OPERATIONS",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def create_event(self, request: EventRequest) -> Response:",
    "        \"\"\"Create a new event with ticket inventory.\"\"\"",
    "        # Validate input",
    "        errors = InputValidator.validate_event_request(request)",
    "        if errors:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Invalid event data\",",
    "                400,",
    "                {\"errors\": errors}",
    "            )",
    "        ",
    "        # Create event",
    "        event_id = self._generate_event_id()",
    "        event_date = datetime.fromisoformat(request.date.replace('Z', '+00:00'))",
    "        ",
    "        event = Event(",
    "            id=event_id,",
    "            name=request.name.strip(),",
    "            date=event_date,",
    "            venue=request.venue.strip(),",
    "            total_tickets=request.total_tickets,",
    "            available_tickets=request.total_tickets,",
    "            price_per_ticket=request.price_per_ticket",
    "        )",
    "        ",
    "        self._events[event_id] = event",
    "        return ResponseBuilder.created(event.to_dict())",
    "    ",
    "    def get_event(self, event_id: str) -> Response:",
    "        \"\"\"Get event details by ID.\"\"\"",
    "        event = self._events.get(event_id)",
    "        if not event:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.EVENT_NOT_FOUND,",
    "                f\"Event {event_id} not found\",",
    "                404",
    "            )",
    "        return ResponseBuilder.success(event.to_dict())",
    "    ",
    "    def list_events(self) -> Response:",
    "        \"\"\"List all events.\"\"\"",
    "        events = [e.to_dict() for e in self._events.values()]",
    "        return ResponseBuilder.success({\"events\": events, \"count\": len(events)})",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 3: THREAD-SAFE BOOKING OPERATIONS",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def book_tickets_atomic(self, request: BookingRequest) -> Response:",
    "        \"\"\"",
    "        Thread-safe ticket booking using pessimistic locking.",
    "        ",
    "        This method guarantees:",
    "        1. No overselling - available tickets never go negative",
    "        2. Atomic operations - read-check-update as single unit",
    "        3. Fair ordering - requests processed in lock acquisition order",
    "        ",
    "        Args:",
    "            request: BookingRequest with event_id, user_id, number_of_tickets",
    "        ",
    "        Returns:",
    "            Response: 201 on success, 409 on insufficient tickets, 4xx on validation errors",
    "        ",
    "        Thread Safety:",
    "            Uses per-event lock. Lock is acquired before reading availability",
    "            and released in finally block after all operations complete.",
    "        \"\"\"",
    "        # Step 1: Input validation (outside lock - fast fail)",
    "        errors = InputValidator.validate_booking_request(request)",
    "        if errors:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Invalid booking request\",",
    "                400,",
    "                {\"errors\": errors}",
    "            )",
    "        ",
    "        # Step 2: Check event exists (outside lock - read only)",
    "        if request.event_id not in self._events:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.EVENT_NOT_FOUND,",
    "                f\"Event {request.event_id} not found\",",
    "                404",
    "            )",
    "        ",
    "        # Step 3: Acquire per-event lock for thread safety",
    "        event_lock = self._lock_manager.get_lock(request.event_id)",
    "        ",
    "        try:",
    "            event_lock.acquire()",
    "            ",
    "            # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "            # CRITICAL SECTION START - All operations here are atomic",
    "            # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "            ",
    "            event = self._events.get(request.event_id)",
    "            ",
    "            # Double-check event still exists (could be deleted between check and lock)",
    "            if not event:",
    "                return ResponseBuilder.error(",
    "                    ErrorCode.EVENT_NOT_FOUND,",
    "                    f\"Event {request.event_id} not found\",",
    "                    404",
    "                )",
    "            ",
    "            # Check ticket availability INSIDE the lock",
    "            if event.available_tickets < request.number_of_tickets:",
    "                return ResponseBuilder.conflict(",
    "                    ErrorCode.INSUFFICIENT_TICKETS,",
    "                    f\"Requested {request.number_of_tickets} tickets but only {event.available_tickets} available\"",
    "                )",
    "            ",
    "            # Decrement available tickets",
    "            event.available_tickets -= request.number_of_tickets",
    "            event.version += 1  # Increment version for optimistic locking compatibility",
    "            ",
    "            # Create booking record",
    "            booking_id = self._generate_booking_id()",
    "            booking = Booking(",
    "                id=booking_id,",
    "                event_id=request.event_id,",
    "                user_id=request.user_id,",
    "                number_of_tickets=request.number_of_tickets,",
    "                total_price=request.number_of_tickets * event.price_per_ticket",
    "            )",
    "            ",
    "            self._bookings[booking_id] = booking",
    "            ",
    "            # Track user bookings",
    "            if request.user_id not in self._user_bookings:",
    "                self._user_bookings[request.user_id] = []",
    "            self._user_bookings[request.user_id].append(booking_id)",
    "            ",
    "            # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "            # CRITICAL SECTION END",
    "            # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "            ",
    "            return ResponseBuilder.created(booking.to_dict())",
    "            ",
    "        finally:",
    "            # ALWAYS release lock - prevents deadlocks on exceptions",
    "            event_lock.release()",
    "    ",
    "    def simulate_concurrent_bookings(self, requests: List[BookingRequest]) -> List[Response]:",
    "        \"\"\"",
    "        Simulate concurrent booking requests for testing thread safety.",
    "        ",
    "        This method:",
    "        1. Submits all requests simultaneously to a thread pool",
    "        2. Waits for all to complete",
    "        3. Returns results in submission order",
    "        ",
    "        Use this to verify:",
    "        - No overselling under concurrent load",
    "        - Proper 409 responses for losers",
    "        - Exactly N tickets sold when N available",
    "        ",
    "        Args:",
    "            requests: List of BookingRequest objects to process concurrently",
    "        ",
    "        Returns:",
    "            List[Response]: Results in same order as input requests",
    "        \"\"\"",
    "        if not requests:",
    "            return []",
    "        ",
    "        results: List[Optional[Response]] = [None] * len(requests)",
    "        ",
    "        def process_booking(index: int, request: BookingRequest) -> tuple:",
    "            \"\"\"Process a single booking and return (index, response).\"\"\"",
    "            response = self.book_tickets_atomic(request)",
    "            return (index, response)",
    "        ",
    "        # Use ThreadPoolExecutor for true concurrent execution",
    "        with ThreadPoolExecutor(max_workers=len(requests)) as executor:",
    "            # Submit all requests",
    "            futures = [",
    "                executor.submit(process_booking, i, req)",
    "                for i, req in enumerate(requests)",
    "            ]",
    "            ",
    "            # Collect results",
    "            for future in as_completed(futures):",
    "                index, response = future.result()",
    "                results[index] = response",
    "        ",
    "        return results",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # STANDARD BOOKING OPERATIONS (delegate to atomic version)",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def book_tickets(self, request: BookingRequest) -> Response:",
    "        \"\"\"Book tickets - delegates to thread-safe atomic version.\"\"\"",
    "        return self.book_tickets_atomic(request)",
    "    ",
    "    def get_booking(self, booking_id: str, user_id: str) -> Response:",
    "        \"\"\"Get booking details. User can only see their own bookings.\"\"\"",
    "        booking = self._bookings.get(booking_id)",
    "        if not booking:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.BOOKING_NOT_FOUND,",
    "                f\"Booking {booking_id} not found\",",
    "                404",
    "            )",
    "        ",
    "        if booking.user_id != user_id:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.FORBIDDEN,",
    "                \"You can only view your own bookings\",",
    "                403",
    "            )",
    "        ",
    "        return ResponseBuilder.success(booking.to_dict())",
    "    ",
    "    def cancel_booking(self, booking_id: str, user_id: str) -> Response:",
    "        \"\"\"Cancel a booking and release tickets back to inventory.\"\"\"",
    "        booking = self._bookings.get(booking_id)",
    "        if not booking:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.BOOKING_NOT_FOUND,",
    "                f\"Booking {booking_id} not found\",",
    "                404",
    "            )",
    "        ",
    "        if booking.user_id != user_id:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.FORBIDDEN,",
    "                \"You can only cancel your own bookings\",",
    "                403",
    "            )",
    "        ",
    "        # Get lock for atomic ticket restoration",
    "        event_lock = self._lock_manager.get_lock(booking.event_id)",
    "        ",
    "        try:",
    "            event_lock.acquire()",
    "            ",
    "            event = self._events.get(booking.event_id)",
    "            if event:",
    "                event.available_tickets += booking.number_of_tickets",
    "                event.version += 1",
    "            ",
    "            booking.status = \"CANCELLED\"",
    "            ",
    "            return ResponseBuilder.success({",
    "                \"message\": \"Booking cancelled successfully\",",
    "                \"booking\": booking.to_dict()",
    "            })",
    "        finally:",
    "            event_lock.release()",
    "    ",
    "    def get_event_availability(self, event_id: str) -> Response:",
    "        \"\"\"Get current ticket availability for an event.\"\"\"",
    "        event = self._events.get(event_id)",
    "        if not event:",
    "            return ResponseBuilder.error(",
    "                ErrorCode.EVENT_NOT_FOUND,",
    "                f\"Event {event_id} not found\",",
    "                404",
    "            )",
    "        ",
    "        return ResponseBuilder.success({",
    "            \"eventId\": event.id,",
    "            \"eventName\": event.name,",
    "            \"totalTickets\": event.total_tickets,",
    "            \"availableTickets\": event.available_tickets,",
    "            \"soldTickets\": event.total_tickets - event.available_tickets",
    "        })",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DEMO AND TESTING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "def demonstrate_race_condition():",
    "    \"\"\"Demonstrate how the API handles race conditions.\"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"PART 3: CONCURRENCY AND RACE CONDITIONS DEMO\")",
    "    print(\"=\" * 70)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # Create a high-demand event with limited tickets",
    "    print(\"\\n[1] Creating a hot concert with only 2 tickets...\")",
    "    event_response = api.create_event(EventRequest(",
    "        name=\"Hot Concert\",",
    "        date=\"2024-12-31T20:00:00Z\",",
    "        venue=\"Arena\",",
    "        total_tickets=2,",
    "        price_per_ticket=150.0",
    "    ))",
    "    print(f\"    Event created: {event_response.body['data']['id']}\")",
    "    print(f\"    Available tickets: {event_response.body['data']['availableTickets']}\")",
    "    ",
    "    # Simulate 5 users trying to book 2 tickets each simultaneously",
    "    print(\"\\n[2] Simulating 5 concurrent users each trying to book 2 tickets...\")",
    "    print(\"    (Only 1 should succeed since we only have 2 tickets)\")",
    "    ",
    "    concurrent_requests = [",
    "        BookingRequest(event_id=\"evt_001\", user_id=f\"usr_{chr(65+i)}\", number_of_tickets=2)",
    "        for i in range(5)",
    "    ]",
    "    ",
    "    results = api.simulate_concurrent_bookings(concurrent_requests)",
    "    ",
    "    print(\"\\n    Results:\")",
    "    success_count = 0",
    "    conflict_count = 0",
    "    ",
    "    for i, (request, response) in enumerate(zip(concurrent_requests, results)):",
    "        status_emoji = \"\u2705\" if response.status == 201 else \"\u274c\"",
    "        status_text = \"SUCCESS\" if response.status == 201 else \"CONFLICT\"",
    "        print(f\"    {status_emoji} User {request.user_id}: {status_text} (HTTP {response.status})\")",
    "        ",
    "        if response.status == 201:",
    "            success_count += 1",
    "        else:",
    "            conflict_count += 1",
    "    ",
    "    # Verify final state",
    "    availability = api.get_event_availability(\"evt_001\")",
    "    available = availability.body['data']['availableTickets']",
    "    sold = availability.body['data']['soldTickets']",
    "    ",
    "    print(f\"\\n[3] Final State:\")",
    "    print(f\"    Successful bookings: {success_count}\")",
    "    print(f\"    Rejected (conflict): {conflict_count}\")",
    "    print(f\"    Tickets sold: {sold}\")",
    "    print(f\"    Tickets remaining: {available}\")",
    "    ",
    "    # Verify invariant: no overselling",
    "    assert available >= 0, \"INVARIANT VIOLATED: Negative availability!\"",
    "    assert success_count == 1, f\"Expected 1 success, got {success_count}\"",
    "    assert conflict_count == 4, f\"Expected 4 conflicts, got {conflict_count}\"",
    "    print(\"\\n    \u2705 All invariants verified: No overselling occurred!\")",
    "    ",
    "    # Test with multiple partial bookings",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"[4] Testing multiple partial bookings...\")",
    "    ",
    "    event2 = api.create_event(EventRequest(",
    "        name=\"Tech Conference\",",
    "        date=\"2024-11-15T09:00:00Z\",",
    "        venue=\"Convention Center\",",
    "        total_tickets=5,",
    "        price_per_ticket=50.0",
    "    ))",
    "    event_id = event2.body['data']['id']",
    "    print(f\"    Created event with 5 tickets\")",
    "    ",
    "    # 10 users each trying to book 1 ticket",
    "    partial_requests = [",
    "        BookingRequest(event_id=event_id, user_id=f\"user_{i}\", number_of_tickets=1)",
    "        for i in range(10)",
    "    ]",
    "    ",
    "    partial_results = api.simulate_concurrent_bookings(partial_requests)",
    "    ",
    "    success_partial = sum(1 for r in partial_results if r.status == 201)",
    "    conflict_partial = sum(1 for r in partial_results if r.status == 409)",
    "    ",
    "    print(f\"    10 users tried to book 1 ticket each:\")",
    "    print(f\"    - Successful: {success_partial}\")",
    "    print(f\"    - Rejected: {conflict_partial}\")",
    "    ",
    "    availability2 = api.get_event_availability(event_id)",
    "    print(f\"    - Remaining tickets: {availability2.body['data']['availableTickets']}\")",
    "    ",
    "    assert success_partial == 5, f\"Expected 5 successes, got {success_partial}\"",
    "    assert conflict_partial == 5, f\"Expected 5 conflicts, got {conflict_partial}\"",
    "    print(\"    \u2705 Exactly 5 bookings succeeded as expected!\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"DEMO COMPLETE - Thread safety verified!\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "def main():",
    "    \"\"\"Run all demos.\"\"\"",
    "    demonstrate_race_condition()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.time.Instant;",
    "import java.time.format.DateTimeParseException;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.atomic.AtomicInteger;",
    "import java.util.concurrent.locks.Lock;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "/**",
    " * Part 3: Production-Ready Event Ticket Booking API - Concurrency and Race Conditions",
    " * ",
    " * This implementation uses per-event pessimistic locking to ensure thread safety.",
    " */",
    "public class TicketBookingAPI {",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DATA MODELS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public enum ErrorCode {",
    "        VALIDATION_ERROR, EVENT_NOT_FOUND, INSUFFICIENT_TICKETS,",
    "        BOOKING_NOT_FOUND, UNAUTHORIZED, FORBIDDEN, DUPLICATE_BOOKING",
    "    }",
    "",
    "    public static class Response {",
    "        public final int status;",
    "        public final Map<String, Object> body;",
    "",
    "        public Response(int status, Map<String, Object> body) {",
    "            this.status = status;",
    "            this.body = body;",
    "        }",
    "    }",
    "",
    "    public static class Event {",
    "        public final String id;",
    "        public final String name;",
    "        public final Instant date;",
    "        public final String venue;",
    "        public final int totalTickets;",
    "        public volatile int availableTickets;  // volatile for visibility",
    "        public final double pricePerTicket;",
    "        public volatile int version = 0;",
    "",
    "        public Event(String id, String name, Instant date, String venue,",
    "                     int totalTickets, double pricePerTicket) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "",
    "        public Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"id\", id);",
    "            map.put(\"name\", name);",
    "            map.put(\"date\", date.toString());",
    "            map.put(\"venue\", venue);",
    "            map.put(\"totalTickets\", totalTickets);",
    "            map.put(\"availableTickets\", availableTickets);",
    "            map.put(\"pricePerTicket\", pricePerTicket);",
    "            return map;",
    "        }",
    "    }",
    "",
    "    public static class Booking {",
    "        public final String id;",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int numberOfTickets;",
    "        public final double totalPrice;",
    "        public String status = \"CONFIRMED\";",
    "",
    "        public Booking(String id, String eventId, String userId,",
    "                       int numberOfTickets, double totalPrice) {",
    "            this.id = id;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = numberOfTickets;",
    "            this.totalPrice = totalPrice;",
    "        }",
    "",
    "        public Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"id\", id);",
    "            map.put(\"eventId\", eventId);",
    "            map.put(\"userId\", userId);",
    "            map.put(\"numberOfTickets\", numberOfTickets);",
    "            map.put(\"totalPrice\", totalPrice);",
    "            map.put(\"status\", status);",
    "            return map;",
    "        }",
    "    }",
    "",
    "    public static class BookingRequest {",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int numberOfTickets;",
    "",
    "        public BookingRequest(String eventId, String userId, int numberOfTickets) {",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = numberOfTickets;",
    "        }",
    "    }",
    "",
    "    public static class EventRequest {",
    "        public final String name;",
    "        public final String date;",
    "        public final String venue;",
    "        public final int totalTickets;",
    "        public final double pricePerTicket;",
    "",
    "        public EventRequest(String name, String date, String venue,",
    "                            int totalTickets, double pricePerTicket) {",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // LOCK MANAGER - Fine-grained locking per event",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    private static class LockManager {",
    "        private final ConcurrentHashMap<String, Lock> locks = new ConcurrentHashMap<>();",
    "",
    "        public Lock getLock(String eventId) {",
    "            return locks.computeIfAbsent(eventId, k -> new ReentrantLock());",
    "        }",
    "",
    "        public void removeLock(String eventId) {",
    "            locks.remove(eventId);",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // RESPONSE BUILDER",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    private static class ResponseBuilder {",
    "        static Response success(Object data, int status) {",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            body.put(\"data\", data);",
    "            return new Response(status, body);",
    "        }",
    "",
    "        static Response created(Object data) {",
    "            return success(data, 201);",
    "        }",
    "",
    "        static Response error(ErrorCode code, String message, int status) {",
    "            Map<String, Object> error = new HashMap<>();",
    "            error.put(\"code\", code.name());",
    "            error.put(\"message\", message);",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", false);",
    "            body.put(\"error\", error);",
    "            return new Response(status, body);",
    "        }",
    "",
    "        static Response conflict(ErrorCode code, String message) {",
    "            return error(code, message, 409);",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // API CLASS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    private final ConcurrentHashMap<String, Event> events = new ConcurrentHashMap<>();",
    "    private final ConcurrentHashMap<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    private final AtomicInteger eventCounter = new AtomicInteger(0);",
    "    private final AtomicInteger bookingCounter = new AtomicInteger(0);",
    "    private final LockManager lockManager = new LockManager();",
    "",
    "    private String generateEventId() {",
    "        return String.format(\"evt_%03d\", eventCounter.incrementAndGet());",
    "    }",
    "",
    "    private String generateBookingId() {",
    "        return String.format(\"bkg_%03d\", bookingCounter.incrementAndGet());",
    "    }",
    "",
    "    public Response createEvent(EventRequest request) {",
    "        // Validation",
    "        List<String> errors = new ArrayList<>();",
    "        if (request.name == null || request.name.trim().isEmpty()) {",
    "            errors.add(\"Event name is required\");",
    "        }",
    "        if (request.totalTickets <= 0) {",
    "            errors.add(\"Total tickets must be positive\");",
    "        }",
    "        if (!errors.isEmpty()) {",
    "            return ResponseBuilder.error(ErrorCode.VALIDATION_ERROR, String.join(\", \", errors), 400);",
    "        }",
    "",
    "        Instant eventDate;",
    "        try {",
    "            eventDate = Instant.parse(request.date);",
    "        } catch (DateTimeParseException e) {",
    "            return ResponseBuilder.error(ErrorCode.VALIDATION_ERROR, \"Invalid date format\", 400);",
    "        }",
    "",
    "        String eventId = generateEventId();",
    "        Event event = new Event(eventId, request.name.trim(), eventDate,",
    "                request.venue.trim(), request.totalTickets, request.pricePerTicket);",
    "        events.put(eventId, event);",
    "",
    "        return ResponseBuilder.created(event.toMap());",
    "    }",
    "",
    "    /**",
    "     * Thread-safe ticket booking using pessimistic locking.",
    "     * ",
    "     * @param request The booking request",
    "     * @return Response with booking details or error",
    "     */",
    "    public Response bookTicketsAtomic(BookingRequest request) {",
    "        // Validation (outside lock)",
    "        List<String> errors = new ArrayList<>();",
    "        if (request.eventId == null || request.eventId.trim().isEmpty()) {",
    "            errors.add(\"Event ID is required\");",
    "        }",
    "        if (request.userId == null || request.userId.trim().isEmpty()) {",
    "            errors.add(\"User ID is required\");",
    "        }",
    "        if (request.numberOfTickets <= 0) {",
    "            errors.add(\"Number of tickets must be positive\");",
    "        }",
    "        if (request.numberOfTickets > 10) {",
    "            errors.add(\"Cannot book more than 10 tickets at once\");",
    "        }",
    "        if (!errors.isEmpty()) {",
    "            return ResponseBuilder.error(ErrorCode.VALIDATION_ERROR, String.join(\", \", errors), 400);",
    "        }",
    "",
    "        // Check event exists (outside lock)",
    "        if (!events.containsKey(request.eventId)) {",
    "            return ResponseBuilder.error(ErrorCode.EVENT_NOT_FOUND,",
    "                    \"Event \" + request.eventId + \" not found\", 404);",
    "        }",
    "",
    "        // Acquire per-event lock",
    "        Lock eventLock = lockManager.getLock(request.eventId);",
    "        eventLock.lock();",
    "        try {",
    "            // CRITICAL SECTION START",
    "            Event event = events.get(request.eventId);",
    "",
    "            if (event == null) {",
    "                return ResponseBuilder.error(ErrorCode.EVENT_NOT_FOUND,",
    "                        \"Event \" + request.eventId + \" not found\", 404);",
    "            }",
    "",
    "            // Check availability INSIDE the lock",
    "            if (event.availableTickets < request.numberOfTickets) {",
    "                return ResponseBuilder.conflict(ErrorCode.INSUFFICIENT_TICKETS,",
    "                        String.format(\"Requested %d but only %d available\",",
    "                                request.numberOfTickets, event.availableTickets));",
    "            }",
    "",
    "            // Decrement tickets",
    "            event.availableTickets -= request.numberOfTickets;",
    "            event.version++;",
    "",
    "            // Create booking",
    "            String bookingId = generateBookingId();",
    "            Booking booking = new Booking(",
    "                    bookingId,",
    "                    request.eventId,",
    "                    request.userId,",
    "                    request.numberOfTickets,",
    "                    request.numberOfTickets * event.pricePerTicket",
    "            );",
    "            bookings.put(bookingId, booking);",
    "",
    "            return ResponseBuilder.created(booking.toMap());",
    "            // CRITICAL SECTION END",
    "        } finally {",
    "            eventLock.unlock();  // ALWAYS release lock",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Simulate concurrent booking requests for testing.",
    "     * ",
    "     * @param requests List of booking requests to process concurrently",
    "     * @return List of responses in same order as input",
    "     */",
    "    public List<Response> simulateConcurrentBookings(List<BookingRequest> requests) {",
    "        if (requests == null || requests.isEmpty()) {",
    "            return new ArrayList<>();",
    "        }",
    "",
    "        Response[] results = new Response[requests.size()];",
    "        ExecutorService executor = Executors.newFixedThreadPool(requests.size());",
    "        CountDownLatch latch = new CountDownLatch(requests.size());",
    "",
    "        for (int i = 0; i < requests.size(); i++) {",
    "            final int index = i;",
    "            final BookingRequest request = requests.get(i);",
    "            executor.submit(() -> {",
    "                try {",
    "                    results[index] = bookTicketsAtomic(request);",
    "                } finally {",
    "                    latch.countDown();",
    "                }",
    "            });",
    "        }",
    "",
    "        try {",
    "            latch.await();",
    "        } catch (InterruptedException e) {",
    "            Thread.currentThread().interrupt();",
    "        }",
    "        executor.shutdown();",
    "",
    "        return Arrays.asList(results);",
    "    }",
    "",
    "    public Response getEventAvailability(String eventId) {",
    "        Event event = events.get(eventId);",
    "        if (event == null) {",
    "            return ResponseBuilder.error(ErrorCode.EVENT_NOT_FOUND,",
    "                    \"Event not found\", 404);",
    "        }",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", event.id);",
    "        data.put(\"availableTickets\", event.availableTickets);",
    "        data.put(\"totalTickets\", event.totalTickets);",
    "        return ResponseBuilder.success(data, 200);",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DEMO",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"PART 3: CONCURRENCY AND RACE CONDITIONS DEMO\");",
    "        System.out.println(\"=\".repeat(70));",
    "",
    "        TicketBookingAPI api = new TicketBookingAPI();",
    "",
    "        // Create event with 2 tickets",
    "        System.out.println(\"\\n[1] Creating event with 2 tickets...\");",
    "        Response eventResp = api.createEvent(new EventRequest(",
    "                \"Hot Concert\", \"2024-12-31T20:00:00Z\", \"Arena\", 2, 150.0));",
    "        System.out.println(\"    Event created: \" + eventResp.body.get(\"data\"));",
    "",
    "        // Simulate 5 concurrent bookings for 2 tickets each",
    "        System.out.println(\"\\n[2] Simulating 5 concurrent users booking 2 tickets each...\");",
    "        List<BookingRequest> requests = new ArrayList<>();",
    "        for (int i = 0; i < 5; i++) {",
    "            requests.add(new BookingRequest(\"evt_001\", \"usr_\" + (char)('A' + i), 2));",
    "        }",
    "",
    "        List<Response> results = api.simulateConcurrentBookings(requests);",
    "",
    "        int successCount = 0;",
    "        int conflictCount = 0;",
    "        for (int i = 0; i < results.size(); i++) {",
    "            Response r = results.get(i);",
    "            String status = r.status == 201 ? \"SUCCESS\" : \"CONFLICT\";",
    "            String emoji = r.status == 201 ? \"OK\" : \"XX\";",
    "            System.out.println(\"    [\" + emoji + \"] User \" + requests.get(i).userId + \": \" + status);",
    "            if (r.status == 201) successCount++;",
    "            else conflictCount++;",
    "        }",
    "",
    "        Response avail = api.getEventAvailability(\"evt_001\");",
    "        @SuppressWarnings(\"unchecked\")",
    "        Map<String, Object> availData = (Map<String, Object>) avail.body.get(\"data\");",
    "",
    "        System.out.println(\"\\n[3] Final State:\");",
    "        System.out.println(\"    Successful bookings: \" + successCount);",
    "        System.out.println(\"    Rejected (conflict): \" + conflictCount);",
    "        System.out.println(\"    Tickets remaining: \" + availData.get(\"availableTickets\"));",
    "",
    "        assert successCount == 1 : \"Expected 1 success\";",
    "        assert conflictCount == 4 : \"Expected 4 conflicts\";",
    "        assert (int) availData.get(\"availableTickets\") >= 0 : \"Overselling detected!\";",
    "",
    "        System.out.println(\"\\n    [OK] All invariants verified - No overselling!\");",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-30",
      "explanation": "Imports and module docstring explaining Part 3 focus on concurrency"
    },
    {
      "lines": "32-80",
      "explanation": "Response classes and ResponseBuilder - consistent API response format with 409 Conflict support"
    },
    {
      "lines": "82-140",
      "explanation": "Data models (Event, Booking) with version field added for potential optimistic locking"
    },
    {
      "lines": "142-175",
      "explanation": "**LockManager** - The key new class for Part 3. Uses double-checked locking pattern to create per-event locks on demand"
    },
    {
      "lines": "177-230",
      "explanation": "InputValidator from Part 1 - unchanged, validates requests before acquiring locks"
    },
    {
      "lines": "232-270",
      "explanation": "AuthService from Part 2 - unchanged, authentication/authorization still applies"
    },
    {
      "lines": "272-320",
      "explanation": "TicketAPI class initialization with new LockManager and counter_lock for thread-safe ID generation"
    },
    {
      "lines": "322-420",
      "explanation": "**book_tickets_atomic** - The core Part 3 method. Notice: lock acquired BEFORE reading, released in finally, check-update inside lock"
    },
    {
      "lines": "422-470",
      "explanation": "**simulate_concurrent_bookings** - Uses ThreadPoolExecutor to submit all requests simultaneously for testing"
    },
    {
      "lines": "472-550",
      "explanation": "Supporting methods: cancel_booking (also uses locking for ticket restoration), get_event_availability"
    },
    {
      "lines": "552-650",
      "explanation": "Demo function showing 5 concurrent users competing for 2 tickets - verifies only 1 succeeds"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "book_tickets_atomic": {
          "complexity": "O(1) + lock wait",
          "explanation": "HashMap operations are O(1), but thread may wait if lock is held by another thread"
        },
        "simulate_concurrent_bookings": {
          "complexity": "O(n) parallel",
          "explanation": "All n requests execute concurrently, results collected in O(n)"
        },
        "LockManager.get_lock": {
          "complexity": "O(1)",
          "explanation": "ConcurrentHashMap lookup with lazy initialization"
        }
      },
      "overall_change": "Time complexity for individual operations unchanged at O(1), but throughput affected by lock contention. Different events can be booked truly in parallel."
    },
    "space": {
      "additional_space": "O(E) where E = number of events",
      "explanation": "One Lock object per event stored in LockManager. Each Lock uses ~48 bytes (ReentrantLock) on JVM."
    }
  },
  "dry_run": {
    "example_input": "Event with 2 tickets, 3 concurrent requests for 2 tickets each",
    "steps": [
      {
        "step": 1,
        "action": "Create event",
        "state": "Event{id=evt_001, available=2}",
        "explanation": "Event created with 2 available tickets"
      },
      {
        "step": 2,
        "action": "Thread A calls book_tickets_atomic",
        "state": "Lock acquired by A",
        "explanation": "Thread A acquires lock for evt_001"
      },
      {
        "step": 3,
        "action": "Thread B, C also call book_tickets_atomic",
        "state": "B, C waiting on lock",
        "explanation": "Threads B and C block on lock.acquire()"
      },
      {
        "step": 4,
        "action": "Thread A reads available=2",
        "state": "Inside critical section",
        "explanation": "A sees 2 tickets, check passes (2 >= 2)"
      },
      {
        "step": 5,
        "action": "Thread A decrements and creates booking",
        "state": "available=0, booking created",
        "explanation": "A reduces available to 0, creates booking bkg_001"
      },
      {
        "step": 6,
        "action": "Thread A releases lock",
        "state": "Lock released",
        "explanation": "Finally block executes, lock.release() called"
      },
      {
        "step": 7,
        "action": "Thread B acquires lock",
        "state": "Lock acquired by B",
        "explanation": "B wins race to acquire lock (arbitrary)"
      },
      {
        "step": 8,
        "action": "Thread B reads available=0",
        "state": "Inside critical section",
        "explanation": "B sees 0 tickets (A's update visible)"
      },
      {
        "step": 9,
        "action": "Thread B check fails",
        "state": "0 < 2, insufficient",
        "explanation": "B cannot book, returns 409 Conflict"
      },
      {
        "step": 10,
        "action": "Thread B releases lock, C proceeds similarly",
        "state": "C also gets 409",
        "explanation": "C also sees 0 available, returns 409"
      }
    ],
    "final_output": "[Response(201, booking), Response(409, insufficient), Response(409, insufficient)]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single booking on event with tickets -> 201 SUCCESS",
      "Booking with 0 tickets -> 400 VALIDATION_ERROR",
      "Booking on non-existent event -> 404 NOT_FOUND"
    ],
    "likely_bugs": [
      "Checking availability OUTSIDE the lock then checking INSIDE - the outside check is useless",
      "Not releasing lock on exception - deadlock",
      "Using global lock instead of per-event lock - unnecessary serialization",
      "Forgetting to decrement INSIDE the lock - race condition"
    ],
    "recommended_logs_or_asserts": [
      "assert event.available_tickets >= 0, 'Overselling detected!'",
      "Log: f'Thread {thread_id} acquired lock for {event_id}'",
      "Log: f'Booking {booking_id} created, {available} tickets remaining'"
    ],
    "how_to_localize": "1. Add print statements inside critical section showing thread ID and available count. 2. Run simulate_concurrent_bookings with 10+ threads. 3. Check for any available < 0 or success count > expected. 4. If bug found, check lock acquisition order and ensure all reads/writes are inside lock."
  },
  "edge_cases": [
    {
      "case": "All concurrent requests for 1 ticket, exactly N available",
      "handling": "Exactly N succeed, rest get 409",
      "gotcha": "Order is non-deterministic - don't assert which specific users win"
    },
    {
      "case": "Event deleted between validation and lock acquisition",
      "handling": "Double-check inside lock, return 404",
      "gotcha": "Must check event exists INSIDE critical section too"
    },
    {
      "case": "Same user submitting duplicate concurrent requests",
      "handling": "Both are processed - could both succeed if enough tickets",
      "gotcha": "Duplicate detection not required in Part 3 (could add in Part 4)"
    },
    {
      "case": "Request for 0 tickets",
      "handling": "Validation fails before lock, return 400",
      "gotcha": "Don't acquire lock for invalid requests - waste of resources"
    },
    {
      "case": "Event with exactly 0 tickets available",
      "handling": "All requests get 409 Conflict",
      "gotcha": "Don't return 400 - the request is valid, just unavailable"
    }
  ],
  "test_cases": [
    {
      "name": "Single successful booking",
      "input": "Event with 5 tickets, 1 request for 3 tickets",
      "expected": "201 Created, 2 tickets remaining",
      "explanation": "Basic case - no concurrency, just verifies atomic method works"
    },
    {
      "name": "Last ticket race condition",
      "input": "Event with 1 ticket, 10 concurrent requests for 1 ticket each",
      "expected": "Exactly 1 success (201), 9 conflicts (409)",
      "explanation": "Classic race condition test - only one winner"
    },
    {
      "name": "Multiple partial successes",
      "input": "Event with 5 tickets, 10 concurrent requests for 1 ticket each",
      "expected": "Exactly 5 successes, 5 conflicts, 0 remaining",
      "explanation": "Verifies correct count when multiple can succeed"
    },
    {
      "name": "Request exceeds available",
      "input": "Event with 3 tickets, 1 request for 5 tickets",
      "expected": "409 Conflict, 3 tickets still remaining",
      "explanation": "Single request insufficient tickets - no partial booking"
    },
    {
      "name": "Different events don't block",
      "input": "2 events, concurrent bookings for each",
      "expected": "Bookings for Event A don't wait for Event B",
      "explanation": "Verifies fine-grained locking - per-event, not global"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking availability outside lock only",
      "why_wrong": "Another thread can decrement between your check and your decrement, causing overselling",
      "correct_approach": "Check availability INSIDE the lock, or only inside if checking once",
      "code_example_wrong": "# WRONG\\nif event.available >= requested:  # Outside lock\\n    with lock:\\n        event.available -= requested  # Race condition!",
      "code_example_correct": "# CORRECT\\nwith lock:\\n    if event.available >= requested:  # Inside lock\\n        event.available -= requested"
    },
    {
      "mistake": "Not releasing lock on exception",
      "why_wrong": "If an exception occurs between acquire and release, the lock is never released - deadlock",
      "correct_approach": "Use try-finally or context manager to guarantee release",
      "code_example_wrong": "# WRONG\\nlock.acquire()\\ndo_something_that_might_throw()\\nlock.release()  # Never reached on exception",
      "code_example_correct": "# CORRECT\\nlock.acquire()\\ntry:\\n    do_something_that_might_throw()\\nfinally:\\n    lock.release()  # Always executed"
    },
    {
      "mistake": "Using global lock for all events",
      "why_wrong": "Serializes ALL bookings - booking for Concert A waits for Conference B to finish",
      "correct_approach": "Per-event lock - only bookings for SAME event compete",
      "code_example_wrong": "# WRONG\\nwith self.global_lock:  # All events serialized\\n    book_for_event(event_id)",
      "code_example_correct": "# CORRECT\\nwith self.locks[event_id]:  # Only same-event serialized\\n    book_for_event(event_id)"
    },
    {
      "mistake": "Returning 400 instead of 409 for insufficient tickets",
      "why_wrong": "400 means invalid request, 409 means valid request conflicting with current state",
      "correct_approach": "Use 409 Conflict for race condition losses",
      "code_example_wrong": "# WRONG\\nreturn Response(400, 'Not enough tickets')",
      "code_example_correct": "# CORRECT\\nreturn Response(409, 'INSUFFICIENT_TICKETS')"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the race condition with a timeline diagram. Then present pessimistic vs optimistic locking trade-offs. Choose pessimistic for high-contention ticket scenarios. Implement with clear critical section comments.",
    "what_to_mention": [
      "Why check-then-act must be atomic",
      "Difference between pessimistic and optimistic locking",
      "Per-event locks for parallelism across events",
      "try-finally pattern for lock safety",
      "How to test concurrent code"
    ],
    "time_allocation": "15-20 minutes: 3 min explaining race condition, 5 min discussing locking strategies, 10 min implementation, 2 min testing",
    "if_stuck": [
      "Think about what happens if two threads read the same value before either writes",
      "How do databases handle concurrent updates? (locks or versions)",
      "What must be true about the order of read-check-update?"
    ]
  },
  "connection_to_next_part": "Part 4 typically adds **observability** (logging, metrics, rate limiting). The locking mechanism stays the same, but we wrap operations with logging decorators and add request counters. The LockManager could be extended to track lock wait times as a metric.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 added auth. Now for Part 3, we face a critical issue: **race conditions**. When a popular concert releases tickets, thousands hit the booking endpoint simultaneously. Let me explain the problem...",
    "explaining_changes": "The key change is wrapping the read-check-update sequence in a lock. I'll add a LockManager with per-event locks so different events don't block each other. The critical insight is that we must check availability INSIDE the lock.",
    "while_extending_code": [
      "Adding LockManager class for fine-grained locking...",
      "Modifying book_tickets to use lock - notice try-finally for safety...",
      "Adding simulate_concurrent_bookings for testing..."
    ],
    "after_completing": "Now we're thread-safe. bookTicketsAtomic is O(1) plus lock wait time. Under high contention, requests serialize but we NEVER oversell. Ready to add observability in Part 4?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes",
    "by_3_min": "Explain the race condition clearly with timeline diagram",
    "by_7_min": "Discuss pessimistic vs optimistic, justify choice",
    "by_12_min": "Core implementation done: LockManager, book_tickets_atomic",
    "by_18_min": "Testing with simulate_concurrent_bookings, verify no overselling",
    "warning_signs": "If still explaining race condition at 5 min, speed up. If stuck on implementation at 10 min, ask for hints."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 auth is blocking, temporarily bypass it: 'Let me focus on the concurrency aspect first, then integrate auth.'",
    "if_new_requirement_unclear": "Ask: 'Should I return 409 Conflict or 200 with error body for insufficient tickets?'",
    "if_running_behind": "Implement global lock first (simpler), then mention per-event optimization. Say: 'For time, I'll use a global lock. In production I'd use per-event locks for parallelism.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Drawing the race condition timeline before coding",
      "Mentioning why pessimistic beats optimistic for flash sales",
      "Using per-event locks instead of global for parallelism",
      "Testing with ThreadPoolExecutor to verify correctness",
      "Mentioning production concerns: lock timeouts, deadlock detection"
    ]
  },
  "pattern_recognition": {
    "pattern": "Pessimistic Locking / Mutual Exclusion",
    "indicators": [
      "Multiple threads/users competing for limited resource",
      "Check-then-act operations that must be atomic",
      "High stakes for inconsistency (overselling tickets = angry customers)",
      "Flash sale / high-traffic scenarios"
    ],
    "similar_problems": [
      "Bank account transfers (balance check + debit)",
      "Inventory management systems",
      "Rate limiters (check count + increment)",
      "Distributed locks with Redis/Zookeeper"
    ],
    "template": "lock.acquire()\\ntry:\\n    # 1. Read current state\\n    # 2. Check condition\\n    # 3. Update state\\n    # 4. Create record\\nfinally:\\n    lock.release()"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'concurrent booking' + 'limited tickets', I immediately think race condition",
      "why": "Classic TOCTOU (time-of-check-to-time-of-use) bug pattern"
    },
    {
      "step": 2,
      "thought": "The constraint is 'never oversell' - this requires atomicity",
      "why": "Business invariant that cannot be violated even under load"
    },
    {
      "step": 3,
      "thought": "Pessimistic locking is safer for high-contention scenarios like flash sales",
      "why": "Optimistic would cause retry storms when everyone wants the same tickets"
    },
    {
      "step": 4,
      "thought": "Per-event locking allows parallelism for different events",
      "why": "Users booking for different concerts shouldn't wait for each other"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you understand race conditions and how to prevent them?",
      "Can you explain the trade-offs between locking strategies?",
      "Do you handle the lock lifecycle correctly (try-finally)?",
      "Can you extend existing code cleanly without rewriting?"
    ],
    "bonus_points": [
      "Drawing timeline diagram without prompting",
      "Mentioning CAS / compare-and-swap as alternative",
      "Discussing lock granularity trade-offs",
      "Writing test that proves no overselling"
    ],
    "red_flags": [
      "Not recognizing the race condition when explained",
      "Checking availability outside the lock",
      "Forgetting to release lock on exceptions",
      "Using Thread.sleep() as a 'solution'"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate LockManager boilerplate",
      "Ask AI for ThreadPoolExecutor syntax",
      "Use AI to write test harness for concurrent simulation"
    ],
    "what_not_to_do": [
      "Don't accept lock code without understanding when lock is acquired/released",
      "Don't let AI use global lock if per-event is better",
      "Verify the critical section boundaries are correct"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining the race condition",
      "Not asking about expected behavior under contention"
    ],
    "technical": [
      "Checking availability outside lock and assuming it's still valid inside",
      "Using sleep() instead of proper synchronization",
      "Forgetting finally block for lock release"
    ],
    "communication": [
      "Not explaining WHY pessimistic vs optimistic",
      "Not mentioning what happens to losing threads (they get 409)"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Is the lock acquired BEFORE reading availability?",
      "Is the lock released in a finally block?",
      "Is check-decrement-create all inside the lock?",
      "Does the test prove no overselling?",
      "Are different events using different locks?"
    ],
    "quick_code_review": [
      "No availability check outside the critical section",
      "try-finally pattern for lock",
      "409 Conflict (not 400) for insufficient tickets",
      "Thread-safe ID generation"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Lock timeout to prevent infinite waits",
      "Metrics: lock wait time, contention rate",
      "Distributed locking with Redis if multi-server",
      "Circuit breaker for flash sale overload",
      "Dead-letter queue for failed bookings"
    ],
    "why_not_in_interview": "Focus on core concurrency pattern; these are operational concerns",
    "how_to_mention": "Say: 'In production, I'd add lock timeouts and metrics to monitor contention. For distributed systems, I'd use Redis distributed locks.'"
  },
  "generated_at": "2026-01-18T21:44:00.350135",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}