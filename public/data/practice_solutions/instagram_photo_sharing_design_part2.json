{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 2: Stories Feature (24-hour ephemeral content)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 adds **ephemeral content** (Stories) that auto-expire after 24 hours. This introduces TTL management, high-volume view tracking, and the Story Ring UI component showing which followed users have unviewed stories. The key architectural shift is handling time-based expiration and billions of write events (views) efficiently.",
    "new_requirements": [
      "Post stories with 24-hour TTL auto-deletion",
      "Story Ring showing followed users with active/unviewed stories",
      "View tracking with viewed/unviewed status per user",
      "Story analytics: view count and viewer list",
      "Support 500M story posts/day and billions of view events"
    ],
    "new_constraints": [
      "Stories must auto-delete after exactly 24 hours",
      "View tracking must handle extreme write volume (billions/day)",
      "Story ring must show unviewed status in real-time",
      "Stories viewed 5x more than regular feed"
    ],
    "key_insight": "**Separate 'has viewed' (fast O(1) Bloom filter) from 'viewer list' (eventually consistent append log)**. Use probabilistic data structures (Bloom filters, HyperLogLog) for read-heavy view checks while maintaining eventual consistency for detailed analytics. Cassandra TTL handles automatic expiration without cleanup jobs."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "24-hour story expiration",
        "how_met": "Cassandra TTL on write + lazy cleanup on read",
        "gotchas": [
          "Timezones",
          "Clock skew between servers",
          "Need cleanup job for orphaned data"
        ]
      },
      {
        "requirement": "Story Ring with unviewed status",
        "how_met": "Redis sorted set with timestamp scores + Bloom filter per story for view check",
        "gotchas": [
          "False positives in Bloom filter show viewed when not",
          "Race condition between posting and ring update"
        ]
      },
      {
        "requirement": "High-volume view tracking",
        "how_met": "Bloom filter for 'has viewed' (O(1)), HyperLogLog for unique count, async append log for viewer list",
        "gotchas": [
          "Bloom filter size must be tuned to expected viewers",
          "HyperLogLog has ~2% error rate"
        ]
      },
      {
        "requirement": "Story analytics",
        "how_met": "HyperLogLog for cardinality, append-only log for detailed viewers",
        "gotchas": [
          "Viewer list can be duplicated if user views multiple times"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "postStory",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Single insert into Cassandra with TTL"
      },
      {
        "operation": "getStoryRing",
        "target": "O(followed_users)",
        "achieved": "O(F)",
        "why": "Must check each followed user for active stories"
      },
      {
        "operation": "markStoryViewed",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Bloom filter add is constant time"
      },
      {
        "operation": "getStoryViewers",
        "target": "O(V)",
        "achieved": "O(V)",
        "why": "Must return all viewers"
      }
    ],
    "non_goals": [
      "Story replies/reactions (separate feature)",
      "Story highlights (archiving beyond 24h)",
      "Close friends list filtering",
      "Story mentions and tags"
    ]
  },
  "assumptions": [
    "Average user has ~500 followers and follows ~500 users",
    "Average 10-20 stories per active user per day",
    "View events are fire-and-forget (eventual consistency OK)",
    "Bloom filter false positive rate of 1% is acceptable for UX",
    "Stories are write-once, read-many (no edits)",
    "Clock synchronization across servers (NTP) within 1 second"
  ],
  "tradeoffs": [
    {
      "decision": "Bloom Filter vs HashSet for view tracking",
      "chosen": "Bloom Filter",
      "why": "O(1) lookup with ~1% false positive rate, uses 10x less memory than HashSet",
      "alternative": "HashSet for exact tracking",
      "when_to_switch": "If business requires 100% accurate 'viewed' status (e.g., for premium analytics)"
    },
    {
      "decision": "Cassandra TTL vs Background Cleanup Job",
      "chosen": "Cassandra TTL",
      "why": "Automatic cleanup, no operational overhead, guaranteed deletion",
      "alternative": "Background job scanning for expired stories",
      "when_to_switch": "If need to archive stories before deletion or trigger events on expiry"
    },
    {
      "decision": "HyperLogLog vs Exact Counter for view count",
      "chosen": "HyperLogLog",
      "why": "Constant space (~12KB) regardless of viewer count, ~2% accuracy",
      "alternative": "Exact counter with dedup",
      "when_to_switch": "If exact counts required for monetization/ads"
    },
    {
      "decision": "Per-story vs Per-user Bloom filter",
      "chosen": "Per-story Bloom filter",
      "why": "Natural expiration with story, simpler cleanup",
      "alternative": "Per-user aggregated filter",
      "when_to_switch": "If checking 'has viewed ANY story from user X' is more common query"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Story ID format",
      "TTL constant (24 hours)",
      "View tracking interface (mark_viewed, has_viewed)",
      "Story ring data structure"
    ],
    "what_to_change": [
      "Added BloomFilter and HyperLogLog classes",
      "New _stories_by_user storage",
      "New _view_bloom_filters tracking",
      "New _user_viewed_stories for ring status"
    ],
    "interfaces_and_boundaries": "StoriesService is a separate class that takes social_graph as dependency injection. This allows easy mocking for tests and clean separation from the main Instagram class. The InstagramWithStories class delegates all story operations to StoriesService.",
    "invariants": [
      "Story expiration time = created_time + 24 hours",
      "Bloom filter never removes items (only adds)",
      "Story ring only shows followed users",
      "View count >= unique viewers count (due to HLL estimation)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n BEFORE (Part 1):                    AFTER (Part 2):\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502   Posts     \u2502                    \u2502   Posts     \u2502\n \u2502  (permanent)\u2502                    \u2502  (permanent)\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           +\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502  Stories    \u2502\n                                    \u2502 (24h TTL)   \u2502\u2500\u2500\u25ba[Expires]\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502 Story Ring  \u2502\n                                    \u2502  (Redis)    \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502View Tracker \u2502\n                                    \u2502(Bloom+HLL)  \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n POST STORY FLOW:\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Upload  \u2502\u2500\u2500\u25ba\u2502 Generate \u2502\u2500\u2500\u25ba\u2502 Store w/  \u2502\u2500\u2500\u25ba\u2502 Update     \u2502\n \u2502 Media   \u2502   \u2502 Story ID \u2502   \u2502 TTL=24h   \u2502   \u2502 Story Ring \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n VIEW STORY FLOW:\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 View    \u2502\u2500\u2500\u25ba\u2502 Add to   \u2502\u2500\u2500\u25ba\u2502 Add to    \u2502\u2500\u2500\u25ba\u2502 Append to  \u2502\n \u2502 Event   \u2502   \u2502 Bloom    \u2502   \u2502 HyperLog  \u2502   \u2502 Viewer Log \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n GET STORY RING FLOW:\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Request \u2502\u2500\u2500\u25ba\u2502 Get Followed \u2502\u2500\u2500\u25ba\u2502 Filter to  \u2502\u2500\u2500\u25ba\u2502 Check  \u2502\n \u2502 Ring    \u2502   \u2502 Users        \u2502   \u2502 Has Stories\u2502   \u2502 Viewed \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                        \u2502\n                                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                         \u2502 Sort: unviewed first,      \u2502\n                                         \u2502       then by recency      \u2502\n                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store stories in same table as posts, check expiration on every read, use HashSet for view tracking",
      "time_complexity": "O(n) for checking all stories on read",
      "space_complexity": "O(viewers) per story for exact tracking",
      "why_not_optimal": "1) Expired stories bloat storage until manual cleanup, 2) HashSet uses too much memory for billions of views, 3) Scanning all stories for expiration is expensive, 4) No efficient way to get 'has unviewed' for story ring"
    },
    {
      "name": "Optimal Approach",
      "description": "Use Cassandra TTL for auto-expiration, Bloom filters for view tracking, HyperLogLog for counts, Redis sorted sets for story ring",
      "time_complexity": "O(1) for post/view, O(F) for story ring where F=followed users",
      "space_complexity": "O(stories) + O(k) per story for Bloom filter where k is small constant",
      "key_insight": "Probabilistic data structures (Bloom filter, HLL) trade small accuracy loss for massive space/time savings. Cassandra TTL eliminates need for cleanup jobs."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Stories Architecture\n\n### 1. **Story Storage with TTL**\nUse Cassandra with built-in TTL support. When inserting a story, set `TTL=86400` (24 hours). Cassandra automatically deletes the row after expiration - no cleanup jobs needed.\n\n### 2. **Story Ring with Redis Sorted Set**\nMaintain a Redis sorted set per user with:\n- Members: user_ids who have active stories\n- Score: latest story timestamp\n\nThis allows O(log n) updates and O(k) retrieval of top-k users with stories.\n\n### 3. **View Tracking with Bloom Filters**\nFor each story, create a Bloom filter to track who has viewed it:\n- **Add viewer**: O(1) - hash viewer_id, set bits\n- **Check viewed**: O(1) - hash viewer_id, check bits\n- **Space**: ~1.2 bytes per expected viewer for 1% false positive rate\n\n### 4. **View Count with HyperLogLog**\nUse HyperLogLog for approximate unique viewer counts:\n- **Space**: Fixed 12KB regardless of cardinality\n- **Accuracy**: Within 2% of true count\n- **Operations**: O(1) add and count\n\n### 5. **Viewer List for Analytics**\nMaintain an append-only log of viewer_ids for detailed analytics (who viewed). This can be async and eventually consistent.",
    "data_structures": [
      {
        "structure": "Cassandra Table with TTL",
        "purpose": "Story storage with automatic 24h expiration"
      },
      {
        "structure": "Redis Sorted Set",
        "purpose": "Story ring - users with stories sorted by recency"
      },
      {
        "structure": "Bloom Filter (per story)",
        "purpose": "Fast O(1) 'has viewed' check with 1% false positive"
      },
      {
        "structure": "HyperLogLog (per story)",
        "purpose": "Approximate unique view count in constant space"
      },
      {
        "structure": "Append Log",
        "purpose": "Detailed viewer list for analytics"
      }
    ],
    "algorithm_steps": [
      "**postStory**: Generate story_id \u2192 Store media in CDN \u2192 Insert row in Cassandra with TTL=24h \u2192 Update Redis sorted set for poster \u2192 Initialize Bloom filter and HLL",
      "**getStoryRing**: Get followed users \u2192 Filter to users in Redis sorted set \u2192 For each, check Bloom filter for unviewed stories \u2192 Sort by (has_unviewed DESC, recency DESC)",
      "**markStoryViewed**: Add viewer_id to story's Bloom filter \u2192 Add to HyperLogLog \u2192 Async append to viewer log \u2192 Update user's viewed stories set",
      "**getStoryViewers**: Read from viewer log (paginated)",
      "**Cleanup**: Cassandra TTL auto-deletes expired rows \u2192 Background job cleans up orphaned Bloom filters and Redis entries"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram Stories Feature - Part 2 Solution",
    "Handles ephemeral 24-hour content with efficient view tracking",
    "\"\"\"",
    "",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Set, Optional, Tuple",
    "from enum import Enum",
    "from collections import defaultdict",
    "import time",
    "import uuid",
    "import hashlib",
    "import math",
    "",
    "",
    "class StoryType(Enum):",
    "    \"\"\"Type of story content\"\"\"",
    "    PHOTO = \"PHOTO\"",
    "    VIDEO = \"VIDEO\"",
    "",
    "",
    "@dataclass",
    "class Story:",
    "    \"\"\"Represents a single story post\"\"\"",
    "    story_id: str",
    "    user_id: str",
    "    media_url: str",
    "    story_type: StoryType",
    "    created_at: int  # Unix timestamp",
    "    expires_at: int  # created_at + 24 hours",
    "    view_count: int = 0",
    "",
    "",
    "@dataclass",
    "class StoryRingEntry:",
    "    \"\"\"Entry in the story ring showing a user with active stories\"\"\"",
    "    user_id: str",
    "    has_unviewed: bool",
    "    latest_story_time: int",
    "    story_count: int",
    "",
    "",
    "@dataclass",
    "class StoryRing:",
    "    \"\"\"Collection of users with active stories for the story ring UI\"\"\"",
    "    users: List[StoryRingEntry]",
    "",
    "",
    "@dataclass",
    "class StoryFeed:",
    "    \"\"\"Stories grouped by user for the stories viewer\"\"\"",
    "    stories_by_user: Dict[str, List[Story]]",
    "",
    "",
    "class BloomFilter:",
    "    \"\"\"",
    "    Probabilistic data structure for membership testing.",
    "    Used for efficient 'has viewed' checks with small false positive rate.",
    "    ",
    "    Time: O(k) for add/check where k = number of hash functions",
    "    Space: O(m) bits where m is calculated from expected items and FP rate",
    "    \"\"\"",
    "",
    "    def __init__(self, expected_items: int = 10000, fp_rate: float = 0.01):",
    "        \"\"\"",
    "        Initialize Bloom filter.",
    "        ",
    "        Args:",
    "            expected_items: Expected number of items to store",
    "            fp_rate: Desired false positive rate (default 1%)",
    "        \"\"\"",
    "        # Calculate optimal size: m = -n * ln(p) / (ln(2)^2)",
    "        self.size = max(1, int(-expected_items * math.log(fp_rate) / (math.log(2) ** 2)))",
    "        # Calculate optimal hash count: k = (m/n) * ln(2)",
    "        self.hash_count = max(1, int((self.size / max(1, expected_items)) * math.log(2)))",
    "        self.bit_array = [False] * self.size",
    "        self._count = 0",
    "",
    "    def _hashes(self, item: str) -> List[int]:",
    "        \"\"\"Generate k hash values for an item\"\"\"",
    "        result = []",
    "        for i in range(self.hash_count):",
    "            h = hashlib.md5(f\"{item}:{i}\".encode()).hexdigest()",
    "            result.append(int(h, 16) % self.size)",
    "        return result",
    "",
    "    def add(self, item: str) -> None:",
    "        \"\"\"Add an item to the filter\"\"\"",
    "        for pos in self._hashes(item):",
    "            self.bit_array[pos] = True",
    "        self._count += 1",
    "",
    "    def might_contain(self, item: str) -> bool:",
    "        \"\"\"",
    "        Check if item might be in the filter.",
    "        Returns False = definitely not in set",
    "        Returns True = probably in set (may be false positive)",
    "        \"\"\"",
    "        return all(self.bit_array[pos] for pos in self._hashes(item))",
    "",
    "",
    "class HyperLogLog:",
    "    \"\"\"",
    "    Probabilistic cardinality estimator.",
    "    Used for approximate unique view counts with constant space.",
    "    ",
    "    Time: O(1) for add/count",
    "    Space: O(2^p) registers, typically ~12KB for p=14",
    "    Accuracy: ~1.04 / sqrt(m) standard error",
    "    \"\"\"",
    "",
    "    def __init__(self, precision: int = 14):",
    "        \"\"\"",
    "        Initialize HyperLogLog.",
    "        ",
    "        Args:",
    "            precision: Number of bits for register indexing (10-18)",
    "        \"\"\"",
    "        self.p = precision",
    "        self.m = 1 << precision  # 2^p registers",
    "        self.registers = [0] * self.m",
    "        # Alpha constant for bias correction",
    "        if self.m >= 128:",
    "            self.alpha = 0.7213 / (1 + 1.079 / self.m)",
    "        elif self.m >= 64:",
    "            self.alpha = 0.709",
    "        elif self.m >= 32:",
    "            self.alpha = 0.697",
    "        else:",
    "            self.alpha = 0.673",
    "",
    "    def _hash(self, item: str) -> int:",
    "        \"\"\"Generate 64-bit hash\"\"\"",
    "        return int(hashlib.md5(item.encode()).hexdigest(), 16) & ((1 << 64) - 1)",
    "",
    "    def _leading_zeros(self, x: int, max_bits: int = 50) -> int:",
    "        \"\"\"Count leading zeros in binary representation\"\"\"",
    "        if x == 0:",
    "            return max_bits",
    "        count = 0",
    "        for i in range(max_bits - 1, -1, -1):",
    "            if x & (1 << i):",
    "                break",
    "            count += 1",
    "        return count",
    "",
    "    def add(self, item: str) -> None:",
    "        \"\"\"Add an item to the estimator\"\"\"",
    "        h = self._hash(item)",
    "        idx = h & (self.m - 1)  # First p bits for register index",
    "        w = h >> self.p  # Remaining bits",
    "        self.registers[idx] = max(self.registers[idx], self._leading_zeros(w) + 1)",
    "",
    "    def count(self) -> int:",
    "        \"\"\"Estimate cardinality\"\"\"",
    "        indicator = sum(2.0 ** (-r) for r in self.registers)",
    "        estimate = self.alpha * self.m * self.m / indicator",
    "        ",
    "        # Apply corrections for small and large values",
    "        if estimate <= 2.5 * self.m:",
    "            # Small range correction",
    "            zeros = self.registers.count(0)",
    "            if zeros > 0:",
    "                estimate = self.m * math.log(self.m / zeros)",
    "        ",
    "        return int(estimate)",
    "",
    "",
    "class StoriesService:",
    "    \"\"\"",
    "    Stories Feature Service - handles ephemeral 24-hour content.",
    "    ",
    "    Architecture:",
    "    - Stories stored in Cassandra with TTL (simulated with dict + expiry check)",
    "    - Story ring maintained in Redis sorted set (simulated with dict)",
    "    - View tracking with Bloom filters and HyperLogLog",
    "    ",
    "    Key Design Decisions:",
    "    1. Cassandra TTL for automatic story expiration",
    "    2. Bloom filter for O(1) 'has viewed' check",
    "    3. HyperLogLog for approximate unique view counts",
    "    4. Separate viewer list for detailed analytics",
    "    \"\"\"",
    "",
    "    TTL_SECONDS = 24 * 60 * 60  # 24 hours in seconds",
    "",
    "    def __init__(self, social_graph: Dict[str, Set[str]]):",
    "        \"\"\"",
    "        Initialize stories service.",
    "        ",
    "        Args:",
    "            social_graph: user_id -> set of user_ids they follow",
    "        \"\"\"",
    "        # Story storage (simulates Cassandra with TTL)",
    "        # Partition: user_id, Clustering: story_id",
    "        self._stories_by_user: Dict[str, Dict[str, Story]] = defaultdict(dict)",
    "",
    "        # Story ring tracking (simulates Redis sorted set)",
    "        # user_id -> latest_story_timestamp",
    "        self._users_with_stories: Dict[str, int] = {}",
    "",
    "        # View tracking - Bloom filters for fast 'has viewed' check",
    "        # story_id -> BloomFilter",
    "        self._view_bloom_filters: Dict[str, BloomFilter] = {}",
    "",
    "        # View tracking - HyperLogLog for unique view counts",
    "        # story_id -> HyperLogLog",
    "        self._view_counters: Dict[str, HyperLogLog] = {}",
    "",
    "        # View tracking - detailed viewer list for analytics",
    "        # story_id -> List[viewer_id]",
    "        self._viewer_lists: Dict[str, List[str]] = defaultdict(list)",
    "",
    "        # Per-user view status for story ring 'has unviewed' check",
    "        # (viewer_id, poster_id) -> set of viewed story_ids",
    "        self._user_viewed_stories: Dict[Tuple[str, str], Set[str]] = defaultdict(set)",
    "",
    "        # Social graph reference (dependency injection)",
    "        self._social_graph = social_graph",
    "",
    "        # CDN simulation for media storage",
    "        self._media_storage: Dict[str, bytes] = {}",
    "",
    "    def _current_time(self) -> int:",
    "        \"\"\"Get current Unix timestamp in seconds\"\"\"",
    "        return int(time.time())",
    "",
    "    def _generate_story_id(self) -> str:",
    "        \"\"\"Generate unique story ID\"\"\"",
    "        return f\"story_{uuid.uuid4().hex[:12]}\"",
    "",
    "    def _is_story_expired(self, story: Story) -> bool:",
    "        \"\"\"Check if story has passed its TTL\"\"\"",
    "        return self._current_time() > story.expires_at",
    "",
    "    def _cleanup_expired_stories(self, user_id: str) -> None:",
    "        \"\"\"",
    "        Remove expired stories for a user.",
    "        In production, Cassandra TTL handles this automatically.",
    "        This simulates lazy cleanup on read.",
    "        \"\"\"",
    "        if user_id not in self._stories_by_user:",
    "            return",
    "",
    "        expired = [",
    "            story_id",
    "            for story_id, story in self._stories_by_user[user_id].items()",
    "            if self._is_story_expired(story)",
    "        ]",
    "",
    "        for story_id in expired:",
    "            del self._stories_by_user[user_id][story_id]",
    "            # Clean up associated tracking data",
    "            self._view_bloom_filters.pop(story_id, None)",
    "            self._view_counters.pop(story_id, None)",
    "            self._viewer_lists.pop(story_id, None)",
    "",
    "        # Update story ring status",
    "        if not self._stories_by_user[user_id]:",
    "            self._users_with_stories.pop(user_id, None)",
    "        elif self._stories_by_user[user_id]:",
    "            latest = max(s.created_at for s in self._stories_by_user[user_id].values())",
    "            self._users_with_stories[user_id] = latest",
    "",
    "    def post_story(",
    "        self, user_id: str, media: bytes, story_type: StoryType",
    "    ) -> str:",
    "        \"\"\"",
    "        Post a new story that expires in 24 hours.",
    "        ",
    "        Time Complexity: O(1)",
    "        Space Complexity: O(media_size)",
    "        ",
    "        Args:",
    "            user_id: User posting the story",
    "            media: Photo or video content bytes",
    "            story_type: PHOTO or VIDEO",
    "            ",
    "        Returns:",
    "            Unique story ID",
    "        \"\"\"",
    "        story_id = self._generate_story_id()",
    "        current_time = self._current_time()",
    "",
    "        # Store media in CDN (simulated)",
    "        media_url = f\"cdn://stories/{user_id}/{story_id}\"",
    "        self._media_storage[media_url] = media",
    "",
    "        # Create story with TTL",
    "        story = Story(",
    "            story_id=story_id,",
    "            user_id=user_id,",
    "            media_url=media_url,",
    "            story_type=story_type,",
    "            created_at=current_time,",
    "            expires_at=current_time + self.TTL_SECONDS,",
    "        )",
    "",
    "        # Store in Cassandra (simulated) - in production: INSERT with TTL",
    "        self._stories_by_user[user_id][story_id] = story",
    "",
    "        # Update story ring - this user now has active stories",
    "        self._users_with_stories[user_id] = current_time",
    "",
    "        # Initialize view tracking structures",
    "        self._view_bloom_filters[story_id] = BloomFilter(",
    "            expected_items=10000, fp_rate=0.01",
    "        )",
    "        self._view_counters[story_id] = HyperLogLog(precision=14)",
    "",
    "        return story_id",
    "",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        \"\"\"",
    "        Get the story ring showing which followed users have active stories.",
    "        ",
    "        Time Complexity: O(F) where F = number of followed users",
    "        Space Complexity: O(F)",
    "        ",
    "        Args:",
    "            user_id: User requesting their story ring",
    "            ",
    "        Returns:",
    "            StoryRing with list of users with active stories",
    "        \"\"\"",
    "        followed_users = self._social_graph.get(user_id, set())",
    "        ring_entries: List[StoryRingEntry] = []",
    "",
    "        for followed_id in followed_users:",
    "            # Clean up expired stories (lazy cleanup)",
    "            self._cleanup_expired_stories(followed_id)",
    "",
    "            # Check if user has active stories",
    "            if followed_id not in self._users_with_stories:",
    "                continue",
    "",
    "            latest_time = self._users_with_stories[followed_id]",
    "            active_stories = self._stories_by_user[followed_id]",
    "",
    "            if not active_stories:",
    "                continue",
    "",
    "            # Check if viewer has any unviewed stories from this user",
    "            viewed_stories = self._user_viewed_stories.get(",
    "                (user_id, followed_id), set()",
    "            )",
    "            has_unviewed = any(",
    "                story_id not in viewed_stories",
    "                for story_id in active_stories.keys()",
    "            )",
    "",
    "            ring_entries.append(",
    "                StoryRingEntry(",
    "                    user_id=followed_id,",
    "                    has_unviewed=has_unviewed,",
    "                    latest_story_time=latest_time,",
    "                    story_count=len(active_stories),",
    "                )",
    "            )",
    "",
    "        # Sort: unviewed first, then by recency (newest first)",
    "        ring_entries.sort(key=lambda e: (-e.has_unviewed, -e.latest_story_time))",
    "",
    "        return StoryRing(users=ring_entries)",
    "",
    "    def get_stories(self, user_id: str) -> StoryFeed:",
    "        \"\"\"",
    "        Get stories from all followed users.",
    "        ",
    "        Time Complexity: O(F * S) where F = followed users, S = avg stories",
    "        Space Complexity: O(F * S)",
    "        ",
    "        Args:",
    "            user_id: User requesting stories",
    "            ",
    "        Returns:",
    "            StoryFeed with stories grouped by user",
    "        \"\"\"",
    "        followed_users = self._social_graph.get(user_id, set())",
    "        stories_by_user: Dict[str, List[Story]] = {}",
    "",
    "        for followed_id in followed_users:",
    "            self._cleanup_expired_stories(followed_id)",
    "",
    "            if followed_id in self._stories_by_user:",
    "                active_stories = list(self._stories_by_user[followed_id].values())",
    "                if active_stories:",
    "                    # Sort by creation time (oldest first for story order)",
    "                    active_stories.sort(key=lambda s: s.created_at)",
    "                    stories_by_user[followed_id] = active_stories",
    "",
    "        return StoryFeed(stories_by_user=stories_by_user)",
    "",
    "    def get_user_stories(self, poster_user_id: str) -> List[Story]:",
    "        \"\"\"",
    "        Get all active stories from a specific user.",
    "        ",
    "        Time Complexity: O(S log S) due to sorting",
    "        Space Complexity: O(S)",
    "        \"\"\"",
    "        self._cleanup_expired_stories(poster_user_id)",
    "        stories = list(self._stories_by_user.get(poster_user_id, {}).values())",
    "        stories.sort(key=lambda s: s.created_at)  # Oldest first",
    "        return stories",
    "",
    "    def mark_story_viewed(",
    "        self, viewer_id: str, story_id: str",
    "    ) -> bool:",
    "        \"\"\"",
    "        Mark a story as viewed by a user.",
    "        ",
    "        Time Complexity: O(1) amortized",
    "        Space Complexity: O(1)",
    "        ",
    "        Args:",
    "            viewer_id: User who viewed the story",
    "            story_id: Story that was viewed",
    "            ",
    "        Returns:",
    "            True if successfully marked, False if story not found/expired",
    "        \"\"\"",
    "        # Find the story",
    "        story = self._find_story(story_id)",
    "        if not story or self._is_story_expired(story):",
    "            return False",
    "",
    "        # Add to Bloom filter for fast 'has viewed' lookup",
    "        bloom = self._view_bloom_filters.get(story_id)",
    "        if bloom:",
    "            bloom.add(viewer_id)",
    "",
    "        # Add to HyperLogLog for unique view count",
    "        hll = self._view_counters.get(story_id)",
    "        if hll:",
    "            hll.add(viewer_id)",
    "",
    "        # Append to viewer list for analytics (async in production)",
    "        self._viewer_lists[story_id].append(viewer_id)",
    "",
    "        # Track per-user view status for story ring",
    "        self._user_viewed_stories[(viewer_id, story.user_id)].add(story_id)",
    "",
    "        return True",
    "",
    "    def _find_story(self, story_id: str) -> Optional[Story]:",
    "        \"\"\"Find a story by ID across all users\"\"\"",
    "        for user_stories in self._stories_by_user.values():",
    "            if story_id in user_stories:",
    "                return user_stories[story_id]",
    "        return None",
    "",
    "    def get_story_viewers(self, story_id: str) -> List[str]:",
    "        \"\"\"",
    "        Get list of users who viewed a story.",
    "        ",
    "        Time Complexity: O(V) where V = number of view events",
    "        Space Complexity: O(V)",
    "        ",
    "        Note: May contain duplicates if user viewed multiple times.",
    "        In production, dedupe at query time or use Set storage.",
    "        \"\"\"",
    "        return list(self._viewer_lists.get(story_id, []))",
    "",
    "    def get_story_view_count(self, story_id: str) -> int:",
    "        \"\"\"",
    "        Get approximate unique view count using HyperLogLog.",
    "        ",
    "        Time Complexity: O(1)",
    "        Space Complexity: O(1)",
    "        Accuracy: Within ~2% of true count",
    "        \"\"\"",
    "        hll = self._view_counters.get(story_id)",
    "        return hll.count() if hll else 0",
    "",
    "    def has_user_viewed_story(",
    "        self, viewer_id: str, story_id: str",
    "    ) -> bool:",
    "        \"\"\"",
    "        Check if user has viewed a story using Bloom filter.",
    "        ",
    "        Time Complexity: O(k) where k = hash functions (~7)",
    "        Space Complexity: O(1)",
    "        ",
    "        Note: May return false positives (~1% rate).",
    "        False = definitely not viewed, True = probably viewed.",
    "        \"\"\"",
    "        bloom = self._view_bloom_filters.get(story_id)",
    "        return bloom.might_contain(viewer_id) if bloom else False",
    "",
    "",
    "class InstagramWithStories:",
    "    \"\"\"",
    "    Complete Instagram system with Stories feature.",
    "    Extends the base Instagram functionality from Part 1.",
    "    \"\"\"",
    "",
    "    def __init__(self):",
    "        # Social graph from Part 1",
    "        self._following: Dict[str, Set[str]] = defaultdict(set)",
    "        self._followers: Dict[str, Set[str]] = defaultdict(set)",
    "",
    "        # Initialize stories service with social graph reference",
    "        self._stories_service = StoriesService(self._following)",
    "",
    "        # Users data",
    "        self._users: Dict[str, dict] = {}",
    "",
    "    def create_user(self, user_id: str, username: str) -> None:",
    "        \"\"\"Create a new user\"\"\"",
    "        self._users[user_id] = {",
    "            \"username\": username,",
    "            \"created_at\": int(time.time()),",
    "        }",
    "",
    "    def follow_user(self, follower_id: str, followee_id: str) -> None:",
    "        \"\"\"User follows another user\"\"\"",
    "        self._following[follower_id].add(followee_id)",
    "        self._followers[followee_id].add(follower_id)",
    "",
    "    def unfollow_user(self, follower_id: str, followee_id: str) -> None:",
    "        \"\"\"User unfollows another user\"\"\"",
    "        self._following[follower_id].discard(followee_id)",
    "        self._followers[followee_id].discard(follower_id)",
    "",
    "    # Stories API - delegate to StoriesService",
    "    def post_story(",
    "        self, user_id: str, media: bytes, story_type: StoryType",
    "    ) -> str:",
    "        \"\"\"Post a story that expires in 24 hours\"\"\"",
    "        return self._stories_service.post_story(user_id, media, story_type)",
    "",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        \"\"\"Get story ring showing users with active stories\"\"\"",
    "        return self._stories_service.get_story_ring(user_id)",
    "",
    "    def get_stories(self, user_id: str) -> StoryFeed:",
    "        \"\"\"Get all stories from followed users\"\"\"",
    "        return self._stories_service.get_stories(user_id)",
    "",
    "    def mark_story_viewed(self, viewer_id: str, story_id: str) -> bool:",
    "        \"\"\"Mark a story as viewed\"\"\"",
    "        return self._stories_service.mark_story_viewed(viewer_id, story_id)",
    "",
    "    def get_story_viewers(self, story_id: str) -> List[str]:",
    "        \"\"\"Get list of story viewers\"\"\"",
    "        return self._stories_service.get_story_viewers(story_id)",
    "",
    "",
    "def demo():",
    "    \"\"\"Demonstrate the Stories feature\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Instagram Stories Feature Demo\")",
    "    print(\"=\" * 60)",
    "",
    "    # Create Instagram instance",
    "    instagram = InstagramWithStories()",
    "",
    "    # Setup users",
    "    instagram.create_user(\"user_A\", \"alice\")",
    "    instagram.create_user(\"user_B\", \"bob\")",
    "    instagram.create_user(\"viewer_C\", \"charlie\")",
    "",
    "    # Setup follows: C follows A and B",
    "    instagram.follow_user(\"viewer_C\", \"user_A\")",
    "    instagram.follow_user(\"viewer_C\", \"user_B\")",
    "",
    "    print(\"\\n1. Initial state - no stories\")",
    "    ring = instagram.get_story_ring(\"viewer_C\")",
    "    print(f\"   Story ring for viewer_C: {len(ring.users)} users with stories\")",
    "",
    "    print(\"\\n2. user_A posts a story\")",
    "    story_a1 = instagram.post_story(",
    "        \"user_A\", b\"photo_bytes_1\", StoryType.PHOTO",
    "    )",
    "    print(f\"   Posted story: {story_a1}\")",
    "",
    "    print(\"\\n3. user_B posts two stories\")",
    "    story_b1 = instagram.post_story(",
    "        \"user_B\", b\"photo_bytes_2\", StoryType.PHOTO",
    "    )",
    "    story_b2 = instagram.post_story(",
    "        \"user_B\", b\"video_bytes_1\", StoryType.VIDEO",
    "    )",
    "    print(f\"   Posted stories: {story_b1}, {story_b2}\")",
    "",
    "    print(\"\\n4. Get story ring for viewer_C (all unviewed)\")",
    "    ring = instagram.get_story_ring(\"viewer_C\")",
    "    for entry in ring.users:",
    "        print(f\"   - {entry.user_id}: {entry.story_count} stories, \"",
    "              f\"unviewed={entry.has_unviewed}\")",
    "",
    "    print(\"\\n5. viewer_C views user_A's story\")",
    "    result = instagram.mark_story_viewed(\"viewer_C\", story_a1)",
    "    print(f\"   Marked as viewed: {result}\")",
    "",
    "    print(\"\\n6. Get story ring after viewing (user_A now viewed)\")",
    "    ring = instagram.get_story_ring(\"viewer_C\")",
    "    for entry in ring.users:",
    "        status = \"VIEWED\" if not entry.has_unviewed else \"UNVIEWED\"",
    "        print(f\"   - {entry.user_id}: {entry.story_count} stories, {status}\")",
    "",
    "    print(\"\\n7. Get story viewers for user_A's story\")",
    "    viewers = instagram.get_story_viewers(story_a1)",
    "    print(f\"   Viewers: {viewers}\")",
    "",
    "    print(\"\\n8. Multiple users view user_B's story\")",
    "    for i in range(100):",
    "        instagram.mark_story_viewed(f\"user_{i}\", story_b1)",
    "    view_count = instagram._stories_service.get_story_view_count(story_b1)",
    "    print(f\"   Approximate unique views (HLL): {view_count}\")",
    "    print(f\"   Actual unique viewers: 100\")",
    "",
    "    print(\"\\n9. Get all stories for viewer_C\")",
    "    feed = instagram.get_stories(\"viewer_C\")",
    "    for poster, stories in feed.stories_by_user.items():",
    "        print(f\"   {poster}: {len(stories)} stories\")",
    "        for s in stories:",
    "            print(f\"      - {s.story_id} ({s.story_type.value})\")",
    "",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo Complete!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    demo()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "import java.security.MessageDigest;",
    "import java.security.NoSuchAlgorithmException;",
    "",
    "/**",
    " * Instagram Stories Feature - Part 2 Solution",
    " * Handles ephemeral 24-hour content with efficient view tracking",
    " */",
    "public class InstagramStories {",
    "",
    "    public enum StoryType { PHOTO, VIDEO }",
    "",
    "    // Story data class",
    "    public static class Story {",
    "        public final String storyId;",
    "        public final String userId;",
    "        public final String mediaUrl;",
    "        public final StoryType storyType;",
    "        public final long createdAt;",
    "        public final long expiresAt;",
    "",
    "        public Story(String storyId, String userId, String mediaUrl,",
    "                     StoryType storyType, long createdAt, long expiresAt) {",
    "            this.storyId = storyId;",
    "            this.userId = userId;",
    "            this.mediaUrl = mediaUrl;",
    "            this.storyType = storyType;",
    "            this.createdAt = createdAt;",
    "            this.expiresAt = expiresAt;",
    "        }",
    "    }",
    "",
    "    // Story ring entry",
    "    public static class StoryRingEntry {",
    "        public final String userId;",
    "        public final boolean hasUnviewed;",
    "        public final long latestStoryTime;",
    "        public final int storyCount;",
    "",
    "        public StoryRingEntry(String userId, boolean hasUnviewed,",
    "                              long latestStoryTime, int storyCount) {",
    "            this.userId = userId;",
    "            this.hasUnviewed = hasUnviewed;",
    "            this.latestStoryTime = latestStoryTime;",
    "            this.storyCount = storyCount;",
    "        }",
    "    }",
    "",
    "    public static class StoryRing {",
    "        public final List<StoryRingEntry> users;",
    "        public StoryRing(List<StoryRingEntry> users) {",
    "            this.users = users;",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Bloom Filter for efficient 'has viewed' checks",
    "     */",
    "    public static class BloomFilter {",
    "        private final BitSet bitArray;",
    "        private final int size;",
    "        private final int hashCount;",
    "",
    "        public BloomFilter(int expectedItems, double fpRate) {",
    "            this.size = (int) Math.max(1, ",
    "                -expectedItems * Math.log(fpRate) / (Math.log(2) * Math.log(2)));",
    "            this.hashCount = (int) Math.max(1, ",
    "                (size / (double) expectedItems) * Math.log(2));",
    "            this.bitArray = new BitSet(size);",
    "        }",
    "",
    "        private int[] getHashes(String item) {",
    "            int[] hashes = new int[hashCount];",
    "            for (int i = 0; i < hashCount; i++) {",
    "                String toHash = item + \":\" + i;",
    "                hashes[i] = Math.abs(toHash.hashCode()) % size;",
    "            }",
    "            return hashes;",
    "        }",
    "",
    "        public void add(String item) {",
    "            for (int pos : getHashes(item)) {",
    "                bitArray.set(pos);",
    "            }",
    "        }",
    "",
    "        public boolean mightContain(String item) {",
    "            for (int pos : getHashes(item)) {",
    "                if (!bitArray.get(pos)) return false;",
    "            }",
    "            return true;",
    "        }",
    "    }",
    "",
    "    /**",
    "     * HyperLogLog for cardinality estimation",
    "     */",
    "    public static class HyperLogLog {",
    "        private final int[] registers;",
    "        private final int m;",
    "        private final double alpha;",
    "",
    "        public HyperLogLog(int precision) {",
    "            this.m = 1 << precision;",
    "            this.registers = new int[m];",
    "            this.alpha = 0.7213 / (1 + 1.079 / m);",
    "        }",
    "",
    "        public void add(String item) {",
    "            int hash = item.hashCode();",
    "            int idx = hash & (m - 1);",
    "            int w = hash >>> (int) (Math.log(m) / Math.log(2));",
    "            registers[idx] = Math.max(registers[idx], leadingZeros(w) + 1);",
    "        }",
    "",
    "        private int leadingZeros(int x) {",
    "            if (x == 0) return 32;",
    "            return Integer.numberOfLeadingZeros(x);",
    "        }",
    "",
    "        public int count() {",
    "            double sum = 0;",
    "            for (int r : registers) {",
    "                sum += Math.pow(2, -r);",
    "            }",
    "            return (int) (alpha * m * m / sum);",
    "        }",
    "    }",
    "",
    "    // Constants",
    "    private static final long TTL_SECONDS = 24 * 60 * 60;",
    "",
    "    // Storage",
    "    private final Map<String, Map<String, Story>> storiesByUser;",
    "    private final Map<String, Long> usersWithStories;",
    "    private final Map<String, BloomFilter> viewBloomFilters;",
    "    private final Map<String, HyperLogLog> viewCounters;",
    "    private final Map<String, List<String>> viewerLists;",
    "    private final Map<String, Set<String>> userViewedStories;",
    "    private final Map<String, Set<String>> socialGraph;",
    "",
    "    public InstagramStories() {",
    "        this.storiesByUser = new ConcurrentHashMap<>();",
    "        this.usersWithStories = new ConcurrentHashMap<>();",
    "        this.viewBloomFilters = new ConcurrentHashMap<>();",
    "        this.viewCounters = new ConcurrentHashMap<>();",
    "        this.viewerLists = new ConcurrentHashMap<>();",
    "        this.userViewedStories = new ConcurrentHashMap<>();",
    "        this.socialGraph = new ConcurrentHashMap<>();",
    "    }",
    "",
    "    public void followUser(String followerId, String followeeId) {",
    "        socialGraph.computeIfAbsent(followerId, k -> new HashSet<>())",
    "                   .add(followeeId);",
    "    }",
    "",
    "    private long currentTime() {",
    "        return System.currentTimeMillis() / 1000;",
    "    }",
    "",
    "    private String generateStoryId() {",
    "        return \"story_\" + UUID.randomUUID().toString().substring(0, 12);",
    "    }",
    "",
    "    private boolean isExpired(Story story) {",
    "        return currentTime() > story.expiresAt;",
    "    }",
    "",
    "    /**",
    "     * Post a new story that expires in 24 hours.",
    "     * Time: O(1), Space: O(media_size)",
    "     */",
    "    public String postStory(String userId, byte[] media, StoryType type) {",
    "        String storyId = generateStoryId();",
    "        long now = currentTime();",
    "        String mediaUrl = \"cdn://stories/\" + userId + \"/\" + storyId;",
    "",
    "        Story story = new Story(storyId, userId, mediaUrl, type, now,",
    "                                now + TTL_SECONDS);",
    "",
    "        storiesByUser.computeIfAbsent(userId, k -> new ConcurrentHashMap<>())",
    "                     .put(storyId, story);",
    "        usersWithStories.put(userId, now);",
    "        viewBloomFilters.put(storyId, new BloomFilter(10000, 0.01));",
    "        viewCounters.put(storyId, new HyperLogLog(14));",
    "",
    "        return storyId;",
    "    }",
    "",
    "    /**",
    "     * Get story ring showing followed users with active stories.",
    "     * Time: O(F) where F = followed users",
    "     */",
    "    public StoryRing getStoryRing(String userId) {",
    "        Set<String> following = socialGraph.getOrDefault(userId, Set.of());",
    "        List<StoryRingEntry> entries = new ArrayList<>();",
    "",
    "        for (String followedId : following) {",
    "            cleanupExpiredStories(followedId);",
    "",
    "            if (!usersWithStories.containsKey(followedId)) continue;",
    "",
    "            Map<String, Story> stories = storiesByUser.get(followedId);",
    "            if (stories == null || stories.isEmpty()) continue;",
    "",
    "            long latestTime = usersWithStories.get(followedId);",
    "            String viewKey = userId + \":\" + followedId;",
    "            Set<String> viewed = userViewedStories.getOrDefault(viewKey, Set.of());",
    "",
    "            boolean hasUnviewed = stories.keySet().stream()",
    "                .anyMatch(sid -> !viewed.contains(sid));",
    "",
    "            entries.add(new StoryRingEntry(followedId, hasUnviewed,",
    "                                           latestTime, stories.size()));",
    "        }",
    "",
    "        // Sort: unviewed first, then by recency",
    "        entries.sort((a, b) -> {",
    "            if (a.hasUnviewed != b.hasUnviewed) {",
    "                return a.hasUnviewed ? -1 : 1;",
    "            }",
    "            return Long.compare(b.latestStoryTime, a.latestStoryTime);",
    "        });",
    "",
    "        return new StoryRing(entries);",
    "    }",
    "",
    "    /**",
    "     * Mark a story as viewed by a user.",
    "     * Time: O(1)",
    "     */",
    "    public boolean markStoryViewed(String viewerId, String storyId) {",
    "        Story story = findStory(storyId);",
    "        if (story == null || isExpired(story)) return false;",
    "",
    "        BloomFilter bloom = viewBloomFilters.get(storyId);",
    "        if (bloom != null) bloom.add(viewerId);",
    "",
    "        HyperLogLog hll = viewCounters.get(storyId);",
    "        if (hll != null) hll.add(viewerId);",
    "",
    "        viewerLists.computeIfAbsent(storyId, k -> new ArrayList<>())",
    "                   .add(viewerId);",
    "",
    "        String viewKey = viewerId + \":\" + story.userId;",
    "        userViewedStories.computeIfAbsent(viewKey, k -> new HashSet<>())",
    "                         .add(storyId);",
    "",
    "        return true;",
    "    }",
    "",
    "    public List<String> getStoryViewers(String storyId) {",
    "        return new ArrayList<>(viewerLists.getOrDefault(storyId, List.of()));",
    "    }",
    "",
    "    public int getStoryViewCount(String storyId) {",
    "        HyperLogLog hll = viewCounters.get(storyId);",
    "        return hll != null ? hll.count() : 0;",
    "    }",
    "",
    "    private Story findStory(String storyId) {",
    "        for (Map<String, Story> userStories : storiesByUser.values()) {",
    "            if (userStories.containsKey(storyId)) {",
    "                return userStories.get(storyId);",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "",
    "    private void cleanupExpiredStories(String userId) {",
    "        Map<String, Story> stories = storiesByUser.get(userId);",
    "        if (stories == null) return;",
    "",
    "        List<String> expired = new ArrayList<>();",
    "        for (Map.Entry<String, Story> e : stories.entrySet()) {",
    "            if (isExpired(e.getValue())) {",
    "                expired.add(e.getKey());",
    "            }",
    "        }",
    "",
    "        for (String storyId : expired) {",
    "            stories.remove(storyId);",
    "            viewBloomFilters.remove(storyId);",
    "            viewCounters.remove(storyId);",
    "            viewerLists.remove(storyId);",
    "        }",
    "",
    "        if (stories.isEmpty()) {",
    "            usersWithStories.remove(userId);",
    "        }",
    "    }",
    "",
    "    // Demo",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"Instagram Stories Feature Demo (Java)\");",
    "        System.out.println(\"=\" .repeat(60));",
    "",
    "        InstagramStories ig = new InstagramStories();",
    "",
    "        // Setup follows",
    "        ig.followUser(\"viewer_C\", \"user_A\");",
    "        ig.followUser(\"viewer_C\", \"user_B\");",
    "",
    "        System.out.println(\"\\n1. user_A posts a story\");",
    "        String storyA1 = ig.postStory(\"user_A\", new byte[100], StoryType.PHOTO);",
    "        System.out.println(\"   Posted: \" + storyA1);",
    "",
    "        System.out.println(\"\\n2. user_B posts two stories\");",
    "        String storyB1 = ig.postStory(\"user_B\", new byte[100], StoryType.PHOTO);",
    "        String storyB2 = ig.postStory(\"user_B\", new byte[200], StoryType.VIDEO);",
    "        System.out.println(\"   Posted: \" + storyB1 + \", \" + storyB2);",
    "",
    "        System.out.println(\"\\n3. Story ring for viewer_C (all unviewed)\");",
    "        StoryRing ring = ig.getStoryRing(\"viewer_C\");",
    "        for (StoryRingEntry e : ring.users) {",
    "            System.out.printf(\"   - %s: %d stories, unviewed=%b%n\",",
    "                              e.userId, e.storyCount, e.hasUnviewed);",
    "        }",
    "",
    "        System.out.println(\"\\n4. viewer_C views user_A's story\");",
    "        ig.markStoryViewed(\"viewer_C\", storyA1);",
    "",
    "        System.out.println(\"\\n5. Story ring after viewing\");",
    "        ring = ig.getStoryRing(\"viewer_C\");",
    "        for (StoryRingEntry e : ring.users) {",
    "            String status = e.hasUnviewed ? \"UNVIEWED\" : \"VIEWED\";",
    "            System.out.printf(\"   - %s: %d stories, %s%n\",",
    "                              e.userId, e.storyCount, status);",
    "        }",
    "",
    "        System.out.println(\"\\n6. Simulate 100 views on user_B's story\");",
    "        for (int i = 0; i < 100; i++) {",
    "            ig.markStoryViewed(\"user_\" + i, storyB1);",
    "        }",
    "        System.out.println(\"   HLL count: \" + ig.getStoryViewCount(storyB1));",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Demo Complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and enums - StoryType enum defines PHOTO/VIDEO content types"
    },
    {
      "lines": "17-50",
      "explanation": "Data classes - Story, StoryRingEntry, StoryRing hold story data and metadata"
    },
    {
      "lines": "52-100",
      "explanation": "BloomFilter class - probabilistic membership test with O(1) add/check, configurable false positive rate"
    },
    {
      "lines": "102-145",
      "explanation": "HyperLogLog class - cardinality estimator with constant space, ~2% accuracy"
    },
    {
      "lines": "147-200",
      "explanation": "StoriesService initialization - sets up storage maps for stories, view tracking, and social graph reference"
    },
    {
      "lines": "202-250",
      "explanation": "postStory method - generates ID, creates story with TTL, initializes view tracking structures"
    },
    {
      "lines": "252-310",
      "explanation": "getStoryRing method - iterates followed users, checks active stories, determines unviewed status, sorts by priority"
    },
    {
      "lines": "312-360",
      "explanation": "markStoryViewed method - updates Bloom filter, HyperLogLog, viewer list, and per-user view status"
    },
    {
      "lines": "362-400",
      "explanation": "Helper methods - findStory, cleanup, view count/viewers retrieval"
    },
    {
      "lines": "402-480",
      "explanation": "InstagramWithStories class - wraps StoriesService with social graph, provides clean API"
    },
    {
      "lines": "482-550",
      "explanation": "Demo function - shows full workflow: post stories, view ring, mark viewed, analytics"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "postStory": {
          "complexity": "O(1)",
          "explanation": "Single insert to map, initialize Bloom filter and HLL"
        },
        "getStoryRing": {
          "complexity": "O(F)",
          "explanation": "Iterate F followed users, O(1) check per user for active stories"
        },
        "markStoryViewed": {
          "complexity": "O(1) amortized",
          "explanation": "Bloom filter add is O(k) where k~7 hashes, treated as constant"
        },
        "getStoryViewers": {
          "complexity": "O(V)",
          "explanation": "Return V viewer entries from list"
        },
        "getStoryViewCount": {
          "complexity": "O(1)",
          "explanation": "HyperLogLog count is O(m) where m is constant ~16K registers"
        }
      },
      "overall_change": "Stories operations are independent of Part 1 feed. Story ring adds O(F) operation but doesn't affect feed generation."
    },
    "space": {
      "additional_space": "O(S * (B + H + V)) where S=stories, B=bloom size, H=HLL registers, V=viewers",
      "explanation": "Each story needs: ~10KB Bloom filter (10K expected viewers), ~12KB HLL, plus viewer list growth. Total ~25KB per story + viewer data."
    }
  },
  "dry_run": {
    "example_input": "postStory(user_A, photo), postStory(user_B, photo), getStoryRing(viewer_C who follows A,B), markStoryViewed(viewer_C, story_A1), getStoryRing(viewer_C)",
    "steps": [
      {
        "step": 1,
        "action": "postStory(user_A, photo)",
        "state": "stories_by_user={A:{s1}}, users_with_stories={A:t1}",
        "explanation": "Story created with ID s1, TTL set to t1+24h"
      },
      {
        "step": 2,
        "action": "postStory(user_B, photo)",
        "state": "stories_by_user={A:{s1}, B:{s2}}, users_with_stories={A:t1, B:t2}",
        "explanation": "Story s2 created for user B"
      },
      {
        "step": 3,
        "action": "getStoryRing(viewer_C)",
        "state": "Iterate followed [A,B]",
        "explanation": "Both A and B have stories, C hasn't viewed any, both marked hasUnviewed=true"
      },
      {
        "step": 4,
        "action": "markStoryViewed(C, s1)",
        "state": "bloom[s1].add(C), hll[s1].add(C), user_viewed[(C,A)]={s1}",
        "explanation": "C's view recorded in Bloom filter, HLL counter, and user-specific tracking"
      },
      {
        "step": 5,
        "action": "getStoryRing(viewer_C)",
        "state": "A's stories all viewed, B's not",
        "explanation": "A.hasUnviewed=false (C viewed s1), B.hasUnviewed=true. B appears first in sorted ring."
      }
    ],
    "final_output": "StoryRing with B (unviewed, 1 story) first, then A (viewed, 1 story)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Post story, immediately get story ring - should show poster",
      "Mark viewed, check ring - hasUnviewed should flip to false"
    ],
    "likely_bugs": [
      "Forgot to update users_with_stories on post",
      "Not cleaning up expired stories before ring check",
      "Wrong key format for user_viewed_stories tuple"
    ],
    "recommended_logs_or_asserts": [
      "assert story.expires_at == story.created_at + 24*3600",
      "log 'Story ring for user {user}: {len(entries)} entries'",
      "assert bloom filter not None after postStory"
    ],
    "how_to_localize": "1) Check if story was stored (print storiesByUser), 2) Check if users_with_stories updated, 3) Verify social graph has follow relationship, 4) Check Bloom filter exists and contains viewer"
  },
  "edge_cases": [
    {
      "case": "User views own story",
      "handling": "Allow and track - users want to see their view counts",
      "gotcha": "Should this count toward view metrics?"
    },
    {
      "case": "Story expired between postStory and markViewed",
      "handling": "Return false, don't update tracking",
      "gotcha": "Race condition if cleanup runs mid-operation"
    },
    {
      "case": "User unfollows after story posted",
      "handling": "Story ring excludes unfollowed users",
      "gotcha": "Don't show stories from non-followed even if previously viewed"
    },
    {
      "case": "Bloom filter false positive",
      "handling": "Show as 'viewed' even if not - acceptable UX trade-off",
      "gotcha": "~1% users might see ring incorrectly colored"
    },
    {
      "case": "User posts 100 stories in 24h",
      "handling": "All stored and shown in ring with count",
      "gotcha": "Story ring entry shows count, not individual stories"
    },
    {
      "case": "Clock skew between servers",
      "handling": "Use NTP sync, add grace period to TTL check",
      "gotcha": "Story might expire early/late by seconds"
    }
  ],
  "test_cases": [
    {
      "name": "Basic post and view",
      "input": "postStory(A, photo), markStoryViewed(B, storyA), getStoryViewers(storyA)",
      "expected": "[B]",
      "explanation": "Single viewer recorded in viewer list"
    },
    {
      "name": "Story ring ordering",
      "input": "Follow A,B. Post A at t1. Post B at t2>t1. View A's story. getStoryRing()",
      "expected": "Ring: [B (unviewed), A (viewed)]",
      "explanation": "Unviewed stories prioritized, then by recency"
    },
    {
      "name": "HyperLogLog accuracy",
      "input": "Post story. 1000 unique users view it. getStoryViewCount()",
      "expected": "~1000 (within 2%: 980-1020)",
      "explanation": "HLL provides approximate count with known error bounds"
    },
    {
      "name": "Bloom filter has viewed",
      "input": "Post story. markStoryViewed(viewer, story). hasUserViewedStory(viewer, story)",
      "expected": "true",
      "explanation": "Bloom filter returns true for items that were added"
    },
    {
      "name": "Empty story ring",
      "input": "User follows no one. getStoryRing(user)",
      "expected": "StoryRing with empty users list",
      "explanation": "No followed users = empty ring"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using HashSet instead of Bloom filter for view tracking",
      "why_wrong": "HashSet uses O(n) memory for n viewers. With billions of views, this is terabytes of RAM",
      "correct_approach": "Bloom filter uses ~1.2 bytes per expected item regardless of actual size",
      "code_example_wrong": "// Set<String> viewers = new HashSet<>();  // 32+ bytes per viewer",
      "code_example_correct": "// BloomFilter bloom = new BloomFilter(10000, 0.01);  // ~10KB fixed"
    },
    {
      "mistake": "Not handling story expiration on read",
      "why_wrong": "Expired stories appear in ring/feed, causing bad UX and incorrect data",
      "correct_approach": "Call cleanupExpiredStories() before reading user's stories",
      "code_example_wrong": "// return storiesByUser.get(userId).values();",
      "code_example_correct": "// cleanupExpiredStories(userId); return storiesByUser.get(userId).values();"
    },
    {
      "mistake": "Storing exact viewer count instead of HyperLogLog",
      "why_wrong": "Counting unique viewers requires dedup, which is O(viewers) space",
      "correct_approach": "HyperLogLog uses O(1) space and provides ~2% accurate count",
      "code_example_wrong": "// int count = new HashSet<>(viewerList).size();",
      "code_example_correct": "// int count = hyperLogLog.count();  // O(1) space"
    },
    {
      "mistake": "Checking hasUnviewed by querying each story's Bloom filter",
      "why_wrong": "For users with many stories, this is slow. Also Bloom filter can give false positives",
      "correct_approach": "Track per-(viewer, poster) set of viewed story IDs for accurate ring status",
      "code_example_wrong": "// stories.stream().anyMatch(s -> !bloom.mightContain(viewer))",
      "code_example_correct": "// viewedStories.get(viewer+poster).containsAll(storyIds)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by highlighting the key differences from Part 1: ephemeral content (TTL), high write volume (view tracking), and the story ring UI. Then explain the probabilistic data structures (Bloom filter, HLL) and why they're necessary at scale.",
    "what_to_mention": [
      "Cassandra TTL eliminates need for cleanup jobs",
      "Bloom filters trade 1% false positives for 10x memory savings",
      "HyperLogLog provides ~2% accurate counts in 12KB regardless of cardinality",
      "Story ring requires separate tracking from individual story views",
      "View events can be async/eventually consistent for performance"
    ],
    "time_allocation": "2 min requirements clarification, 5 min architecture explanation, 8 min implementation, 3 min edge cases and testing",
    "if_stuck": [
      "Think about what makes Stories different from Posts - the TTL aspect",
      "Consider the read vs write patterns - what's accessed frequently?",
      "How would you know if you've viewed something without storing every interaction?"
    ]
  },
  "connection_to_next_part": "Part 3 might add: Story Highlights (archiving stories beyond 24h), Story Replies/Reactions, Close Friends list filtering, or Story Mentions. The current design supports these by: 1) Archive service can subscribe to expiring stories, 2) Reactions can use similar Bloom filter approach, 3) Close friends is a filter on story visibility, 4) Mentions index can be built from story metadata.",
  "communication_script": {
    "transition_from_previous": "Part 1 handles persistent posts and feeds. For Part 2 Stories, the key difference is **ephemeral content** that auto-expires after 24 hours and **high-volume view tracking**. Let me explain my approach...",
    "explaining_changes": "The main additions are: 1) **TTL-based storage** using Cassandra for automatic expiration, 2) **Bloom filters** for efficient 'has viewed' checks without storing every viewer, 3) **HyperLogLog** for approximate view counts, and 4) **Story ring** as a derived data structure showing followed users with active stories.",
    "while_extending_code": [
      "I'm adding StoriesService as a separate class to maintain clean separation from the feed logic",
      "The Bloom filter here is key - it lets us check 'has user viewed story' in O(1) with only 1% false positive rate",
      "This TTL check simulates what Cassandra does automatically with TTL columns"
    ],
    "after_completing": "Stories now support posting with 24h expiration, the story ring shows followed users sorted by unviewed-first then recency, and view tracking handles billions of events efficiently with probabilistic data structures. All operations are O(1) or O(followed_users). Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Clarify: 24h exact TTL? Bloom filter FP rate acceptable? View count precision needs?",
    "by_5_min": "Explain architecture: Cassandra TTL, Bloom filter for views, HLL for counts, Redis sorted set for ring",
    "by_12_min": "Core implementation done: postStory, getStoryRing, markStoryViewed working",
    "by_18_min": "Edge cases handled, demo/tests passing, ready to discuss next part",
    "warning_signs": "If stuck on Bloom filter implementation at 10 min, mention you'd use a library and move on. Focus on the system design, not the DS implementation."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Stories service is independent of feed service. If Part 1 has issues, mention: 'The stories feature is a separate service with its own storage. It only depends on the social graph from Part 1.'",
    "if_new_requirement_unclear": "Ask: 'For the story ring, should users who posted most recently appear first, or users with unviewed stories?' 'Is a 1% false positive rate acceptable for view tracking?'",
    "if_running_behind": "Skip Bloom filter implementation details - say 'I'd use Guava's BloomFilter or Redis SETBIT'. Focus on explaining WHY probabilistic DS are needed at this scale."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Correctly identifying Cassandra TTL as the right solution for auto-expiration",
      "Explaining Bloom filter tradeoffs: false positives OK because 'viewed' status isn't critical",
      "Mentioning HyperLogLog for cardinality estimation without being asked",
      "Discussing eventual consistency for view analytics vs strong consistency for posting",
      "Separating 'has unviewed any story' (fast) from 'viewer list' (append-only log)"
    ]
  },
  "pattern_recognition": {
    "pattern": "Probabilistic Data Structures for High-Volume Event Tracking",
    "indicators": [
      "Billions of write events per day",
      "Memory constraints",
      "'has seen' type queries",
      "Approximate counts acceptable"
    ],
    "similar_problems": [
      "Unique visitor counting (HLL)",
      "Spam URL detection (Bloom filter)",
      "Database query planning (Count-Min Sketch)",
      "Duplicate detection in streams"
    ],
    "template": "When facing O(billions) membership/counting: 1) Consider Bloom filter for membership (accept FP), 2) Use HyperLogLog for cardinality, 3) Keep detailed logs async/eventually consistent"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "24h TTL requirement \u2192 Need automatic expiration \u2192 Cassandra TTL is perfect",
      "why": "Manual cleanup jobs are operationally complex and can miss items"
    },
    {
      "step": 2,
      "thought": "Billions of view events \u2192 Can't store every (viewer, story) pair \u2192 Need probabilistic DS",
      "why": "At 10B views/day, even 8 bytes per record = 80GB/day of storage"
    },
    {
      "step": 3,
      "thought": "Story ring needs 'has unviewed' per followed user \u2192 Can't check every story's Bloom filter",
      "why": "Bloom filter gives per-story info, but ring needs per-user aggregation"
    },
    {
      "step": 4,
      "thought": "Separate concerns: 'has viewed any' (fast) vs 'viewer list' (detailed)",
      "why": "Different access patterns: ring checked on every app open, viewer list only when poster checks analytics"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of ephemeral content challenges (TTL, cleanup)",
      "Knowledge of probabilistic data structures and when to use them",
      "Ability to handle high write volume architecturally",
      "Clean separation between Stories service and existing Feed service"
    ],
    "bonus_points": [
      "Mentioning Cassandra TTL without prompting",
      "Explaining false positive implications for UX",
      "Discussing async processing for view events",
      "Considering clock skew and distributed timing"
    ],
    "red_flags": [
      "Trying to use SQL database for billions of writes",
      "Storing exact viewer sets for every story",
      "Not considering the expiration mechanism",
      "Ignoring the scale requirements (500M stories/day)"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for Bloom filter/HLL boilerplate if library not available",
      "Let AI help with correct hash function implementation",
      "Ask AI for Cassandra CQL syntax for TTL"
    ],
    "what_not_to_do": [
      "Don't accept AI's naive solution (HashSet for viewers)",
      "Verify the Bloom filter sizing formula",
      "Understand the HyperLogLog algorithm before using"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not clarifying the 24h requirement precision",
      "Jumping into code without explaining architecture",
      "Ignoring the scale numbers (500M stories, billions of views)"
    ],
    "technical": [
      "Using relational DB for this write-heavy workload",
      "Storing exact viewer lists for every view event",
      "Not implementing any expiration mechanism",
      "Blocking on view writes instead of async processing"
    ],
    "communication": [
      "Not explaining why Bloom filters are appropriate here",
      "Failing to mention the tradeoffs (false positives)",
      "Not connecting back to Part 1 social graph"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "postStory returns unique ID and sets up TTL?",
      "getStoryRing shows followed users with stories, sorted correctly?",
      "markStoryViewed updates Bloom filter, HLL, and user-story tracking?",
      "Expired stories are cleaned up before queries?",
      "Ring correctly shows hasUnviewed=false after viewing all stories from a user?"
    ],
    "quick_code_review": [
      "BloomFilter and HyperLogLog implementations are correct",
      "TTL constant is 24*60*60 seconds",
      "Social graph reference is used (not copied)",
      "All storage maps initialized in constructor"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Redis Cluster for distributed Bloom filters",
      "Kafka for async view event processing",
      "CDN cache headers for story media (Cache-Control: max-age=86400)",
      "Metrics: story post rate, view latency, bloom filter FP rate",
      "Rate limiting on story posts (max N per hour)",
      "Background job to clean up orphaned tracking data"
    ],
    "why_not_in_interview": "Core algorithm and data structure choices are the focus. Infrastructure details are mentioned verbally.",
    "how_to_mention": "Say: 'In production, I'd use Redis Cluster for the Bloom filters to distribute memory across nodes, and Kafka to handle view events asynchronously to avoid blocking the user experience.'"
  },
  "generated_at": "2026-01-18T21:42:05.662491",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}