{
  "problem_title": "Design a Hotel Booking/Reservation System - Part 2: Handling Concurrent Bookings",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 1 focused on basic booking flow (search, view, book, manage). Part 2 dives into the **critical concurrency challenge**: ensuring exactly one booking succeeds when multiple users attempt to book the same room simultaneously. We must implement different locking strategies (pessimistic, optimistic, constraint-based) and handle distributed scenarios across multiple servers.",
    "new_requirements": [
      "Never double-book a room - only ONE booking succeeds for conflicting requests",
      "Handle exact same dates AND overlapping date conflicts",
      "Provide fair access during peak times (Black Friday, holidays)",
      "Minimize failed attempts and provide clear error messages",
      "Work correctly across distributed servers",
      "Support multiple locking strategies with tradeoffs"
    ],
    "new_constraints": [
      "Must handle thousands of concurrent booking attempts",
      "Lock timeout must be reasonable (2-5 seconds typically)",
      "Distributed locks must have TTL to prevent deadlocks",
      "Database constraints as ultimate source of truth",
      "Retry logic needed for optimistic locking"
    ],
    "key_insight": "**Defense in Depth**: Use distributed locks as an optimization to fail fast, but ALWAYS rely on database constraints as the final source of truth. The database is the single point of coordination that all servers must agree on."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Never double-book a room",
        "how_met": "Database UNIQUE/EXCLUDE constraint on (room_id, date) + additional locking layer",
        "gotchas": [
          "Race condition between check and insert without proper locking",
          "Distributed servers bypassing single-server locks"
        ]
      },
      {
        "requirement": "Handle overlapping dates",
        "how_met": "Book each individual date or use PostgreSQL EXCLUDE constraint with daterange type",
        "gotchas": [
          "Only checking start/end dates, not the full range",
          "Off-by-one errors with check-out date"
        ]
      },
      {
        "requirement": "Distributed coordination",
        "how_met": "Redis SETNX distributed lock + database constraint backup",
        "gotchas": [
          "Lock expiry too short causing double-booking",
          "Not releasing lock on failure paths"
        ]
      },
      {
        "requirement": "Fair access during peak times",
        "how_met": "FIFO queue for lock acquisition, reasonable timeouts",
        "gotchas": [
          "Starvation of some requests",
          "Lock convoy issues"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "createBookingWithLock (pessimistic)",
        "target": "O(d)",
        "achieved": "O(d)",
        "why": "d = number of days, must check/lock each date"
      },
      {
        "operation": "createBookingWithLock (optimistic)",
        "target": "O(d * r)",
        "achieved": "O(d * r)",
        "why": "r = retries on conflict, typically 1-3"
      },
      {
        "operation": "createBookingWithLock (constraint)",
        "target": "O(d)",
        "achieved": "O(d)",
        "why": "Single atomic DB operation, d dates inserted"
      },
      {
        "operation": "distributed lock acquire",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Redis SETNX is O(1)"
      }
    ],
    "non_goals": [
      "Implementing actual Redis/ZooKeeper (simulated)",
      "Payment processing integration",
      "Waitlist/queue for unavailable rooms",
      "Price negotiation or dynamic pricing"
    ]
  },
  "assumptions": [
    "Database supports atomic transactions with proper isolation levels (SERIALIZABLE or READ COMMITTED with FOR UPDATE)",
    "Distributed lock service (Redis) has higher availability than individual app servers",
    "Check-out date is exclusive (booking Jan 1-3 means nights of Jan 1 and Jan 2)",
    "Room inventory is finite and pre-loaded in database",
    "Network partitions are rare but must be handled gracefully"
  ],
  "tradeoffs": [
    {
      "decision": "Pessimistic vs Optimistic locking",
      "chosen": "Depends on contention level",
      "why": "Pessimistic for high-contention (popular rooms), Optimistic for low-contention (most rooms)",
      "alternative": "Always use one strategy",
      "when_to_switch": "Monitor conflict rate - if >10% conflicts, switch to pessimistic"
    },
    {
      "decision": "Per-date booking vs date-range booking",
      "chosen": "Per-date with UNIQUE constraint",
      "why": "Simpler constraint validation, easier to query availability",
      "alternative": "Date range with EXCLUDE constraint (PostgreSQL)",
      "when_to_switch": "If using PostgreSQL and need better performance for long stays"
    },
    {
      "decision": "Distributed lock + DB constraint vs DB constraint only",
      "chosen": "Both (defense in depth)",
      "why": "Distributed lock fails fast (no DB roundtrip), constraint catches edge cases",
      "alternative": "DB constraint only (simpler)",
      "when_to_switch": "If distributed lock service becomes a bottleneck"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "BookingRequest and BookingResponse interfaces",
      "LockStrategy enum (can add new strategies)",
      "Core invariant: database is source of truth"
    ],
    "what_to_change": [
      "Added LockStrategy parameter to booking method",
      "New DistributedLock interface for future implementations",
      "Retry configuration for optimistic locking"
    ],
    "interfaces_and_boundaries": "The DistributedLock interface allows swapping Redis for ZooKeeper or database advisory locks. BookingService is decoupled from specific lock implementation.",
    "invariants": [
      "A room-date combination has at most ONE confirmed booking",
      "Lock is ALWAYS released (even on exceptions) - use try/finally",
      "Database constraint violation always returns graceful error, never crashes"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  BEFORE (Part 1): Simple sequential booking                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  User A \u2500\u2500\u2500\u2500\u25b6 Check \u2500\u2500\u2500\u2500\u25b6 Book \u2500\u2500\u2500\u2500\u25b6 \u2705 Confirmed               \u2502\n\u2502                                                                  \u2502\n\u2502  (No concurrency consideration)                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  AFTER (Part 2): Concurrent booking with locking                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  User A \u2500\u2500\u252c\u2500\u2500\u25b6 [LOCK] \u2500\u2500\u25b6 Check \u2500\u2500\u25b6 Book \u2500\u2500\u25b6 [UNLOCK] \u2500\u2500\u25b6 \u2705    \u2502\n\u2502           \u2502                                                      \u2502\n\u2502  User B \u2500\u2500\u2534\u2500\u2500\u25b6 [WAIT...] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u274c Timeout  \u2502\n\u2502                                                                  \u2502\n\u2502  OR with database constraint:                                    \u2502\n\u2502                                                                  \u2502\n\u2502  User A \u2500\u2500\u252c\u2500\u2500\u25b6 INSERT (room, date) \u2500\u2500\u25b6 \u2705 Success               \u2502\n\u2502           \u2502                                                      \u2502\n\u2502  User B \u2500\u2500\u2534\u2500\u2500\u25b6 INSERT (room, date) \u2500\u2500\u25b6 \u274c UNIQUE VIOLATION      \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BOOKING FLOW WITH DISTRIBUTED LOCK                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Book Request   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                             \u25bc\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502  Layer 1: Distributed Lock (Redis)    \u2502\n         \u2502  SETNX room:101:2024-01-10            \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                             \u2502\n         [Acquired]                    [Failed]\n              \u2502                             \u2502\n              \u25bc                             \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Check Availability\u2502          \u2502  Return Error   \u2502\n    \u2502 (Fast, non-locking)\u2502         \u2502  \"Lock timeout\" \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                 \u2502\n[Available]      [Unavailable]\n    \u2502                 \u2502\n    \u25bc                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Layer 2: DB     \u2502  \u2502  Release Lock   \u2502\n\u2502 INSERT with     \u2502  \u2502  Return Error   \u2502\n\u2502 UNIQUE constraint\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         \u2502\n[Success]  [Constraint Violation]\n    \u2502         \u2502\n    \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 COMMIT  \u2502  \u2502 Race condition! \u2502\n\u2502 Release \u2502  \u2502 Someone else    \u2502\n\u2502 Lock    \u2502  \u2502 was faster      \u2502\n\u2502 \u2705      \u2502  \u2502 Return Error    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (Check-then-Book without Locking)",
      "description": "Simply check availability then insert booking without any locking mechanism",
      "time_complexity": "O(d)",
      "space_complexity": "O(1)",
      "why_not_optimal": "**RACE CONDITION**: Between checking availability and inserting booking, another request can book the same room. Classic TOCTOU (Time-of-check to time-of-use) bug. Two users can both see room as available and both create bookings."
    },
    {
      "name": "Pessimistic Locking (SELECT FOR UPDATE)",
      "description": "Acquire exclusive database lock on room rows before checking and booking. Other transactions must wait.",
      "time_complexity": "O(d) for booking, O(timeout) for waiting",
      "space_complexity": "O(1)",
      "why_not_optimal": "Blocks other transactions, doesn't scale well for popular rooms. Can cause lock convoy and reduced throughput. Good for high-contention scenarios."
    },
    {
      "name": "Optimistic Locking (Version Check)",
      "description": "Read version, process, then update only if version unchanged. No blocking during processing.",
      "time_complexity": "O(d * r) where r = retry count",
      "space_complexity": "O(1)",
      "why_not_optimal": "Wasted work on conflicts - all processing done before discovering conflict. Good for low-contention scenarios where conflicts are rare."
    },
    {
      "name": "Database Constraint (RECOMMENDED)",
      "description": "Use database UNIQUE/EXCLUDE constraint on (room_id, date). Let database handle concurrency atomically.",
      "time_complexity": "O(d)",
      "space_complexity": "O(d) for storing bookings",
      "key_insight": "Database is designed for this! Leverage ACID properties. Constraint violation is an expected business case, not an error. Combined with distributed lock for fail-fast optimization."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: **Defense in Depth**\n\nThe key insight is that **no single mechanism is perfect**, so we use **layered defenses**:\n\n### Layer 1: Distributed Lock (Redis SETNX)\n- **Purpose**: Fail fast without hitting the database\n- **Mechanism**: `SETNX room:{room_id}:{date_range}` with TTL\n- **Benefit**: Reduces database load during flash sales\n- **Limitation**: Can fail (network issues), so NOT the source of truth\n\n### Layer 2: Database Constraint\n- **Purpose**: Ultimate source of truth\n- **Mechanism**: `UNIQUE (room_id, booking_date)` or PostgreSQL `EXCLUDE USING gist`\n- **Benefit**: ACID guarantees, works even if distributed lock fails\n- **Handles**: The rare case where distributed lock expires mid-transaction\n\n### Strategy Selection:\n```\nIF high contention (popular room, flash sale):\n    Use PESSIMISTIC + CONSTRAINT\nELSE IF normal load:\n    Use DISTRIBUTED_LOCK + CONSTRAINT  \nELSE IF very low contention:\n    Use OPTIMISTIC + CONSTRAINT\n```\n\n### Critical Implementation Details:\n1. **Lock key granularity**: `room:{id}:{check_in}:{check_out}` for date-range locks\n2. **TTL for distributed lock**: 5-10 seconds (long enough for booking, short enough to recover)\n3. **Always release lock in finally block**: Even on exceptions\n4. **Handle constraint violation gracefully**: Return user-friendly error, not 500",
    "data_structures": [
      {
        "structure": "Redis SETNX",
        "purpose": "Distributed lock with atomic set-if-not-exists"
      },
      {
        "structure": "Database UNIQUE constraint",
        "purpose": "Prevent duplicate (room_id, date) pairs"
      },
      {
        "structure": "Version column",
        "purpose": "For optimistic locking - incremented on each change"
      },
      {
        "structure": "Retry queue",
        "purpose": "Failed bookings can be queued for retry (optional)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate request (dates, room exists)",
      "Step 2: Acquire distributed lock with timeout (SETNX key TTL)",
      "Step 3: If lock failed, return LOCK_TIMEOUT error immediately",
      "Step 4: Check room availability (fast read query)",
      "Step 5: If unavailable, release lock and return UNAVAILABLE error",
      "Step 6: Generate unique booking ID",
      "Step 7: INSERT booking with database constraint",
      "Step 8: If constraint violation (rare race), return ALREADY_BOOKED error",
      "Step 9: COMMIT transaction",
      "Step 10: Release distributed lock (finally block)",
      "Step 11: Return success with booking ID"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Part 2: Concurrent Booking Handling",
    "",
    "This module implements multiple locking strategies to prevent double-booking:",
    "1. Pessimistic Locking (SELECT FOR UPDATE)",
    "2. Optimistic Locking (Version check)",
    "3. Database Constraint (UNIQUE violation handling)",
    "4. Distributed Locking (Redis SETNX simulation)",
    "\"\"\"",
    "",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "from datetime import date, timedelta",
    "from typing import Dict, List, Optional, Set, Tuple, Callable",
    "from abc import ABC, abstractmethod",
    "import threading",
    "import time",
    "import uuid",
    "from contextlib import contextmanager",
    "",
    "",
    "# ============================================================================",
    "# ENUMS AND DATA CLASSES",
    "# ============================================================================",
    "",
    "class LockStrategy(Enum):",
    "    \"\"\"Available locking strategies for concurrent booking handling.\"\"\"",
    "    PESSIMISTIC = \"pessimistic\"   # SELECT FOR UPDATE - blocks other transactions",
    "    OPTIMISTIC = \"optimistic\"     # Version check - retry on conflict",
    "    CONSTRAINT = \"constraint\"     # Database UNIQUE constraint",
    "    DISTRIBUTED = \"distributed\"   # Redis lock + DB constraint",
    "",
    "",
    "class BookingStatus(Enum):",
    "    \"\"\"Status of a booking response.\"\"\"",
    "    CONFIRMED = \"CONFIRMED\"",
    "    FAILED = \"FAILED\"",
    "    PENDING = \"PENDING\"",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Request to create a booking.\"\"\"",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    ",
    "    def __post_init__(self):",
    "        if self.check_in >= self.check_out:",
    "            raise ValueError(\"Check-in must be before check-out\")",
    "    ",
    "    def get_date_range(self) -> List[date]:",
    "        \"\"\"Return list of dates covered by this booking (excluding checkout).\"\"\"",
    "        dates = []",
    "        current = self.check_in",
    "        while current < self.check_out:",
    "            dates.append(current)",
    "            current += timedelta(days=1)",
    "        return dates",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    \"\"\"Response from a booking attempt.\"\"\"",
    "    status: BookingStatus",
    "    booking_id: Optional[str] = None",
    "    error: Optional[str] = None",
    "    message: Optional[str] = None",
    "    retry_after_ms: Optional[int] = None  # For optimistic locking retries",
    "",
    "",
    "@dataclass",
    "class RoomBooking:",
    "    \"\"\"Internal representation of a confirmed booking.\"\"\"",
    "    booking_id: str",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    version: int = 1",
    "    created_at: float = field(default_factory=time.time)",
    "",
    "",
    "# ============================================================================",
    "# DISTRIBUTED LOCK INTERFACE AND IMPLEMENTATION",
    "# ============================================================================",
    "",
    "class DistributedLock(ABC):",
    "    \"\"\"Abstract interface for distributed locking.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def acquire(self, key: str, timeout_sec: float = 5.0) -> Optional[str]:",
    "        \"\"\"",
    "        Attempt to acquire a lock.",
    "        Returns lock_token if successful, None if timeout.",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def release(self, key: str, token: str) -> bool:",
    "        \"\"\"Release a lock. Token must match to prevent releasing others' locks.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def extend(self, key: str, token: str, additional_sec: float) -> bool:",
    "        \"\"\"Extend lock TTL if we still hold it.\"\"\"",
    "        pass",
    "",
    "",
    "class RedisDistributedLock(DistributedLock):",
    "    \"\"\"",
    "    Simulated Redis-based distributed lock using SETNX pattern.",
    "    ",
    "    In production, use redis-py with SET NX EX pattern:",
    "        redis.set(key, token, nx=True, ex=ttl_seconds)",
    "    \"\"\"",
    "    ",
    "    def __init__(self, default_ttl_sec: float = 10.0):",
    "        self._locks: Dict[str, Tuple[str, float]] = {}  # key -> (token, expiry_time)",
    "        self._mutex = threading.Lock()  # Simulates Redis atomicity",
    "        self._default_ttl = default_ttl_sec",
    "    ",
    "    def acquire(self, key: str, timeout_sec: float = 5.0) -> Optional[str]:",
    "        \"\"\"Try to acquire lock with timeout. Returns token or None.\"\"\"",
    "        token = str(uuid.uuid4())",
    "        expiry = time.time() + self._default_ttl",
    "        deadline = time.time() + timeout_sec",
    "        ",
    "        while time.time() < deadline:",
    "            with self._mutex:",
    "                # Clean up expired lock",
    "                if key in self._locks:",
    "                    _, lock_expiry = self._locks[key]",
    "                    if lock_expiry < time.time():",
    "                        del self._locks[key]",
    "                ",
    "                # SETNX: Set if Not eXists",
    "                if key not in self._locks:",
    "                    self._locks[key] = (token, expiry)",
    "                    return token",
    "            ",
    "            # Retry with exponential backoff",
    "            time.sleep(0.05)",
    "        ",
    "        return None  # Timeout",
    "    ",
    "    def release(self, key: str, token: str) -> bool:",
    "        \"\"\"Release lock only if we own it (token matches).\"\"\"",
    "        with self._mutex:",
    "            if key in self._locks:",
    "                stored_token, _ = self._locks[key]",
    "                if stored_token == token:",
    "                    del self._locks[key]",
    "                    return True",
    "        return False",
    "    ",
    "    def extend(self, key: str, token: str, additional_sec: float) -> bool:",
    "        \"\"\"Extend lock TTL if we still own it.\"\"\"",
    "        with self._mutex:",
    "            if key in self._locks:",
    "                stored_token, _ = self._locks[key]",
    "                if stored_token == token:",
    "                    self._locks[key] = (token, time.time() + additional_sec)",
    "                    return True",
    "        return False",
    "",
    "",
    "# ============================================================================",
    "# SIMULATED DATABASE WITH LOCKING SUPPORT",
    "# ============================================================================",
    "",
    "class RoomAvailabilityDatabase:",
    "    \"\"\"",
    "    Simulated database with support for:",
    "    - Row-level locking (pessimistic)",
    "    - Version tracking (optimistic)",
    "    - Unique constraints",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # room_id -> date -> booking_id (simulates room_availability table)",
    "        self._room_dates: Dict[str, Dict[date, str]] = {}",
    "        ",
    "        # room_id -> version (for optimistic locking)",
    "        self._room_versions: Dict[str, int] = {}",
    "        ",
    "        # Row-level locks (simulates SELECT FOR UPDATE)",
    "        self._row_locks: Dict[str, threading.RLock] = {}",
    "        ",
    "        # Global lock for atomic operations",
    "        self._global_lock = threading.Lock()",
    "        ",
    "        # All bookings for reference",
    "        self._bookings: Dict[str, RoomBooking] = {}",
    "    ",
    "    def _get_row_lock(self, room_id: str) -> threading.RLock:",
    "        \"\"\"Get or create a row-level lock for a room.\"\"\"",
    "        with self._global_lock:",
    "            if room_id not in self._row_locks:",
    "                self._row_locks[room_id] = threading.RLock()",
    "            return self._row_locks[room_id]",
    "    ",
    "    @contextmanager",
    "    def select_for_update(self, room_id: str, timeout_sec: float = 2.0):",
    "        \"\"\"",
    "        Simulates SELECT ... FOR UPDATE.",
    "        Acquires exclusive lock on room rows.",
    "        \"\"\"",
    "        lock = self._get_row_lock(room_id)",
    "        acquired = lock.acquire(timeout=timeout_sec)",
    "        if not acquired:",
    "            raise TimeoutError(f\"Could not acquire row lock for room {room_id}\")",
    "        try:",
    "            yield",
    "        finally:",
    "            lock.release()",
    "    ",
    "    def get_version(self, room_id: str) -> int:",
    "        \"\"\"Get current version for optimistic locking.\"\"\"",
    "        return self._room_versions.get(room_id, 0)",
    "    ",
    "    def is_available(self, room_id: str, dates: List[date]) -> bool:",
    "        \"\"\"Check if all dates are available for a room.\"\"\"",
    "        if room_id not in self._room_dates:",
    "            return True",
    "        room_bookings = self._room_dates[room_id]",
    "        return all(d not in room_bookings for d in dates)",
    "    ",
    "    def insert_booking_constraint(",
    "        self,",
    "        booking: RoomBooking",
    "    ) -> bool:",
    "        \"\"\"",
    "        Insert booking using UNIQUE constraint approach.",
    "        Returns False if constraint violation (date already booked).",
    "        \"\"\"",
    "        dates = []",
    "        current = booking.check_in",
    "        while current < booking.check_out:",
    "            dates.append(current)",
    "            current += timedelta(days=1)",
    "        ",
    "        with self._global_lock:",
    "            # Initialize room if needed",
    "            if booking.room_id not in self._room_dates:",
    "                self._room_dates[booking.room_id] = {}",
    "            ",
    "            # Check UNIQUE constraint",
    "            room_dates = self._room_dates[booking.room_id]",
    "            for d in dates:",
    "                if d in room_dates:",
    "                    return False  # Constraint violation",
    "            ",
    "            # Insert all dates atomically",
    "            for d in dates:",
    "                room_dates[d] = booking.booking_id",
    "            ",
    "            # Store booking",
    "            self._bookings[booking.booking_id] = booking",
    "            ",
    "            # Increment version",
    "            self._room_versions[booking.room_id] = \\",
    "                self._room_versions.get(booking.room_id, 0) + 1",
    "            ",
    "            return True",
    "    ",
    "    def update_with_version_check(",
    "        self,",
    "        booking: RoomBooking,",
    "        expected_version: int",
    "    ) -> bool:",
    "        \"\"\"",
    "        Optimistic locking: Only insert if version matches.",
    "        Returns False if version mismatch (someone else modified).",
    "        \"\"\"",
    "        with self._global_lock:",
    "            current_version = self._room_versions.get(booking.room_id, 0)",
    "            if current_version != expected_version:",
    "                return False  # Version conflict",
    "            ",
    "            return self.insert_booking_constraint(booking)",
    "",
    "",
    "# ============================================================================",
    "# BOOKING SERVICE WITH LOCKING STRATEGIES",
    "# ============================================================================",
    "",
    "class BookingService:",
    "    \"\"\"",
    "    Main service for handling hotel bookings with concurrency control.",
    "    ",
    "    Supports multiple locking strategies:",
    "    - PESSIMISTIC: SELECT FOR UPDATE (blocking)",
    "    - OPTIMISTIC: Version check with retry",
    "    - CONSTRAINT: Database UNIQUE constraint",
    "    - DISTRIBUTED: Redis lock + DB constraint (recommended)",
    "    \"\"\"",
    "    ",
    "    def __init__(",
    "        self,",
    "        db: RoomAvailabilityDatabase,",
    "        distributed_lock: Optional[DistributedLock] = None",
    "    ):",
    "        self._db = db",
    "        self._distributed_lock = distributed_lock or RedisDistributedLock()",
    "        self._strategy_handlers = {",
    "            LockStrategy.PESSIMISTIC: self._create_pessimistic,",
    "            LockStrategy.OPTIMISTIC: self._create_optimistic,",
    "            LockStrategy.CONSTRAINT: self._create_constraint,",
    "            LockStrategy.DISTRIBUTED: self._create_distributed,",
    "        }",
    "    ",
    "    def create_booking_with_lock(",
    "        self,",
    "        request: BookingRequest,",
    "        strategy: LockStrategy = LockStrategy.DISTRIBUTED",
    "    ) -> BookingResponse:",
    "        \"\"\"",
    "        Create a booking using the specified locking strategy.",
    "        ",
    "        Args:",
    "            request: Booking details (user, room, dates)",
    "            strategy: Locking strategy to use",
    "        ",
    "        Returns:",
    "            BookingResponse with status and booking_id or error",
    "        \"\"\"",
    "        handler = self._strategy_handlers.get(strategy)",
    "        if not handler:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error=\"INVALID_STRATEGY\",",
    "                message=f\"Unknown strategy: {strategy}\"",
    "            )",
    "        ",
    "        return handler(request)",
    "    ",
    "    def _generate_booking_id(self, user_id: str) -> str:",
    "        \"\"\"Generate unique booking ID.\"\"\"",
    "        return f\"BK_{user_id}_{uuid.uuid4().hex[:8]}\"",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    # PESSIMISTIC LOCKING",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    ",
    "    def _create_pessimistic(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Pessimistic locking using SELECT ... FOR UPDATE.",
    "        ",
    "        Flow:",
    "        1. BEGIN transaction",
    "        2. SELECT ... FOR UPDATE (blocks other transactions)",
    "        3. Check availability",
    "        4. INSERT booking",
    "        5. COMMIT (releases lock)",
    "        ",
    "        Pros: Simple, guaranteed consistency",
    "        Cons: Blocks other transactions, doesn't scale well",
    "        \"\"\"",
    "        try:",
    "            with self._db.select_for_update(request.room_id, timeout_sec=2.0):",
    "                # We have exclusive lock - check and book",
    "                dates = request.get_date_range()",
    "                ",
    "                if not self._db.is_available(request.room_id, dates):",
    "                    return BookingResponse(",
    "                        status=BookingStatus.FAILED,",
    "                        error=\"ROOM_UNAVAILABLE\",",
    "                        message=\"Room is already booked for selected dates\"",
    "                    )",
    "                ",
    "                booking = RoomBooking(",
    "                    booking_id=self._generate_booking_id(request.user_id),",
    "                    user_id=request.user_id,",
    "                    room_id=request.room_id,",
    "                    check_in=request.check_in,",
    "                    check_out=request.check_out",
    "                )",
    "                ",
    "                if self._db.insert_booking_constraint(booking):",
    "                    return BookingResponse(",
    "                        status=BookingStatus.CONFIRMED,",
    "                        booking_id=booking.booking_id",
    "                    )",
    "                else:",
    "                    # Should not happen with lock held",
    "                    return BookingResponse(",
    "                        status=BookingStatus.FAILED,",
    "                        error=\"INSERT_FAILED\",",
    "                        message=\"Unexpected insert failure\"",
    "                    )",
    "        ",
    "        except TimeoutError:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error=\"LOCK_TIMEOUT\",",
    "                message=\"Could not acquire lock within timeout\"",
    "            )",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    # OPTIMISTIC LOCKING",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    ",
    "    def _create_optimistic(",
    "        self,",
    "        request: BookingRequest,",
    "        max_retries: int = 3",
    "    ) -> BookingResponse:",
    "        \"\"\"",
    "        Optimistic locking using version check.",
    "        ",
    "        Flow:",
    "        1. SELECT room with version",
    "        2. Process (check availability, create booking object)",
    "        3. UPDATE WHERE version = original_version",
    "        4. If version mismatch, retry",
    "        ",
    "        Pros: Non-blocking, better throughput",
    "        Cons: Wasted work on conflict, retries needed",
    "        \"\"\"",
    "        dates = request.get_date_range()",
    "        ",
    "        for attempt in range(max_retries):",
    "            # Read current state (version)",
    "            version = self._db.get_version(request.room_id)",
    "            ",
    "            # Check availability (non-blocking read)",
    "            if not self._db.is_available(request.room_id, dates):",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error=\"ROOM_UNAVAILABLE\",",
    "                    message=\"Room is already booked for selected dates\"",
    "                )",
    "            ",
    "            # Create booking object",
    "            booking = RoomBooking(",
    "                booking_id=self._generate_booking_id(request.user_id),",
    "                user_id=request.user_id,",
    "                room_id=request.room_id,",
    "                check_in=request.check_in,",
    "                check_out=request.check_out,",
    "                version=version + 1",
    "            )",
    "            ",
    "            # Try to update with version check",
    "            if self._db.update_with_version_check(booking, version):",
    "                return BookingResponse(",
    "                    status=BookingStatus.CONFIRMED,",
    "                    booking_id=booking.booking_id",
    "                )",
    "            ",
    "            # Version conflict - exponential backoff and retry",
    "            backoff_ms = 50 * (2 ** attempt)  # 50ms, 100ms, 200ms",
    "            time.sleep(backoff_ms / 1000.0)",
    "        ",
    "        return BookingResponse(",
    "            status=BookingStatus.FAILED,",
    "            error=\"VERSION_CONFLICT\",",
    "            message=\"Resource was modified, please retry\",",
    "            retry_after_ms=1000",
    "        )",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    # DATABASE CONSTRAINT",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    ",
    "    def _create_constraint(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Database constraint approach.",
    "        ",
    "        Flow:",
    "        1. INSERT booking (or INSERT dates into availability table)",
    "        2. Database enforces UNIQUE constraint",
    "        3. Handle constraint violation as business logic",
    "        ",
    "        Pros: Simplest code, database handles concurrency",
    "        Cons: Must handle constraint violation gracefully",
    "        ",
    "        SQL Example:",
    "        INSERT INTO room_availability (room_id, date, booking_id)",
    "        VALUES ('R1', '2024-01-10', 'BK123'), ('R1', '2024-01-11', 'BK123');",
    "        -- UNIQUE(room_id, date) will fail if any date is taken",
    "        \"\"\"",
    "        booking = RoomBooking(",
    "            booking_id=self._generate_booking_id(request.user_id),",
    "            user_id=request.user_id,",
    "            room_id=request.room_id,",
    "            check_in=request.check_in,",
    "            check_out=request.check_out",
    "        )",
    "        ",
    "        if self._db.insert_booking_constraint(booking):",
    "            return BookingResponse(",
    "                status=BookingStatus.CONFIRMED,",
    "                booking_id=booking.booking_id",
    "            )",
    "        else:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error=\"CONSTRAINT_VIOLATION\",",
    "                message=\"Room already booked for these dates\"",
    "            )",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    # DISTRIBUTED LOCKING (RECOMMENDED)",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    ",
    "    def _create_distributed(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Defense in depth: Distributed lock + Database constraint.",
    "        ",
    "        Flow:",
    "        1. Acquire distributed lock (fail fast if can't)",
    "        2. Check availability (optional optimization)",
    "        3. INSERT with constraint (source of truth)",
    "        4. Release distributed lock (ALWAYS, even on failure)",
    "        ",
    "        Why both?",
    "        - Distributed lock: Reduces DB load, fails fast",
    "        - DB constraint: Catches edge cases (lock expired, network issues)",
    "        \"\"\"",
    "        # Create lock key for this room and date range",
    "        lock_key = f\"booking:room:{request.room_id}:{request.check_in}:{request.check_out}\"",
    "        ",
    "        # Layer 1: Distributed lock",
    "        token = self._distributed_lock.acquire(lock_key, timeout_sec=3.0)",
    "        if not token:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error=\"DISTRIBUTED_LOCK_TIMEOUT\",",
    "                message=\"High demand - please try again shortly\",",
    "                retry_after_ms=2000",
    "            )",
    "        ",
    "        try:",
    "            # Optional: Check availability first (avoid DB write if unavailable)",
    "            dates = request.get_date_range()",
    "            if not self._db.is_available(request.room_id, dates):",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error=\"ROOM_UNAVAILABLE\",",
    "                    message=\"Room is already booked for selected dates\"",
    "                )",
    "            ",
    "            # Layer 2: Database constraint (source of truth)",
    "            return self._create_constraint(request)",
    "        ",
    "        finally:",
    "            # ALWAYS release the lock",
    "            self._distributed_lock.release(lock_key, token)",
    "",
    "",
    "# ============================================================================",
    "# CONCURRENT BOOKING SIMULATOR",
    "# ============================================================================",
    "",
    "class ConcurrentBookingSimulator:",
    "    \"\"\"Simulates concurrent booking scenarios for testing.\"\"\"",
    "    ",
    "    def __init__(self, service: BookingService):",
    "        self._service = service",
    "        self._results: Dict[str, BookingResponse] = {}",
    "        self._lock = threading.Lock()",
    "    ",
    "    def _book_worker(",
    "        self,",
    "        request: BookingRequest,",
    "        strategy: LockStrategy,",
    "        result_key: str",
    "    ):",
    "        \"\"\"Worker thread for concurrent booking.\"\"\"",
    "        response = self._service.create_booking_with_lock(request, strategy)",
    "        with self._lock:",
    "            self._results[result_key] = response",
    "    ",
    "    def simulate_concurrent_bookings(",
    "        self,",
    "        requests: List[Tuple[BookingRequest, LockStrategy]],",
    "        delay_between_ms: int = 0",
    "    ) -> Dict[str, BookingResponse]:",
    "        \"\"\"",
    "        Simulate multiple concurrent booking attempts.",
    "        \"\"\"",
    "        self._results = {}",
    "        threads = []",
    "        ",
    "        for i, (request, strategy) in enumerate(requests):",
    "            result_key = f\"{request.user_id}_{i}\"",
    "            t = threading.Thread(",
    "                target=self._book_worker,",
    "                args=(request, strategy, result_key)",
    "            )",
    "            threads.append(t)",
    "        ",
    "        # Start all threads nearly simultaneously",
    "        for t in threads:",
    "            t.start()",
    "            if delay_between_ms > 0:",
    "                time.sleep(delay_between_ms / 1000.0)",
    "        ",
    "        # Wait for all to complete",
    "        for t in threads:",
    "            t.join()",
    "        ",
    "        return self._results",
    "",
    "",
    "# ============================================================================",
    "# DEMONSTRATION",
    "# ============================================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate concurrent booking handling with different strategies.\"\"\"",
    "    ",
    "    print(\"=\" * 70)",
    "    print(\"HOTEL BOOKING SYSTEM - PART 2: CONCURRENT BOOKING HANDLING\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Setup",
    "    db = RoomAvailabilityDatabase()",
    "    distributed_lock = RedisDistributedLock(default_ttl_sec=10.0)",
    "    service = BookingService(db, distributed_lock)",
    "    simulator = ConcurrentBookingSimulator(service)",
    "    ",
    "    # Test dates",
    "    check_in = date(2024, 1, 10)",
    "    check_out = date(2024, 1, 13)  # 3 nights",
    "    ",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 1: Pessimistic Locking (same room, same dates)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    requests = [",
    "        (BookingRequest(\"UserA\", \"Room101\", check_in, check_out), LockStrategy.PESSIMISTIC),",
    "        (BookingRequest(\"UserB\", \"Room101\", check_in, check_out), LockStrategy.PESSIMISTIC),",
    "    ]",
    "    ",
    "    results = simulator.simulate_concurrent_bookings(requests)",
    "    for key, response in results.items():",
    "        print(f\"  {key}: {response.status.value}\")",
    "        if response.booking_id:",
    "            print(f\"          Booking ID: {response.booking_id}\")",
    "        if response.error:",
    "            print(f\"          Error: {response.error} - {response.message}\")",
    "    ",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 2: Optimistic Locking (same room, same dates)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    requests = [",
    "        (BookingRequest(\"UserX\", \"Room202\", check_in, check_out), LockStrategy.OPTIMISTIC),",
    "        (BookingRequest(\"UserY\", \"Room202\", check_in, check_out), LockStrategy.OPTIMISTIC),",
    "    ]",
    "    ",
    "    results = simulator.simulate_concurrent_bookings(requests)",
    "    for key, response in results.items():",
    "        print(f\"  {key}: {response.status.value}\")",
    "        if response.booking_id:",
    "            print(f\"          Booking ID: {response.booking_id}\")",
    "        if response.error:",
    "            print(f\"          Error: {response.error} - {response.message}\")",
    "    ",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 3: Database Constraint (overlapping dates)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # UserP books Jan 10-13, UserQ tries Jan 12-15 (overlaps on 12)",
    "    overlap_out = date(2024, 1, 15)",
    "    overlap_in = date(2024, 1, 12)",
    "    ",
    "    requests = [",
    "        (BookingRequest(\"UserP\", \"Room303\", check_in, check_out), LockStrategy.CONSTRAINT),",
    "        (BookingRequest(\"UserQ\", \"Room303\", overlap_in, overlap_out), LockStrategy.CONSTRAINT),",
    "    ]",
    "    ",
    "    results = simulator.simulate_concurrent_bookings(requests, delay_between_ms=10)",
    "    for key, response in results.items():",
    "        user = key.split('_')[0]",
    "        print(f\"  {user}: {response.status.value}\")",
    "        if response.booking_id:",
    "            print(f\"          Booking ID: {response.booking_id}\")",
    "        if response.error:",
    "            print(f\"          Error: {response.error} - {response.message}\")",
    "    ",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 4: Distributed Lock + Constraint (recommended)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    requests = [",
    "        (BookingRequest(\"UserM\", \"Room404\", check_in, check_out), LockStrategy.DISTRIBUTED),",
    "        (BookingRequest(\"UserN\", \"Room404\", check_in, check_out), LockStrategy.DISTRIBUTED),",
    "        (BookingRequest(\"UserO\", \"Room404\", check_in, check_out), LockStrategy.DISTRIBUTED),",
    "    ]",
    "    ",
    "    results = simulator.simulate_concurrent_bookings(requests)",
    "    confirmed = 0",
    "    for key, response in results.items():",
    "        user = key.split('_')[0]",
    "        print(f\"  {user}: {response.status.value}\")",
    "        if response.status == BookingStatus.CONFIRMED:",
    "            confirmed += 1",
    "            print(f\"          Booking ID: {response.booking_id}\")",
    "        if response.error:",
    "            print(f\"          Error: {response.error}\")",
    "    ",
    "    print(f\"\\n  RESULT: Exactly {confirmed} booking confirmed (expected: 1)\")",
    "    ",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"SCENARIO 5: Sequential booking (no conflict)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    different_room = BookingRequest(\"UserZ\", \"Room505\", check_in, check_out)",
    "    response = service.create_booking_with_lock(different_room, LockStrategy.DISTRIBUTED)",
    "    print(f\"  UserZ booking Room505: {response.status.value}\")",
    "    print(f\"          Booking ID: {response.booking_id}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"STRATEGY COMPARISON SUMMARY\")",
    "    print(\"=\" * 70)",
    "    print(\"\"\"",
    "    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510",
    "    \u2502 Strategy        \u2502 Best For                                           \u2502",
    "    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524",
    "    \u2502 PESSIMISTIC     \u2502 High contention (flash sales, popular rooms)       \u2502",
    "    \u2502                 \u2502 \u2713 Guaranteed consistency                           \u2502",
    "    \u2502                 \u2502 \u2717 Blocks other transactions                        \u2502",
    "    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524",
    "    \u2502 OPTIMISTIC      \u2502 Low contention (rare conflicts)                    \u2502",
    "    \u2502                 \u2502 \u2713 Non-blocking, high throughput                    \u2502",
    "    \u2502                 \u2502 \u2717 Wasted work on conflicts, needs retry            \u2502",
    "    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524",
    "    \u2502 CONSTRAINT      \u2502 Simple implementation                              \u2502",
    "    \u2502                 \u2502 \u2713 Database handles concurrency                     \u2502",
    "    \u2502                 \u2502 \u2717 More DB load, constraint violations are slow     \u2502",
    "    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524",
    "    \u2502 DISTRIBUTED     \u2502 Production systems (RECOMMENDED)                   \u2502",
    "    \u2502                 \u2502 \u2713 Fail fast + DB as source of truth                \u2502",
    "    \u2502                 \u2502 \u2713 Works across multiple servers                    \u2502",
    "    \u2502                 \u2502 \u2717 Additional Redis infrastructure needed           \u2502",
    "    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "    \"\"\")",
    "    ",
    "    print(\"\\n\u2705 All scenarios completed successfully!\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.time.LocalDate;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.locks.*;",
    "import java.util.function.Supplier;",
    "",
    "/**",
    " * Hotel Booking System - Part 2: Concurrent Booking Handling",
    " * ",
    " * Implements multiple locking strategies to prevent double-booking:",
    " * 1. Pessimistic Locking (SELECT FOR UPDATE simulation)",
    " * 2. Optimistic Locking (Version check)",
    " * 3. Database Constraint (UNIQUE violation handling)",
    " * 4. Distributed Locking (Redis SETNX simulation)",
    " */",
    "public class HotelBookingConcurrency {",
    "",
    "    // ========================================================================",
    "    // ENUMS AND DATA CLASSES",
    "    // ========================================================================",
    "",
    "    public enum LockStrategy {",
    "        PESSIMISTIC,   // SELECT FOR UPDATE - blocks other transactions",
    "        OPTIMISTIC,    // Version check with retry",
    "        CONSTRAINT,    // Database UNIQUE constraint",
    "        DISTRIBUTED    // Redis lock + DB constraint (recommended)",
    "    }",
    "",
    "    public enum BookingStatus {",
    "        CONFIRMED, FAILED, PENDING",
    "    }",
    "",
    "    public static class BookingRequest {",
    "        public final String userId;",
    "        public final String roomId;",
    "        public final LocalDate checkIn;",
    "        public final LocalDate checkOut;",
    "",
    "        public BookingRequest(String userId, String roomId, LocalDate checkIn, LocalDate checkOut) {",
    "            if (!checkIn.isBefore(checkOut)) {",
    "                throw new IllegalArgumentException(\"Check-in must be before check-out\");",
    "            }",
    "            this.userId = userId;",
    "            this.roomId = roomId;",
    "            this.checkIn = checkIn;",
    "            this.checkOut = checkOut;",
    "        }",
    "",
    "        public List<LocalDate> getDateRange() {",
    "            List<LocalDate> dates = new ArrayList<>();",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                dates.add(current);",
    "                current = current.plusDays(1);",
    "            }",
    "            return dates;",
    "        }",
    "    }",
    "",
    "    public static class BookingResponse {",
    "        public final BookingStatus status;",
    "        public final String bookingId;",
    "        public final String error;",
    "        public final String message;",
    "",
    "        private BookingResponse(BookingStatus status, String bookingId, String error, String message) {",
    "            this.status = status;",
    "            this.bookingId = bookingId;",
    "            this.error = error;",
    "            this.message = message;",
    "        }",
    "",
    "        public static BookingResponse success(String bookingId) {",
    "            return new BookingResponse(BookingStatus.CONFIRMED, bookingId, null, null);",
    "        }",
    "",
    "        public static BookingResponse failure(String error, String message) {",
    "            return new BookingResponse(BookingStatus.FAILED, null, error, message);",
    "        }",
    "",
    "        @Override",
    "        public String toString() {",
    "            if (status == BookingStatus.CONFIRMED) {",
    "                return String.format(\"CONFIRMED [%s]\", bookingId);",
    "            }",
    "            return String.format(\"FAILED [%s: %s]\", error, message);",
    "        }",
    "    }",
    "",
    "    public static class RoomBooking {",
    "        public final String bookingId;",
    "        public final String userId;",
    "        public final String roomId;",
    "        public final LocalDate checkIn;",
    "        public final LocalDate checkOut;",
    "        public final int version;",
    "",
    "        public RoomBooking(String bookingId, String userId, String roomId,",
    "                           LocalDate checkIn, LocalDate checkOut, int version) {",
    "            this.bookingId = bookingId;",
    "            this.userId = userId;",
    "            this.roomId = roomId;",
    "            this.checkIn = checkIn;",
    "            this.checkOut = checkOut;",
    "            this.version = version;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // DISTRIBUTED LOCK (REDIS SIMULATION)",
    "    // ========================================================================",
    "",
    "    public interface DistributedLock {",
    "        String acquire(String key, long timeoutMs);",
    "        boolean release(String key, String token);",
    "    }",
    "",
    "    public static class RedisDistributedLock implements DistributedLock {",
    "        private final ConcurrentHashMap<String, LockEntry> locks = new ConcurrentHashMap<>();",
    "        private final long defaultTtlMs;",
    "",
    "        private static class LockEntry {",
    "            final String token;",
    "            final long expiryTime;",
    "",
    "            LockEntry(String token, long expiryTime) {",
    "                this.token = token;",
    "                this.expiryTime = expiryTime;",
    "            }",
    "        }",
    "",
    "        public RedisDistributedLock(long defaultTtlMs) {",
    "            this.defaultTtlMs = defaultTtlMs;",
    "        }",
    "",
    "        @Override",
    "        public synchronized String acquire(String key, long timeoutMs) {",
    "            String token = UUID.randomUUID().toString();",
    "            long deadline = System.currentTimeMillis() + timeoutMs;",
    "",
    "            while (System.currentTimeMillis() < deadline) {",
    "                // Clean expired lock",
    "                LockEntry existing = locks.get(key);",
    "                if (existing != null && existing.expiryTime < System.currentTimeMillis()) {",
    "                    locks.remove(key);",
    "                }",
    "",
    "                // SETNX simulation",
    "                if (!locks.containsKey(key)) {",
    "                    locks.put(key, new LockEntry(token, System.currentTimeMillis() + defaultTtlMs));",
    "                    return token;",
    "                }",
    "",
    "                try {",
    "                    Thread.sleep(50);",
    "                } catch (InterruptedException e) {",
    "                    Thread.currentThread().interrupt();",
    "                    return null;",
    "                }",
    "            }",
    "            return null;",
    "        }",
    "",
    "        @Override",
    "        public synchronized boolean release(String key, String token) {",
    "            LockEntry entry = locks.get(key);",
    "            if (entry != null && entry.token.equals(token)) {",
    "                locks.remove(key);",
    "                return true;",
    "            }",
    "            return false;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // DATABASE SIMULATION",
    "    // ========================================================================",
    "",
    "    public static class RoomAvailabilityDatabase {",
    "        private final ConcurrentHashMap<String, ConcurrentHashMap<LocalDate, String>> roomDates",
    "            = new ConcurrentHashMap<>();",
    "        private final ConcurrentHashMap<String, Integer> roomVersions = new ConcurrentHashMap<>();",
    "        private final ConcurrentHashMap<String, ReentrantLock> rowLocks = new ConcurrentHashMap<>();",
    "        private final Object globalLock = new Object();",
    "",
    "        public ReentrantLock getRowLock(String roomId) {",
    "            return rowLocks.computeIfAbsent(roomId, k -> new ReentrantLock());",
    "        }",
    "",
    "        public int getVersion(String roomId) {",
    "            return roomVersions.getOrDefault(roomId, 0);",
    "        }",
    "",
    "        public boolean isAvailable(String roomId, List<LocalDate> dates) {",
    "            ConcurrentHashMap<LocalDate, String> bookings = roomDates.get(roomId);",
    "            if (bookings == null) return true;",
    "            return dates.stream().noneMatch(bookings::containsKey);",
    "        }",
    "",
    "        public synchronized boolean insertBookingConstraint(RoomBooking booking) {",
    "            ConcurrentHashMap<LocalDate, String> bookings = ",
    "                roomDates.computeIfAbsent(booking.roomId, k -> new ConcurrentHashMap<>());",
    "",
    "            LocalDate current = booking.checkIn;",
    "            while (current.isBefore(booking.checkOut)) {",
    "                if (bookings.containsKey(current)) {",
    "                    return false; // Constraint violation",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "",
    "            current = booking.checkIn;",
    "            while (current.isBefore(booking.checkOut)) {",
    "                bookings.put(current, booking.bookingId);",
    "                current = current.plusDays(1);",
    "            }",
    "",
    "            roomVersions.merge(booking.roomId, 1, Integer::sum);",
    "            return true;",
    "        }",
    "",
    "        public synchronized boolean updateWithVersionCheck(RoomBooking booking, int expectedVersion) {",
    "            int currentVersion = roomVersions.getOrDefault(booking.roomId, 0);",
    "            if (currentVersion != expectedVersion) {",
    "                return false;",
    "            }",
    "            return insertBookingConstraint(booking);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // BOOKING SERVICE",
    "    // ========================================================================",
    "",
    "    public static class BookingService {",
    "        private final RoomAvailabilityDatabase db;",
    "        private final DistributedLock distributedLock;",
    "",
    "        public BookingService(RoomAvailabilityDatabase db, DistributedLock distributedLock) {",
    "            this.db = db;",
    "            this.distributedLock = distributedLock;",
    "        }",
    "",
    "        public BookingResponse createBookingWithLock(BookingRequest request, LockStrategy strategy) {",
    "            switch (strategy) {",
    "                case PESSIMISTIC: return createPessimistic(request);",
    "                case OPTIMISTIC: return createOptimistic(request);",
    "                case CONSTRAINT: return createConstraint(request);",
    "                case DISTRIBUTED: return createDistributed(request);",
    "                default: return BookingResponse.failure(\"INVALID_STRATEGY\", \"Unknown strategy\");",
    "            }",
    "        }",
    "",
    "        private String generateBookingId(String userId) {",
    "            return \"BK_\" + userId + \"_\" + UUID.randomUUID().toString().substring(0, 8);",
    "        }",
    "",
    "        private BookingResponse createPessimistic(BookingRequest request) {",
    "            ReentrantLock lock = db.getRowLock(request.roomId);",
    "            try {",
    "                if (!lock.tryLock(2, TimeUnit.SECONDS)) {",
    "                    return BookingResponse.failure(\"LOCK_TIMEOUT\", ",
    "                        \"Could not acquire lock within timeout\");",
    "                }",
    "                try {",
    "                    if (!db.isAvailable(request.roomId, request.getDateRange())) {",
    "                        return BookingResponse.failure(\"ROOM_UNAVAILABLE\", ",
    "                            \"Room is already booked\");",
    "                    }",
    "                    RoomBooking booking = new RoomBooking(",
    "                        generateBookingId(request.userId), request.userId, request.roomId,",
    "                        request.checkIn, request.checkOut, 1);",
    "                    if (db.insertBookingConstraint(booking)) {",
    "                        return BookingResponse.success(booking.bookingId);",
    "                    }",
    "                    return BookingResponse.failure(\"INSERT_FAILED\", \"Unexpected failure\");",
    "                } finally {",
    "                    lock.unlock();",
    "                }",
    "            } catch (InterruptedException e) {",
    "                Thread.currentThread().interrupt();",
    "                return BookingResponse.failure(\"INTERRUPTED\", \"Operation interrupted\");",
    "            }",
    "        }",
    "",
    "        private BookingResponse createOptimistic(BookingRequest request) {",
    "            int maxRetries = 3;",
    "            for (int attempt = 0; attempt < maxRetries; attempt++) {",
    "                int version = db.getVersion(request.roomId);",
    "                if (!db.isAvailable(request.roomId, request.getDateRange())) {",
    "                    return BookingResponse.failure(\"ROOM_UNAVAILABLE\", \"Room is already booked\");",
    "                }",
    "                RoomBooking booking = new RoomBooking(",
    "                    generateBookingId(request.userId), request.userId, request.roomId,",
    "                    request.checkIn, request.checkOut, version + 1);",
    "                if (db.updateWithVersionCheck(booking, version)) {",
    "                    return BookingResponse.success(booking.bookingId);",
    "                }",
    "                try {",
    "                    Thread.sleep(50L * (1L << attempt));",
    "                } catch (InterruptedException e) {",
    "                    Thread.currentThread().interrupt();",
    "                    return BookingResponse.failure(\"INTERRUPTED\", \"Operation interrupted\");",
    "                }",
    "            }",
    "            return BookingResponse.failure(\"VERSION_CONFLICT\", \"Resource was modified, please retry\");",
    "        }",
    "",
    "        private BookingResponse createConstraint(BookingRequest request) {",
    "            RoomBooking booking = new RoomBooking(",
    "                generateBookingId(request.userId), request.userId, request.roomId,",
    "                request.checkIn, request.checkOut, 1);",
    "            if (db.insertBookingConstraint(booking)) {",
    "                return BookingResponse.success(booking.bookingId);",
    "            }",
    "            return BookingResponse.failure(\"CONSTRAINT_VIOLATION\", \"Room already booked for these dates\");",
    "        }",
    "",
    "        private BookingResponse createDistributed(BookingRequest request) {",
    "            String lockKey = String.format(\"booking:room:%s:%s:%s\", ",
    "                request.roomId, request.checkIn, request.checkOut);",
    "            String token = distributedLock.acquire(lockKey, 3000);",
    "            if (token == null) {",
    "                return BookingResponse.failure(\"DISTRIBUTED_LOCK_TIMEOUT\", ",
    "                    \"High demand - please try again\");",
    "            }",
    "            try {",
    "                if (!db.isAvailable(request.roomId, request.getDateRange())) {",
    "                    return BookingResponse.failure(\"ROOM_UNAVAILABLE\", \"Room is already booked\");",
    "                }",
    "                return createConstraint(request);",
    "            } finally {",
    "                distributedLock.release(lockKey, token);",
    "            }",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN DEMO",
    "    // ========================================================================",
    "",
    "    public static void main(String[] args) throws Exception {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"HOTEL BOOKING SYSTEM - PART 2: CONCURRENT BOOKING HANDLING\");",
    "        System.out.println(\"=\".repeat(70));",
    "",
    "        RoomAvailabilityDatabase db = new RoomAvailabilityDatabase();",
    "        DistributedLock distLock = new RedisDistributedLock(10000);",
    "        BookingService service = new BookingService(db, distLock);",
    "        ExecutorService executor = Executors.newFixedThreadPool(10);",
    "",
    "        LocalDate checkIn = LocalDate.of(2024, 1, 10);",
    "        LocalDate checkOut = LocalDate.of(2024, 1, 13);",
    "",
    "        System.out.println(\"\\nSCENARIO: Distributed Lock (3 users, same room)\");",
    "        System.out.println(\"-\".repeat(50));",
    "",
    "        List<Future<BookingResponse>> futures = new ArrayList<>();",
    "        String[] users = {\"UserA\", \"UserB\", \"UserC\"};",
    "        ",
    "        for (String user : users) {",
    "            BookingRequest req = new BookingRequest(user, \"Room101\", checkIn, checkOut);",
    "            futures.add(executor.submit(() -> ",
    "                service.createBookingWithLock(req, LockStrategy.DISTRIBUTED)));",
    "        }",
    "",
    "        int confirmed = 0;",
    "        for (int i = 0; i < futures.size(); i++) {",
    "            BookingResponse resp = futures.get(i).get();",
    "            System.out.printf(\"  %s: %s%n\", users[i], resp);",
    "            if (resp.status == BookingStatus.CONFIRMED) confirmed++;",
    "        }",
    "",
    "        System.out.printf(\"%n  RESULT: Exactly %d booking confirmed (expected: 1)%n\", confirmed);",
    "",
    "        executor.shutdown();",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"All scenarios completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-18",
      "explanation": "Module docstring and imports. We use threading for simulating concurrency, uuid for unique IDs, and ABC for abstract interfaces."
    },
    {
      "lines": "24-36",
      "explanation": "LockStrategy enum defines the four locking approaches. Each has different tradeoffs for throughput vs consistency."
    },
    {
      "lines": "45-69",
      "explanation": "BookingRequest with validation. get_date_range() expands check_in to check_out into individual dates for per-date locking."
    },
    {
      "lines": "72-101",
      "explanation": "DistributedLock interface and RedisDistributedLock implementation. Uses SETNX pattern with TTL for lock expiry."
    },
    {
      "lines": "137-195",
      "explanation": "RoomAvailabilityDatabase simulates a database with row locks, version tracking, and unique constraints."
    },
    {
      "lines": "200-270",
      "explanation": "BookingService._create_pessimistic uses SELECT FOR UPDATE pattern. Acquires exclusive lock, checks availability, inserts booking."
    },
    {
      "lines": "275-320",
      "explanation": "BookingService._create_optimistic reads version, processes, then updates only if version unchanged. Includes exponential backoff retry."
    },
    {
      "lines": "325-355",
      "explanation": "BookingService._create_constraint lets database handle concurrency. Simplest code, constraint violation is business logic."
    },
    {
      "lines": "360-400",
      "explanation": "BookingService._create_distributed combines Redis lock (fail fast) with DB constraint (source of truth). ALWAYS releases lock in finally."
    },
    {
      "lines": "405-480",
      "explanation": "ConcurrentBookingSimulator creates multiple threads to simulate concurrent bookings. Demonstrates race conditions and resolution."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "createBookingWithLock (pessimistic)": {
          "complexity": "O(d + timeout)",
          "explanation": "d = number of days to book. May block up to timeout waiting for lock."
        },
        "createBookingWithLock (optimistic)": {
          "complexity": "O(d * r)",
          "explanation": "d = days, r = retry count (typically 1-3). Each retry reprocesses all dates."
        },
        "createBookingWithLock (constraint)": {
          "complexity": "O(d)",
          "explanation": "d = days. Single atomic DB operation."
        },
        "createBookingWithLock (distributed)": {
          "complexity": "O(d + lock_timeout)",
          "explanation": "Distributed lock acquisition plus d dates to check and insert."
        }
      },
      "overall_change": "Lock acquisition adds constant or timeout-bounded overhead. Core booking logic remains O(d)."
    },
    "space": {
      "additional_space": "O(1) per request, O(total_bookings * d) for storage",
      "explanation": "Each request uses constant space during processing. Database stores each booked date as a row."
    }
  },
  "dry_run": {
    "example_input": "User A and User B simultaneously try to book Room 101 for Jan 10-12 using DISTRIBUTED strategy",
    "steps": [
      {
        "step": 1,
        "action": "User A calls createBookingWithLock",
        "state": "locks={}, room_dates={}",
        "explanation": "Starting state - no locks, no bookings"
      },
      {
        "step": 2,
        "action": "User A acquires distributed lock",
        "state": "locks={room:101:Jan10:Jan12: tokenA}",
        "explanation": "SETNX succeeds, A holds lock"
      },
      {
        "step": 3,
        "action": "User B calls createBookingWithLock",
        "state": "B waiting for lock",
        "explanation": "SETNX fails, B retries in loop"
      },
      {
        "step": 4,
        "action": "User A checks availability",
        "state": "room_dates[101] = {}",
        "explanation": "No dates booked, available"
      },
      {
        "step": 5,
        "action": "User A inserts booking",
        "state": "room_dates[101] = {Jan10: BK_A, Jan11: BK_A}",
        "explanation": "Constraint check passes, dates inserted"
      },
      {
        "step": 6,
        "action": "User A releases lock",
        "state": "locks={}",
        "explanation": "Lock released in finally block"
      },
      {
        "step": 7,
        "action": "User B acquires distributed lock",
        "state": "locks={room:101:Jan10:Jan12: tokenB}",
        "explanation": "B finally gets lock after A releases"
      },
      {
        "step": 8,
        "action": "User B checks availability",
        "state": "Jan10, Jan11 are taken",
        "explanation": "Dates no longer available"
      },
      {
        "step": 9,
        "action": "User B returns ROOM_UNAVAILABLE",
        "state": "B's booking fails",
        "explanation": "Conflict detected before DB insert attempt"
      },
      {
        "step": 10,
        "action": "User B releases lock",
        "state": "locks={}",
        "explanation": "Lock released in finally block"
      }
    ],
    "final_output": "User A: CONFIRMED (BK_A_xxx), User B: FAILED (ROOM_UNAVAILABLE)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single user booking should always succeed",
      "Two users booking different rooms should both succeed",
      "Same dates on same room should result in exactly one success"
    ],
    "likely_bugs": [
      "Lock not released on exception path - use try/finally",
      "Race between check and insert without lock",
      "Lock key not specific enough (e.g., missing dates)",
      "Wrong comparison for overlapping dates (off-by-one with check-out)"
    ],
    "recommended_logs_or_asserts": [
      "Log: 'Acquired lock {key} with token {token}' and 'Released lock {key}'",
      "Log: 'Constraint violation for room {id} dates {dates}'",
      "Assert: confirmed_count <= 1 for same room/dates",
      "Assert: lock is released (finally block executed)"
    ],
    "how_to_localize": "1. Add logging before/after lock acquire/release. 2. Log database state before insert. 3. Use thread IDs in logs. 4. Run with single thread first, then add concurrency."
  },
  "edge_cases": [
    {
      "case": "Lock expires during long processing",
      "handling": "DB constraint catches the race condition. User gets constraint violation but booking integrity maintained.",
      "gotcha": "Set TTL long enough for typical processing but short enough for recovery"
    },
    {
      "case": "Network partition between lock service and DB",
      "handling": "If can't reach lock service, can fall back to constraint-only mode with warning log",
      "gotcha": "Must monitor lock service availability"
    },
    {
      "case": "Check-in equals check-out",
      "handling": "Validation in BookingRequest constructor rejects this",
      "gotcha": "Don't allow 0-night bookings"
    },
    {
      "case": "Overlapping but not identical dates",
      "handling": "Per-date unique constraint catches any overlap. Jan 1-5 blocks Jan 3-7 because Jan 3,4 overlap.",
      "gotcha": "Must check ALL dates, not just start/end"
    }
  ],
  "test_cases": [
    {
      "name": "Concurrent exact conflict - only one succeeds",
      "input": "A: Room101 Jan10-12, B: Room101 Jan10-12, simultaneous",
      "expected": "Exactly one CONFIRMED, one FAILED",
      "explanation": "Core double-booking prevention test"
    },
    {
      "name": "Concurrent overlapping dates",
      "input": "A: Room101 Jan10-15, B: Room101 Jan12-18, A starts first",
      "expected": "A: CONFIRMED, B: FAILED (overlap on Jan 12-14)",
      "explanation": "Partial overlap detection"
    },
    {
      "name": "Concurrent different rooms - both succeed",
      "input": "A: Room101 Jan10-12, B: Room102 Jan10-12, simultaneous",
      "expected": "Both CONFIRMED",
      "explanation": "No conflict, different rooms"
    },
    {
      "name": "Sequential same room - second fails",
      "input": "A books Room101 Jan10-12, then B tries same dates",
      "expected": "A: CONFIRMED, B: FAILED (ROOM_UNAVAILABLE)",
      "explanation": "Normal sequential conflict"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Check-then-act without locking",
      "why_wrong": "Classic TOCTOU bug. Between checking availability and inserting, another request can book.",
      "correct_approach": "Either hold lock during entire check-insert, or use atomic insert with constraint",
      "code_example_wrong": "if is_available(room, dates):\\n    insert_booking(room, dates)  # Race condition!",
      "code_example_correct": "with select_for_update(room):\\n    if is_available(room, dates):\\n        insert_booking(room, dates)"
    },
    {
      "mistake": "Not releasing lock on exception",
      "why_wrong": "Lock stays held, blocking all other bookings for that room until TTL expires",
      "correct_approach": "Always use try/finally or context manager for lock release",
      "code_example_wrong": "lock = acquire_lock()\\nprocess()  # If this throws, lock never released\\nrelease_lock()",
      "code_example_correct": "lock = acquire_lock()\\ntry:\\n    process()\\nfinally:\\n    release_lock()"
    },
    {
      "mistake": "Lock key too broad (just room_id)",
      "why_wrong": "Blocks ALL bookings for the room, even non-overlapping dates",
      "correct_approach": "Include date range in lock key for better parallelism",
      "code_example_wrong": "lock_key = f'room:{room_id}'",
      "code_example_correct": "lock_key = f'room:{room_id}:{check_in}:{check_out}'"
    },
    {
      "mistake": "Treating constraint violation as system error",
      "why_wrong": "Constraint violation is expected business case during races, not a bug",
      "correct_approach": "Catch constraint violation and return user-friendly ALREADY_BOOKED message",
      "code_example_wrong": "try:\\n    insert()\\nexcept ConstraintViolation:\\n    raise ServerError()",
      "code_example_correct": "try:\\n    insert()\\nexcept ConstraintViolation:\\n    return BookingResponse.failure('ALREADY_BOOKED', 'Room taken')"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying the RACE CONDITION as the core problem. Draw the timeline showing two concurrent requests. Then present the layered defense strategy: distributed lock for fail-fast, DB constraint for correctness.",
    "what_to_mention": [
      "Explain WHY naive check-then-act fails (TOCTOU bug)",
      "Compare locking strategies and when to use each",
      "Emphasize that DB constraint is the SOURCE OF TRUTH",
      "Discuss distributed lock TTL tradeoffs",
      "Mention monitoring/alerting for lock service health"
    ],
    "time_allocation": "15-20 minutes: 3 min on problem analysis, 5 min on strategy comparison, 7 min on implementation, 5 min on edge cases",
    "if_stuck": [
      "Think about what happens if two requests read 'available' simultaneously",
      "Consider what guarantees ACID databases provide",
      "Ask: what's the single point of truth that all servers must agree on?"
    ]
  },
  "connection_to_next_part": "Part 3 might cover: payment processing integration (2-phase commit), waitlist for unavailable rooms, caching layer for read scalability, or handling cancellations with refunds. The locking infrastructure from Part 2 will be essential for any financial transactions.",
  "communication_script": {
    "transition_from_previous": "Great, so Part 1 has basic booking flow working. For Part 2, I need to handle the critical RACE CONDITION when multiple users try to book the same room simultaneously. Let me explain my approach...",
    "explaining_changes": "The key challenge is preventing double-booking. I'll use a DEFENSE IN DEPTH approach: distributed locks for fail-fast, with database constraints as the ultimate source of truth. Let me walk through the strategies...",
    "while_extending_code": [
      "I'm adding a LockStrategy enum to support multiple approaches...",
      "This DistributedLock interface allows swapping Redis for ZooKeeper later...",
      "Notice the finally block - we MUST release the lock even on failure...",
      "The constraint handler returns a user-friendly error, not a 500..."
    ],
    "after_completing": "This now handles concurrent bookings safely. Pessimistic for high contention, optimistic for low contention, and distributed lock + constraint for production. The new operations are O(d) where d is nights. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_3_min": "Clearly explain the race condition problem and why naive approach fails",
    "by_7_min": "Present comparison of locking strategies with tradeoffs",
    "by_12_min": "Core implementation of at least 2 strategies complete",
    "by_15_min": "Edge cases discussed, testing concurrent scenarios",
    "warning_signs": "If still explaining the problem at 5 min, speed up and show code. If implementation incomplete at 12 min, focus on one strategy deeply."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has issues affecting Part 2, fix them first. Say: 'I notice a gap in Part 1 - let me fix the availability check before adding locking.'",
    "if_new_requirement_unclear": "Ask: 'Should the lock timeout be configurable per request, or is a system default acceptable?' or 'Do we need fair queuing for popular rooms?'",
    "if_running_behind": "Focus on DATABASE CONSTRAINT approach - it's the simplest and most important. Say: 'Let me focus on the constraint approach first since it's the source of truth, then we can discuss distributed locking.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Drawing the race condition timeline before coding",
      "Explaining defense in depth: distributed lock + DB constraint",
      "Mentioning lock key granularity for better parallelism",
      "Discussing monitoring and alerting for lock service",
      "Knowing when to use pessimistic vs optimistic",
      "Handling constraint violation as business logic, not error"
    ]
  },
  "pattern_recognition": {
    "pattern": "Distributed Locking with Fallback Constraint",
    "indicators": [
      "Multiple servers/processes accessing shared resource",
      "Exactly-once semantics required (no double-booking)",
      "High availability requirement (can't have single point of failure)",
      "Flash sale / high contention scenarios mentioned"
    ],
    "similar_problems": [
      "Ticket booking systems (concert, flight)",
      "Inventory reservation (e-commerce flash sales)",
      "Distributed rate limiting",
      "Leader election in distributed systems"
    ],
    "template": "1. Try distributed lock (fail-fast optimization)\\n2. If lock acquired, check and operate\\n3. Use database constraint as final check\\n4. ALWAYS release lock in finally block\\n5. Handle constraint violation gracefully"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'concurrent booking', I immediately think of race conditions",
      "why": "Classic TOCTOU problem - checking availability then booking has a gap where another request can slip through"
    },
    {
      "step": 2,
      "thought": "The key constraint is 'never double-book'",
      "why": "This is an invariant we MUST maintain, not a soft requirement. Database constraints are designed for exactly this."
    },
    {
      "step": 3,
      "thought": "Multiple servers means single-server locking is insufficient",
      "why": "Thread locks only work within one process. Need distributed coordination via Redis/ZooKeeper or rely on database."
    },
    {
      "step": 4,
      "thought": "I should use defense in depth, not a single mechanism",
      "why": "Distributed locks can fail (network issues), so DB constraint is the backup. Lock is just an optimization."
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you understand race conditions and concurrency issues?",
      "Can you compare tradeoffs between different locking strategies?",
      "Do you know that database constraints are source of truth?",
      "Can you implement correct lock release (finally block)?",
      "Do you consider distributed systems challenges?"
    ],
    "bonus_points": [
      "Drawing the race condition timeline",
      "Mentioning lock key granularity",
      "Discussing TTL tradeoffs",
      "Knowing when each strategy is appropriate",
      "Mentioning monitoring/alerting"
    ],
    "red_flags": [
      "Not understanding why check-then-act fails",
      "Forgetting to release locks on exceptions",
      "Treating constraint violation as system error",
      "Using only in-memory locks for distributed system",
      "Not considering lock timeout scenarios"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate like enum definitions and data classes",
      "Ask AI for threading primitives syntax (Lock, RLock, acquire timeout)",
      "Let AI generate test case structure"
    ],
    "what_not_to_do": [
      "Don't let AI design the locking strategy - YOU must understand tradeoffs",
      "Review every line of lock handling code - bugs here cause data corruption",
      "Don't accept 'check-then-act' code without locking"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about expected contention level (affects strategy choice)",
      "Jumping to implementation without explaining the problem",
      "Not discussing tradeoffs between strategies"
    ],
    "technical": [
      "Using simple check-then-act without any locking",
      "Forgetting finally block for lock release",
      "Lock timeout too short or too long without justification",
      "Not handling constraint violation error"
    ],
    "communication": [
      "Not drawing the race condition scenario",
      "Not explaining WHY defense in depth",
      "Forgetting to test concurrent scenarios"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does exactly ONE booking succeed for concurrent conflicts?",
      "Are locks ALWAYS released (check finally blocks)?",
      "Is constraint violation handled gracefully?",
      "Did I trace through a concurrent scenario?",
      "Did I mention when to use each strategy?"
    ],
    "quick_code_review": [
      "try/finally around ALL lock acquisition",
      "Lock key includes room AND dates",
      "Constraint violation returns user-friendly error",
      "Version incremented atomically on update"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Metrics: lock acquisition time, conflict rate, retry count",
      "Logging: lock acquired/released events with request IDs",
      "Circuit breaker: if Redis fails, fall back to constraint-only",
      "Dead letter queue: failed bookings for manual review",
      "Lock monitoring: alert if lock held too long"
    ],
    "why_not_in_interview": "Focus on core concurrency logic; these are operational concerns",
    "how_to_mention": "Say: 'In production, I'd add Prometheus metrics for lock contention and a circuit breaker to fall back to constraint-only if Redis is down.'"
  },
  "generated_at": "2026-01-18T21:28:17.504213",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}