{
  "problem_title": "Stack Overflow API Design - Part 2: Voting and Reputation System",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 extends the basic Q&A system with voting mechanics and reputation tracking. Users can now upvote/downvote questions and answers, and question authors can accept answers. Each action affects both the content's score AND the author's reputation. The key challenge is handling vote changes (switching from upvote to downvote) correctly while maintaining accurate reputation counts.",
    "new_requirements": [
      "Upvote and downvote questions with score tracking",
      "Upvote and downvote answers with score tracking",
      "Track user reputation based on voting rules",
      "Allow question authors to accept answers (+15 rep)",
      "Prevent self-voting on own content",
      "Allow vote changes (flip upvote to downvote)",
      "One vote per user per item"
    ],
    "new_constraints": [
      "Users cannot vote on their own questions/answers",
      "Each user can only have one active vote per item",
      "Vote changes must correctly update both score AND reputation",
      "Reputation changes: upvote=+10, downvote=-2, accept=+15"
    ],
    "key_insight": "Track previous vote state to calculate the delta for both score and reputation when a vote changes. Use nested HashMap (item_id -> voter_id -> vote_value) for O(1) vote lookups and updates."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Upvote/downvote questions and answers",
        "how_met": "Generic _apply_vote() method handles all voting logic with vote value +1 or -1",
        "gotchas": [
          "Must handle vote changes, not just new votes"
        ]
      },
      {
        "requirement": "Track user reputation",
        "how_met": "User object stores reputation; updated incrementally on each vote action",
        "gotchas": [
          "Reputation delta differs when changing vote vs new vote"
        ]
      },
      {
        "requirement": "Prevent self-voting",
        "how_met": "Check voter_id != author_id before processing vote",
        "gotchas": [
          "Return -1, not throw exception"
        ]
      },
      {
        "requirement": "Allow vote changes",
        "how_met": "Track previous vote and calculate delta (e.g., +1 to -1 = -2 score change)",
        "gotchas": [
          "Must update reputation correctly: remove old effect, add new effect"
        ]
      },
      {
        "requirement": "Accept answers",
        "how_met": "Only question author can accept; answer gets marked, author gets +15 rep",
        "gotchas": [
          "Don't give reputation twice if already accepted"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "upvoteQuestion",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct HashMap lookups for question, voter, and vote tracking"
      },
      {
        "operation": "downvoteQuestion",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Same as upvote"
      },
      {
        "operation": "acceptAnswer",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct HashMap lookups"
      },
      {
        "operation": "getUserReputation",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Stored directly on User object"
      }
    ],
    "non_goals": [
      "Removing votes (only changing votes is supported)",
      "Voting history/audit trail",
      "Reputation floor (can go negative)",
      "Complex reputation rules (no daily caps, no badges)"
    ]
  },
  "assumptions": [
    "Reputation can go negative (no floor) - confirm with interviewer",
    "Accepting an already-accepted answer is idempotent (no additional reputation)",
    "A question can only have one accepted answer",
    "Invalid operations return -1 for vote methods, False for accept method",
    "Vote value of 0 means no vote (not neutral vote)"
  ],
  "tradeoffs": [
    {
      "decision": "Store votes in nested HashMap vs flat HashMap with composite key",
      "chosen": "Nested HashMap: item_id -> (voter_id -> vote_value)",
      "why": "More readable, easier to iterate over all votes for an item if needed",
      "alternative": "Flat HashMap with key 'itemId:voterId'",
      "when_to_switch": "If memory is constrained and items have many voters"
    },
    {
      "decision": "Store reputation on User object vs separate tracking",
      "chosen": "Store on User object",
      "why": "O(1) retrieval, intuitive data modeling",
      "alternative": "Separate reputation HashMap",
      "when_to_switch": "If reputation needs complex calculations or history"
    },
    {
      "decision": "Generic vote method vs separate implementations",
      "chosen": "Generic _apply_vote() helper",
      "why": "DRY principle, reduces bugs, easier to maintain",
      "alternative": "Separate upvoteQuestion, downvoteQuestion, etc.",
      "when_to_switch": "If voting rules diverge significantly between questions and answers"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures from Part 1",
      "User, Question, Answer data structures (add fields, don't remove)",
      "Return value conventions (-1 for invalid, actual value for success)"
    ],
    "what_to_change": [
      "Added score field to Question and Answer",
      "Added reputation field to User",
      "Added accepted field to Answer",
      "Added vote tracking HashMaps",
      "Added _apply_vote helper method"
    ],
    "interfaces_and_boundaries": "Keep voting logic in private helper method. Public methods do validation and delegate. This allows Part 3 to add features like vote removal or vote history without changing public API.",
    "invariants": [
      "Question.score == sum of all votes for that question",
      "User.reputation reflects cumulative effect of all votes received + accepts",
      "Each voter has at most one entry per item in votes dictionary",
      "Vote value is always +1 or -1 (never 0 in the dictionary)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE Part 2:                    AFTER Part 2:\n========================          ========================\nUser                              User\n\u251c\u2500\u2500 id                            \u251c\u2500\u2500 id\n\u2514\u2500\u2500 name                          \u251c\u2500\u2500 name\n                                  \u2514\u2500\u2500 reputation: int\n\nQuestion                          Question\n\u251c\u2500\u2500 id                            \u251c\u2500\u2500 id\n\u251c\u2500\u2500 author_id                     \u251c\u2500\u2500 author_id\n\u251c\u2500\u2500 title                         \u251c\u2500\u2500 title\n\u251c\u2500\u2500 body                          \u251c\u2500\u2500 body\n\u2514\u2500\u2500 tags                          \u251c\u2500\u2500 tags\n                                  \u251c\u2500\u2500 score: int\n                                  \u2514\u2500\u2500 accepted_answer_id\n\nStackOverflow                     StackOverflow\n\u251c\u2500\u2500 users {}                      \u251c\u2500\u2500 users {}\n\u251c\u2500\u2500 questions {}                  \u251c\u2500\u2500 questions {}\n\u251c\u2500\u2500 answers {}                    \u251c\u2500\u2500 answers {}\n                                  \u251c\u2500\u2500 question_votes {}\n                                  \u2514\u2500\u2500 answer_votes {}\n```",
    "algorithm_flow": "```\n              Vote Flow: User B upvotes User A's question\n              \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 upvoteQuestion(voter_id='u2', question_id='q_1')        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 1: Validate                                        \u2502\n    \u2502   \u251c\u2500\u2500 Question q_1 exists? \u2713                            \u2502\n    \u2502   \u251c\u2500\u2500 Voter u2 exists? \u2713                                \u2502\n    \u2502   \u2514\u2500\u2500 u2 != q_1.author_id? \u2713 (u2 != u1)                 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 2: Check Previous Vote                             \u2502\n    \u2502   question_votes['q_1']['u2'] = ?                       \u2502\n    \u2502   \u251c\u2500\u2500 None \u2192 New vote                                   \u2502\n    \u2502   \u251c\u2500\u2500 +1 \u2192 Already upvoted (no change)                  \u2502\n    \u2502   \u2514\u2500\u2500 -1 \u2192 Changing from downvote                       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 3: Calculate Deltas (if new vote, prev=0)          \u2502\n    \u2502   score_delta = new_vote(+1) - prev_vote(0) = +1        \u2502\n    \u2502   rep_delta = +10 (upvote reputation)                   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 4: Apply Changes                                   \u2502\n    \u2502   q_1.score += 1        \u2192 score: 0 \u2192 1                  \u2502\n    \u2502   u1.reputation += 10   \u2192 rep: 0 \u2192 10                   \u2502\n    \u2502   votes['q_1']['u2'] = 1                                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Return: 1 (new score)                                   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n              Vote Change: User B changes upvote to downvote\n              \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    Previous state: votes['q_1']['u2'] = +1\n                    q_1.score = 1, u1.reputation = 10\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 downvoteQuestion(voter_id='u2', question_id='q_1')      \u2502\n    \u2502                                                         \u2502\n    \u2502 Previous vote: +1, New vote: -1                         \u2502\n    \u2502                                                         \u2502\n    \u2502 score_delta = (-1) - (+1) = -2                          \u2502\n    \u2502 rep_delta = (-2) - (+10) = -12                          \u2502\n    \u2502   (remove upvote effect, add downvote effect)           \u2502\n    \u2502                                                         \u2502\n    \u2502 q_1.score: 1 + (-2) = -1                                \u2502\n    \u2502 u1.reputation: 10 + (-12) = -2                          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store votes in a simple list and recalculate score/reputation on every query by iterating through all votes.",
      "time_complexity": "O(n) per vote operation where n is number of votes",
      "space_complexity": "O(v) where v is total votes",
      "why_not_optimal": "Recalculating from scratch on every operation is wasteful. Looking up if a user already voted requires O(n) scan. Does not meet O(1) requirement."
    },
    {
      "name": "Optimal Approach",
      "description": "Use nested HashMaps for O(1) vote tracking. Store score on items and reputation on users, updating incrementally. Calculate deltas when votes change.",
      "time_complexity": "O(1) for all voting operations",
      "space_complexity": "O(v) for vote storage where v is total votes",
      "key_insight": "Track previous vote to calculate delta. Nested map (item_id -> voter_id -> vote) gives O(1) lookup for 'has this user voted on this item' and 'what was their vote'."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Incremental Delta-Based Voting\n\n### Core Insight\nThe key insight is that we **don't need to recalculate** score or reputation from scratch. Instead, we:\n1. Track each user's vote per item in a **nested HashMap**\n2. When a vote occurs, calculate the **delta** from previous state\n3. Apply delta to both **score** and **reputation** incrementally\n\n### Data Structure Design\n\n```\nquestion_votes: Dict[question_id, Dict[voter_id, vote_value]]\nanswer_votes: Dict[answer_id, Dict[voter_id, vote_value]]\n```\n\nWhere `vote_value` is:\n- `+1` for upvote\n- `-1` for downvote\n- Key absent means no vote\n\n### Vote Change Delta Calculation\n\n| Previous | New | Score Delta | Reputation Delta |\n|----------|-----|-------------|------------------|\n| None (0) | +1  | +1          | +10              |\n| None (0) | -1  | -1          | -2               |\n| +1       | -1  | -2          | -12 (-10 + -2)   |\n| -1       | +1  | +2          | +12 (+2 + +10)   |\n| +1       | +1  | 0           | 0 (no change)    |\n| -1       | -1  | 0           | 0 (no change)    |\n\n### Generic Vote Handler\n\nWe use a **single helper method** `_apply_vote()` that handles all four voting operations (upvote/downvote \u00d7 question/answer). This:\n- Reduces code duplication\n- Ensures consistent behavior\n- Makes testing easier\n\n### Accept Answer Logic\n\nAccepting an answer is simpler:\n1. Verify caller is question author\n2. Mark answer as accepted (idempotent)\n3. Award +15 reputation (only once)",
    "data_structures": [
      {
        "structure": "Nested HashMap (question_votes)",
        "purpose": "O(1) lookup of a user's vote on a specific question"
      },
      {
        "structure": "Nested HashMap (answer_votes)",
        "purpose": "O(1) lookup of a user's vote on a specific answer"
      },
      {
        "structure": "User.reputation field",
        "purpose": "O(1) reputation retrieval"
      },
      {
        "structure": "Question.score field",
        "purpose": "O(1) score retrieval"
      },
      {
        "structure": "Answer.accepted field",
        "purpose": "Prevent duplicate accept reputation"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate inputs (voter exists, item exists, not self-voting)",
      "Step 2: Look up previous vote (default to 0 if no previous vote)",
      "Step 3: If same vote as before, return current score (no-op)",
      "Step 4: Calculate score_delta = new_vote - previous_vote",
      "Step 5: Calculate rep_delta based on vote transition (new vs change)",
      "Step 6: Update item.score += score_delta",
      "Step 7: Update author.reputation += rep_delta",
      "Step 8: Store new vote in votes dictionary",
      "Step 9: Return new score"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 2: Voting and Reputation System",
    "",
    "This extends Part 1 with voting mechanics and reputation tracking.",
    "\"\"\"",
    "from typing import Dict, List, Optional",
    "from dataclasses import dataclass, field",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.\"\"\"",
    "    id: str",
    "    name: str",
    "    reputation: int = 0  # NEW in Part 2",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Represents a question posted by a user.\"\"\"",
    "    id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    score: int = 0  # NEW in Part 2",
    "    accepted_answer_id: Optional[str] = None  # NEW in Part 2",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.\"\"\"",
    "    id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    score: int = 0  # NEW in Part 2",
    "    accepted: bool = False  # NEW in Part 2",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class for Stack Overflow functionality.",
    "    ",
    "    Part 2 adds voting and reputation system.",
    "    \"\"\"",
    "    ",
    "    # Reputation constants",
    "    UPVOTE_REP = 10",
    "    DOWNVOTE_REP = -2",
    "    ACCEPT_REP = 15",
    "    ",
    "    def __init__(self):",
    "        # Part 1 data structures",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        self._question_counter = 0",
    "        self._answer_counter = 0",
    "        ",
    "        # Part 2 data structures - vote tracking",
    "        # Structure: item_id -> {voter_id -> vote_value (+1 or -1)}",
    "        self._question_votes: Dict[str, Dict[str, int]] = {}",
    "        self._answer_votes: Dict[str, Dict[str, int]] = {}",
    "    ",
    "    # ==================== PART 1 METHODS ====================",
    "    ",
    "    def create_user(self, user_id: str, name: str) -> Optional[Dict]:",
    "        \"\"\"Create a new user with the given ID and name.\"\"\"",
    "        if user_id in self._users:",
    "            return None",
    "        self._users[user_id] = User(id=user_id, name=name)",
    "        return {\"id\": user_id}",
    "    ",
    "    def post_question(self, author_id: str, title: str, body: str,",
    "                      tags: List[str]) -> Optional[Dict]:",
    "        \"\"\"Post a new question.\"\"\"",
    "        if author_id not in self._users:",
    "            return None",
    "        ",
    "        self._question_counter += 1",
    "        question_id = f\"q_{self._question_counter}\"",
    "        ",
    "        question = Question(",
    "            id=question_id,",
    "            author_id=author_id,",
    "            title=title,",
    "            body=body,",
    "            tags=list(tags)",
    "        )",
    "        self._questions[question_id] = question",
    "        self._question_votes[question_id] = {}  # Initialize vote tracking",
    "        ",
    "        return {\"id\": question_id, \"score\": 0}",
    "    ",
    "    def post_answer(self, author_id: str, question_id: str,",
    "                    body: str) -> Optional[Dict]:",
    "        \"\"\"Post an answer to a question.\"\"\"",
    "        if author_id not in self._users:",
    "            return None",
    "        if question_id not in self._questions:",
    "            return None",
    "        ",
    "        self._answer_counter += 1",
    "        answer_id = f\"a_{self._answer_counter}\"",
    "        ",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            author_id=author_id,",
    "            body=body",
    "        )",
    "        self._answers[answer_id] = answer",
    "        self._answer_votes[answer_id] = {}  # Initialize vote tracking",
    "        ",
    "        return {\"id\": answer_id}",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Dict]:",
    "        \"\"\"Get a question with all its answers.\"\"\"",
    "        if question_id not in self._questions:",
    "            return None",
    "        ",
    "        q = self._questions[question_id]",
    "        answers = [",
    "            {",
    "                \"id\": a.id,",
    "                \"body\": a.body,",
    "                \"score\": a.score,",
    "                \"accepted\": a.accepted",
    "            }",
    "            for a in self._answers.values()",
    "            if a.question_id == question_id",
    "        ]",
    "        ",
    "        return {",
    "            \"id\": q.id,",
    "            \"title\": q.title,",
    "            \"body\": q.body,",
    "            \"tags\": q.tags,",
    "            \"score\": q.score,",
    "            \"answers\": answers",
    "        }",
    "    ",
    "    def search_questions(self, keyword: str) -> List[Dict]:",
    "        \"\"\"Search questions by keyword in title or body.\"\"\"",
    "        results = []",
    "        keyword_lower = keyword.lower()",
    "        ",
    "        for q in self._questions.values():",
    "            if (keyword_lower in q.title.lower() or",
    "                keyword_lower in q.body.lower()):",
    "                results.append({",
    "                    \"id\": q.id,",
    "                    \"title\": q.title,",
    "                    \"score\": q.score",
    "                })",
    "        ",
    "        return results",
    "    ",
    "    # ==================== PART 2 METHODS ====================",
    "    ",
    "    def _apply_vote(self, votes_dict: Dict[str, Dict[str, int]],",
    "                    item_id: str, voter_id: str, author_id: str,",
    "                    new_vote: int, item) -> int:",
    "        \"\"\"",
    "        Generic vote application logic for questions and answers.",
    "        ",
    "        Args:",
    "            votes_dict: The votes dictionary (question_votes or answer_votes)",
    "            item_id: ID of the item being voted on",
    "            voter_id: ID of the voter",
    "            author_id: ID of the item author",
    "            new_vote: +1 for upvote, -1 for downvote",
    "            item: The question or answer object",
    "        ",
    "        Returns:",
    "            New score of the item, or -1 if operation is invalid",
    "        \"\"\"",
    "        # Validate voter exists",
    "        if voter_id not in self._users:",
    "            return -1",
    "        ",
    "        # Cannot vote on own content",
    "        if voter_id == author_id:",
    "            return -1",
    "        ",
    "        # Get current votes for this item",
    "        votes_for_item = votes_dict.get(item_id, {})",
    "        ",
    "        # Get previous vote (0 if no previous vote)",
    "        previous_vote = votes_for_item.get(voter_id, 0)",
    "        ",
    "        # If same vote as before, no change needed",
    "        if previous_vote == new_vote:",
    "            return item.score",
    "        ",
    "        # Calculate score delta",
    "        score_delta = new_vote - previous_vote",
    "        item.score += score_delta",
    "        ",
    "        # Calculate reputation delta",
    "        author = self._users[author_id]",
    "        ",
    "        if previous_vote == 0:",
    "            # New vote - apply full reputation effect",
    "            rep_delta = self.UPVOTE_REP if new_vote == 1 else self.DOWNVOTE_REP",
    "        else:",
    "            # Changing vote - remove old effect, add new effect",
    "            old_rep = self.UPVOTE_REP if previous_vote == 1 else self.DOWNVOTE_REP",
    "            new_rep = self.UPVOTE_REP if new_vote == 1 else self.DOWNVOTE_REP",
    "            rep_delta = new_rep - old_rep",
    "        ",
    "        author.reputation += rep_delta",
    "        ",
    "        # Record the new vote",
    "        votes_for_item[voter_id] = new_vote",
    "        votes_dict[item_id] = votes_for_item",
    "        ",
    "        return item.score",
    "    ",
    "    def upvote_question(self, voter_id: str, question_id: str) -> int:",
    "        \"\"\"",
    "        Upvote a question.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            question_id: ID of the question to upvote",
    "        ",
    "        Returns:",
    "            New score of the question, or -1 if invalid",
    "        \"\"\"",
    "        if question_id not in self._questions:",
    "            return -1",
    "        ",
    "        question = self._questions[question_id]",
    "        return self._apply_vote(",
    "            self._question_votes, question_id, voter_id,",
    "            question.author_id, 1, question",
    "        )",
    "    ",
    "    def downvote_question(self, voter_id: str, question_id: str) -> int:",
    "        \"\"\"",
    "        Downvote a question.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            question_id: ID of the question to downvote",
    "        ",
    "        Returns:",
    "            New score of the question, or -1 if invalid",
    "        \"\"\"",
    "        if question_id not in self._questions:",
    "            return -1",
    "        ",
    "        question = self._questions[question_id]",
    "        return self._apply_vote(",
    "            self._question_votes, question_id, voter_id,",
    "            question.author_id, -1, question",
    "        )",
    "    ",
    "    def upvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        \"\"\"",
    "        Upvote an answer.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            answer_id: ID of the answer to upvote",
    "        ",
    "        Returns:",
    "            New score of the answer, or -1 if invalid",
    "        \"\"\"",
    "        if answer_id not in self._answers:",
    "            return -1",
    "        ",
    "        answer = self._answers[answer_id]",
    "        return self._apply_vote(",
    "            self._answer_votes, answer_id, voter_id,",
    "            answer.author_id, 1, answer",
    "        )",
    "    ",
    "    def downvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        \"\"\"",
    "        Downvote an answer.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            answer_id: ID of the answer to downvote",
    "        ",
    "        Returns:",
    "            New score of the answer, or -1 if invalid",
    "        \"\"\"",
    "        if answer_id not in self._answers:",
    "            return -1",
    "        ",
    "        answer = self._answers[answer_id]",
    "        return self._apply_vote(",
    "            self._answer_votes, answer_id, voter_id,",
    "            answer.author_id, -1, answer",
    "        )",
    "    ",
    "    def accept_answer(self, question_author_id: str, answer_id: str) -> bool:",
    "        \"\"\"",
    "        Accept an answer (only question author can do this).",
    "        ",
    "        Args:",
    "            question_author_id: ID of the question author",
    "            answer_id: ID of the answer to accept",
    "        ",
    "        Returns:",
    "            True if successful, False otherwise",
    "        \"\"\"",
    "        # Check answer exists",
    "        if answer_id not in self._answers:",
    "            return False",
    "        ",
    "        answer = self._answers[answer_id]",
    "        question_id = answer.question_id",
    "        ",
    "        # Check question exists",
    "        if question_id not in self._questions:",
    "            return False",
    "        ",
    "        question = self._questions[question_id]",
    "        ",
    "        # Verify the caller is the question author",
    "        if question.author_id != question_author_id:",
    "            return False",
    "        ",
    "        # Check if already accepted (idempotent - no double reputation)",
    "        if answer.accepted:",
    "            return True",
    "        ",
    "        # Accept the answer",
    "        answer.accepted = True",
    "        question.accepted_answer_id = answer_id",
    "        ",
    "        # Award reputation to answer author",
    "        if answer.author_id in self._users:",
    "            self._users[answer.author_id].reputation += self.ACCEPT_REP",
    "        ",
    "        return True",
    "    ",
    "    def get_user_reputation(self, user_id: str) -> int:",
    "        \"\"\"",
    "        Get the current reputation of a user.",
    "        ",
    "        Args:",
    "            user_id: ID of the user",
    "        ",
    "        Returns:",
    "            Current reputation, or -1 if user doesn't exist",
    "        \"\"\"",
    "        if user_id not in self._users:",
    "            return -1",
    "        return self._users[user_id].reputation",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate Part 2: Voting and Reputation System.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Stack Overflow API - Part 2: Voting and Reputation Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    so = StackOverflow()",
    "    ",
    "    # Create users",
    "    print(\"\\n1. Creating users...\")",
    "    print(f\"   Create Alice: {so.create_user('u1', 'alice')}\")",
    "    print(f\"   Create Bob: {so.create_user('u2', 'bob')}\")",
    "    print(f\"   Create Charlie: {so.create_user('u3', 'charlie')}\")",
    "    ",
    "    # Post a question",
    "    print(\"\\n2. Alice posts a question...\")",
    "    result = so.post_question(",
    "        'u1', 'How to reverse a string in Python?',",
    "        'I need help with string manipulation', ['python', 'strings']",
    "    )",
    "    print(f\"   Question posted: {result}\")",
    "    ",
    "    # Bob upvotes the question",
    "    print(\"\\n3. Bob upvotes Alice's question...\")",
    "    new_score = so.upvote_question('u2', 'q_1')",
    "    print(f\"   New question score: {new_score}\")",
    "    print(f\"   Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Charlie also upvotes",
    "    print(\"\\n4. Charlie also upvotes...\")",
    "    new_score = so.upvote_question('u3', 'q_1')",
    "    print(f\"   New question score: {new_score}\")",
    "    print(f\"   Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Bob changes vote to downvote",
    "    print(\"\\n5. Bob changes his vote to downvote...\")",
    "    new_score = so.downvote_question('u2', 'q_1')",
    "    print(f\"   New question score: {new_score}\")",
    "    print(f\"   Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    print(\"   (Score went from 2 to 0: -2 delta)\")",
    "    print(\"   (Reputation: 20 - 12 = 8, removed +10 upvote, added -2 downvote)\")",
    "    ",
    "    # Alice tries to upvote her own question",
    "    print(\"\\n6. Alice tries to upvote her own question...\")",
    "    result = so.upvote_question('u1', 'q_1')",
    "    print(f\"   Result: {result} (expected -1, self-voting not allowed)\")",
    "    ",
    "    # Bob posts and gets answer accepted",
    "    print(\"\\n7. Bob posts an answer...\")",
    "    answer = so.post_answer('u2', 'q_1', 'Use string[::-1] for reversal')",
    "    print(f\"   Answer posted: {answer}\")",
    "    ",
    "    print(\"\\n8. Alice accepts Bob's answer...\")",
    "    accepted = so.accept_answer('u1', 'a_1')",
    "    print(f\"   Accepted: {accepted}\")",
    "    print(f\"   Bob's reputation: {so.get_user_reputation('u2')} (+15 for accepted)\")",
    "    ",
    "    # Charlie upvotes the answer",
    "    print(\"\\n9. Charlie upvotes Bob's answer...\")",
    "    new_score = so.upvote_answer('u3', 'a_1')",
    "    print(f\"   Answer score: {new_score}\")",
    "    print(f\"   Bob's reputation: {so.get_user_reputation('u2')} (+10 for upvote)\")",
    "    ",
    "    # Show final question state",
    "    print(\"\\n10. Final question state:\")",
    "    q = so.get_question('q_1')",
    "    print(f\"    Title: {q['title']}\")",
    "    print(f\"    Score: {q['score']}\")",
    "    print(f\"    Answers: {q['answers']}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo Complete!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Stack Overflow API - Part 2: Voting and Reputation System",
    " */",
    "class User {",
    "    String id;",
    "    String name;",
    "    int reputation;  // NEW in Part 2",
    "    ",
    "    User(String id, String name) {",
    "        this.id = id;",
    "        this.name = name;",
    "        this.reputation = 0;",
    "    }",
    "}",
    "",
    "class Question {",
    "    String id;",
    "    String authorId;",
    "    String title;",
    "    String body;",
    "    List<String> tags;",
    "    int score;  // NEW in Part 2",
    "    String acceptedAnswerId;  // NEW in Part 2",
    "    ",
    "    Question(String id, String authorId, String title, String body, List<String> tags) {",
    "        this.id = id;",
    "        this.authorId = authorId;",
    "        this.title = title;",
    "        this.body = body;",
    "        this.tags = new ArrayList<>(tags);",
    "        this.score = 0;",
    "        this.acceptedAnswerId = null;",
    "    }",
    "}",
    "",
    "class Answer {",
    "    String id;",
    "    String questionId;",
    "    String authorId;",
    "    String body;",
    "    int score;  // NEW in Part 2",
    "    boolean accepted;  // NEW in Part 2",
    "    ",
    "    Answer(String id, String questionId, String authorId, String body) {",
    "        this.id = id;",
    "        this.questionId = questionId;",
    "        this.authorId = authorId;",
    "        this.body = body;",
    "        this.score = 0;",
    "        this.accepted = false;",
    "    }",
    "}",
    "",
    "public class StackOverflow {",
    "    // Reputation constants",
    "    private static final int UPVOTE_REP = 10;",
    "    private static final int DOWNVOTE_REP = -2;",
    "    private static final int ACCEPT_REP = 15;",
    "    ",
    "    // Part 1 data structures",
    "    private Map<String, User> users;",
    "    private Map<String, Question> questions;",
    "    private Map<String, Answer> answers;",
    "    private int questionCounter;",
    "    private int answerCounter;",
    "    ",
    "    // Part 2 data structures - vote tracking",
    "    private Map<String, Map<String, Integer>> questionVotes;",
    "    private Map<String, Map<String, Integer>> answerVotes;",
    "    ",
    "    public StackOverflow() {",
    "        users = new HashMap<>();",
    "        questions = new HashMap<>();",
    "        answers = new HashMap<>();",
    "        questionVotes = new HashMap<>();",
    "        answerVotes = new HashMap<>();",
    "        questionCounter = 0;",
    "        answerCounter = 0;",
    "    }",
    "    ",
    "    // ==================== PART 1 METHODS ====================",
    "    ",
    "    public Map<String, Object> createUser(String userId, String name) {",
    "        if (users.containsKey(userId)) {",
    "            return null;",
    "        }",
    "        users.put(userId, new User(userId, name));",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", userId);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> postQuestion(String authorId, String title,",
    "                                            String body, List<String> tags) {",
    "        if (!users.containsKey(authorId)) {",
    "            return null;",
    "        }",
    "        ",
    "        questionCounter++;",
    "        String questionId = \"q_\" + questionCounter;",
    "        ",
    "        Question question = new Question(questionId, authorId, title, body, tags);",
    "        questions.put(questionId, question);",
    "        questionVotes.put(questionId, new HashMap<>());",
    "        ",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", questionId);",
    "        result.put(\"score\", 0);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> postAnswer(String authorId, String questionId, String body) {",
    "        if (!users.containsKey(authorId) || !questions.containsKey(questionId)) {",
    "            return null;",
    "        }",
    "        ",
    "        answerCounter++;",
    "        String answerId = \"a_\" + answerCounter;",
    "        ",
    "        Answer answer = new Answer(answerId, questionId, authorId, body);",
    "        answers.put(answerId, answer);",
    "        answerVotes.put(answerId, new HashMap<>());",
    "        ",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", answerId);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> getQuestion(String questionId) {",
    "        if (!questions.containsKey(questionId)) {",
    "            return null;",
    "        }",
    "        ",
    "        Question q = questions.get(questionId);",
    "        List<Map<String, Object>> answerList = new ArrayList<>();",
    "        ",
    "        for (Answer a : answers.values()) {",
    "            if (a.questionId.equals(questionId)) {",
    "                Map<String, Object> answerMap = new HashMap<>();",
    "                answerMap.put(\"id\", a.id);",
    "                answerMap.put(\"body\", a.body);",
    "                answerMap.put(\"score\", a.score);",
    "                answerMap.put(\"accepted\", a.accepted);",
    "                answerList.add(answerMap);",
    "            }",
    "        }",
    "        ",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", q.id);",
    "        result.put(\"title\", q.title);",
    "        result.put(\"body\", q.body);",
    "        result.put(\"tags\", q.tags);",
    "        result.put(\"score\", q.score);",
    "        result.put(\"answers\", answerList);",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== PART 2 METHODS ====================",
    "    ",
    "    /**",
    "     * Generic vote application logic.",
    "     */",
    "    private int applyVote(Map<String, Map<String, Integer>> votesDict,",
    "                          String itemId, String voterId, String authorId,",
    "                          int newVote, int[] scoreRef) {",
    "        // Validate voter exists",
    "        if (!users.containsKey(voterId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Cannot vote on own content",
    "        if (voterId.equals(authorId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Get current votes for this item",
    "        Map<String, Integer> votesForItem = votesDict.getOrDefault(itemId, new HashMap<>());",
    "        ",
    "        // Get previous vote (0 if no previous vote)",
    "        int previousVote = votesForItem.getOrDefault(voterId, 0);",
    "        ",
    "        // If same vote as before, no change",
    "        if (previousVote == newVote) {",
    "            return scoreRef[0];",
    "        }",
    "        ",
    "        // Calculate score delta",
    "        int scoreDelta = newVote - previousVote;",
    "        scoreRef[0] += scoreDelta;",
    "        ",
    "        // Calculate reputation delta",
    "        User author = users.get(authorId);",
    "        int repDelta;",
    "        ",
    "        if (previousVote == 0) {",
    "            repDelta = (newVote == 1) ? UPVOTE_REP : DOWNVOTE_REP;",
    "        } else {",
    "            int oldRep = (previousVote == 1) ? UPVOTE_REP : DOWNVOTE_REP;",
    "            int newRep = (newVote == 1) ? UPVOTE_REP : DOWNVOTE_REP;",
    "            repDelta = newRep - oldRep;",
    "        }",
    "        ",
    "        author.reputation += repDelta;",
    "        ",
    "        // Record the new vote",
    "        votesForItem.put(voterId, newVote);",
    "        votesDict.put(itemId, votesForItem);",
    "        ",
    "        return scoreRef[0];",
    "    }",
    "    ",
    "    public int upvoteQuestion(String voterId, String questionId) {",
    "        if (!questions.containsKey(questionId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Question question = questions.get(questionId);",
    "        int[] scoreRef = {question.score};",
    "        int result = applyVote(questionVotes, questionId, voterId,",
    "                               question.authorId, 1, scoreRef);",
    "        question.score = scoreRef[0];",
    "        return result;",
    "    }",
    "    ",
    "    public int downvoteQuestion(String voterId, String questionId) {",
    "        if (!questions.containsKey(questionId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Question question = questions.get(questionId);",
    "        int[] scoreRef = {question.score};",
    "        int result = applyVote(questionVotes, questionId, voterId,",
    "                               question.authorId, -1, scoreRef);",
    "        question.score = scoreRef[0];",
    "        return result;",
    "    }",
    "    ",
    "    public int upvoteAnswer(String voterId, String answerId) {",
    "        if (!answers.containsKey(answerId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        int[] scoreRef = {answer.score};",
    "        int result = applyVote(answerVotes, answerId, voterId,",
    "                               answer.authorId, 1, scoreRef);",
    "        answer.score = scoreRef[0];",
    "        return result;",
    "    }",
    "    ",
    "    public int downvoteAnswer(String voterId, String answerId) {",
    "        if (!answers.containsKey(answerId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        int[] scoreRef = {answer.score};",
    "        int result = applyVote(answerVotes, answerId, voterId,",
    "                               answer.authorId, -1, scoreRef);",
    "        answer.score = scoreRef[0];",
    "        return result;",
    "    }",
    "    ",
    "    public boolean acceptAnswer(String questionAuthorId, String answerId) {",
    "        if (!answers.containsKey(answerId)) {",
    "            return false;",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        String questionId = answer.questionId;",
    "        ",
    "        if (!questions.containsKey(questionId)) {",
    "            return false;",
    "        }",
    "        ",
    "        Question question = questions.get(questionId);",
    "        ",
    "        if (!question.authorId.equals(questionAuthorId)) {",
    "            return false;",
    "        }",
    "        ",
    "        if (answer.accepted) {",
    "            return true;  // Idempotent",
    "        }",
    "        ",
    "        answer.accepted = true;",
    "        question.acceptedAnswerId = answerId;",
    "        ",
    "        if (users.containsKey(answer.authorId)) {",
    "            users.get(answer.authorId).reputation += ACCEPT_REP;",
    "        }",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    public int getUserReputation(String userId) {",
    "        if (!users.containsKey(userId)) {",
    "            return -1;",
    "        }",
    "        return users.get(userId).reputation;",
    "    }",
    "    ",
    "    // ==================== DEMO ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API - Part 2: Voting Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        ",
    "        // Create users",
    "        System.out.println(\"\\n1. Creating users...\");",
    "        System.out.println(\"   \" + so.createUser(\"u1\", \"alice\"));",
    "        System.out.println(\"   \" + so.createUser(\"u2\", \"bob\"));",
    "        System.out.println(\"   \" + so.createUser(\"u3\", \"charlie\"));",
    "        ",
    "        // Post question",
    "        System.out.println(\"\\n2. Alice posts a question...\");",
    "        System.out.println(\"   \" + so.postQuestion(\"u1\", \"How to reverse?\",",
    "                           \"Help needed\", Arrays.asList(\"python\")));",
    "        ",
    "        // Voting",
    "        System.out.println(\"\\n3. Bob upvotes...\");",
    "        System.out.println(\"   Score: \" + so.upvoteQuestion(\"u2\", \"q_1\"));",
    "        System.out.println(\"   Alice rep: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        System.out.println(\"\\n4. Charlie upvotes...\");",
    "        System.out.println(\"   Score: \" + so.upvoteQuestion(\"u3\", \"q_1\"));",
    "        System.out.println(\"   Alice rep: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        System.out.println(\"\\n5. Bob changes to downvote...\");",
    "        System.out.println(\"   Score: \" + so.downvoteQuestion(\"u2\", \"q_1\"));",
    "        System.out.println(\"   Alice rep: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        System.out.println(\"\\n6. Self-vote attempt...\");",
    "        System.out.println(\"   Result: \" + so.upvoteQuestion(\"u1\", \"q_1\"));",
    "        ",
    "        // Answer and accept",
    "        System.out.println(\"\\n7. Bob answers...\");",
    "        System.out.println(\"   \" + so.postAnswer(\"u2\", \"q_1\", \"Use [::-1]\"));",
    "        ",
    "        System.out.println(\"\\n8. Alice accepts...\");",
    "        System.out.println(\"   \" + so.acceptAnswer(\"u1\", \"a_1\"));",
    "        System.out.println(\"   Bob rep: \" + so.getUserReputation(\"u2\"));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-6",
      "explanation": "Imports and module docstring"
    },
    {
      "lines": "10-14",
      "explanation": "User dataclass with new reputation field (default 0)"
    },
    {
      "lines": "17-25",
      "explanation": "Question dataclass with new score field and accepted_answer_id"
    },
    {
      "lines": "28-35",
      "explanation": "Answer dataclass with new score and accepted fields"
    },
    {
      "lines": "38-62",
      "explanation": "StackOverflow class with Part 2 vote tracking data structures"
    },
    {
      "lines": "64-89",
      "explanation": "Part 1 methods unchanged except for initializing vote dictionaries"
    },
    {
      "lines": "120-170",
      "explanation": "Core _apply_vote() helper method - handles vote validation, delta calculation, and reputation updates"
    },
    {
      "lines": "172-215",
      "explanation": "Public voting methods for questions and answers, all delegating to _apply_vote()"
    },
    {
      "lines": "217-250",
      "explanation": "acceptAnswer() method with authorization check and idempotent behavior"
    },
    {
      "lines": "252-260",
      "explanation": "getUserReputation() - simple O(1) lookup"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "upvoteQuestion": {
          "complexity": "O(1)",
          "explanation": "HashMap lookups for question, voter, and vote tracking"
        },
        "downvoteQuestion": {
          "complexity": "O(1)",
          "explanation": "Same as upvote"
        },
        "upvoteAnswer": {
          "complexity": "O(1)",
          "explanation": "Same pattern as question voting"
        },
        "downvoteAnswer": {
          "complexity": "O(1)",
          "explanation": "Same pattern"
        },
        "acceptAnswer": {
          "complexity": "O(1)",
          "explanation": "HashMap lookups only"
        },
        "getUserReputation": {
          "complexity": "O(1)",
          "explanation": "Direct field access on User object"
        }
      },
      "overall_change": "All new operations are O(1). No change to Part 1 complexity."
    },
    "space": {
      "additional_space": "O(V) where V is total number of votes",
      "explanation": "Each vote stores one entry in the nested HashMap. In worst case, every user votes on every item: O(U * (Q + A))."
    }
  },
  "dry_run": {
    "example_input": "Create users u1 (Alice), u2 (Bob). Alice posts question q_1. Bob upvotes it. Alice's reputation?",
    "steps": [
      {
        "step": 1,
        "action": "createUser('u1', 'alice')",
        "state": "users = {'u1': User(id='u1', name='alice', reputation=0)}",
        "explanation": "User created with 0 reputation"
      },
      {
        "step": 2,
        "action": "createUser('u2', 'bob')",
        "state": "users = {'u1': ..., 'u2': User(id='u2', name='bob', reputation=0)}",
        "explanation": "Second user created"
      },
      {
        "step": 3,
        "action": "postQuestion('u1', 'Q', 'Body', ['tag'])",
        "state": "questions = {'q_1': Question(score=0, author_id='u1')}, question_votes = {'q_1': {}}",
        "explanation": "Question created with score 0, empty vote tracking initialized"
      },
      {
        "step": 4,
        "action": "upvoteQuestion('u2', 'q_1')",
        "state": "Entering _apply_vote: voterId='u2', authorId='u1', newVote=1",
        "explanation": "Bob is voting on Alice's question (not self-voting)"
      },
      {
        "step": 5,
        "action": "Check previous vote",
        "state": "previousVote = question_votes['q_1'].get('u2', 0) = 0",
        "explanation": "Bob has not voted before"
      },
      {
        "step": 6,
        "action": "Calculate deltas",
        "state": "scoreDelta = 1 - 0 = 1, repDelta = 10 (new upvote)",
        "explanation": "New vote, full reputation effect applies"
      },
      {
        "step": 7,
        "action": "Apply changes",
        "state": "q_1.score = 0 + 1 = 1, u1.reputation = 0 + 10 = 10",
        "explanation": "Score and reputation updated"
      },
      {
        "step": 8,
        "action": "Record vote",
        "state": "question_votes = {'q_1': {'u2': 1}}",
        "explanation": "Vote recorded for future reference"
      },
      {
        "step": 9,
        "action": "getUserReputation('u1')",
        "state": "Return users['u1'].reputation = 10",
        "explanation": "Direct lookup returns updated reputation"
      }
    ],
    "final_output": "upvoteQuestion returns 1 (new score), getUserReputation returns 10"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Upvote on valid question should return positive score",
      "Self-vote should return -1",
      "Vote on non-existent question should return -1"
    ],
    "likely_bugs": [
      "Forgetting to update reputation when changing votes",
      "Wrong delta calculation: should be (newVote - prevVote) not just newVote",
      "Not checking if user is author before allowing vote",
      "Giving accept reputation multiple times"
    ],
    "recommended_logs_or_asserts": [
      "assert question.score == sum(question_votes[qid].values())",
      "Log previous vote and new vote when calculating delta",
      "Log reputation before/after each vote operation"
    ],
    "how_to_localize": "1. Print vote tracking state before and after operation. 2. Verify previous_vote is correct. 3. Check delta calculation. 4. Verify reputation update."
  },
  "edge_cases": [
    {
      "case": "Self-voting",
      "handling": "Return -1, no changes to score or reputation",
      "gotcha": "Must check author_id matches voter_id before any processing"
    },
    {
      "case": "Voting twice with same vote",
      "handling": "Return current score, no-op",
      "gotcha": "Don't add reputation again for duplicate votes"
    },
    {
      "case": "Changing vote (upvote to downvote)",
      "handling": "Score changes by -2, reputation changes by -12",
      "gotcha": "Must remove old reputation effect AND add new effect"
    },
    {
      "case": "Voting on non-existent item",
      "handling": "Return -1",
      "gotcha": "Check item existence before voter existence"
    },
    {
      "case": "Accepting already-accepted answer",
      "handling": "Return True but don't give additional reputation",
      "gotcha": "Idempotent operation - check accepted flag first"
    },
    {
      "case": "Non-author trying to accept answer",
      "handling": "Return False",
      "gotcha": "Must verify question.author_id == questionAuthorId"
    }
  ],
  "test_cases": [
    {
      "name": "Basic upvote",
      "input": "createUser(u1), createUser(u2), postQuestion(u1), upvoteQuestion(u2, q_1)",
      "expected": "Score=1, u1 reputation=10",
      "explanation": "Standard upvote flow"
    },
    {
      "name": "Self-vote rejected",
      "input": "createUser(u1), postQuestion(u1), upvoteQuestion(u1, q_1)",
      "expected": "-1",
      "explanation": "Cannot vote on own content"
    },
    {
      "name": "Vote change",
      "input": "...upvote(u2, q_1) then downvote(u2, q_1)",
      "expected": "Score goes 0\u21921\u2192-1, reputation goes 0\u219210\u2192-2",
      "explanation": "Changing vote updates both score and reputation correctly"
    },
    {
      "name": "Accept answer",
      "input": "Alice posts Q, Bob answers, Alice accepts",
      "expected": "Bob gets +15 reputation, answer.accepted=True",
      "explanation": "Accept flow with authorization check"
    },
    {
      "name": "Wrong person accepts",
      "input": "Alice posts Q, Bob answers, Charlie tries to accept",
      "expected": "False",
      "explanation": "Only question author can accept"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not handling vote changes correctly",
      "why_wrong": "When user changes from upvote to downvote, both the score delta (-2) and reputation delta (-12) must be calculated correctly",
      "correct_approach": "Calculate: scoreDelta = newVote - prevVote; repDelta = newRepEffect - oldRepEffect",
      "code_example_wrong": "// Wrong: Just overwrite\nvotes[item][voter] = newVote;\nitem.score = newVote;",
      "code_example_correct": "// Correct: Calculate delta\nint delta = newVote - prevVote;\nitem.score += delta;"
    },
    {
      "mistake": "Allowing self-voting",
      "why_wrong": "Stack Overflow doesn't allow users to vote on their own content",
      "correct_approach": "Check voterId != authorId before processing",
      "code_example_wrong": "// Missing check\npublic int upvote(String voterId, String itemId) {\n    // process vote...\n}",
      "code_example_correct": "if (voterId.equals(item.authorId)) {\n    return -1;\n}"
    },
    {
      "mistake": "Recalculating score from all votes",
      "why_wrong": "O(n) operation when O(1) is possible with incremental updates",
      "correct_approach": "Store score on object, update incrementally",
      "code_example_wrong": "// Wrong: Recalculate\nint score = 0;\nfor (int v : votes.values()) score += v;",
      "code_example_correct": "// Correct: Incremental\nitem.score += (newVote - prevVote);"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by saying: 'For Part 2, I need to add voting and reputation. The key insight is tracking previous vote state to calculate deltas. Let me add the data structures first, then implement the voting logic.'",
    "what_to_mention": [
      "Nested HashMap gives O(1) vote lookup",
      "Delta-based updates avoid recalculation",
      "Generic helper method reduces code duplication",
      "Self-voting prevention is a business rule"
    ],
    "time_allocation": "2 min understanding, 2 min explaining approach, 8 min coding, 3 min testing",
    "if_stuck": [
      "Think about what state you need to track for 'has this user voted before'",
      "Consider: what changes when a vote flips from up to down?",
      "Start with simple upvote, then generalize"
    ]
  },
  "connection_to_next_part": "Part 3 might add: vote removal (undo), voting history, reputation badges, or time-based features. Current design supports extension: add remove_vote() that sets vote to 0 and reverses reputation, or add timestamps to votes.",
  "communication_script": {
    "transition_from_previous": "Part 1 gives us the basic Q&A structure. Now I need to add voting. The main challenge is tracking who voted on what and correctly handling vote changes.",
    "explaining_changes": "I'll add two nested HashMaps for vote tracking - one for questions, one for answers. Structure is item_id -> (voter_id -> vote_value). I'll also add score to items and reputation to users.",
    "while_extending_code": [
      "Adding reputation field to User...",
      "Adding score field to Question and Answer...",
      "Creating vote tracking HashMaps...",
      "Now implementing the generic vote handler...",
      "Key logic: calculate delta from previous vote state"
    ],
    "after_completing": "Voting system is complete. All operations are O(1). The delta-based approach handles vote changes correctly. Ready for Part 3!"
  },
  "time_milestones": {
    "time_budget": "12-15 minutes for Part 2",
    "by_2_min": "Understand requirements: votes, reputation rules, constraints",
    "by_5_min": "Explain approach: nested HashMap, delta calculation, generic helper",
    "by_10_min": "Core implementation done: _apply_vote, upvote/downvote methods",
    "warning_signs": "If still designing at 6 min, start coding. Ask interviewer if unclear on reputation rules."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has a bug affecting voting, fix it first. Say: 'Let me fix the question lookup first before adding votes.'",
    "if_new_requirement_unclear": "Ask: 'When a vote changes from upvote to downvote, should reputation change be -12 (remove +10, add -2)?'",
    "if_running_behind": "Implement upvoteQuestion fully first, then copy pattern for others. Mention: 'Same pattern applies to answers.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing nested HashMap for O(1) lookup",
      "Proposing generic _apply_vote helper without prompting",
      "Correctly handling vote change delta on first try",
      "Mentioning idempotency for accept_answer",
      "Discussing what happens at reputation boundaries (can go negative?)"
    ]
  },
  "pattern_recognition": {
    "pattern": "State Tracking with Delta Updates",
    "indicators": [
      "Need to track per-user state (votes)",
      "State can change (vote flip)",
      "Need O(1) lookup of previous state",
      "Cumulative value (reputation) affected by state changes"
    ],
    "similar_problems": [
      "LC 146 - LRU Cache (tracking state per key)",
      "Rate limiter with sliding window",
      "Like/unlike system",
      "Stock buy/sell with transaction history"
    ],
    "template": "Use nested HashMap: entity_id -> (actor_id -> state). On update: lookup previous state, calculate delta, apply to aggregate, store new state."
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'one vote per user per item', I think nested HashMap",
      "why": "Need O(1) lookup for 'has this user voted on this item'"
    },
    {
      "step": 2,
      "thought": "Vote changes mean I can't just count votes",
      "why": "Need to track WHO voted, not just total"
    },
    {
      "step": 3,
      "thought": "Reputation is cumulative, so incremental updates",
      "why": "Recalculating from all votes would be O(n)"
    },
    {
      "step": 4,
      "thought": "Self-voting check comes early",
      "why": "Business rule that blocks entire operation"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend existing code cleanly without rewriting?",
      "Do you handle state changes correctly (vote flip)?",
      "Is your code DRY (generic helper)?",
      "Do you consider edge cases (self-vote, double accept)?"
    ],
    "bonus_points": [
      "Proposing the delta calculation without hints",
      "Mentioning O(1) complexity explicitly",
      "Using constants for reputation values",
      "Making accept_answer idempotent"
    ],
    "red_flags": [
      "Recalculating totals from scratch",
      "Separate implementations for upvote/downvote without noticing duplication",
      "Forgetting self-vote check",
      "Not handling vote changes"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for repetitive methods (upvote_answer mirrors upvote_question)",
      "Let AI help with docstrings",
      "Ask AI to spot missing edge cases"
    ],
    "what_not_to_do": [
      "Don't let AI design the vote tracking structure - understand it yourself",
      "Don't accept delta calculation without verifying the math"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about reputation rules if unclear",
      "Staying silent while figuring out delta calculation"
    ],
    "technical": [
      "Using list instead of HashMap for votes",
      "Modifying Part 1 methods unnecessarily",
      "Wrong delta math for vote changes"
    ],
    "communication": [
      "Not explaining the nested HashMap choice",
      "Not mentioning O(1) complexity"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Self-vote returns -1?",
      "Vote change updates BOTH score AND reputation?",
      "Accept answer is idempotent?",
      "All operations O(1)?",
      "Tested with the example inputs?"
    ],
    "quick_code_review": [
      "Vote tracking initialized when creating questions/answers",
      "Using constants for reputation values",
      "Type hints on all new methods",
      "Generic helper reduces duplication"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Rate limiting on voting (prevent vote manipulation)",
      "Audit log for vote changes",
      "Reputation floor (minimum 1)",
      "Database transactions for vote + reputation update"
    ],
    "why_not_in_interview": "Focus on core algorithm; these are infrastructure concerns",
    "how_to_mention": "Say: 'In production, I'd add rate limiting on votes and make the vote+reputation update atomic.'"
  },
  "generated_at": "2026-01-18T18:54:41.837592",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}