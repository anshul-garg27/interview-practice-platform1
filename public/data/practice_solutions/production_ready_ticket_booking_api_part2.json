{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 2: Authentication and Authorization",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 adds a security layer on top of Part 1's core CRUD functionality. We now need to verify WHO is making requests (authentication) and WHETHER they're allowed to perform the action (authorization). Every API endpoint must check tokens before processing, and different roles have different access levels. This transforms a simple API into a production-ready secure system.",
    "new_requirements": [
      "JWT-style token-based authentication",
      "Role-based access control (RBAC) with ADMIN, USER, GUEST roles",
      "Users can only access their own bookings (ownership check)",
      "Rate limiting on login attempts to prevent brute force",
      "New login endpoint that returns tokens",
      "Token validation on every protected endpoint"
    ],
    "new_constraints": [
      "Tokens must expire (security best practice)",
      "Password must never be stored in plaintext",
      "Authorization checks must happen BEFORE business logic",
      "Rate limiting: max 5 failed attempts per 5 minutes"
    ],
    "key_insight": "The AHA moment is separating authentication (WHO are you?) from authorization (WHAT can you do?). Check auth first, then authz, then process. This is the standard security middleware pattern used by every production API."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Users must authenticate to book",
        "how_met": "bookTickets() validates token and extracts userId before processing",
        "gotchas": [
          "Forgetting to check token expiry",
          "Not validating signature"
        ]
      },
      {
        "requirement": "Only admins can create events",
        "how_met": "createEvent() checks role == ADMIN after token validation",
        "gotchas": [
          "Checking role before validating token (wrong order)"
        ]
      },
      {
        "requirement": "Users can only view/cancel own bookings",
        "how_met": "getUserBookings() compares token.userId with requested userId",
        "gotchas": [
          "Admins should bypass this check - different path for admin"
        ]
      },
      {
        "requirement": "Rate limiting per user",
        "how_met": "Track failed attempts in HashMap with timestamps, block after 5 failures in 5 min",
        "gotchas": [
          "Using IP instead of username",
          "Not cleaning up old attempts"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "login",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup for user, constant time hash comparison"
      },
      {
        "operation": "validateToken",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "String parsing and HMAC comparison are constant time"
      },
      {
        "operation": "authorize",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Simple role comparison from parsed token"
      },
      {
        "operation": "getUserBookings",
        "target": "O(b)",
        "achieved": "O(b)",
        "why": "Must iterate through user's bookings, can't avoid this"
      }
    ],
    "non_goals": [
      "OAuth2/OpenID Connect integration (too complex for interview)",
      "Refresh tokens (would add but mention verbally)",
      "Password reset flow",
      "Multi-factor authentication",
      "Session management (using stateless JWT approach)"
    ]
  },
  "assumptions": [
    "Assumption: Simple token format (userId:timestamp:role:signature) is acceptable vs full JWT library - ASK: 'Is a simplified JWT acceptable or should I use a proper JWT library?'",
    "Assumption: Passwords are pre-hashed or we hash them ourselves - ASK: 'Should I implement password hashing or assume pre-hashed?'",
    "Assumption: Default admin/user accounts exist for testing - this is reasonable for demo",
    "Assumption: Token stored client-side, server is stateless - standard REST approach",
    "Assumption: HTTPS is handled at infrastructure layer, not in code"
  ],
  "tradeoffs": [
    {
      "decision": "Stateless JWT vs Session-based auth",
      "chosen": "Stateless JWT",
      "why": "Scales horizontally, no session store needed, fits interview constraints",
      "alternative": "Session-based",
      "when_to_switch": "If you need immediate token revocation (JWT can't truly revoke until expiry)"
    },
    {
      "decision": "Role in token vs lookup from DB",
      "chosen": "Role embedded in token",
      "why": "O(1) authorization without database hit",
      "alternative": "Lookup from DB",
      "when_to_switch": "If roles change frequently and you need immediate effect"
    },
    {
      "decision": "In-memory rate limiting vs Redis",
      "chosen": "In-memory HashMap",
      "why": "Simple for interview, works for single instance",
      "alternative": "Redis",
      "when_to_switch": "Multi-instance deployment requires distributed rate limiting"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Response format from Part 1 (status, body, success, error)",
      "Existing Event and Booking data structures",
      "Public method signatures from Part 1"
    ],
    "what_to_change": [
      "Add User class and users HashMap",
      "Add tokens HashMap for active sessions (optional for stateless)",
      "Add AuthService as separate class (clean separation)",
      "Modify existing methods to accept token parameter"
    ],
    "interfaces_and_boundaries": "AuthService is a separate class that TicketAPI delegates to. This allows swapping auth implementations. All auth logic is isolated, so Part 3 (concurrency, caching) won't need to touch auth code.",
    "invariants": [
      "A valid token always contains a valid user_id that exists in users map",
      "Token signature is tamper-proof (HMAC with secret key)",
      "No request modifies data without valid authentication (except public endpoints)",
      "Admin can access any resource, User can only access own resources"
    ]
  },
  "visual_explanation": {
    "before_after": "```\\n=== BEFORE (Part 1) ===\\n\\n    Request \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Process \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Response\\n    (no auth)                        (direct)\\n\\n\\n=== AFTER (Part 2) ===\\n\\n    Request \u2500\u2500\u25ba Auth \u2500\u2500\u25ba Authz \u2500\u2500\u25ba Process \u2500\u2500\u25ba Response\\n              Middleware  Check     Logic\\n                \u2502          \u2502\\n                \u25bc          \u25bc\\n             401 if      403 if\\n             invalid     forbidden\\n\\n\\nDATA STRUCTURES ADDED:\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502  users: HashMap<username, User>                     \u2502\\n\u2502    \u2514\u2500\u2500 User { userId, username, passwordHash, role }\u2502\\n\u2502                                                     \u2502\\n\u2502  loginAttempts: HashMap<username, List<timestamp>>  \u2502\\n\u2502    \u2514\u2500\u2500 Track failed logins for rate limiting        \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```",
    "algorithm_flow": "```\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502                    LOGIN FLOW                           \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502  1. Receive username + password                         \u2502\\n\u2502  2. Check rate limit (>5 fails in 5min = blocked)       \u2502\\n\u2502  3. Look up user by username                            \u2502\\n\u2502  4. Hash input password, compare with stored hash       \u2502\\n\u2502  5. If match: generate token = userId:time:role:sig     \u2502\\n\u2502  6. If no match: record failed attempt, return 401      \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502              PROTECTED ENDPOINT FLOW                    \u2502\\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\\n\u2502  1. Extract token from request                          \u2502\\n\u2502  2. Parse token: userId:timestamp:role:signature        \u2502\\n\u2502  3. Verify signature (HMAC with secret key)             \u2502\\n\u2502  4. Check expiry (current_time - timestamp < TTL)       \u2502\\n\u2502  5. Check role permission for this endpoint             \u2502\\n\u2502  6. Check ownership if applicable (own bookings)        \u2502\\n\u2502  7. If all pass: proceed to business logic              \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Check Auth Inside Each Method",
      "description": "Add auth checks directly in each existing method body. Copy-paste validation logic everywhere.",
      "time_complexity": "O(1) per check",
      "space_complexity": "O(u) for users",
      "why_not_optimal": "Violates DRY principle, easy to forget a check, hard to maintain. If auth logic changes, must update every method. Real systems use middleware pattern."
    },
    {
      "name": "Optimal Approach - Centralized Auth Service",
      "description": "Create a dedicated AuthService class that handles all authentication and authorization. Each API method calls authService.validateToken() and authService.authorize() before processing. Clean separation of concerns.",
      "time_complexity": "O(1) for token validation and authorization",
      "space_complexity": "O(u + a) where u=users, a=login attempts",
      "key_insight": "The middleware pattern: validate token once, extract user context, check permissions, then hand off to business logic. Same pattern used by Express.js, Spring Security, Django REST."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Layered Security with AuthService\n\n### Core Components\n\n1. **User Model**: Stores `userId`, `username`, `passwordHash`, and `role`. Password is **never** stored in plaintext.\n\n2. **Token Format**: `userId:timestamp:role:signature`\n   - **userId**: Identifies the user\n   - **timestamp**: When token was issued (for expiry check)\n   - **role**: Cached role for O(1) authorization\n   - **signature**: HMAC-SHA256 to prevent tampering\n\n3. **AuthService Class**: Handles all security logic\n   - `login()`: Validates credentials, generates token\n   - `validateToken()`: Parses and verifies token\n   - `authorize()`: Checks if role can perform action\n   - `checkOwnership()`: Verifies user owns resource\n\n4. **Rate Limiting**: Track failed attempts per username in sliding window (5 attempts per 5 minutes).\n\n### Key Design Decisions\n\n- **Stateless tokens**: No server-side session storage needed\n- **Role in token**: Avoids database lookup on every request\n- **Separate AuthService**: Clean boundaries, testable, replaceable\n- **Guard clauses**: Check auth early, fail fast with proper HTTP status codes\n\n### Access Control Implementation\n\n```python\ndef require_role(self, token: str, *allowed_roles: Role) -> Response | None:\n    user = self.validate_token(token)\n    if not user:\n        return Response(401, error=\"UNAUTHORIZED\")\n    if user.role not in allowed_roles:\n        return Response(403, error=\"FORBIDDEN\")\n    return None  # Proceed with request\n```",
    "data_structures": [
      {
        "structure": "HashMap<username, User>",
        "purpose": "O(1) user lookup during login"
      },
      {
        "structure": "HashMap<username, List<timestamp>>",
        "purpose": "Track failed login attempts for rate limiting"
      },
      {
        "structure": "Role Enum",
        "purpose": "Type-safe role representation (GUEST, USER, ADMIN)"
      },
      {
        "structure": "User dataclass",
        "purpose": "Immutable user record with id, username, passwordHash, role"
      }
    ],
    "algorithm_steps": [
      "Step 1: On login request, check rate limit for username",
      "Step 2: Look up user by username, hash input password",
      "Step 3: Compare hashes using constant-time comparison",
      "Step 4: If match, generate token with HMAC signature",
      "Step 5: On API request, extract and parse token",
      "Step 6: Verify signature matches (tamper check)",
      "Step 7: Check timestamp for expiry",
      "Step 8: Check role against endpoint requirements",
      "Step 9: For user-specific resources, verify ownership",
      "Step 10: If all pass, execute business logic"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Production-Ready Event Ticket Booking API - Part 2: Authentication & Authorization",
    "",
    "This module extends Part 1 with:",
    "- JWT-style token authentication",
    "- Role-based access control (RBAC)",
    "- Rate limiting on login attempts",
    "- Ownership verification for user resources",
    "\"\"\"",
    "",
    "import hashlib",
    "import hmac",
    "import time",
    "import re",
    "from typing import Dict, List, Optional, Any, Tuple",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "from threading import Lock",
    "from datetime import datetime",
    "from decimal import Decimal",
    "",
    "",
    "# ============================================================",
    "# ENUMS AND DATA CLASSES",
    "# ============================================================",
    "",
    "class Role(Enum):",
    "    \"\"\"User roles with hierarchical permissions.\"\"\"",
    "    GUEST = \"GUEST\"",
    "    USER = \"USER\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"Represents a system user.\"\"\"",
    "    user_id: str",
    "    username: str",
    "    password_hash: str",
    "    role: Role",
    "    created_at: float = field(default_factory=time.time)",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"Represents a bookable event.\"\"\"",
    "    event_id: str",
    "    name: str",
    "    date: str",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "    created_by: str  # user_id of creator",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Represents a ticket booking.\"\"\"",
    "    booking_id: str",
    "    event_id: str",
    "    user_id: str",
    "    quantity: int",
    "    total_price: Decimal",
    "    status: str",
    "    created_at: float = field(default_factory=time.time)",
    "",
    "",
    "@dataclass",
    "class LoginRequest:",
    "    \"\"\"Login request payload.\"\"\"",
    "    username: str",
    "    password: str",
    "",
    "",
    "@dataclass",
    "class EventRequest:",
    "    \"\"\"Event creation request payload.\"\"\"",
    "    name: str",
    "    date: str",
    "    venue: str",
    "    total_tickets: int",
    "    price_per_ticket: float",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Booking request payload.\"\"\"",
    "    event_id: str",
    "    quantity: int",
    "",
    "",
    "class Response:",
    "    \"\"\"Standardized API response.\"\"\"",
    "    ",
    "    def __init__(self, status: int, body: Optional[Dict] = None, ",
    "                 error: Optional[Dict] = None):",
    "        self.status = status",
    "        self.body = body or {}",
    "        if error:",
    "            self.body = {",
    "                \"success\": False,",
    "                \"error\": error",
    "            }",
    "        elif \"success\" not in self.body:",
    "            self.body[\"success\"] = status < 400",
    "    ",
    "    def __repr__(self):",
    "        return f\"Response(status={self.status}, body={self.body})\"",
    "",
    "",
    "# ============================================================",
    "# AUTHENTICATION SERVICE",
    "# ============================================================",
    "",
    "class AuthService:",
    "    \"\"\"",
    "    Handles authentication and authorization.",
    "    ",
    "    Token format: userId:timestamp:role:signature",
    "    - userId: Unique user identifier",
    "    - timestamp: Token issue time (Unix seconds)",
    "    - role: User's role for authorization",
    "    - signature: HMAC-SHA256 for integrity",
    "    \"\"\"",
    "    ",
    "    SECRET_KEY = \"super-secret-key-change-in-production\"",
    "    TOKEN_EXPIRY_SECONDS = 3600  # 1 hour",
    "    MAX_LOGIN_ATTEMPTS = 5",
    "    RATE_LIMIT_WINDOW = 300  # 5 minutes",
    "    ",
    "    def __init__(self):",
    "        self.users: Dict[str, User] = {}",
    "        self.users_by_id: Dict[str, User] = {}",
    "        self.login_attempts: Dict[str, List[float]] = {}",
    "        self.lock = Lock()",
    "        self._init_default_users()",
    "    ",
    "    def _init_default_users(self) -> None:",
    "        \"\"\"Create default admin and user accounts for testing.\"\"\"",
    "        self.register_user(\"admin\", \"admin123\", Role.ADMIN)",
    "        self.register_user(\"user\", \"user123\", Role.USER)",
    "    ",
    "    def _hash_password(self, password: str) -> str:",
    "        \"\"\"Hash password using SHA-256. Production: use bcrypt.\"\"\"",
    "        return hashlib.sha256(password.encode()).hexdigest()",
    "    ",
    "    def register_user(self, username: str, password: str, ",
    "                      role: Role = Role.USER) -> User:",
    "        \"\"\"Register a new user in the system.\"\"\"",
    "        user_id = f\"usr_{len(self.users) + 1:03d}\"",
    "        user = User(",
    "            user_id=user_id,",
    "            username=username,",
    "            password_hash=self._hash_password(password),",
    "            role=role",
    "        )",
    "        self.users[username] = user",
    "        self.users_by_id[user_id] = user",
    "        return user",
    "    ",
    "    def _generate_token(self, user: User) -> str:",
    "        \"\"\"",
    "        Generate a signed token for authenticated user.",
    "        ",
    "        Format: userId:timestamp:role:signature",
    "        \"\"\"",
    "        timestamp = int(time.time())",
    "        payload = f\"{user.user_id}:{timestamp}:{user.role.value}\"",
    "        signature = hmac.new(",
    "            self.SECRET_KEY.encode(),",
    "            payload.encode(),",
    "            hashlib.sha256",
    "        ).hexdigest()[:16]  # Truncate for brevity",
    "        return f\"{payload}:{signature}\"",
    "    ",
    "    def validate_token(self, token: Optional[str]) -> Optional[Dict[str, Any]]:",
    "        \"\"\"",
    "        Validate token and return user context if valid.",
    "        ",
    "        Returns: {user_id, role, timestamp} or None if invalid",
    "        \"\"\"",
    "        if not token:",
    "            return None",
    "        ",
    "        try:",
    "            parts = token.split(\":\")",
    "            if len(parts) != 4:",
    "                return None",
    "            ",
    "            user_id, timestamp_str, role_str, signature = parts",
    "            ",
    "            # Verify signature (tamper check)",
    "            payload = f\"{user_id}:{timestamp_str}:{role_str}\"",
    "            expected_sig = hmac.new(",
    "                self.SECRET_KEY.encode(),",
    "                payload.encode(),",
    "                hashlib.sha256",
    "            ).hexdigest()[:16]",
    "            ",
    "            if not hmac.compare_digest(signature, expected_sig):",
    "                return None",
    "            ",
    "            # Check expiry",
    "            timestamp = int(timestamp_str)",
    "            if int(time.time()) - timestamp > self.TOKEN_EXPIRY_SECONDS:",
    "                return None",
    "            ",
    "            # Verify user still exists",
    "            if user_id not in self.users_by_id:",
    "                return None",
    "            ",
    "            return {",
    "                \"user_id\": user_id,",
    "                \"role\": Role(role_str),",
    "                \"timestamp\": timestamp,",
    "                \"user\": self.users_by_id[user_id]",
    "            }",
    "        except (ValueError, KeyError):",
    "            return None",
    "    ",
    "    def _is_rate_limited(self, username: str) -> bool:",
    "        \"\"\"Check if user has exceeded login attempt limit.\"\"\"",
    "        with self.lock:",
    "            if username not in self.login_attempts:",
    "                return False",
    "            ",
    "            current_time = time.time()",
    "            # Clean old attempts and check count",
    "            recent = [t for t in self.login_attempts[username] ",
    "                     if current_time - t < self.RATE_LIMIT_WINDOW]",
    "            self.login_attempts[username] = recent",
    "            return len(recent) >= self.MAX_LOGIN_ATTEMPTS",
    "    ",
    "    def _record_failed_attempt(self, username: str) -> None:",
    "        \"\"\"Record a failed login attempt for rate limiting.\"\"\"",
    "        with self.lock:",
    "            if username not in self.login_attempts:",
    "                self.login_attempts[username] = []",
    "            self.login_attempts[username].append(time.time())",
    "    ",
    "    def login(self, request: LoginRequest) -> Response:",
    "        \"\"\"",
    "        Authenticate user and return token.",
    "        ",
    "        Returns:",
    "            200 + token on success",
    "            401 on invalid credentials",
    "            429 on rate limit exceeded",
    "        \"\"\"",
    "        # Input validation",
    "        if not request.username or not request.password:",
    "            return Response(400, error={",
    "                \"code\": \"INVALID_INPUT\",",
    "                \"message\": \"Username and password required\"",
    "            })",
    "        ",
    "        # Rate limit check",
    "        if self._is_rate_limited(request.username):",
    "            return Response(429, error={",
    "                \"code\": \"RATE_LIMITED\",",
    "                \"message\": \"Too many login attempts. Try again later.\"",
    "            })",
    "        ",
    "        # Credential validation",
    "        user = self.users.get(request.username)",
    "        if not user:",
    "            self._record_failed_attempt(request.username)",
    "            return Response(401, error={",
    "                \"code\": \"UNAUTHORIZED\",",
    "                \"message\": \"Invalid credentials\"",
    "            })",
    "        ",
    "        # Password check (constant-time comparison)",
    "        input_hash = self._hash_password(request.password)",
    "        if not hmac.compare_digest(user.password_hash, input_hash):",
    "            self._record_failed_attempt(request.username)",
    "            return Response(401, error={",
    "                \"code\": \"UNAUTHORIZED\",",
    "                \"message\": \"Invalid credentials\"",
    "            })",
    "        ",
    "        # Success: generate token",
    "        token = self._generate_token(user)",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"token\": token,",
    "            \"role\": user.role.value,",
    "            \"userId\": user.user_id",
    "        })",
    "    ",
    "    def get_user_by_id(self, user_id: str) -> Optional[User]:",
    "        \"\"\"Get user by ID.\"\"\"",
    "        return self.users_by_id.get(user_id)",
    "",
    "",
    "# ============================================================",
    "# MAIN TICKET API WITH AUTHENTICATION",
    "# ============================================================",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready Ticket Booking API with authentication.",
    "    ",
    "    All modifying operations require authentication.",
    "    Role-based access control enforced on all endpoints.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.auth_service = AuthService()",
    "        self.events: Dict[str, Event] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self.user_bookings: Dict[str, List[str]] = {}  # userId -> [bookingIds]",
    "        self.event_counter = 0",
    "        self.booking_counter = 0",
    "        self.lock = Lock()",
    "    ",
    "    # ----------------------------------------------------------",
    "    # HELPER: Authorization Decorators",
    "    # ----------------------------------------------------------",
    "    ",
    "    def _require_auth(self, token: str) -> Tuple[Optional[Response], Optional[Dict]]:",
    "        \"\"\"",
    "        Validate token and return user context.",
    "        ",
    "        Returns: (error_response, user_context)",
    "        - If error: (Response, None)",
    "        - If success: (None, user_context)",
    "        \"\"\"",
    "        user_ctx = self.auth_service.validate_token(token)",
    "        if not user_ctx:",
    "            return (Response(401, error={",
    "                \"code\": \"UNAUTHORIZED\",",
    "                \"message\": \"Invalid or expired token\"",
    "            }), None)",
    "        return (None, user_ctx)",
    "    ",
    "    def _require_role(self, user_ctx: Dict, *allowed_roles: Role) -> Optional[Response]:",
    "        \"\"\"Check if user has required role. Returns error response if not.\"\"\"",
    "        if user_ctx[\"role\"] not in allowed_roles:",
    "            return Response(403, error={",
    "                \"code\": \"FORBIDDEN\",",
    "                \"message\": f\"{allowed_roles[0].value} role required\"",
    "            })",
    "        return None",
    "    ",
    "    def _require_ownership(self, user_ctx: Dict, resource_user_id: str) -> Optional[Response]:",
    "        \"\"\"Check if user owns resource or is admin.\"\"\"",
    "        if user_ctx[\"role\"] == Role.ADMIN:",
    "            return None  # Admins can access any resource",
    "        if user_ctx[\"user_id\"] != resource_user_id:",
    "            return Response(403, error={",
    "                \"code\": \"FORBIDDEN\",",
    "                \"message\": \"Access denied to this resource\"",
    "            })",
    "        return None",
    "    ",
    "    # ----------------------------------------------------------",
    "    # INPUT VALIDATION",
    "    # ----------------------------------------------------------",
    "    ",
    "    def _validate_event_request(self, request: EventRequest) -> Optional[Response]:",
    "        \"\"\"Validate event creation request.\"\"\"",
    "        errors = []",
    "        ",
    "        if not request.name or len(request.name.strip()) < 3:",
    "            errors.append(\"Name must be at least 3 characters\")",
    "        if len(request.name) > 200:",
    "            errors.append(\"Name too long (max 200 characters)\")",
    "        ",
    "        # Sanitize name",
    "        if request.name and re.search(r'[<>\"\\';]', request.name):",
    "            errors.append(\"Name contains invalid characters\")",
    "        ",
    "        if not request.venue or len(request.venue.strip()) < 3:",
    "            errors.append(\"Venue must be at least 3 characters\")",
    "        ",
    "        if request.total_tickets <= 0:",
    "            errors.append(\"Total tickets must be positive\")",
    "        if request.total_tickets > 100000:",
    "            errors.append(\"Total tickets exceeds maximum (100000)\")",
    "        ",
    "        if request.price_per_ticket < 0:",
    "            errors.append(\"Price cannot be negative\")",
    "        if request.price_per_ticket > 10000:",
    "            errors.append(\"Price exceeds maximum ($10000)\")",
    "        ",
    "        # Validate date format",
    "        try:",
    "            datetime.fromisoformat(request.date.replace('Z', '+00:00'))",
    "        except ValueError:",
    "            errors.append(\"Invalid date format (use ISO 8601)\")",
    "        ",
    "        if errors:",
    "            return Response(400, error={",
    "                \"code\": \"VALIDATION_ERROR\",",
    "                \"message\": \"Invalid request\",",
    "                \"details\": errors",
    "            })",
    "        return None",
    "    ",
    "    # ----------------------------------------------------------",
    "    # PUBLIC ENDPOINTS",
    "    # ----------------------------------------------------------",
    "    ",
    "    def login(self, request: LoginRequest) -> Response:",
    "        \"\"\"",
    "        Authenticate user and return JWT token.",
    "        ",
    "        Public endpoint - no authentication required.",
    "        \"\"\"",
    "        return self.auth_service.login(request)",
    "    ",
    "    def get_current_user(self, token: str) -> Response:",
    "        \"\"\"",
    "        Get current user details from token.",
    "        ",
    "        Requires: Valid token",
    "        \"\"\"",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        user = user_ctx[\"user\"]",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"data\": {",
    "                \"userId\": user.user_id,",
    "                \"username\": user.username,",
    "                \"role\": user.role.value",
    "            }",
    "        })",
    "    ",
    "    def list_events(self, token: Optional[str] = None) -> Response:",
    "        \"\"\"",
    "        List all events.",
    "        ",
    "        Public endpoint - guests can view (no auth required).",
    "        \"\"\"",
    "        events_list = [",
    "            {",
    "                \"eventId\": e.event_id,",
    "                \"name\": e.name,",
    "                \"date\": e.date,",
    "                \"venue\": e.venue,",
    "                \"availableTickets\": e.available_tickets,",
    "                \"pricePerTicket\": float(e.price_per_ticket)",
    "            }",
    "            for e in self.events.values()",
    "        ]",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"data\": events_list",
    "        })",
    "    ",
    "    def get_event(self, event_id: str, token: Optional[str] = None) -> Response:",
    "        \"\"\"",
    "        Get event details by ID.",
    "        ",
    "        Public endpoint - guests can view.",
    "        \"\"\"",
    "        if event_id not in self.events:",
    "            return Response(404, error={",
    "                \"code\": \"NOT_FOUND\",",
    "                \"message\": f\"Event {event_id} not found\"",
    "            })",
    "        ",
    "        e = self.events[event_id]",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"data\": {",
    "                \"eventId\": e.event_id,",
    "                \"name\": e.name,",
    "                \"date\": e.date,",
    "                \"venue\": e.venue,",
    "                \"totalTickets\": e.total_tickets,",
    "                \"availableTickets\": e.available_tickets,",
    "                \"pricePerTicket\": float(e.price_per_ticket)",
    "            }",
    "        })",
    "    ",
    "    # ----------------------------------------------------------",
    "    # ADMIN ONLY ENDPOINTS",
    "    # ----------------------------------------------------------",
    "    ",
    "    def create_event(self, request: EventRequest, token: str) -> Response:",
    "        \"\"\"",
    "        Create a new event.",
    "        ",
    "        Requires: ADMIN role",
    "        \"\"\"",
    "        # Step 1: Authentication",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Step 2: Authorization",
    "        role_error = self._require_role(user_ctx, Role.ADMIN)",
    "        if role_error:",
    "            return role_error",
    "        ",
    "        # Step 3: Input validation",
    "        validation_error = self._validate_event_request(request)",
    "        if validation_error:",
    "            return validation_error",
    "        ",
    "        # Step 4: Business logic",
    "        with self.lock:",
    "            self.event_counter += 1",
    "            event_id = f\"evt_{self.event_counter:03d}\"",
    "            ",
    "            event = Event(",
    "                event_id=event_id,",
    "                name=request.name.strip(),",
    "                date=request.date,",
    "                venue=request.venue.strip(),",
    "                total_tickets=request.total_tickets,",
    "                available_tickets=request.total_tickets,",
    "                price_per_ticket=Decimal(str(request.price_per_ticket)),",
    "                created_by=user_ctx[\"user_id\"]",
    "            )",
    "            self.events[event_id] = event",
    "        ",
    "        return Response(201, body={",
    "            \"success\": True,",
    "            \"data\": {\"eventId\": event_id}",
    "        })",
    "    ",
    "    def delete_event(self, event_id: str, token: str) -> Response:",
    "        \"\"\"",
    "        Delete an event.",
    "        ",
    "        Requires: ADMIN role",
    "        \"\"\"",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        role_error = self._require_role(user_ctx, Role.ADMIN)",
    "        if role_error:",
    "            return role_error",
    "        ",
    "        with self.lock:",
    "            if event_id not in self.events:",
    "                return Response(404, error={",
    "                    \"code\": \"NOT_FOUND\",",
    "                    \"message\": f\"Event {event_id} not found\"",
    "                })",
    "            del self.events[event_id]",
    "        ",
    "        return Response(200, body={\"success\": True, \"message\": \"Event deleted\"})",
    "    ",
    "    # ----------------------------------------------------------",
    "    # USER ENDPOINTS (Authenticated users)",
    "    # ----------------------------------------------------------",
    "    ",
    "    def book_tickets(self, request: BookingRequest, token: str) -> Response:",
    "        \"\"\"",
    "        Book tickets for an event.",
    "        ",
    "        Requires: USER or ADMIN role",
    "        \"\"\"",
    "        # Authentication",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Authorization",
    "        role_error = self._require_role(user_ctx, Role.USER, Role.ADMIN)",
    "        if role_error:",
    "            return role_error",
    "        ",
    "        # Validation",
    "        if request.quantity <= 0:",
    "            return Response(400, error={",
    "                \"code\": \"VALIDATION_ERROR\",",
    "                \"message\": \"Quantity must be positive\"",
    "            })",
    "        if request.quantity > 10:",
    "            return Response(400, error={",
    "                \"code\": \"VALIDATION_ERROR\",",
    "                \"message\": \"Maximum 10 tickets per booking\"",
    "            })",
    "        ",
    "        # Business logic with lock for concurrency safety",
    "        with self.lock:",
    "            if request.event_id not in self.events:",
    "                return Response(404, error={",
    "                    \"code\": \"NOT_FOUND\",",
    "                    \"message\": f\"Event {request.event_id} not found\"",
    "                })",
    "            ",
    "            event = self.events[request.event_id]",
    "            ",
    "            if event.available_tickets < request.quantity:",
    "                return Response(409, error={",
    "                    \"code\": \"INSUFFICIENT_TICKETS\",",
    "                    \"message\": f\"Only {event.available_tickets} tickets available\"",
    "                })",
    "            ",
    "            # Create booking",
    "            self.booking_counter += 1",
    "            booking_id = f\"bkg_{self.booking_counter:03d}\"",
    "            user_id = user_ctx[\"user_id\"]",
    "            ",
    "            booking = Booking(",
    "                booking_id=booking_id,",
    "                event_id=request.event_id,",
    "                user_id=user_id,",
    "                quantity=request.quantity,",
    "                total_price=event.price_per_ticket * request.quantity,",
    "                status=\"CONFIRMED\"",
    "            )",
    "            ",
    "            # Update state atomically",
    "            event.available_tickets -= request.quantity",
    "            self.bookings[booking_id] = booking",
    "            ",
    "            if user_id not in self.user_bookings:",
    "                self.user_bookings[user_id] = []",
    "            self.user_bookings[user_id].append(booking_id)",
    "        ",
    "        return Response(201, body={",
    "            \"success\": True,",
    "            \"data\": {",
    "                \"bookingId\": booking_id,",
    "                \"totalPrice\": float(booking.total_price)",
    "            }",
    "        })",
    "    ",
    "    def get_user_bookings(self, token: str, user_id: str) -> Response:",
    "        \"\"\"",
    "        Get bookings for a user.",
    "        ",
    "        Requires: ADMIN (any user) or USER (own bookings only)",
    "        \"\"\"",
    "        # Authentication",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Ownership check (admin can see any, user can see own)",
    "        ownership_error = self._require_ownership(user_ctx, user_id)",
    "        if ownership_error:",
    "            return ownership_error",
    "        ",
    "        # Get bookings",
    "        booking_ids = self.user_bookings.get(user_id, [])",
    "        bookings_list = []",
    "        ",
    "        for bid in booking_ids:",
    "            if bid in self.bookings:",
    "                b = self.bookings[bid]",
    "                bookings_list.append({",
    "                    \"bookingId\": b.booking_id,",
    "                    \"eventId\": b.event_id,",
    "                    \"quantity\": b.quantity,",
    "                    \"totalPrice\": float(b.total_price),",
    "                    \"status\": b.status",
    "                })",
    "        ",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"data\": bookings_list",
    "        })",
    "    ",
    "    def cancel_booking(self, booking_id: str, token: str) -> Response:",
    "        \"\"\"",
    "        Cancel a booking.",
    "        ",
    "        Requires: ADMIN (any booking) or USER (own booking only)",
    "        \"\"\"",
    "        # Authentication",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        with self.lock:",
    "            if booking_id not in self.bookings:",
    "                return Response(404, error={",
    "                    \"code\": \"NOT_FOUND\",",
    "                    \"message\": f\"Booking {booking_id} not found\"",
    "                })",
    "            ",
    "            booking = self.bookings[booking_id]",
    "            ",
    "            # Ownership check",
    "            ownership_error = self._require_ownership(user_ctx, booking.user_id)",
    "            if ownership_error:",
    "                return ownership_error",
    "            ",
    "            if booking.status == \"CANCELLED\":",
    "                return Response(400, error={",
    "                    \"code\": \"ALREADY_CANCELLED\",",
    "                    \"message\": \"Booking already cancelled\"",
    "                })",
    "            ",
    "            # Restore tickets",
    "            if booking.event_id in self.events:",
    "                self.events[booking.event_id].available_tickets += booking.quantity",
    "            ",
    "            booking.status = \"CANCELLED\"",
    "        ",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"message\": \"Booking cancelled successfully\"",
    "        })",
    "    ",
    "    def get_all_bookings(self, token: str) -> Response:",
    "        \"\"\"",
    "        Get all bookings in the system.",
    "        ",
    "        Requires: ADMIN role",
    "        \"\"\"",
    "        error, user_ctx = self._require_auth(token)",
    "        if error:",
    "            return error",
    "        ",
    "        role_error = self._require_role(user_ctx, Role.ADMIN)",
    "        if role_error:",
    "            return role_error",
    "        ",
    "        bookings_list = [",
    "            {",
    "                \"bookingId\": b.booking_id,",
    "                \"eventId\": b.event_id,",
    "                \"userId\": b.user_id,",
    "                \"quantity\": b.quantity,",
    "                \"totalPrice\": float(b.total_price),",
    "                \"status\": b.status",
    "            }",
    "            for b in self.bookings.values()",
    "        ]",
    "        ",
    "        return Response(200, body={",
    "            \"success\": True,",
    "            \"data\": bookings_list",
    "        })",
    "",
    "",
    "# ============================================================",
    "# DEMO AND TESTING",
    "# ============================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate Part 2: Authentication & Authorization.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"TICKET BOOKING API - PART 2: AUTHENTICATION & AUTHORIZATION\")",
    "    print(\"=\" * 70)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 1: Admin Login and Event Creation",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 1: Admin Login and Event Creation\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # Admin login",
    "    admin_login = api.login(LoginRequest(\"admin\", \"admin123\"))",
    "    print(f\"Admin login: {admin_login.status}\")",
    "    print(f\"Response: {admin_login.body}\")",
    "    admin_token = admin_login.body.get(\"token\", \"\")",
    "    ",
    "    # Create event as admin",
    "    event_req = EventRequest(",
    "        name=\"Taylor Swift Concert\",",
    "        date=\"2024-12-25T20:00:00Z\",",
    "        venue=\"Madison Square Garden\",",
    "        total_tickets=500,",
    "        price_per_ticket=150.00",
    "    )",
    "    create_result = api.create_event(event_req, admin_token)",
    "    print(f\"Create event: {create_result.status}\")",
    "    print(f\"Response: {create_result.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 2: Regular User Cannot Create Events",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 2: Regular User Cannot Create Events (403 Forbidden)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # User login",
    "    user_login = api.login(LoginRequest(\"user\", \"user123\"))",
    "    print(f\"User login: {user_login.status}\")",
    "    user_token = user_login.body.get(\"token\", \"\")",
    "    user_id = user_login.body.get(\"userId\", \"\")",
    "    ",
    "    # Try to create event as user (should fail)",
    "    user_event = api.create_event(event_req, user_token)",
    "    print(f\"User create event: {user_event.status}\")",
    "    print(f\"Response: {user_event.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 3: User Can Book Tickets",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 3: User Booking Tickets\")",
    "    print(\"-\" * 70)",
    "    ",
    "    booking_req = BookingRequest(event_id=\"evt_001\", quantity=2)",
    "    booking_result = api.book_tickets(booking_req, user_token)",
    "    print(f\"Booking result: {booking_result.status}\")",
    "    print(f\"Response: {booking_result.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 4: User Can View Own Bookings",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 4: User Views Own Bookings\")",
    "    print(\"-\" * 70)",
    "    ",
    "    my_bookings = api.get_user_bookings(user_token, user_id)",
    "    print(f\"My bookings: {my_bookings.status}\")",
    "    print(f\"Response: {my_bookings.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 5: User Cannot View Other User's Bookings",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 5: User Cannot View Other's Bookings (403)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    other_bookings = api.get_user_bookings(user_token, \"usr_001\")  # Admin's ID",
    "    print(f\"Other's bookings: {other_bookings.status}\")",
    "    print(f\"Response: {other_bookings.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 6: Admin Can View Any User's Bookings",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 6: Admin Can View Any User's Bookings\")",
    "    print(\"-\" * 70)",
    "    ",
    "    admin_view = api.get_user_bookings(admin_token, user_id)",
    "    print(f\"Admin view user bookings: {admin_view.status}\")",
    "    print(f\"Response: {admin_view.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 7: Guest Can View Events (No Token)",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 7: Guest Can View Events (No Auth Required)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    events = api.list_events()",
    "    print(f\"List events: {events.status}\")",
    "    print(f\"Response: {events.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 8: Guest Cannot Book (401)",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 8: Guest Cannot Book (401 Unauthorized)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    guest_booking = api.book_tickets(booking_req, \"\")",
    "    print(f\"Guest booking: {guest_booking.status}\")",
    "    print(f\"Response: {guest_booking.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 9: Invalid Token (401)",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 9: Invalid Token Rejected\")",
    "    print(\"-\" * 70)",
    "    ",
    "    invalid_result = api.get_current_user(\"fake:token:here:abc123\")",
    "    print(f\"Invalid token: {invalid_result.status}\")",
    "    print(f\"Response: {invalid_result.body}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 10: Rate Limiting",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 10: Rate Limiting (5 failed attempts)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    for i in range(6):",
    "        result = api.login(LoginRequest(\"testuser\", \"wrongpass\"))",
    "        print(f\"Attempt {i+1}: {result.status} - {result.body.get('error', {}).get('code', 'N/A')}\")",
    "    ",
    "    # ----------------------------------------------------------",
    "    # Test 11: Cancel Own Booking",
    "    # ----------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"TEST 11: User Cancels Own Booking\")",
    "    print(\"-\" * 70)",
    "    ",
    "    cancel_result = api.cancel_booking(\"bkg_001\", user_token)",
    "    print(f\"Cancel booking: {cancel_result.status}\")",
    "    print(f\"Response: {cancel_result.body}\")",
    "    ",
    "    # Verify tickets restored",
    "    event_after = api.get_event(\"evt_001\")",
    "    print(f\"Tickets after cancel: {event_after.body['data']['availableTickets']}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"ALL TESTS COMPLETED\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.security.MessageDigest;",
    "import java.security.NoSuchAlgorithmException;",
    "import java.time.Instant;",
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "import java.util.stream.Collectors;",
    "import javax.crypto.Mac;",
    "import javax.crypto.spec.SecretKeySpec;",
    "import java.math.BigDecimal;",
    "",
    "/**",
    " * Production-Ready Event Ticket Booking API",
    " * Part 2: Authentication & Authorization",
    " */",
    "public class TicketBookingAPI {",
    "",
    "    // ============================================================",
    "    // ENUMS",
    "    // ============================================================",
    "    ",
    "    public enum Role {",
    "        GUEST, USER, ADMIN",
    "    }",
    "",
    "    // ============================================================",
    "    // DATA CLASSES",
    "    // ============================================================",
    "    ",
    "    public static class User {",
    "        public final String userId;",
    "        public final String username;",
    "        public final String passwordHash;",
    "        public final Role role;",
    "        ",
    "        public User(String userId, String username, String passwordHash, Role role) {",
    "            this.userId = userId;",
    "            this.username = username;",
    "            this.passwordHash = passwordHash;",
    "            this.role = role;",
    "        }",
    "    }",
    "    ",
    "    public static class Event {",
    "        public final String eventId;",
    "        public String name;",
    "        public String date;",
    "        public String venue;",
    "        public int totalTickets;",
    "        public int availableTickets;",
    "        public BigDecimal pricePerTicket;",
    "        public String createdBy;",
    "        ",
    "        public Event(String eventId, String name, String date, String venue,",
    "                     int totalTickets, BigDecimal pricePerTicket, String createdBy) {",
    "            this.eventId = eventId;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "            this.createdBy = createdBy;",
    "        }",
    "    }",
    "    ",
    "    public static class Booking {",
    "        public final String bookingId;",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int quantity;",
    "        public final BigDecimal totalPrice;",
    "        public String status;",
    "        ",
    "        public Booking(String bookingId, String eventId, String userId,",
    "                       int quantity, BigDecimal totalPrice) {",
    "            this.bookingId = bookingId;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.quantity = quantity;",
    "            this.totalPrice = totalPrice;",
    "            this.status = \"CONFIRMED\";",
    "        }",
    "    }",
    "    ",
    "    public static class LoginRequest {",
    "        public final String username;",
    "        public final String password;",
    "        ",
    "        public LoginRequest(String username, String password) {",
    "            this.username = username;",
    "            this.password = password;",
    "        }",
    "    }",
    "    ",
    "    public static class EventRequest {",
    "        public String name;",
    "        public String date;",
    "        public String venue;",
    "        public int totalTickets;",
    "        public double pricePerTicket;",
    "        ",
    "        public EventRequest(String name, String date, String venue,",
    "                           int totalTickets, double pricePerTicket) {",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "    }",
    "    ",
    "    public static class BookingRequest {",
    "        public final String eventId;",
    "        public final int quantity;",
    "        ",
    "        public BookingRequest(String eventId, int quantity) {",
    "            this.eventId = eventId;",
    "            this.quantity = quantity;",
    "        }",
    "    }",
    "    ",
    "    public static class Response {",
    "        public final int status;",
    "        public final Map<String, Object> body;",
    "        ",
    "        public Response(int status, Map<String, Object> body) {",
    "            this.status = status;",
    "            this.body = body != null ? body : new HashMap<>();",
    "        }",
    "        ",
    "        public static Response success(int status, Map<String, Object> data) {",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", true);",
    "            body.put(\"data\", data);",
    "            return new Response(status, body);",
    "        }",
    "        ",
    "        public static Response error(int status, String code, String message) {",
    "            Map<String, Object> body = new HashMap<>();",
    "            body.put(\"success\", false);",
    "            Map<String, String> error = new HashMap<>();",
    "            error.put(\"code\", code);",
    "            error.put(\"message\", message);",
    "            body.put(\"error\", error);",
    "            return new Response(status, body);",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return \"Response{status=\" + status + \", body=\" + body + \"}\";",
    "        }",
    "    }",
    "    ",
    "    public static class UserContext {",
    "        public final String userId;",
    "        public final Role role;",
    "        public final User user;",
    "        ",
    "        public UserContext(String userId, Role role, User user) {",
    "            this.userId = userId;",
    "            this.role = role;",
    "            this.user = user;",
    "        }",
    "    }",
    "",
    "    // ============================================================",
    "    // AUTH SERVICE",
    "    // ============================================================",
    "    ",
    "    public static class AuthService {",
    "        private static final String SECRET_KEY = \"super-secret-key\";",
    "        private static final long TOKEN_EXPIRY_SECONDS = 3600;",
    "        private static final int MAX_LOGIN_ATTEMPTS = 5;",
    "        private static final long RATE_LIMIT_WINDOW = 300;",
    "        ",
    "        private final Map<String, User> users = new ConcurrentHashMap<>();",
    "        private final Map<String, User> usersById = new ConcurrentHashMap<>();",
    "        private final Map<String, List<Long>> loginAttempts = new ConcurrentHashMap<>();",
    "        ",
    "        public AuthService() {",
    "            registerUser(\"admin\", \"admin123\", Role.ADMIN);",
    "            registerUser(\"user\", \"user123\", Role.USER);",
    "        }",
    "        ",
    "        private String hashPassword(String password) {",
    "            try {",
    "                MessageDigest md = MessageDigest.getInstance(\"SHA-256\");",
    "                byte[] hash = md.digest(password.getBytes());",
    "                StringBuilder sb = new StringBuilder();",
    "                for (byte b : hash) {",
    "                    sb.append(String.format(\"%02x\", b));",
    "                }",
    "                return sb.toString();",
    "            } catch (NoSuchAlgorithmException e) {",
    "                throw new RuntimeException(e);",
    "            }",
    "        }",
    "        ",
    "        public User registerUser(String username, String password, Role role) {",
    "            String userId = String.format(\"usr_%03d\", users.size() + 1);",
    "            User user = new User(userId, username, hashPassword(password), role);",
    "            users.put(username, user);",
    "            usersById.put(userId, user);",
    "            return user;",
    "        }",
    "        ",
    "        private String generateToken(User user) {",
    "            long timestamp = Instant.now().getEpochSecond();",
    "            String payload = user.userId + \":\" + timestamp + \":\" + user.role.name();",
    "            String signature = hmacSign(payload).substring(0, 16);",
    "            return payload + \":\" + signature;",
    "        }",
    "        ",
    "        private String hmacSign(String data) {",
    "            try {",
    "                Mac mac = Mac.getInstance(\"HmacSHA256\");",
    "                mac.init(new SecretKeySpec(SECRET_KEY.getBytes(), \"HmacSHA256\"));",
    "                byte[] hash = mac.doFinal(data.getBytes());",
    "                StringBuilder sb = new StringBuilder();",
    "                for (byte b : hash) {",
    "                    sb.append(String.format(\"%02x\", b));",
    "                }",
    "                return sb.toString();",
    "            } catch (Exception e) {",
    "                throw new RuntimeException(e);",
    "            }",
    "        }",
    "        ",
    "        public UserContext validateToken(String token) {",
    "            if (token == null || token.isEmpty()) return null;",
    "            ",
    "            String[] parts = token.split(\":\");",
    "            if (parts.length != 4) return null;",
    "            ",
    "            String userId = parts[0];",
    "            long timestamp;",
    "            try {",
    "                timestamp = Long.parseLong(parts[1]);",
    "            } catch (NumberFormatException e) {",
    "                return null;",
    "            }",
    "            String roleStr = parts[2];",
    "            String signature = parts[3];",
    "            ",
    "            // Verify signature",
    "            String payload = userId + \":\" + timestamp + \":\" + roleStr;",
    "            String expectedSig = hmacSign(payload).substring(0, 16);",
    "            if (!MessageDigest.isEqual(signature.getBytes(), expectedSig.getBytes())) {",
    "                return null;",
    "            }",
    "            ",
    "            // Check expiry",
    "            if (Instant.now().getEpochSecond() - timestamp > TOKEN_EXPIRY_SECONDS) {",
    "                return null;",
    "            }",
    "            ",
    "            User user = usersById.get(userId);",
    "            if (user == null) return null;",
    "            ",
    "            return new UserContext(userId, Role.valueOf(roleStr), user);",
    "        }",
    "        ",
    "        private boolean isRateLimited(String username) {",
    "            List<Long> attempts = loginAttempts.get(username);",
    "            if (attempts == null) return false;",
    "            long now = Instant.now().getEpochSecond();",
    "            long count = attempts.stream()",
    "                .filter(t -> now - t < RATE_LIMIT_WINDOW)",
    "                .count();",
    "            return count >= MAX_LOGIN_ATTEMPTS;",
    "        }",
    "        ",
    "        private void recordFailedAttempt(String username) {",
    "            loginAttempts.computeIfAbsent(username, k -> new ArrayList<>())",
    "                .add(Instant.now().getEpochSecond());",
    "        }",
    "        ",
    "        public Response login(LoginRequest request) {",
    "            if (request.username == null || request.password == null) {",
    "                return Response.error(400, \"INVALID_INPUT\", \"Username and password required\");",
    "            }",
    "            ",
    "            if (isRateLimited(request.username)) {",
    "                return Response.error(429, \"RATE_LIMITED\", \"Too many login attempts\");",
    "            }",
    "            ",
    "            User user = users.get(request.username);",
    "            if (user == null || !user.passwordHash.equals(hashPassword(request.password))) {",
    "                recordFailedAttempt(request.username);",
    "                return Response.error(401, \"UNAUTHORIZED\", \"Invalid credentials\");",
    "            }",
    "            ",
    "            String token = generateToken(user);",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"token\", token);",
    "            data.put(\"role\", user.role.name());",
    "            data.put(\"userId\", user.userId);",
    "            return new Response(200, Map.of(\"success\", true, \"token\", token, ",
    "                \"role\", user.role.name(), \"userId\", user.userId));",
    "        }",
    "        ",
    "        public User getUserById(String userId) {",
    "            return usersById.get(userId);",
    "        }",
    "    }",
    "",
    "    // ============================================================",
    "    // TICKET API",
    "    // ============================================================",
    "    ",
    "    private final AuthService authService = new AuthService();",
    "    private final Map<String, Event> events = new ConcurrentHashMap<>();",
    "    private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userBookings = new ConcurrentHashMap<>();",
    "    private int eventCounter = 0;",
    "    private int bookingCounter = 0;",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    ",
    "    // Helper: Require authentication",
    "    private UserContext requireAuth(String token) {",
    "        return authService.validateToken(token);",
    "    }",
    "    ",
    "    // Helper: Require role",
    "    private Response requireRole(UserContext ctx, Role... roles) {",
    "        for (Role role : roles) {",
    "            if (ctx.role == role) return null;",
    "        }",
    "        return Response.error(403, \"FORBIDDEN\", roles[0].name() + \" role required\");",
    "    }",
    "    ",
    "    // Helper: Require ownership",
    "    private Response requireOwnership(UserContext ctx, String resourceUserId) {",
    "        if (ctx.role == Role.ADMIN) return null;",
    "        if (!ctx.userId.equals(resourceUserId)) {",
    "            return Response.error(403, \"FORBIDDEN\", \"Access denied\");",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    public Response login(LoginRequest request) {",
    "        return authService.login(request);",
    "    }",
    "    ",
    "    public Response getCurrentUser(String token) {",
    "        UserContext ctx = requireAuth(token);",
    "        if (ctx == null) {",
    "            return Response.error(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        }",
    "        return Response.success(200, Map.of(",
    "            \"userId\", ctx.userId,",
    "            \"username\", ctx.user.username,",
    "            \"role\", ctx.role.name()",
    "        ));",
    "    }",
    "    ",
    "    public Response listEvents() {",
    "        List<Map<String, Object>> list = events.values().stream()",
    "            .map(e -> Map.<String, Object>of(",
    "                \"eventId\", e.eventId,",
    "                \"name\", e.name,",
    "                \"availableTickets\", e.availableTickets",
    "            ))",
    "            .collect(Collectors.toList());",
    "        return Response.success(200, Map.of(\"events\", list));",
    "    }",
    "    ",
    "    public Response createEvent(EventRequest request, String token) {",
    "        UserContext ctx = requireAuth(token);",
    "        if (ctx == null) {",
    "            return Response.error(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        }",
    "        ",
    "        Response roleError = requireRole(ctx, Role.ADMIN);",
    "        if (roleError != null) return roleError;",
    "        ",
    "        lock.lock();",
    "        try {",
    "            eventCounter++;",
    "            String eventId = String.format(\"evt_%03d\", eventCounter);",
    "            Event event = new Event(eventId, request.name, request.date,",
    "                request.venue, request.totalTickets,",
    "                BigDecimal.valueOf(request.pricePerTicket), ctx.userId);",
    "            events.put(eventId, event);",
    "            return Response.success(201, Map.of(\"eventId\", eventId));",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    public Response bookTickets(BookingRequest request, String token) {",
    "        UserContext ctx = requireAuth(token);",
    "        if (ctx == null) {",
    "            return Response.error(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        }",
    "        ",
    "        Response roleError = requireRole(ctx, Role.USER, Role.ADMIN);",
    "        if (roleError != null) return roleError;",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Event event = events.get(request.eventId);",
    "            if (event == null) {",
    "                return Response.error(404, \"NOT_FOUND\", \"Event not found\");",
    "            }",
    "            if (event.availableTickets < request.quantity) {",
    "                return Response.error(409, \"INSUFFICIENT_TICKETS\", \"Not enough tickets\");",
    "            }",
    "            ",
    "            bookingCounter++;",
    "            String bookingId = String.format(\"bkg_%03d\", bookingCounter);",
    "            BigDecimal total = event.pricePerTicket.multiply(BigDecimal.valueOf(request.quantity));",
    "            Booking booking = new Booking(bookingId, request.eventId, ctx.userId,",
    "                request.quantity, total);",
    "            ",
    "            event.availableTickets -= request.quantity;",
    "            bookings.put(bookingId, booking);",
    "            userBookings.computeIfAbsent(ctx.userId, k -> new ArrayList<>()).add(bookingId);",
    "            ",
    "            return Response.success(201, Map.of(\"bookingId\", bookingId, \"totalPrice\", total));",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    public Response getUserBookings(String token, String userId) {",
    "        UserContext ctx = requireAuth(token);",
    "        if (ctx == null) {",
    "            return Response.error(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        }",
    "        ",
    "        Response ownershipError = requireOwnership(ctx, userId);",
    "        if (ownershipError != null) return ownershipError;",
    "        ",
    "        List<String> bookingIds = userBookings.getOrDefault(userId, new ArrayList<>());",
    "        List<Map<String, Object>> list = bookingIds.stream()",
    "            .filter(bookings::containsKey)",
    "            .map(id -> {",
    "                Booking b = bookings.get(id);",
    "                return Map.<String, Object>of(",
    "                    \"bookingId\", b.bookingId,",
    "                    \"eventId\", b.eventId,",
    "                    \"quantity\", b.quantity,",
    "                    \"status\", b.status",
    "                );",
    "            })",
    "            .collect(Collectors.toList());",
    "        return Response.success(200, Map.of(\"bookings\", list));",
    "    }",
    "    ",
    "    public Response cancelBooking(String bookingId, String token) {",
    "        UserContext ctx = requireAuth(token);",
    "        if (ctx == null) {",
    "            return Response.error(401, \"UNAUTHORIZED\", \"Invalid token\");",
    "        }",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Booking booking = bookings.get(bookingId);",
    "            if (booking == null) {",
    "                return Response.error(404, \"NOT_FOUND\", \"Booking not found\");",
    "            }",
    "            ",
    "            Response ownershipError = requireOwnership(ctx, booking.userId);",
    "            if (ownershipError != null) return ownershipError;",
    "            ",
    "            if (\"CANCELLED\".equals(booking.status)) {",
    "                return Response.error(400, \"ALREADY_CANCELLED\", \"Already cancelled\");",
    "            }",
    "            ",
    "            Event event = events.get(booking.eventId);",
    "            if (event != null) {",
    "                event.availableTickets += booking.quantity;",
    "            }",
    "            booking.status = \"CANCELLED\";",
    "            ",
    "            return Response.success(200, Map.of(\"message\", \"Booking cancelled\"));",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    // ============================================================",
    "    // MAIN DEMO",
    "    // ============================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(70));",
    "        System.out.println(\"TICKET API - PART 2: AUTHENTICATION & AUTHORIZATION\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        TicketBookingAPI api = new TicketBookingAPI();",
    "        ",
    "        // Test 1: Admin login and event creation",
    "        System.out.println(\"\\nTEST 1: Admin Login\");",
    "        Response adminLogin = api.login(new LoginRequest(\"admin\", \"admin123\"));",
    "        System.out.println(adminLogin);",
    "        String adminToken = (String) adminLogin.body.get(\"token\");",
    "        ",
    "        Response createEvent = api.createEvent(",
    "            new EventRequest(\"Concert\", \"2024-12-25\", \"Arena\", 100, 50.0),",
    "            adminToken);",
    "        System.out.println(\"Create event: \" + createEvent);",
    "        ",
    "        // Test 2: User cannot create events",
    "        System.out.println(\"\\nTEST 2: User Cannot Create Events\");",
    "        Response userLogin = api.login(new LoginRequest(\"user\", \"user123\"));",
    "        String userToken = (String) userLogin.body.get(\"token\");",
    "        String userId = (String) userLogin.body.get(\"userId\");",
    "        ",
    "        Response userCreateEvent = api.createEvent(",
    "            new EventRequest(\"User Event\", \"2024-12-25\", \"Venue\", 100, 50.0),",
    "            userToken);",
    "        System.out.println(\"User create event: \" + userCreateEvent);",
    "        ",
    "        // Test 3: User can book",
    "        System.out.println(\"\\nTEST 3: User Books Tickets\");",
    "        Response booking = api.bookTickets(new BookingRequest(\"evt_001\", 2), userToken);",
    "        System.out.println(\"Booking: \" + booking);",
    "        ",
    "        // Test 4: User views own bookings",
    "        System.out.println(\"\\nTEST 4: User Views Own Bookings\");",
    "        Response myBookings = api.getUserBookings(userToken, userId);",
    "        System.out.println(\"My bookings: \" + myBookings);",
    "        ",
    "        // Test 5: User cannot view others' bookings",
    "        System.out.println(\"\\nTEST 5: User Cannot View Others' Bookings\");",
    "        Response othersBookings = api.getUserBookings(userToken, \"usr_001\");",
    "        System.out.println(\"Others' bookings: \" + othersBookings);",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"ALL TESTS COMPLETED\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "explanation": "Imports and module docstring explaining Part 2 additions"
    },
    {
      "lines": "25-40",
      "explanation": "Role enum and User dataclass - core auth models"
    },
    {
      "lines": "42-80",
      "explanation": "Event, Booking, Request dataclasses - same as Part 1 with userId additions"
    },
    {
      "lines": "82-100",
      "explanation": "Response class with success/error factory patterns"
    },
    {
      "lines": "105-140",
      "explanation": "AuthService initialization with default users and password hashing"
    },
    {
      "lines": "142-165",
      "explanation": "Token generation: userId:timestamp:role:signature format using HMAC"
    },
    {
      "lines": "167-210",
      "explanation": "Token validation: parse, verify signature, check expiry, return user context"
    },
    {
      "lines": "212-240",
      "explanation": "Rate limiting: track failed attempts, block after 5 in 5 minutes"
    },
    {
      "lines": "242-285",
      "explanation": "Login method: rate limit check \u2192 credential validation \u2192 token generation"
    },
    {
      "lines": "295-330",
      "explanation": "TicketAPI helper methods: _require_auth, _require_role, _require_ownership"
    },
    {
      "lines": "335-380",
      "explanation": "Protected endpoints: create_event (ADMIN only), book_tickets (USER+ADMIN)"
    },
    {
      "lines": "382-430",
      "explanation": "Ownership-checked endpoints: get_user_bookings, cancel_booking"
    },
    {
      "lines": "435-550",
      "explanation": "Comprehensive demo testing all auth scenarios"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "login": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup + constant-time password hash comparison"
        },
        "validateToken": {
          "complexity": "O(1)",
          "explanation": "String parsing and HMAC computation are constant time"
        },
        "authorize": {
          "complexity": "O(1)",
          "explanation": "Simple enum comparison"
        },
        "requireOwnership": {
          "complexity": "O(1)",
          "explanation": "String comparison of user IDs"
        },
        "getUserBookings": {
          "complexity": "O(b)",
          "explanation": "Must iterate user's bookings list where b = number of bookings"
        }
      },
      "overall_change": "All auth operations are O(1). No change to core business logic complexity from Part 1. Rate limiting cleanup is O(a) where a = login attempts, but bounded by window."
    },
    "space": {
      "additional_space": "O(u + a) where u = number of users, a = login attempt records",
      "explanation": "New data structures: users HashMap, usersById HashMap, loginAttempts HashMap. Token is stateless (not stored server-side)."
    }
  },
  "dry_run": {
    "example_input": "Admin creates event, User tries to create event (fails), User books tickets",
    "steps": [
      {
        "step": 1,
        "action": "admin login with 'admin/admin123'",
        "state": "users={'admin':User, 'user':User}",
        "explanation": "Look up admin, verify password hash matches"
      },
      {
        "step": 2,
        "action": "generate token for admin",
        "state": "token='usr_001:1703520000:ADMIN:abc123def'",
        "explanation": "Create payload, compute HMAC signature"
      },
      {
        "step": 3,
        "action": "admin calls createEvent with token",
        "state": "Validate token \u2192 role=ADMIN \u2713",
        "explanation": "Parse token, verify signature, check role"
      },
      {
        "step": 4,
        "action": "create event in events map",
        "state": "events={'evt_001': Event}",
        "explanation": "Event created, return 201"
      },
      {
        "step": 5,
        "action": "user login with 'user/user123'",
        "state": "token='usr_002:1703520005:USER:xyz789'",
        "explanation": "Different token with USER role"
      },
      {
        "step": 6,
        "action": "user calls createEvent with token",
        "state": "Validate token \u2192 role=USER \u2717",
        "explanation": "Token valid but role is USER not ADMIN"
      },
      {
        "step": 7,
        "action": "return 403 Forbidden",
        "state": "No change to events",
        "explanation": "Authorization failed, request rejected"
      },
      {
        "step": 8,
        "action": "user calls bookTickets",
        "state": "Validate token \u2192 role=USER \u2713",
        "explanation": "USER role allowed for booking"
      },
      {
        "step": 9,
        "action": "create booking, reduce available tickets",
        "state": "bookings={'bkg_001': Booking}, events.evt_001.available=498",
        "explanation": "Booking success, return 201"
      }
    ],
    "final_output": "Admin: 200 (login), 201 (event). User: 200 (login), 403 (event), 201 (booking)"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Login with valid credentials returns 200 + token",
      "Login with wrong password returns 401",
      "Valid token + wrong role returns 403 (not 401)"
    ],
    "likely_bugs": [
      "Checking role before validating token (wrong order)",
      "Using == instead of .equals() for string comparison (Java)",
      "Not using constant-time comparison for password/signature",
      "Forgetting to check token expiry",
      "Admins blocked by ownership check (should bypass)"
    ],
    "recommended_logs_or_asserts": [
      "Log token validation result: 'Token valid: userId={}, role={}'",
      "Log auth failures: 'Auth failed: reason={}'",
      "Assert: after login, token is non-empty",
      "Assert: role from token matches role from user lookup"
    ],
    "how_to_localize": "1. Print token after login. 2. Manually decode token parts. 3. Verify signature computation. 4. Check expiry calculation. 5. Trace role comparison."
  },
  "edge_cases": [
    {
      "case": "Empty token",
      "handling": "validateToken returns None \u2192 401",
      "gotcha": "Check null AND empty string"
    },
    {
      "case": "Expired token",
      "handling": "Check timestamp difference > TTL \u2192 401",
      "gotcha": "Use server time, not token time for comparison"
    },
    {
      "case": "Tampered token",
      "handling": "Signature mismatch \u2192 401",
      "gotcha": "Use constant-time comparison to prevent timing attacks"
    },
    {
      "case": "Deleted user with valid token",
      "handling": "User lookup fails \u2192 401",
      "gotcha": "Token may be valid signature-wise but user no longer exists"
    },
    {
      "case": "Admin viewing user bookings",
      "handling": "Skip ownership check for ADMIN role",
      "gotcha": "Check role first in requireOwnership"
    },
    {
      "case": "5 failed logins then correct password",
      "handling": "Still blocked for rate limit window",
      "gotcha": "Rate limit by username, not by correct/incorrect"
    }
  ],
  "test_cases": [
    {
      "name": "Admin can create events",
      "input": "login(admin/admin123) \u2192 createEvent(concert, token)",
      "expected": "200 (login with token), 201 (event created)",
      "explanation": "Happy path for admin operations"
    },
    {
      "name": "User cannot create events",
      "input": "login(user/user123) \u2192 createEvent(concert, token)",
      "expected": "200 (login), 403 (forbidden)",
      "explanation": "Role check blocks non-admin"
    },
    {
      "name": "Invalid token rejected",
      "input": "createEvent(concert, 'invalid:token')",
      "expected": "401 (unauthorized)",
      "explanation": "Malformed token rejected before role check"
    },
    {
      "name": "User can only see own bookings",
      "input": "getUserBookings(userToken, otherUserId)",
      "expected": "403 (forbidden)",
      "explanation": "Ownership check prevents cross-user access"
    },
    {
      "name": "Rate limiting after 5 failures",
      "input": "5x login(user/wrong) \u2192 login(user/correct)",
      "expected": "5x 401, then 429 (rate limited)",
      "explanation": "6th attempt blocked regardless of credentials"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking authorization before authentication",
      "why_wrong": "Must verify token is valid before checking role. Invalid token should be 401, not 403.",
      "correct_approach": "Always: 1) Validate token 2) Check role 3) Process request",
      "code_example_wrong": "if user.role != ADMIN: return 403  # What if token is invalid?",
      "code_example_correct": "user = validate_token(token)\\nif not user: return 401\\nif user.role != ADMIN: return 403"
    },
    {
      "mistake": "Storing passwords in plaintext",
      "why_wrong": "Database breach exposes all passwords. Never store plaintext.",
      "correct_approach": "Hash with SHA-256 (interview) or bcrypt (production)",
      "code_example_wrong": "user.password = request.password",
      "code_example_correct": "user.password_hash = hashlib.sha256(password.encode()).hexdigest()"
    },
    {
      "mistake": "Non-constant-time password comparison",
      "why_wrong": "Timing attacks can reveal password character-by-character",
      "correct_approach": "Use hmac.compare_digest() or MessageDigest.isEqual()",
      "code_example_wrong": "if stored_hash == input_hash:",
      "code_example_correct": "if hmac.compare_digest(stored_hash, input_hash):"
    },
    {
      "mistake": "Admin blocked by ownership check",
      "why_wrong": "Admin should have access to all resources",
      "correct_approach": "Check if role is ADMIN first, skip ownership check",
      "code_example_wrong": "if ctx.user_id != resource.user_id: return 403",
      "code_example_correct": "if ctx.role == ADMIN: return None  # Allow\\nif ctx.user_id != resource.user_id: return 403"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the security flow: 'Every request goes through auth middleware - first I validate the token, then check permissions, then process.' Draw the flow diagram. Then show the access control matrix.",
    "what_to_mention": [
      "Authentication vs Authorization distinction",
      "Token format and why each field is needed",
      "Why constant-time comparison matters (timing attacks)",
      "Rate limiting to prevent brute force",
      "Stateless tokens for horizontal scaling"
    ],
    "time_allocation": "15-20 min: 3 min explain auth design, 10 min implement, 2 min test edge cases",
    "if_stuck": [
      "Start with just login() returning a simple token",
      "Add validateToken() that parses the token",
      "Add role check as a helper function",
      "Apply helpers to existing endpoints"
    ]
  },
  "connection_to_next_part": "Part 3 will likely add concurrency handling and caching. The AuthService is already thread-safe with locks. The token validation is stateless, so it scales for concurrent requests. We might add token caching to avoid re-parsing, or use Redis for distributed rate limiting.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 handles the core CRUD operations. For Part 2, I need to add authentication and authorization. The key challenge is securing every endpoint while keeping the code clean. Let me walk you through my approach.",
    "explaining_changes": "I'll create a separate AuthService class to handle all security concerns. This follows the single responsibility principle. The main API delegates to AuthService before processing any request.",
    "while_extending_code": [
      "I'm adding a User class with userId, username, passwordHash, and role...",
      "The token format is userId:timestamp:role:signature - this gives me everything I need for stateless auth...",
      "I'm using HMAC-SHA256 for the signature to prevent token tampering...",
      "Each protected endpoint will call _require_auth() first, then _require_role()..."
    ],
    "after_completing": "This now handles auth for all endpoints. Login is O(1), token validation is O(1). The authorization checks add negligible overhead. I've also added rate limiting on login to prevent brute force attacks. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Understand auth vs authz, sketch the token format, identify which endpoints need which protection",
    "by_5_min": "AuthService class structure defined, login() working",
    "by_10_min": "Token validation working, helper methods for role/ownership checks",
    "by_15_min": "All endpoints secured, testing the access matrix",
    "warning_signs": "If still designing at 8 min, simplify token format. If auth logic is complex, ask if simpler approach is OK."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has bugs affecting auth (e.g., missing userId on bookings), fix it first: 'I notice I need to add userId to bookings for ownership checks. Let me update Part 1.'",
    "if_new_requirement_unclear": "Ask: 'For the token, should I use a full JWT library or is a simple signed format acceptable?' or 'Should admins be able to act on behalf of users?'",
    "if_running_behind": "Prioritize: 1) login() working 2) token validation 3) role check on createEvent 4) other endpoints. Skip rate limiting if needed, mention it verbally."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning constant-time comparison to prevent timing attacks",
      "Separating AuthService for clean architecture",
      "Discussing stateless tokens for horizontal scaling",
      "Proactively adding rate limiting",
      "Explaining the 401 vs 403 distinction"
    ]
  },
  "pattern_recognition": {
    "pattern": "Authentication Middleware + Role-Based Access Control (RBAC)",
    "indicators": [
      "Need to verify WHO is making request (auth)",
      "Need to check WHAT they can do (authz)",
      "Different users have different permissions",
      "Resources have owners"
    ],
    "similar_problems": [
      "LC 1396 - Design Underground System (user tracking)",
      "Any API design problem with user context",
      "E-commerce systems with seller/buyer roles"
    ],
    "template": "def protected_endpoint(token, ...):\\n    user = validate_token(token)\\n    if not user: return 401\\n    if not has_permission(user, 'action'): return 403\\n    # business logic"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'users must be authenticated', I immediately think of JWT/tokens",
      "why": "Stateless auth is standard for APIs, allows horizontal scaling"
    },
    {
      "step": 2,
      "thought": "Different roles with different permissions = RBAC pattern",
      "why": "Access control matrix makes permissions clear and maintainable"
    },
    {
      "step": 3,
      "thought": "'Only own bookings' = ownership check",
      "why": "Common pattern: is requester the resource owner OR admin?"
    },
    {
      "step": 4,
      "thought": "Rate limiting on login = security best practice",
      "why": "Prevents brute force password attacks"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you understand auth vs authz?",
      "Can you implement secure token handling?",
      "Do you think about edge cases (expired token, tampered token)?",
      "Is your code organized and maintainable?"
    ],
    "bonus_points": [
      "Constant-time comparison mention",
      "Clean separation of AuthService",
      "Proactive rate limiting",
      "Understanding of security implications"
    ],
    "red_flags": [
      "Storing plaintext passwords",
      "No token expiry",
      "Checking authz before auth",
      "Copy-pasting auth logic into every method"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for HMAC boilerplate code",
      "Let it generate the hash function",
      "Ask for token parsing logic"
    ],
    "what_not_to_do": [
      "Don't accept without understanding the security implications",
      "Don't let AI skip the authz checks",
      "Verify the token format makes sense"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about password storage requirements",
      "Assuming auth approach without clarifying"
    ],
    "technical": [
      "Using non-constant-time string comparison for passwords",
      "Forgetting to check token expiry",
      "Not separating auth concerns into service"
    ],
    "communication": [
      "Not explaining the auth flow clearly",
      "Forgetting to mention security considerations"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does login return a token?",
      "Does token validation check signature AND expiry?",
      "Does every protected endpoint check auth first?",
      "Can users only access their own bookings?",
      "Can admins access everything?",
      "Is rate limiting implemented?"
    ],
    "quick_code_review": [
      "No plaintext password storage",
      "Constant-time comparison for secrets",
      "Auth before authz order",
      "Clean helper methods for auth checks"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Use bcrypt instead of SHA-256 for password hashing",
      "Refresh tokens for long sessions",
      "Token blacklist for logout/revocation",
      "Audit logging for security events",
      "Password complexity requirements",
      "HTTPS enforcement"
    ],
    "why_not_in_interview": "Focus on core auth logic; these are infrastructure concerns",
    "how_to_mention": "Say: 'In production, I'd use bcrypt for passwords and add refresh tokens, but SHA-256 is fine for demonstrating the concept.'"
  },
  "generated_at": "2026-01-18T21:45:43.899353",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}