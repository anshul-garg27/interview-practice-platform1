{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 4: Direct Messaging (DMs)",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "This part introduces real-time bidirectional communication for messaging. Unlike Parts 1-3 which focused on request-response patterns for feeds and search, DMs require persistent WebSocket connections, message ordering guarantees, and handling both online and offline users. We must now manage connection state, implement pub/sub patterns, and ensure exactly-once message delivery.",
    "new_requirements": [
      "Real-time message delivery under 100ms for online users",
      "Support 10M concurrent WebSocket connections",
      "Persistent message storage with ordering guarantees",
      "Read receipts with delivery status tracking",
      "Group chat support with fan-out to multiple recipients",
      "Offline message queuing and sync on reconnect"
    ],
    "new_constraints": [
      "Messages must be delivered in order within a conversation",
      "System must handle network partitions gracefully",
      "Horizontal scaling of WebSocket servers with sticky sessions",
      "Exactly-once delivery semantics"
    ],
    "key_insight": "Decouple message persistence from delivery. Store first (for durability), then push asynchronously (for speed). Use Kafka partitioned by conversation_id to guarantee ordering, and Redis to track which WebSocket server each user is connected to for routing."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Real-time message delivery",
        "how_met": "WebSocket connections maintained by gateway cluster, with Redis tracking user\u2192server mapping for message routing",
        "gotchas": [
          "WebSocket reconnection handling",
          "Server failover during active sessions"
        ]
      },
      {
        "requirement": "Message ordering",
        "how_met": "Kafka partitioned by conversation_id ensures FIFO within conversation; sequence numbers handle client-side reordering",
        "gotchas": [
          "Clock skew between servers",
          "Out-of-order acknowledgments"
        ]
      },
      {
        "requirement": "Offline handling",
        "how_met": "Pending messages stored in database, push notifications sent, full sync on reconnect using last_seen_message_id",
        "gotchas": [
          "Large message backlogs",
          "Pagination during sync"
        ]
      },
      {
        "requirement": "Group chat fan-out",
        "how_met": "Write to shared conversation partition, WebSocket gateway fans out to all online group members",
        "gotchas": [
          "Large groups causing hot partitions",
          "Typing indicators at scale"
        ]
      },
      {
        "requirement": "Read receipts",
        "how_met": "markAsRead updates conversation state, broadcasts receipt to sender via same pub/sub channel",
        "gotchas": [
          "Aggregating receipts for groups",
          "Privacy considerations"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "sendMessage",
        "target": "O(group_size)",
        "achieved": "O(group_size)",
        "why": "Must notify all online members in a group"
      },
      {
        "operation": "getConversations",
        "target": "O(1) with caching",
        "achieved": "O(1)",
        "why": "Cached conversation list per user in Redis"
      },
      {
        "operation": "getMessages",
        "target": "O(page_size)",
        "achieved": "O(page_size)",
        "why": "Cassandra range query on partition key"
      }
    ],
    "non_goals": [
      "End-to-end encryption implementation (mentioned but not fully implemented)",
      "Voice/video calling",
      "Message reactions (could be Part 5)",
      "Message editing/deletion history"
    ]
  },
  "assumptions": [
    "Messages are immutable once sent (no edit history complexity)",
    "Group size limit of ~256 members (Instagram default)",
    "Users have unique IDs; authentication is handled externally",
    "Media is uploaded separately; messages contain media URLs",
    "Interviewer accepts simulated WebSocket behavior in demo code"
  ],
  "tradeoffs": [
    {
      "decision": "Cassandra vs PostgreSQL for messages",
      "chosen": "Cassandra",
      "why": "Optimized for write-heavy workloads, easy sharding by conversation_id, time-series queries for message history",
      "alternative": "PostgreSQL",
      "when_to_switch": "If you need complex joins or ACID transactions across conversations"
    },
    {
      "decision": "Push vs Pull for message delivery",
      "chosen": "Push (WebSocket)",
      "why": "Lower latency (<100ms requirement), better UX, reduced client polling",
      "alternative": "Long polling",
      "when_to_switch": "If clients can't maintain WebSocket connections (firewalls, etc.)"
    },
    {
      "decision": "Fan-out on write vs fan-out on read for group messages",
      "chosen": "Fan-out on write",
      "why": "Single write to shared conversation partition, fan-out only for delivery notification",
      "alternative": "Fan-out on read",
      "when_to_switch": "If groups become very large (1000+ members)"
    },
    {
      "decision": "Redis vs Dedicated presence service",
      "chosen": "Redis",
      "why": "Simple key-value store sufficient for session mapping, built-in TTL for cleanup",
      "alternative": "Custom presence service",
      "when_to_switch": "If presence requires complex logic like multi-device handling"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Message and Conversation data models",
      "WebSocket connection protocol",
      "Kafka topic partitioning scheme",
      "API signatures for sendMessage, getConversations, getMessages"
    ],
    "what_to_change": [
      "Added MessageService class for messaging logic",
      "Added WebSocketManager for connection handling",
      "Added PresenceTracker for online status",
      "Extended User model with presence info"
    ],
    "interfaces_and_boundaries": "MessageService is decoupled from WebSocket layer. Storage layer (Cassandra abstraction) is separate from delivery layer. This allows adding reactions, replies, or voice messages by extending Message class without touching delivery code.",
    "invariants": [
      "Messages within a conversation maintain sequence order",
      "A user has exactly one active WebSocket per device",
      "Undelivered messages are never lost",
      "Read receipts are idempotent"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3 - Request/Response):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    HTTP    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    Query    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502   API   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502    DB    \u2502\n\u2502        \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 Gateway \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  Response  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   Result    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER (Part 4 - Bidirectional Real-time):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 WebSocket  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   Publish   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502   WS    \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502  Kafka   \u2502\n\u2502        \u2502            \u2502 Gateway \u2502             \u2502          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n     \u25b2                     \u2502                       \u2502\n     \u2502                     \u2502 Store                 \u2502 Route\n     \u2502                     \u25bc                       \u25bc\n     \u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502               \u2502 Cassandra\u2502           \u2502  Redis   \u2502\n     \u2502               \u2502 Messages \u2502           \u2502 Sessions \u2502\n     \u2502               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502                                           \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Push to correct server \u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nMESSAGE FLOW (sendMessage):\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\nStep 1: API receives message from sender\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 {sender: A, conv: 123,      \u2502\n        \u2502  text: \"Hello!\"}            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nStep 2: Generate message_id, timestamp, sequence_num\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 message_id: msg_abc123      \u2502\n        \u2502 sequence: 47                \u2502\n        \u2502 timestamp: 1699900000       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nStep 3: Write to Cassandra (DURABLE)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 INSERT INTO messages        \u2502\n        \u2502 WHERE conv_id = 123         \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nStep 4: Publish to Kafka (conv_id partition)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Topic: messages             \u2502\n        \u2502 Partition: hash(123) % N    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nStep 5: WebSocket Gateway consumes event\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 For each member in conv:    \u2502\n        \u2502   - Lookup server in Redis  \u2502\n        \u2502   - Route message           \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\nStep 6: Push to recipient's WebSocket\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 If ONLINE:  Push via WS     \u2502\n        \u2502 If OFFLINE: Queue + Push    \u2502\n        \u2502             Notification    \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - HTTP Polling",
      "description": "Use existing HTTP endpoints. Clients poll /messages every few seconds to check for new messages. No WebSocket needed.",
      "time_complexity": "O(n) per poll where n is unread messages",
      "space_complexity": "O(1) server-side",
      "why_not_optimal": "Fails 100ms delivery requirement. Polling at 1s intervals = 500ms average latency. More frequent polling causes massive server load. Not real-time."
    },
    {
      "name": "Suboptimal - Server-Sent Events (SSE)",
      "description": "Use SSE for server\u2192client push. Messages sent via HTTP POST, delivered via SSE stream.",
      "time_complexity": "O(1) for delivery",
      "space_complexity": "O(connections)",
      "why_not_optimal": "Unidirectional - client can't send via same connection. Still need HTTP for uploads. No native support for acknowledgments."
    },
    {
      "name": "Optimal Approach - WebSocket + Kafka + Redis",
      "description": "Persistent WebSocket connections for bidirectional real-time communication. Kafka ensures ordered delivery with partitioning. Redis tracks session\u2192server mapping for routing. Cassandra stores messages durably.",
      "time_complexity": "O(group_size) for fan-out",
      "space_complexity": "O(users * conversations)",
      "key_insight": "Store-then-push pattern: Persist message immediately for durability, then async push for speed. Kafka partitioning by conversation_id gives free ordering. Redis pub/sub for cross-server message routing."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal DM Architecture\n\n### Core Design Principles\n\n1. **Decouple Persistence from Delivery**: Message is written to Cassandra *before* attempting delivery. This ensures no message loss even if delivery fails.\n\n2. **Kafka for Ordered Fan-out**: By partitioning Kafka by `conversation_id`, all messages for a conversation go to the same partition, guaranteeing FIFO order.\n\n3. **Redis Session Store**: Maps `user_id \u2192 websocket_server_id`. When routing a message, we lookup which server the recipient is connected to.\n\n4. **Sequence Numbers**: Each message in a conversation gets an incrementing sequence number. Clients use this to detect gaps and request re-sync.\n\n### Data Models\n\n```\nMessage {\n  message_id: UUID\n  conversation_id: UUID\n  sender_id: UUID\n  content: string\n  media_url: string?\n  message_type: TEXT|IMAGE|VIDEO\n  sequence_num: int\n  created_at: timestamp\n  status: SENT|DELIVERED|READ\n}\n\nConversation {\n  conversation_id: UUID\n  type: DIRECT|GROUP\n  member_ids: List<UUID>\n  last_message_id: UUID\n  last_message_preview: string\n  updated_at: timestamp\n}\n```\n\n### Message Flow\n\n1. **Client sends** message via WebSocket\n2. **Gateway validates** and assigns message_id, sequence\n3. **Write to Cassandra** (durable)\n4. **Publish to Kafka** topic partitioned by conv_id\n5. **Consumer routes** to recipient's WebSocket server\n6. **Push via WebSocket** or queue if offline\n7. **Send delivery receipt** back to sender",
    "data_structures": [
      {
        "structure": "WebSocket Connection Pool",
        "purpose": "Maintain persistent bidirectional connections with clients"
      },
      {
        "structure": "Redis Hash",
        "purpose": "Map user_id \u2192 {server_id, connection_id, last_active} for routing"
      },
      {
        "structure": "Kafka Topic (partitioned)",
        "purpose": "Ordered message queue per conversation for reliable delivery"
      },
      {
        "structure": "Cassandra Table",
        "purpose": "Persistent message storage with efficient time-range queries"
      },
      {
        "structure": "In-memory Conversation Cache",
        "purpose": "Fast access to recent conversations list"
      }
    ],
    "algorithm_steps": [
      "Step 1: Receive message from client via WebSocket with conversation_id and content",
      "Step 2: Validate sender is member of conversation",
      "Step 3: Generate unique message_id (UUID) and sequence_number (atomic increment)",
      "Step 4: Create Message object with timestamp and SENT status",
      "Step 5: Write to Cassandra messages table (partition key: conversation_id)",
      "Step 6: Update conversation's last_message metadata",
      "Step 7: Publish NewMessageEvent to Kafka topic (partition by conversation_id)",
      "Step 8: Kafka consumer receives event, looks up all conversation members",
      "Step 9: For each member, query Redis for their WebSocket server location",
      "Step 10: Route message to each member's server (skip sender unless multi-device)",
      "Step 11: WebSocket server pushes message to client connection",
      "Step 12: If member offline, store in pending_messages queue and send push notification",
      "Step 13: Client acknowledges receipt, update message status to DELIVERED",
      "Step 14: When client reads message, send READ receipt to update status"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram Direct Messaging System - Part 4",
    "Real-time messaging with WebSocket, Kafka, and Redis",
    "\"\"\"",
    "",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Optional, Set, Callable, Any",
    "from enum import Enum",
    "from datetime import datetime, timedelta",
    "from collections import defaultdict",
    "from threading import Lock",
    "import uuid",
    "import heapq",
    "import json",
    "import time",
    "",
    "",
    "# ============================================================",
    "# ENUMS AND DATA CLASSES",
    "# ============================================================",
    "",
    "class MessageType(Enum):",
    "    TEXT = \"TEXT\"",
    "    IMAGE = \"IMAGE\"",
    "    VIDEO = \"VIDEO\"",
    "    VOICE = \"VOICE\"",
    "",
    "",
    "class MessageStatus(Enum):",
    "    SENDING = \"SENDING\"",
    "    SENT = \"SENT\"",
    "    DELIVERED = \"DELIVERED\"",
    "    READ = \"READ\"",
    "    FAILED = \"FAILED\"",
    "",
    "",
    "class ConversationType(Enum):",
    "    DIRECT = \"DIRECT\"",
    "    GROUP = \"GROUP\"",
    "",
    "",
    "class ConnectionStatus(Enum):",
    "    ONLINE = \"ONLINE\"",
    "    OFFLINE = \"OFFLINE\"",
    "    AWAY = \"AWAY\"",
    "",
    "",
    "@dataclass",
    "class Message:",
    "    \"\"\"Represents a single message in a conversation.\"\"\"",
    "    message_id: str",
    "    conversation_id: str",
    "    sender_id: str",
    "    content: str",
    "    message_type: MessageType",
    "    sequence_num: int",
    "    created_at: datetime",
    "    status: MessageStatus = MessageStatus.SENT",
    "    media_url: Optional[str] = None",
    "    reply_to_id: Optional[str] = None",
    "    ",
    "    def to_dict(self) -> Dict:",
    "        return {",
    "            \"message_id\": self.message_id,",
    "            \"conversation_id\": self.conversation_id,",
    "            \"sender_id\": self.sender_id,",
    "            \"content\": self.content,",
    "            \"message_type\": self.message_type.value,",
    "            \"sequence_num\": self.sequence_num,",
    "            \"created_at\": self.created_at.isoformat(),",
    "            \"status\": self.status.value,",
    "            \"media_url\": self.media_url",
    "        }",
    "",
    "",
    "@dataclass",
    "class Conversation:",
    "    \"\"\"Represents a conversation (1:1 or group).\"\"\"",
    "    conversation_id: str",
    "    conv_type: ConversationType",
    "    member_ids: List[str]",
    "    created_at: datetime",
    "    updated_at: datetime",
    "    name: Optional[str] = None  # For group chats",
    "    last_message_preview: Optional[str] = None",
    "    last_message_time: Optional[datetime] = None",
    "    creator_id: Optional[str] = None",
    "    sequence_counter: int = 0",
    "    ",
    "    def to_dict(self) -> Dict:",
    "        return {",
    "            \"conversation_id\": self.conversation_id,",
    "            \"type\": self.conv_type.value,",
    "            \"member_ids\": self.member_ids,",
    "            \"name\": self.name,",
    "            \"last_message_preview\": self.last_message_preview,",
    "            \"last_message_time\": self.last_message_time.isoformat() if self.last_message_time else None,",
    "            \"updated_at\": self.updated_at.isoformat()",
    "        }",
    "",
    "",
    "@dataclass",
    "class ReadReceipt:",
    "    \"\"\"Tracks read status for a user in a conversation.\"\"\"",
    "    user_id: str",
    "    conversation_id: str",
    "    last_read_message_id: str",
    "    last_read_sequence: int",
    "    read_at: datetime",
    "",
    "",
    "@dataclass",
    "class UserSession:",
    "    \"\"\"Tracks a user's WebSocket session.\"\"\"",
    "    user_id: str",
    "    server_id: str",
    "    connection_id: str",
    "    status: ConnectionStatus",
    "    connected_at: datetime",
    "    last_active: datetime",
    "    device_id: Optional[str] = None",
    "",
    "",
    "# ============================================================",
    "# SIMULATED WEBSOCKET CONNECTION",
    "# ============================================================",
    "",
    "class WebSocketConnection:",
    "    \"\"\"Simulates a WebSocket connection for demo purposes.\"\"\"",
    "    ",
    "    def __init__(self, connection_id: str, user_id: str):",
    "        self.connection_id = connection_id",
    "        self.user_id = user_id",
    "        self.is_open = True",
    "        self.message_queue: List[Dict] = []",
    "        self._on_message_callback: Optional[Callable] = None",
    "    ",
    "    def send(self, message: Dict) -> bool:",
    "        \"\"\"Send message to client via WebSocket.\"\"\"",
    "        if not self.is_open:",
    "            return False",
    "        self.message_queue.append(message)",
    "        print(f\"    [WS] \u2192 {self.user_id}: {message.get('type', 'unknown')}\")",
    "        return True",
    "    ",
    "    def close(self):",
    "        self.is_open = False",
    "    ",
    "    def get_received_messages(self) -> List[Dict]:",
    "        return self.message_queue.copy()",
    "",
    "",
    "# ============================================================",
    "# PRESENCE TRACKER (Redis Simulation)",
    "# ============================================================",
    "",
    "class PresenceTracker:",
    "    \"\"\"",
    "    Tracks user online status and WebSocket server mapping.",
    "    In production: Redis with TTL for automatic cleanup.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._sessions: Dict[str, UserSession] = {}  # user_id \u2192 session",
    "        self._lock = Lock()",
    "    ",
    "    def set_online(self, user_id: str, server_id: str, ",
    "                   connection_id: str, device_id: str = None) -> UserSession:",
    "        \"\"\"Mark user as online with their WebSocket server location.\"\"\"",
    "        with self._lock:",
    "            now = datetime.now()",
    "            session = UserSession(",
    "                user_id=user_id,",
    "                server_id=server_id,",
    "                connection_id=connection_id,",
    "                status=ConnectionStatus.ONLINE,",
    "                connected_at=now,",
    "                last_active=now,",
    "                device_id=device_id",
    "            )",
    "            self._sessions[user_id] = session",
    "            return session",
    "    ",
    "    def set_offline(self, user_id: str):",
    "        \"\"\"Mark user as offline.\"\"\"",
    "        with self._lock:",
    "            if user_id in self._sessions:",
    "                del self._sessions[user_id]",
    "    ",
    "    def get_session(self, user_id: str) -> Optional[UserSession]:",
    "        \"\"\"Get user's current session if online.\"\"\"",
    "        return self._sessions.get(user_id)",
    "    ",
    "    def is_online(self, user_id: str) -> bool:",
    "        \"\"\"Check if user is currently online.\"\"\"",
    "        session = self._sessions.get(user_id)",
    "        return session is not None and session.status == ConnectionStatus.ONLINE",
    "    ",
    "    def update_activity(self, user_id: str):",
    "        \"\"\"Update last active timestamp.\"\"\"",
    "        with self._lock:",
    "            if user_id in self._sessions:",
    "                self._sessions[user_id].last_active = datetime.now()",
    "",
    "",
    "# ============================================================",
    "# WEBSOCKET GATEWAY (Connection Manager)",
    "# ============================================================",
    "",
    "class WebSocketGateway:",
    "    \"\"\"",
    "    Manages WebSocket connections and message routing.",
    "    In production: Distributed across multiple servers.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, server_id: str, presence_tracker: PresenceTracker):",
    "        self.server_id = server_id",
    "        self.presence = presence_tracker",
    "        self._connections: Dict[str, WebSocketConnection] = {}  # connection_id \u2192 connection",
    "        self._user_connections: Dict[str, str] = {}  # user_id \u2192 connection_id",
    "        self._lock = Lock()",
    "    ",
    "    def connect(self, user_id: str, device_id: str = None) -> WebSocketConnection:",
    "        \"\"\"Establish new WebSocket connection for user.\"\"\"",
    "        with self._lock:",
    "            connection_id = f\"conn_{uuid.uuid4().hex[:8]}\"",
    "            connection = WebSocketConnection(connection_id, user_id)",
    "            ",
    "            self._connections[connection_id] = connection",
    "            self._user_connections[user_id] = connection_id",
    "            ",
    "            # Register with presence tracker",
    "            self.presence.set_online(user_id, self.server_id, connection_id, device_id)",
    "            ",
    "            print(f\"    [Gateway] User {user_id} connected (conn: {connection_id})\")",
    "            return connection",
    "    ",
    "    def disconnect(self, user_id: str):",
    "        \"\"\"Close WebSocket connection for user.\"\"\"",
    "        with self._lock:",
    "            if user_id in self._user_connections:",
    "                connection_id = self._user_connections[user_id]",
    "                if connection_id in self._connections:",
    "                    self._connections[connection_id].close()",
    "                    del self._connections[connection_id]",
    "                del self._user_connections[user_id]",
    "            ",
    "            self.presence.set_offline(user_id)",
    "            print(f\"    [Gateway] User {user_id} disconnected\")",
    "    ",
    "    def send_to_user(self, user_id: str, message: Dict) -> bool:",
    "        \"\"\"Send message to user if connected to this server.\"\"\"",
    "        connection_id = self._user_connections.get(user_id)",
    "        if connection_id and connection_id in self._connections:",
    "            return self._connections[connection_id].send(message)",
    "        return False",
    "    ",
    "    def get_connection(self, user_id: str) -> Optional[WebSocketConnection]:",
    "        \"\"\"Get user's WebSocket connection.\"\"\"",
    "        connection_id = self._user_connections.get(user_id)",
    "        return self._connections.get(connection_id) if connection_id else None",
    "",
    "",
    "# ============================================================",
    "# MESSAGE QUEUE (Kafka Simulation)",
    "# ============================================================",
    "",
    "class MessageEvent:",
    "    \"\"\"Event published to message queue.\"\"\"",
    "    def __init__(self, event_type: str, payload: Dict, partition_key: str):",
    "        self.event_type = event_type",
    "        self.payload = payload",
    "        self.partition_key = partition_key",
    "        self.timestamp = datetime.now()",
    "",
    "",
    "class MessageQueue:",
    "    \"\"\"",
    "    Simulates Kafka-like message queue with partitioning.",
    "    Partitioning by conversation_id ensures ordering.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, num_partitions: int = 8):",
    "        self.num_partitions = num_partitions",
    "        self._partitions: Dict[int, List[MessageEvent]] = {",
    "            i: [] for i in range(num_partitions)",
    "        }",
    "        self._consumers: List[Callable[[MessageEvent], None]] = []",
    "        self._lock = Lock()",
    "    ",
    "    def _get_partition(self, key: str) -> int:",
    "        \"\"\"Consistent hashing to partition.\"\"\"",
    "        return hash(key) % self.num_partitions",
    "    ",
    "    def publish(self, event: MessageEvent):",
    "        \"\"\"Publish event to appropriate partition.\"\"\"",
    "        partition = self._get_partition(event.partition_key)",
    "        with self._lock:",
    "            self._partitions[partition].append(event)",
    "        ",
    "        # Immediately deliver to consumers (simplified)",
    "        for consumer in self._consumers:",
    "            consumer(event)",
    "    ",
    "    def subscribe(self, consumer: Callable[[MessageEvent], None]):",
    "        \"\"\"Register consumer for events.\"\"\"",
    "        self._consumers.append(consumer)",
    "",
    "",
    "# ============================================================",
    "# MESSAGE STORAGE (Cassandra Simulation)",
    "# ============================================================",
    "",
    "class MessageStore:",
    "    \"\"\"",
    "    Persistent message storage.",
    "    In production: Cassandra with partition key = conversation_id.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # conversation_id \u2192 List[Message] (sorted by sequence)",
    "        self._messages: Dict[str, List[Message]] = defaultdict(list)",
    "        self._conversations: Dict[str, Conversation] = {}",
    "        self._user_conversations: Dict[str, Set[str]] = defaultdict(set)  # user_id \u2192 conv_ids",
    "        self._read_receipts: Dict[str, Dict[str, ReadReceipt]] = defaultdict(dict)  # conv_id \u2192 {user_id: receipt}",
    "        self._pending_messages: Dict[str, List[Message]] = defaultdict(list)  # offline user_id \u2192 messages",
    "        self._lock = Lock()",
    "    ",
    "    def create_conversation(self, conv_type: ConversationType, ",
    "                           member_ids: List[str], name: str = None,",
    "                           creator_id: str = None) -> Conversation:",
    "        \"\"\"Create new conversation.\"\"\"",
    "        with self._lock:",
    "            # Check for existing 1:1 conversation",
    "            if conv_type == ConversationType.DIRECT and len(member_ids) == 2:",
    "                existing = self._find_direct_conversation(member_ids[0], member_ids[1])",
    "                if existing:",
    "                    return existing",
    "            ",
    "            conv_id = f\"conv_{uuid.uuid4().hex[:12]}\"",
    "            now = datetime.now()",
    "            ",
    "            conversation = Conversation(",
    "                conversation_id=conv_id,",
    "                conv_type=conv_type,",
    "                member_ids=member_ids,",
    "                created_at=now,",
    "                updated_at=now,",
    "                name=name,",
    "                creator_id=creator_id",
    "            )",
    "            ",
    "            self._conversations[conv_id] = conversation",
    "            for member_id in member_ids:",
    "                self._user_conversations[member_id].add(conv_id)",
    "            ",
    "            return conversation",
    "    ",
    "    def _find_direct_conversation(self, user1: str, user2: str) -> Optional[Conversation]:",
    "        \"\"\"Find existing 1:1 conversation between two users.\"\"\"",
    "        user1_convs = self._user_conversations.get(user1, set())",
    "        for conv_id in user1_convs:",
    "            conv = self._conversations.get(conv_id)",
    "            if (conv and conv.conv_type == ConversationType.DIRECT and ",
    "                set(conv.member_ids) == {user1, user2}):",
    "                return conv",
    "        return None",
    "    ",
    "    def get_conversation(self, conv_id: str) -> Optional[Conversation]:",
    "        \"\"\"Get conversation by ID.\"\"\"",
    "        return self._conversations.get(conv_id)",
    "    ",
    "    def save_message(self, message: Message):",
    "        \"\"\"Persist message to storage.\"\"\"",
    "        with self._lock:",
    "            self._messages[message.conversation_id].append(message)",
    "            ",
    "            # Update conversation metadata",
    "            conv = self._conversations.get(message.conversation_id)",
    "            if conv:",
    "                conv.last_message_preview = message.content[:50] if message.content else \"[Media]\"",
    "                conv.last_message_time = message.created_at",
    "                conv.updated_at = message.created_at",
    "                conv.sequence_counter = message.sequence_num",
    "    ",
    "    def get_messages(self, conv_id: str, cursor: int = None, ",
    "                     limit: int = 50) -> List[Message]:",
    "        \"\"\"",
    "        Get messages for conversation with pagination.",
    "        cursor is the sequence number to start after.",
    "        \"\"\"",
    "        messages = self._messages.get(conv_id, [])",
    "        ",
    "        if cursor is not None:",
    "            # Find messages after cursor",
    "            messages = [m for m in messages if m.sequence_num > cursor]",
    "        ",
    "        # Return most recent 'limit' messages",
    "        return messages[-limit:] if len(messages) > limit else messages",
    "    ",
    "    def get_user_conversations(self, user_id: str, limit: int = 20) -> List[Conversation]:",
    "        \"\"\"Get user's conversations sorted by last message time.\"\"\"",
    "        conv_ids = self._user_conversations.get(user_id, set())",
    "        conversations = [self._conversations[cid] for cid in conv_ids ",
    "                        if cid in self._conversations]",
    "        ",
    "        # Sort by last message time (most recent first)",
    "        conversations.sort(",
    "            key=lambda c: c.last_message_time or c.created_at,",
    "            reverse=True",
    "        )",
    "        ",
    "        return conversations[:limit]",
    "    ",
    "    def get_next_sequence(self, conv_id: str) -> int:",
    "        \"\"\"Get next sequence number for conversation.\"\"\"",
    "        with self._lock:",
    "            conv = self._conversations.get(conv_id)",
    "            if conv:",
    "                conv.sequence_counter += 1",
    "                return conv.sequence_counter",
    "            return 1",
    "    ",
    "    def save_read_receipt(self, receipt: ReadReceipt):",
    "        \"\"\"Save read receipt for user in conversation.\"\"\"",
    "        with self._lock:",
    "            self._read_receipts[receipt.conversation_id][receipt.user_id] = receipt",
    "    ",
    "    def get_read_receipts(self, conv_id: str) -> Dict[str, ReadReceipt]:",
    "        \"\"\"Get all read receipts for a conversation.\"\"\"",
    "        return self._read_receipts.get(conv_id, {})",
    "    ",
    "    def queue_pending_message(self, user_id: str, message: Message):",
    "        \"\"\"Queue message for offline user.\"\"\"",
    "        with self._lock:",
    "            self._pending_messages[user_id].append(message)",
    "    ",
    "    def get_pending_messages(self, user_id: str) -> List[Message]:",
    "        \"\"\"Get and clear pending messages for user.\"\"\"",
    "        with self._lock:",
    "            messages = self._pending_messages.get(user_id, [])",
    "            self._pending_messages[user_id] = []",
    "            return messages",
    "",
    "",
    "# ============================================================",
    "# DIRECT MESSAGE SERVICE (Main API)",
    "# ============================================================",
    "",
    "class DirectMessageService:",
    "    \"\"\"",
    "    Main service for direct messaging functionality.",
    "    Coordinates between WebSocket gateway, message queue, and storage.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.store = MessageStore()",
    "        self.presence = PresenceTracker()",
    "        self.queue = MessageQueue()",
    "        self.gateway = WebSocketGateway(\"server_1\", self.presence)",
    "        ",
    "        # Subscribe to message events",
    "        self.queue.subscribe(self._handle_message_event)",
    "    ",
    "    def connect_user(self, user_id: str) -> WebSocketConnection:",
    "        \"\"\"",
    "        Connect user to WebSocket gateway.",
    "        Syncs pending messages on reconnect.",
    "        \"\"\"",
    "        connection = self.gateway.connect(user_id)",
    "        ",
    "        # Sync pending messages",
    "        pending = self.store.get_pending_messages(user_id)",
    "        for msg in pending:",
    "            connection.send({",
    "                \"type\": \"NEW_MESSAGE\",",
    "                \"payload\": msg.to_dict()",
    "            })",
    "        ",
    "        if pending:",
    "            print(f\"    [Sync] Delivered {len(pending)} pending messages to {user_id}\")",
    "        ",
    "        return connection",
    "    ",
    "    def disconnect_user(self, user_id: str):",
    "        \"\"\"Disconnect user from WebSocket gateway.\"\"\"",
    "        self.gateway.disconnect(user_id)",
    "    ",
    "    def create_conversation(self, creator_id: str, ",
    "                           member_ids: List[str]) -> str:",
    "        \"\"\"",
    "        Create direct conversation between two users.",
    "        Returns existing conversation if one exists.",
    "        \"\"\"",
    "        all_members = list(set([creator_id] + member_ids))",
    "        conv = self.store.create_conversation(",
    "            conv_type=ConversationType.DIRECT,",
    "            member_ids=all_members,",
    "            creator_id=creator_id",
    "        )",
    "        return conv.conversation_id",
    "    ",
    "    def create_group_chat(self, creator_id: str, ",
    "                         member_ids: List[str], ",
    "                         name: str) -> str:",
    "        \"\"\"",
    "        Create group chat with multiple members.",
    "        Creator is automatically added to members.",
    "        \"\"\"",
    "        all_members = list(set([creator_id] + member_ids))",
    "        conv = self.store.create_conversation(",
    "            conv_type=ConversationType.GROUP,",
    "            member_ids=all_members,",
    "            name=name,",
    "            creator_id=creator_id",
    "        )",
    "        ",
    "        # Notify all members about new group",
    "        for member_id in all_members:",
    "            self._notify_user(member_id, {",
    "                \"type\": \"GROUP_CREATED\",",
    "                \"payload\": conv.to_dict()",
    "            })",
    "        ",
    "        return conv.conversation_id",
    "    ",
    "    def send_message(self, sender_id: str, conversation_id: str,",
    "                    content: str, message_type: MessageType = MessageType.TEXT,",
    "                    media_url: str = None) -> str:",
    "        \"\"\"",
    "        Send message to conversation.",
    "        Returns message_id.",
    "        ",
    "        Flow:",
    "        1. Validate sender is in conversation",
    "        2. Create message with sequence number",
    "        3. Persist to storage (durability first)",
    "        4. Publish to queue for async delivery",
    "        \"\"\"",
    "        # Validate conversation and membership",
    "        conv = self.store.get_conversation(conversation_id)",
    "        if not conv:",
    "            raise ValueError(f\"Conversation {conversation_id} not found\")",
    "        if sender_id not in conv.member_ids:",
    "            raise ValueError(f\"User {sender_id} not in conversation\")",
    "        ",
    "        # Generate message ID and sequence number",
    "        message_id = f\"msg_{uuid.uuid4().hex[:12]}\"",
    "        sequence_num = self.store.get_next_sequence(conversation_id)",
    "        ",
    "        # Create message",
    "        message = Message(",
    "            message_id=message_id,",
    "            conversation_id=conversation_id,",
    "            sender_id=sender_id,",
    "            content=content,",
    "            message_type=message_type,",
    "            sequence_num=sequence_num,",
    "            created_at=datetime.now(),",
    "            status=MessageStatus.SENT,",
    "            media_url=media_url",
    "        )",
    "        ",
    "        # Step 1: Persist (durability)",
    "        self.store.save_message(message)",
    "        ",
    "        # Step 2: Publish for async delivery",
    "        event = MessageEvent(",
    "            event_type=\"NEW_MESSAGE\",",
    "            payload={",
    "                \"message\": message.to_dict(),",
    "                \"conversation\": conv.to_dict()",
    "            },",
    "            partition_key=conversation_id  # Ensures ordering",
    "        )",
    "        self.queue.publish(event)",
    "        ",
    "        print(f\"    [Message] {sender_id} \u2192 conv:{conversation_id[:8]}... : \\\"{content[:20]}...\\\"\")",
    "        return message_id",
    "    ",
    "    def _handle_message_event(self, event: MessageEvent):",
    "        \"\"\"",
    "        Handle message event from queue.",
    "        Routes message to all conversation members.",
    "        \"\"\"",
    "        if event.event_type != \"NEW_MESSAGE\":",
    "            return",
    "        ",
    "        message_data = event.payload[\"message\"]",
    "        conv_data = event.payload[\"conversation\"]",
    "        sender_id = message_data[\"sender_id\"]",
    "        ",
    "        # Fan-out to all members",
    "        for member_id in conv_data[\"member_ids\"]:",
    "            if member_id == sender_id:",
    "                continue  # Don't send to sender",
    "            ",
    "            self._notify_user(member_id, {",
    "                \"type\": \"NEW_MESSAGE\",",
    "                \"payload\": message_data",
    "            })",
    "    ",
    "    def _notify_user(self, user_id: str, notification: Dict):",
    "        \"\"\"",
    "        Notify user via WebSocket or queue for later.",
    "        \"\"\"",
    "        if self.presence.is_online(user_id):",
    "            # User online - send via WebSocket",
    "            delivered = self.gateway.send_to_user(user_id, notification)",
    "            if delivered:",
    "                return",
    "        ",
    "        # User offline - queue for later",
    "        if notification[\"type\"] == \"NEW_MESSAGE\":",
    "            msg_data = notification[\"payload\"]",
    "            message = Message(",
    "                message_id=msg_data[\"message_id\"],",
    "                conversation_id=msg_data[\"conversation_id\"],",
    "                sender_id=msg_data[\"sender_id\"],",
    "                content=msg_data[\"content\"],",
    "                message_type=MessageType(msg_data[\"message_type\"]),",
    "                sequence_num=msg_data[\"sequence_num\"],",
    "                created_at=datetime.fromisoformat(msg_data[\"created_at\"]),",
    "                status=MessageStatus(msg_data[\"status\"])",
    "            )",
    "            self.store.queue_pending_message(user_id, message)",
    "            print(f\"    [Queue] Message queued for offline user {user_id}\")",
    "    ",
    "    def get_conversations(self, user_id: str, limit: int = 20) -> List[Conversation]:",
    "        \"\"\"",
    "        Get user's conversations sorted by last message time.",
    "        \"\"\"",
    "        return self.store.get_user_conversations(user_id, limit)",
    "    ",
    "    def get_messages(self, user_id: str, conversation_id: str,",
    "                    cursor: int = None, limit: int = 50) -> List[Message]:",
    "        \"\"\"",
    "        Get messages for conversation with pagination.",
    "        cursor is the sequence number to start after.",
    "        \"\"\"",
    "        # Validate membership",
    "        conv = self.store.get_conversation(conversation_id)",
    "        if not conv or user_id not in conv.member_ids:",
    "            raise ValueError(\"Access denied\")",
    "        ",
    "        return self.store.get_messages(conversation_id, cursor, limit)",
    "    ",
    "    def mark_as_read(self, user_id: str, conversation_id: str, ",
    "                    message_id: str, sequence_num: int):",
    "        \"\"\"",
    "        Mark messages as read up to given message.",
    "        Broadcasts read receipt to other members.",
    "        \"\"\"",
    "        conv = self.store.get_conversation(conversation_id)",
    "        if not conv or user_id not in conv.member_ids:",
    "            raise ValueError(\"Access denied\")",
    "        ",
    "        # Save read receipt",
    "        receipt = ReadReceipt(",
    "            user_id=user_id,",
    "            conversation_id=conversation_id,",
    "            last_read_message_id=message_id,",
    "            last_read_sequence=sequence_num,",
    "            read_at=datetime.now()",
    "        )",
    "        self.store.save_read_receipt(receipt)",
    "        ",
    "        # Notify other members",
    "        for member_id in conv.member_ids:",
    "            if member_id != user_id:",
    "                self._notify_user(member_id, {",
    "                    \"type\": \"READ_RECEIPT\",",
    "                    \"payload\": {",
    "                        \"conversation_id\": conversation_id,",
    "                        \"user_id\": user_id,",
    "                        \"last_read_message_id\": message_id,",
    "                        \"last_read_sequence\": sequence_num",
    "                    }",
    "                })",
    "        ",
    "        print(f\"    [Read] {user_id} read up to msg:{message_id[:8]}... in conv:{conversation_id[:8]}...\")",
    "    ",
    "    def add_to_group(self, group_id: str, adder_id: str, new_member_id: str):",
    "        \"\"\"Add member to group chat.\"\"\"",
    "        conv = self.store.get_conversation(group_id)",
    "        if not conv or conv.conv_type != ConversationType.GROUP:",
    "            raise ValueError(\"Group not found\")",
    "        if adder_id not in conv.member_ids:",
    "            raise ValueError(\"Not authorized\")",
    "        if new_member_id in conv.member_ids:",
    "            return  # Already member",
    "        ",
    "        conv.member_ids.append(new_member_id)",
    "        self.store._user_conversations[new_member_id].add(group_id)",
    "        ",
    "        # Notify all members",
    "        for member_id in conv.member_ids:",
    "            self._notify_user(member_id, {",
    "                \"type\": \"MEMBER_ADDED\",",
    "                \"payload\": {",
    "                    \"conversation_id\": group_id,",
    "                    \"added_by\": adder_id,",
    "                    \"new_member\": new_member_id",
    "                }",
    "            })",
    "",
    "",
    "# ============================================================",
    "# DEMONSTRATION",
    "# ============================================================",
    "",
    "def run_demo():",
    "    \"\"\"Demonstrate the Direct Messaging system.\"\"\"",
    "    print(\"=\"*70)",
    "    print(\"INSTAGRAM DM SYSTEM - PART 4 DEMONSTRATION\")",
    "    print(\"=\"*70)",
    "    ",
    "    service = DirectMessageService()",
    "    ",
    "    # ---- Test 1: Basic 1:1 Messaging ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 1: Basic 1:1 Messaging\")",
    "    print(\"-\"*70)",
    "    ",
    "    # Connect users",
    "    print(\"\\n[1.1] Connecting users...\")",
    "    alice_conn = service.connect_user(\"alice\")",
    "    bob_conn = service.connect_user(\"bob\")",
    "    ",
    "    # Create conversation",
    "    print(\"\\n[1.2] Creating conversation between Alice and Bob...\")",
    "    conv_id = service.create_conversation(\"alice\", [\"bob\"])",
    "    print(f\"    Created conversation: {conv_id}\")",
    "    ",
    "    # Send messages",
    "    print(\"\\n[1.3] Sending messages...\")",
    "    msg1_id = service.send_message(\"alice\", conv_id, \"Hey Bob! \ud83d\udc4b\")",
    "    msg2_id = service.send_message(\"bob\", conv_id, \"Hi Alice! How are you?\")",
    "    msg3_id = service.send_message(\"alice\", conv_id, \"I'm great! Check out this photo \ud83d\udcf8\", ",
    "                                   MessageType.IMAGE, \"https://cdn.example.com/photo123.jpg\")",
    "    ",
    "    # Verify Bob received messages",
    "    print(\"\\n[1.4] Checking Bob's WebSocket received messages...\")",
    "    bob_messages = bob_conn.get_received_messages()",
    "    print(f\"    Bob received {len(bob_messages)} messages via WebSocket\")",
    "    ",
    "    # Get message history",
    "    print(\"\\n[1.5] Retrieving message history...\")",
    "    history = service.get_messages(\"alice\", conv_id)",
    "    for msg in history:",
    "        print(f\"    [{msg.sequence_num}] {msg.sender_id}: {msg.content[:30]}\")",
    "    ",
    "    # ---- Test 2: Offline User Handling ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 2: Offline User Message Queuing\")",
    "    print(\"-\"*70)",
    "    ",
    "    # Disconnect Bob",
    "    print(\"\\n[2.1] Bob goes offline...\")",
    "    service.disconnect_user(\"bob\")",
    "    ",
    "    # Alice sends while Bob is offline",
    "    print(\"\\n[2.2] Alice sends messages while Bob is offline...\")",
    "    service.send_message(\"alice\", conv_id, \"Bob, are you there?\")",
    "    service.send_message(\"alice\", conv_id, \"I'll wait for you!\")",
    "    ",
    "    # Bob reconnects and gets pending messages",
    "    print(\"\\n[2.3] Bob reconnects...\")",
    "    bob_conn = service.connect_user(\"bob\")",
    "    ",
    "    bob_new_messages = bob_conn.get_received_messages()",
    "    print(f\"    Bob received {len(bob_new_messages)} messages on reconnect\")",
    "    ",
    "    # ---- Test 3: Group Chat ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 3: Group Chat\")",
    "    print(\"-\"*70)",
    "    ",
    "    # Create group with multiple members",
    "    print(\"\\n[3.1] Connecting more users...\")",
    "    charlie_conn = service.connect_user(\"charlie\")",
    "    diana_conn = service.connect_user(\"diana\")",
    "    ",
    "    print(\"\\n[3.2] Alice creates group chat...\")",
    "    group_id = service.create_group_chat(",
    "        creator_id=\"alice\",",
    "        member_ids=[\"bob\", \"charlie\", \"diana\"],",
    "        name=\"Weekend Trip Planning \ud83c\udfd6\ufe0f\"",
    "    )",
    "    print(f\"    Created group: {group_id}\")",
    "    ",
    "    # Group messages",
    "    print(\"\\n[3.3] Group conversation...\")",
    "    service.send_message(\"alice\", group_id, \"Hey everyone! Let's plan our trip!\")",
    "    service.send_message(\"charlie\", group_id, \"I'm in! When are we going?\")",
    "    service.send_message(\"diana\", group_id, \"How about next Saturday?\")",
    "    service.send_message(\"bob\", group_id, \"Sounds perfect! \ud83c\udf89\")",
    "    ",
    "    # Verify fan-out",
    "    print(\"\\n[3.4] Checking message fan-out...\")",
    "    print(f\"    Charlie received: {len(charlie_conn.get_received_messages())} messages\")",
    "    print(f\"    Diana received: {len(diana_conn.get_received_messages())} messages\")",
    "    ",
    "    # ---- Test 4: Read Receipts ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 4: Read Receipts\")",
    "    print(\"-\"*70)",
    "    ",
    "    print(\"\\n[4.1] Bob marks messages as read...\")",
    "    group_messages = service.get_messages(\"bob\", group_id)",
    "    if group_messages:",
    "        last_msg = group_messages[-1]",
    "        service.mark_as_read(\"bob\", group_id, last_msg.message_id, last_msg.sequence_num)",
    "    ",
    "    # ---- Test 5: Conversation List ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 5: Conversations List\")",
    "    print(\"-\"*70)",
    "    ",
    "    print(\"\\n[5.1] Getting Alice's conversations...\")",
    "    alice_convs = service.get_conversations(\"alice\")",
    "    print(f\"    Alice has {len(alice_convs)} conversations:\")",
    "    for conv in alice_convs:",
    "        conv_name = conv.name or f\"DM with {[m for m in conv.member_ids if m != 'alice'][0]}\"",
    "        print(f\"    - {conv_name}: \\\"{conv.last_message_preview}\\\"\")",
    "    ",
    "    # ---- Test 6: Adding Members to Group ----",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 6: Add Member to Group\")",
    "    print(\"-\"*70)",
    "    ",
    "    print(\"\\n[6.1] Connecting new user Eve...\")",
    "    eve_conn = service.connect_user(\"eve\")",
    "    ",
    "    print(\"\\n[6.2] Alice adds Eve to group...\")",
    "    service.add_to_group(group_id, \"alice\", \"eve\")",
    "    ",
    "    print(\"\\n[6.3] Eve can now see group messages...\")",
    "    eve_messages = service.get_messages(\"eve\", group_id)",
    "    print(f\"    Eve can see {len(eve_messages)} existing messages\")",
    "    ",
    "    # Summary",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"DEMONSTRATION COMPLETE\")",
    "    print(\"=\"*70)",
    "    print(\"\"\"",
    "Key Features Demonstrated:",
    "\u2705 Real-time message delivery via WebSocket",
    "\u2705 Offline message queuing and sync",
    "\u2705 Group chat with fan-out to members",
    "\u2705 Read receipts",
    "\u2705 Conversations list sorted by recency",
    "\u2705 Adding members to groups",
    "\"\"\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.Instant;",
    "import java.util.function.Consumer;",
    "",
    "/**",
    " * Instagram Direct Messaging System - Part 4",
    " * Real-time messaging with WebSocket, Kafka, and Redis simulation",
    " */",
    "public class InstagramDMSystem {",
    "    ",
    "    // ============================================================",
    "    // ENUMS",
    "    // ============================================================",
    "    ",
    "    enum MessageType { TEXT, IMAGE, VIDEO, VOICE }",
    "    enum MessageStatus { SENDING, SENT, DELIVERED, READ, FAILED }",
    "    enum ConversationType { DIRECT, GROUP }",
    "    enum ConnectionStatus { ONLINE, OFFLINE, AWAY }",
    "    ",
    "    // ============================================================",
    "    // DATA CLASSES",
    "    // ============================================================",
    "    ",
    "    static class Message {",
    "        String messageId;",
    "        String conversationId;",
    "        String senderId;",
    "        String content;",
    "        MessageType messageType;",
    "        int sequenceNum;",
    "        Instant createdAt;",
    "        MessageStatus status;",
    "        String mediaUrl;",
    "        ",
    "        Message(String messageId, String conversationId, String senderId,",
    "                String content, MessageType messageType, int sequenceNum) {",
    "            this.messageId = messageId;",
    "            this.conversationId = conversationId;",
    "            this.senderId = senderId;",
    "            this.content = content;",
    "            this.messageType = messageType;",
    "            this.sequenceNum = sequenceNum;",
    "            this.createdAt = Instant.now();",
    "            this.status = MessageStatus.SENT;",
    "        }",
    "        ",
    "        Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"messageId\", messageId);",
    "            map.put(\"conversationId\", conversationId);",
    "            map.put(\"senderId\", senderId);",
    "            map.put(\"content\", content);",
    "            map.put(\"messageType\", messageType.name());",
    "            map.put(\"sequenceNum\", sequenceNum);",
    "            map.put(\"createdAt\", createdAt.toString());",
    "            map.put(\"status\", status.name());",
    "            return map;",
    "        }",
    "    }",
    "    ",
    "    static class Conversation {",
    "        String conversationId;",
    "        ConversationType convType;",
    "        List<String> memberIds;",
    "        Instant createdAt;",
    "        Instant updatedAt;",
    "        String name;",
    "        String lastMessagePreview;",
    "        Instant lastMessageTime;",
    "        int sequenceCounter = 0;",
    "        ",
    "        Conversation(String id, ConversationType type, List<String> members) {",
    "            this.conversationId = id;",
    "            this.convType = type;",
    "            this.memberIds = new ArrayList<>(members);",
    "            this.createdAt = Instant.now();",
    "            this.updatedAt = this.createdAt;",
    "        }",
    "    }",
    "    ",
    "    static class UserSession {",
    "        String userId;",
    "        String serverId;",
    "        String connectionId;",
    "        ConnectionStatus status;",
    "        Instant connectedAt;",
    "        ",
    "        UserSession(String userId, String serverId, String connectionId) {",
    "            this.userId = userId;",
    "            this.serverId = serverId;",
    "            this.connectionId = connectionId;",
    "            this.status = ConnectionStatus.ONLINE;",
    "            this.connectedAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // WEBSOCKET CONNECTION (Simulated)",
    "    // ============================================================",
    "    ",
    "    static class WebSocketConnection {",
    "        String connectionId;",
    "        String userId;",
    "        boolean isOpen = true;",
    "        List<Map<String, Object>> messageQueue = new ArrayList<>();",
    "        ",
    "        WebSocketConnection(String connectionId, String userId) {",
    "            this.connectionId = connectionId;",
    "            this.userId = userId;",
    "        }",
    "        ",
    "        boolean send(Map<String, Object> message) {",
    "            if (!isOpen) return false;",
    "            messageQueue.add(message);",
    "            System.out.println(\"    [WS] -> \" + userId + \": \" + message.get(\"type\"));",
    "            return true;",
    "        }",
    "        ",
    "        void close() { isOpen = false; }",
    "        int getReceivedCount() { return messageQueue.size(); }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // PRESENCE TRACKER (Redis Simulation)",
    "    // ============================================================",
    "    ",
    "    static class PresenceTracker {",
    "        private final Map<String, UserSession> sessions = new ConcurrentHashMap<>();",
    "        ",
    "        UserSession setOnline(String userId, String serverId, String connId) {",
    "            UserSession session = new UserSession(userId, serverId, connId);",
    "            sessions.put(userId, session);",
    "            return session;",
    "        }",
    "        ",
    "        void setOffline(String userId) {",
    "            sessions.remove(userId);",
    "        }",
    "        ",
    "        boolean isOnline(String userId) {",
    "            UserSession session = sessions.get(userId);",
    "            return session != null && session.status == ConnectionStatus.ONLINE;",
    "        }",
    "        ",
    "        UserSession getSession(String userId) {",
    "            return sessions.get(userId);",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // MESSAGE STORE (Cassandra Simulation)",
    "    // ============================================================",
    "    ",
    "    static class MessageStore {",
    "        private final Map<String, List<Message>> messages = new ConcurrentHashMap<>();",
    "        private final Map<String, Conversation> conversations = new ConcurrentHashMap<>();",
    "        private final Map<String, Set<String>> userConversations = new ConcurrentHashMap<>();",
    "        private final Map<String, List<Message>> pendingMessages = new ConcurrentHashMap<>();",
    "        ",
    "        Conversation createConversation(ConversationType type, List<String> members, String name) {",
    "            // Check for existing direct conversation",
    "            if (type == ConversationType.DIRECT && members.size() == 2) {",
    "                Conversation existing = findDirectConversation(members.get(0), members.get(1));",
    "                if (existing != null) return existing;",
    "            }",
    "            ",
    "            String convId = \"conv_\" + UUID.randomUUID().toString().substring(0, 12);",
    "            Conversation conv = new Conversation(convId, type, members);",
    "            conv.name = name;",
    "            ",
    "            conversations.put(convId, conv);",
    "            for (String member : members) {",
    "                userConversations.computeIfAbsent(member, k -> ConcurrentHashMap.newKeySet()).add(convId);",
    "            }",
    "            ",
    "            return conv;",
    "        }",
    "        ",
    "        private Conversation findDirectConversation(String user1, String user2) {",
    "            Set<String> user1Convs = userConversations.getOrDefault(user1, Collections.emptySet());",
    "            for (String convId : user1Convs) {",
    "                Conversation conv = conversations.get(convId);",
    "                if (conv != null && conv.convType == ConversationType.DIRECT &&",
    "                    new HashSet<>(conv.memberIds).equals(Set.of(user1, user2))) {",
    "                    return conv;",
    "                }",
    "            }",
    "            return null;",
    "        }",
    "        ",
    "        Conversation getConversation(String convId) {",
    "            return conversations.get(convId);",
    "        }",
    "        ",
    "        void saveMessage(Message message) {",
    "            messages.computeIfAbsent(message.conversationId, k -> new ArrayList<>()).add(message);",
    "            Conversation conv = conversations.get(message.conversationId);",
    "            if (conv != null) {",
    "                conv.lastMessagePreview = message.content.length() > 50 ? ",
    "                    message.content.substring(0, 50) : message.content;",
    "                conv.lastMessageTime = message.createdAt;",
    "                conv.updatedAt = message.createdAt;",
    "                conv.sequenceCounter = message.sequenceNum;",
    "            }",
    "        }",
    "        ",
    "        List<Message> getMessages(String convId, int limit) {",
    "            List<Message> convMessages = messages.getOrDefault(convId, Collections.emptyList());",
    "            int start = Math.max(0, convMessages.size() - limit);",
    "            return new ArrayList<>(convMessages.subList(start, convMessages.size()));",
    "        }",
    "        ",
    "        List<Conversation> getUserConversations(String userId, int limit) {",
    "            Set<String> convIds = userConversations.getOrDefault(userId, Collections.emptySet());",
    "            List<Conversation> result = new ArrayList<>();",
    "            for (String convId : convIds) {",
    "                Conversation conv = conversations.get(convId);",
    "                if (conv != null) result.add(conv);",
    "            }",
    "            result.sort((a, b) -> {",
    "                Instant timeA = a.lastMessageTime != null ? a.lastMessageTime : a.createdAt;",
    "                Instant timeB = b.lastMessageTime != null ? b.lastMessageTime : b.createdAt;",
    "                return timeB.compareTo(timeA);",
    "            });",
    "            return result.subList(0, Math.min(limit, result.size()));",
    "        }",
    "        ",
    "        synchronized int getNextSequence(String convId) {",
    "            Conversation conv = conversations.get(convId);",
    "            if (conv != null) {",
    "                conv.sequenceCounter++;",
    "                return conv.sequenceCounter;",
    "            }",
    "            return 1;",
    "        }",
    "        ",
    "        void queuePendingMessage(String userId, Message message) {",
    "            pendingMessages.computeIfAbsent(userId, k -> new ArrayList<>()).add(message);",
    "        }",
    "        ",
    "        List<Message> getPendingMessages(String userId) {",
    "            return pendingMessages.remove(userId);",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // WEBSOCKET GATEWAY",
    "    // ============================================================",
    "    ",
    "    static class WebSocketGateway {",
    "        private final String serverId;",
    "        private final PresenceTracker presence;",
    "        private final Map<String, WebSocketConnection> connections = new ConcurrentHashMap<>();",
    "        private final Map<String, String> userConnections = new ConcurrentHashMap<>();",
    "        ",
    "        WebSocketGateway(String serverId, PresenceTracker presence) {",
    "            this.serverId = serverId;",
    "            this.presence = presence;",
    "        }",
    "        ",
    "        WebSocketConnection connect(String userId) {",
    "            String connectionId = \"conn_\" + UUID.randomUUID().toString().substring(0, 8);",
    "            WebSocketConnection conn = new WebSocketConnection(connectionId, userId);",
    "            ",
    "            connections.put(connectionId, conn);",
    "            userConnections.put(userId, connectionId);",
    "            presence.setOnline(userId, serverId, connectionId);",
    "            ",
    "            System.out.println(\"    [Gateway] User \" + userId + \" connected\");",
    "            return conn;",
    "        }",
    "        ",
    "        void disconnect(String userId) {",
    "            String connectionId = userConnections.remove(userId);",
    "            if (connectionId != null) {",
    "                WebSocketConnection conn = connections.remove(connectionId);",
    "                if (conn != null) conn.close();",
    "            }",
    "            presence.setOffline(userId);",
    "            System.out.println(\"    [Gateway] User \" + userId + \" disconnected\");",
    "        }",
    "        ",
    "        boolean sendToUser(String userId, Map<String, Object> message) {",
    "            String connectionId = userConnections.get(userId);",
    "            if (connectionId != null) {",
    "                WebSocketConnection conn = connections.get(connectionId);",
    "                if (conn != null) return conn.send(message);",
    "            }",
    "            return false;",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // DIRECT MESSAGE SERVICE",
    "    // ============================================================",
    "    ",
    "    static class DirectMessageService {",
    "        private final MessageStore store = new MessageStore();",
    "        private final PresenceTracker presence = new PresenceTracker();",
    "        private final WebSocketGateway gateway;",
    "        ",
    "        DirectMessageService() {",
    "            this.gateway = new WebSocketGateway(\"server_1\", presence);",
    "        }",
    "        ",
    "        WebSocketConnection connectUser(String userId) {",
    "            WebSocketConnection conn = gateway.connect(userId);",
    "            ",
    "            // Sync pending messages",
    "            List<Message> pending = store.getPendingMessages(userId);",
    "            if (pending != null) {",
    "                for (Message msg : pending) {",
    "                    Map<String, Object> notification = new HashMap<>();",
    "                    notification.put(\"type\", \"NEW_MESSAGE\");",
    "                    notification.put(\"payload\", msg.toMap());",
    "                    conn.send(notification);",
    "                }",
    "                System.out.println(\"    [Sync] Delivered \" + pending.size() + \" pending to \" + userId);",
    "            }",
    "            return conn;",
    "        }",
    "        ",
    "        void disconnectUser(String userId) {",
    "            gateway.disconnect(userId);",
    "        }",
    "        ",
    "        String createConversation(String creatorId, List<String> memberIds) {",
    "            Set<String> allMembers = new HashSet<>(memberIds);",
    "            allMembers.add(creatorId);",
    "            Conversation conv = store.createConversation(",
    "                ConversationType.DIRECT, new ArrayList<>(allMembers), null);",
    "            return conv.conversationId;",
    "        }",
    "        ",
    "        String createGroupChat(String creatorId, List<String> memberIds, String name) {",
    "            Set<String> allMembers = new HashSet<>(memberIds);",
    "            allMembers.add(creatorId);",
    "            Conversation conv = store.createConversation(",
    "                ConversationType.GROUP, new ArrayList<>(allMembers), name);",
    "            ",
    "            for (String memberId : allMembers) {",
    "                notifyUser(memberId, Map.of(",
    "                    \"type\", \"GROUP_CREATED\",",
    "                    \"conversationId\", conv.conversationId",
    "                ));",
    "            }",
    "            return conv.conversationId;",
    "        }",
    "        ",
    "        String sendMessage(String senderId, String conversationId, String content) {",
    "            return sendMessage(senderId, conversationId, content, MessageType.TEXT);",
    "        }",
    "        ",
    "        String sendMessage(String senderId, String conversationId, ",
    "                          String content, MessageType type) {",
    "            Conversation conv = store.getConversation(conversationId);",
    "            if (conv == null) throw new IllegalArgumentException(\"Conversation not found\");",
    "            if (!conv.memberIds.contains(senderId)) {",
    "                throw new IllegalArgumentException(\"User not in conversation\");",
    "            }",
    "            ",
    "            String messageId = \"msg_\" + UUID.randomUUID().toString().substring(0, 12);",
    "            int seqNum = store.getNextSequence(conversationId);",
    "            ",
    "            Message message = new Message(messageId, conversationId, senderId, content, type, seqNum);",
    "            store.saveMessage(message);",
    "            ",
    "            // Fan-out to members",
    "            for (String memberId : conv.memberIds) {",
    "                if (!memberId.equals(senderId)) {",
    "                    notifyUser(memberId, Map.of(",
    "                        \"type\", \"NEW_MESSAGE\",",
    "                        \"payload\", message.toMap()",
    "                    ));",
    "                }",
    "            }",
    "            ",
    "            System.out.println(\"    [Message] \" + senderId + \" -> conv:\" + ",
    "                conversationId.substring(0, 8) + \"... : \\\"\" + ",
    "                content.substring(0, Math.min(20, content.length())) + \"...\\\"\");",
    "            return messageId;",
    "        }",
    "        ",
    "        private void notifyUser(String userId, Map<String, Object> notification) {",
    "            if (presence.isOnline(userId)) {",
    "                if (gateway.sendToUser(userId, notification)) return;",
    "            }",
    "            ",
    "            // Queue for offline user",
    "            if (\"NEW_MESSAGE\".equals(notification.get(\"type\"))) {",
    "                @SuppressWarnings(\"unchecked\")",
    "                Map<String, Object> payload = (Map<String, Object>) notification.get(\"payload\");",
    "                Message msg = new Message(",
    "                    (String) payload.get(\"messageId\"),",
    "                    (String) payload.get(\"conversationId\"),",
    "                    (String) payload.get(\"senderId\"),",
    "                    (String) payload.get(\"content\"),",
    "                    MessageType.valueOf((String) payload.get(\"messageType\")),",
    "                    (Integer) payload.get(\"sequenceNum\")",
    "                );",
    "                store.queuePendingMessage(userId, msg);",
    "                System.out.println(\"    [Queue] Message queued for offline \" + userId);",
    "            }",
    "        }",
    "        ",
    "        List<Conversation> getConversations(String userId, int limit) {",
    "            return store.getUserConversations(userId, limit);",
    "        }",
    "        ",
    "        List<Message> getMessages(String userId, String conversationId, int limit) {",
    "            Conversation conv = store.getConversation(conversationId);",
    "            if (conv == null || !conv.memberIds.contains(userId)) {",
    "                throw new IllegalArgumentException(\"Access denied\");",
    "            }",
    "            return store.getMessages(conversationId, limit);",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // MAIN DEMO",
    "    // ============================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"INSTAGRAM DM SYSTEM - PART 4 (JAVA)\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        DirectMessageService service = new DirectMessageService();",
    "        ",
    "        // Test 1: Basic Messaging",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"TEST 1: Basic 1:1 Messaging\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        System.out.println(\"\\n[1.1] Connecting users...\");",
    "        WebSocketConnection aliceConn = service.connectUser(\"alice\");",
    "        WebSocketConnection bobConn = service.connectUser(\"bob\");",
    "        ",
    "        System.out.println(\"\\n[1.2] Creating conversation...\");",
    "        String convId = service.createConversation(\"alice\", List.of(\"bob\"));",
    "        System.out.println(\"    Created: \" + convId);",
    "        ",
    "        System.out.println(\"\\n[1.3] Sending messages...\");",
    "        service.sendMessage(\"alice\", convId, \"Hey Bob!\");",
    "        service.sendMessage(\"bob\", convId, \"Hi Alice!\");",
    "        ",
    "        System.out.println(\"\\n[1.4] Bob received: \" + bobConn.getReceivedCount() + \" messages\");",
    "        ",
    "        // Test 2: Offline handling",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"TEST 2: Offline Handling\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        System.out.println(\"\\n[2.1] Bob goes offline...\");",
    "        service.disconnectUser(\"bob\");",
    "        ",
    "        System.out.println(\"\\n[2.2] Alice sends while Bob offline...\");",
    "        service.sendMessage(\"alice\", convId, \"Are you there?\");",
    "        ",
    "        System.out.println(\"\\n[2.3] Bob reconnects...\");",
    "        bobConn = service.connectUser(\"bob\");",
    "        ",
    "        // Test 3: Group Chat",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"TEST 3: Group Chat\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        WebSocketConnection charlieConn = service.connectUser(\"charlie\");",
    "        String groupId = service.createGroupChat(\"alice\", List.of(\"bob\", \"charlie\"), \"Trip Planning\");",
    "        System.out.println(\"    Created group: \" + groupId);",
    "        ",
    "        service.sendMessage(\"alice\", groupId, \"Let's plan the trip!\");",
    "        service.sendMessage(\"charlie\", groupId, \"I'm in!\");",
    "        ",
    "        System.out.println(\"\\n    Charlie received: \" + charlieConn.getReceivedCount() + \" messages\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"DEMO COMPLETE\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-18",
      "explanation": "Imports and module docstring for the DM system"
    },
    {
      "lines": "24-42",
      "explanation": "Enums defining message types, status, conversation types, and connection states"
    },
    {
      "lines": "45-73",
      "explanation": "Message dataclass with all fields including sequence number for ordering and to_dict for serialization"
    },
    {
      "lines": "76-107",
      "explanation": "Conversation dataclass supporting both direct and group chats with last message preview"
    },
    {
      "lines": "128-147",
      "explanation": "WebSocketConnection simulating real WebSocket for demo - stores sent messages in queue"
    },
    {
      "lines": "153-185",
      "explanation": "PresenceTracker managing user online status - maps user_id to session info like which server they're connected to"
    },
    {
      "lines": "191-237",
      "explanation": "WebSocketGateway managing connections and routing - the connection manager for WebSocket servers"
    },
    {
      "lines": "243-294",
      "explanation": "MessageQueue simulating Kafka with partitioning by conversation_id for message ordering"
    },
    {
      "lines": "300-398",
      "explanation": "MessageStore simulating Cassandra - handles conversations, messages, read receipts, and pending message queue"
    },
    {
      "lines": "404-578",
      "explanation": "DirectMessageService - main API coordinating all components with sendMessage, getConversations, markAsRead methods"
    },
    {
      "lines": "510-537",
      "explanation": "sendMessage implementation - validates, generates IDs, persists, then publishes event for async delivery"
    },
    {
      "lines": "584-700",
      "explanation": "Comprehensive demonstration showing all features: 1:1 chat, offline handling, groups, read receipts"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "sendMessage": {
          "complexity": "O(group_size)",
          "explanation": "Must notify all members in conversation; single DB write is O(1) but fan-out is O(n)"
        },
        "getConversations": {
          "complexity": "O(n log n) without cache, O(1) with cache",
          "explanation": "Sorting by last message time; caching recommended for hot users"
        },
        "getMessages": {
          "complexity": "O(page_size)",
          "explanation": "Range query on Cassandra partition, returns fixed page size"
        },
        "markAsRead": {
          "complexity": "O(group_size)",
          "explanation": "Update receipt then notify other members"
        },
        "createGroupChat": {
          "complexity": "O(members)",
          "explanation": "Create conversation and notify all members"
        }
      },
      "overall_change": "Adds constant-time message persistence but O(n) fan-out for delivery. WebSocket push is O(1) per connection."
    },
    "space": {
      "additional_space": "O(users * conversations + messages)",
      "explanation": "Session store: O(online_users). Message store: O(total_messages) partitioned by conversation. Pending queue: O(offline_messages)."
    }
  },
  "dry_run": {
    "example_input": "Alice sends 'Hello!' to conversation with Bob who is online",
    "steps": [
      {
        "step": 1,
        "action": "sendMessage('alice', 'conv_1', 'Hello!')",
        "state": "Validating conversation exists and alice is member",
        "explanation": "Check conv_1 exists in store and alice in member_ids"
      },
      {
        "step": 2,
        "action": "Generate message_id and sequence",
        "state": "msg_abc123, sequence=1",
        "explanation": "UUID for message_id, atomic increment for sequence"
      },
      {
        "step": 3,
        "action": "Create Message object",
        "state": "Message(msg_abc123, conv_1, alice, 'Hello!', TEXT, 1, now, SENT)",
        "explanation": "Populate all message fields"
      },
      {
        "step": 4,
        "action": "store.save_message()",
        "state": "messages['conv_1'] = [message]",
        "explanation": "Persist to Cassandra (durability first)"
      },
      {
        "step": 5,
        "action": "Update conversation metadata",
        "state": "conv.last_message_preview = 'Hello!'",
        "explanation": "Update for conversation list view"
      },
      {
        "step": 6,
        "action": "Publish MessageEvent to Kafka",
        "state": "queue.publish(event) on partition hash('conv_1')",
        "explanation": "Async delivery via message queue"
      },
      {
        "step": 7,
        "action": "Consumer receives event",
        "state": "_handle_message_event called",
        "explanation": "Message queue consumer processes event"
      },
      {
        "step": 8,
        "action": "Lookup members except sender",
        "state": "members = ['bob']",
        "explanation": "Get all recipients for fan-out"
      },
      {
        "step": 9,
        "action": "Check bob's presence",
        "state": "presence.is_online('bob') = True",
        "explanation": "Redis lookup for session"
      },
      {
        "step": 10,
        "action": "Route to bob's WebSocket",
        "state": "gateway.send_to_user('bob', notification)",
        "explanation": "Push message via WebSocket connection"
      }
    ],
    "final_output": "message_id='msg_abc123', Bob receives NEW_MESSAGE event via WebSocket in <100ms"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Send message between two online users - should appear instantly",
      "Create same DM conversation twice - should return existing conv_id",
      "Send to non-existent conversation - should raise ValueError"
    ],
    "likely_bugs": [
      "Message delivered to sender (forgot to skip sender_id in fan-out)",
      "Messages out of order (not using sequence number for sorting)",
      "Offline messages lost (not queuing before presence check)",
      "Race condition in sequence number generation (need atomic increment)"
    ],
    "recommended_logs_or_asserts": [
      "assert message.sequence_num > last_sequence for ordering",
      "log every WebSocket send with user_id and message_id",
      "log presence transitions: online/offline with timestamp"
    ],
    "how_to_localize": "1. Check if message persisted (query store.get_messages). 2. Check if event published (log queue.publish). 3. Check presence (presence.is_online). 4. Check WebSocket send result (gateway.send_to_user return value)."
  },
  "edge_cases": [
    {
      "case": "User sends to themselves",
      "handling": "Allow in storage but skip WebSocket delivery (no self-notification)",
      "gotcha": "Don't create infinite loop in fan-out"
    },
    {
      "case": "Very large group (256 members)",
      "handling": "Fan-out still O(n) but batch WebSocket sends, consider pagination for typing indicators",
      "gotcha": "Single message causes 255 WebSocket pushes"
    },
    {
      "case": "User disconnects mid-message",
      "handling": "Message already persisted, will be delivered on reconnect from pending queue",
      "gotcha": "Don't mark as DELIVERED until WebSocket ACK"
    },
    {
      "case": "Duplicate message send (client retry)",
      "handling": "Idempotency key (client_message_id) to detect duplicates",
      "gotcha": "Without dedup, message appears twice"
    },
    {
      "case": "Empty conversation (all members left)",
      "handling": "Keep conversation for history, prevent new messages",
      "gotcha": "Check member count before allowing send"
    },
    {
      "case": "Concurrent conversation creation",
      "handling": "findDirectConversation check + database-level unique constraint",
      "gotcha": "Race condition can create duplicate DM conversations"
    }
  ],
  "test_cases": [
    {
      "name": "Basic 1:1 messaging",
      "input": "create_conversation('alice', ['bob']), send_message('alice', conv_id, 'Hi')",
      "expected": "Bob receives NEW_MESSAGE via WebSocket with content='Hi'",
      "explanation": "Verifies basic message flow works end-to-end"
    },
    {
      "name": "Offline message delivery",
      "input": "disconnect_user('bob'), send_message('alice', conv_id, 'Test'), connect_user('bob')",
      "expected": "Bob receives pending message on reconnect",
      "explanation": "Verifies offline queuing and sync"
    },
    {
      "name": "Group message fan-out",
      "input": "create_group(['alice', 'bob', 'charlie']), send_message('alice', group_id, 'Hi all')",
      "expected": "Both bob and charlie receive message, alice does not",
      "explanation": "Verifies fan-out skips sender"
    },
    {
      "name": "Conversation ordering",
      "input": "send to conv1, wait, send to conv2, get_conversations('alice')",
      "expected": "conv2 appears before conv1 in list",
      "explanation": "Verifies sorting by last_message_time"
    },
    {
      "name": "Message sequence",
      "input": "send 3 messages rapidly to same conversation",
      "expected": "Messages have sequence_num 1, 2, 3 in order",
      "explanation": "Verifies atomic sequence generation"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Delivering message before persisting",
      "why_wrong": "If server crashes after WebSocket send but before DB write, message is lost forever",
      "correct_approach": "Always persist first, then deliver. 'Store-then-push' pattern.",
      "code_example_wrong": "# BAD: gateway.send(msg); store.save(msg)",
      "code_example_correct": "# GOOD: store.save(msg); gateway.send(msg)"
    },
    {
      "mistake": "Using timestamp for message ordering",
      "why_wrong": "Clock skew between servers can cause out-of-order messages",
      "correct_approach": "Use monotonic sequence numbers per conversation",
      "code_example_wrong": "# BAD: messages.sort(key=lambda m: m.timestamp)",
      "code_example_correct": "# GOOD: messages.sort(key=lambda m: m.sequence_num)"
    },
    {
      "mistake": "Not partitioning Kafka by conversation_id",
      "why_wrong": "Messages for same conversation can go to different partitions, breaking FIFO guarantee",
      "correct_approach": "Always use conversation_id as partition key",
      "code_example_wrong": "# BAD: kafka.send(topic, message)  # random partition",
      "code_example_correct": "# GOOD: kafka.send(topic, message, key=conversation_id)"
    },
    {
      "mistake": "Synchronous fan-out in API thread",
      "why_wrong": "For large groups, API latency = O(group_size) - unacceptable for sender",
      "correct_approach": "Async fan-out via message queue consumer",
      "code_example_wrong": "# BAD: for member in members: websocket.send(member, msg)",
      "code_example_correct": "# GOOD: kafka.publish(event); # consumer handles fan-out"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying requirements (100ms latency, 10M connections). Then draw the architecture showing message flow. Explain why you decouple persistence from delivery. Walk through online vs offline user paths. Discuss trade-offs (push vs pull, Cassandra vs SQL).",
    "what_to_mention": [
      "Store-then-push pattern for reliability",
      "Kafka partitioning for ordering",
      "Redis for session/presence tracking",
      "WebSocket vs polling for real-time",
      "Exactly-once delivery challenges"
    ],
    "time_allocation": "2 min: requirements clarification, 5 min: architecture diagram, 5 min: key components (WebSocket, Kafka, storage), 3 min: edge cases (offline, ordering)",
    "if_stuck": [
      "Think about: What happens when recipient is offline?",
      "Think about: How do we ensure messages are in order?",
      "Think about: How does server know which WebSocket server the user is on?"
    ]
  },
  "connection_to_next_part": "Part 5 could add message reactions, replies, or message deletion. The current Message model supports reply_to_id for threading. The pub/sub architecture easily extends to broadcast REACTION_ADDED events. Message deletion would require soft-delete with tombstones for sync consistency.",
  "communication_script": {
    "transition_from_previous": "Great, so Parts 1-3 covered feed, stories, and search using request-response patterns. Part 4 is fundamentally different - we need real-time bidirectional communication for DMs. Let me explain my approach...",
    "explaining_changes": "The key change is introducing WebSocket connections for push-based delivery. I'll add three new components: a WebSocket gateway for connection management, a presence tracker in Redis to know which server each user is on, and a Kafka message queue for reliable, ordered delivery.",
    "while_extending_code": [
      "I'm adding a MessageStore class to handle persistence - think of it as our Cassandra abstraction",
      "The PresenceTracker maps user_id to their WebSocket server - this is critical for routing",
      "sendMessage follows store-then-push: persist first for durability, then async fan-out for speed"
    ],
    "after_completing": "This now handles Part 4. sendMessage is O(group_size) due to fan-out. getMessages is O(page_size) with Cassandra range queries. The architecture supports 10M connections by horizontally scaling WebSocket gateways. Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Clarify requirements: 100ms latency, 10M connections, offline handling, group support",
    "by_5_min": "Draw architecture: WebSocket gateway, Kafka, Cassandra, Redis for presence",
    "by_10_min": "Explain message flow for online and offline cases, discuss ordering guarantees",
    "by_15_min": "Address edge cases: large groups, disconnection, deduplication",
    "warning_signs": "If still discussing architecture at 10 min, skip to code walkthrough. If no mention of offline handling by 5 min, interviewer may prompt."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "DMs are mostly independent of Parts 1-3. Only shared components are User model and media storage. If previous parts have issues, mention: 'DMs use the same CDN for media sharing, but otherwise this is a separate subsystem.'",
    "if_new_requirement_unclear": "Ask: 'For group chats, is there a member limit? Should I support typing indicators? Is E2E encryption in scope or should I just mention it?'",
    "if_running_behind": "Focus on 1:1 messaging first, mention group as extension. Say: 'Groups follow same pattern but with fan-out to multiple recipients.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning sequence numbers for ordering instead of timestamps",
      "Explaining store-then-push pattern unprompted",
      "Discussing exactly-once delivery challenges",
      "Bringing up E2E encryption considerations",
      "Mentioning WebSocket heartbeats for connection health"
    ]
  },
  "pattern_recognition": {
    "pattern": "Pub/Sub with Ordered Delivery",
    "indicators": [
      "Real-time requirement (<100ms)",
      "Multiple recipients (fan-out)",
      "Ordering guarantees within conversation",
      "Offline support (durable messaging)"
    ],
    "similar_problems": [
      "Slack/Discord messaging",
      "WhatsApp architecture",
      "Twitter DMs",
      "Real-time collaboration tools"
    ],
    "template": "1. Validate and persist (durability)\n2. Publish to partitioned queue (ordering)\n3. Consumer fans out to recipients\n4. Push to online, queue for offline\n5. Sync pending on reconnect"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see '<100ms delivery', I immediately think WebSocket not polling",
      "why": "Polling has inherent latency (half the poll interval on average)"
    },
    {
      "step": 2,
      "thought": "10M concurrent connections means horizontal scaling of WebSocket servers",
      "why": "Single server can handle ~100K connections max"
    },
    {
      "step": 3,
      "thought": "Need session store to route messages to correct server",
      "why": "User connects to one server, message arrives at another - need routing layer"
    },
    {
      "step": 4,
      "thought": "Kafka partitioned by conversation_id for ordering",
      "why": "Same partition = FIFO guarantee within conversation"
    },
    {
      "step": 5,
      "thought": "Store before push for reliability",
      "why": "If push fails, message isn't lost - can retry or sync on reconnect"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Understanding of real-time architecture (WebSocket vs polling)",
      "Handling of distributed systems challenges (ordering, delivery guarantees)",
      "Graceful degradation (offline users, reconnection)",
      "Scalability thinking (10M connections, partitioning)"
    ],
    "bonus_points": [
      "Mentioning idempotency for message sends",
      "Discussing exactly-once vs at-least-once delivery",
      "Bringing up E2E encryption trade-offs",
      "Considering multi-device scenarios"
    ],
    "red_flags": [
      "Suggesting HTTP polling for real-time",
      "Not addressing offline users",
      "Using timestamps for ordering",
      "Synchronous fan-out blocking sender"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for boilerplate (dataclasses, enum definitions)",
      "Let it help with Kafka/Redis API syntax if unfamiliar",
      "Generate test cases from your requirements"
    ],
    "what_not_to_do": [
      "Don't let AI design the architecture - explain YOUR design",
      "Don't accept code that delivers before persisting",
      "Verify partitioning logic is correct"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without discussing architecture",
      "Not asking about group size limits or latency requirements",
      "Ignoring the '10M connections' scale requirement"
    ],
    "technical": [
      "Suggesting database polling for real-time",
      "Not separating persistence from delivery",
      "Using global sequence numbers instead of per-conversation"
    ],
    "communication": [
      "Not explaining WHY WebSocket over polling",
      "Forgetting to discuss offline user flow",
      "Not mentioning trade-offs in chosen approach"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I address real-time delivery (<100ms)?",
      "Did I handle offline users with queuing?",
      "Did I explain message ordering guarantees?",
      "Did I discuss fan-out for groups?",
      "Did I mention how to scale WebSocket servers?"
    ],
    "quick_code_review": [
      "sendMessage persists BEFORE publishing",
      "Sequence numbers are per-conversation, not global",
      "Fan-out skips the sender",
      "Presence check before WebSocket send"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "WebSocket heartbeat/ping-pong for connection health",
      "Message delivery acknowledgments from client",
      "Retry logic with exponential backoff for failed pushes",
      "Metrics: message latency p50/p99, connection count, queue depth",
      "Rate limiting per user to prevent spam",
      "Message size limits and content validation"
    ],
    "why_not_in_interview": "Focus on core architecture and flow; mention these verbally as 'production hardening'",
    "how_to_mention": "Say: 'In production, I'd add delivery ACKs from clients, retry logic for failed pushes, and metrics for latency monitoring. I'd also implement rate limiting to prevent abuse.'"
  },
  "generated_at": "2026-01-18T21:41:45.977495",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}