{
  "problem_title": "Travel Expense Calculation System - Part 3: Per-Diem Calculations by Location",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 introduces **location-based per-diem rates** and **trip management**. Instead of fixed global limits, reimbursement caps now vary by travel destination. The system must track trips with date ranges, associate expenses with trips, and apply location-specific hotel/meal limits when calculating reimbursements.",
    "new_requirements": [
      "Store per-diem configuration (hotel limit, meal limit) for each location",
      "Create trips with employee, location, and date range",
      "Associate expenses with specific trips",
      "Calculate trip reimbursement using location-specific limits",
      "Calculate days from date range: (endDate - startDate).days + 1",
      "Calculate nights from date range: (endDate - startDate).days"
    ],
    "new_constraints": [
      "Hotel limit varies by location (default $200/night if location not configured)",
      "Meal limit varies by location (default $50/day if location not configured)",
      "Meal 50% rule still applies, then capped at location limit",
      "Trip dates in YYYY-MM-DD format",
      "Expenses must reference nights/days from details or infer from trip dates"
    ],
    "key_insight": "The key insight is that **per-diem limits become dynamic parameters looked up at calculation time**, not static strategy properties. Create a LocationPerDiem config that overrides default limits, and inject these limits into the reimbursement calculation when processing trip expenses."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Set location-specific per-diem rates",
        "how_met": "setLocationPerDiem() stores LocationPerDiem objects in a HashMap keyed by location name",
        "gotchas": [
          "Case sensitivity of location names",
          "Forgetting default fallback for unknown locations"
        ]
      },
      {
        "requirement": "Create trips with date ranges",
        "how_met": "createTrip() creates Trip object with parsed dates, auto-generates unique trip ID",
        "gotchas": [
          "Date parsing format must be YYYY-MM-DD",
          "Days vs nights calculation differs"
        ]
      },
      {
        "requirement": "Add expenses to trips",
        "how_met": "addExpenseToTrip() creates TripExpense and appends to trip's expense list",
        "gotchas": [
          "Validating trip exists",
          "Handling currency conversion from Part 2"
        ]
      },
      {
        "requirement": "Calculate trip reimbursement with location limits",
        "how_met": "calculateTripReimbursement() looks up location per-diem and applies limits per expense type",
        "gotchas": [
          "Meal: apply 50% THEN cap at limit",
          "Hotel: cap per-night, not total"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "setLocationPerDiem",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap put operation"
      },
      {
        "operation": "createTrip",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap put with generated key"
      },
      {
        "operation": "addExpenseToTrip",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "List append operation"
      },
      {
        "operation": "calculateTripReimbursement",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Iterate through n expenses in trip"
      }
    ],
    "non_goals": [
      "Partial day calculations (arrival/departure adjustments)",
      "Per-expense currency tracking within trips",
      "Trip modification or deletion",
      "Expense categorization beyond type"
    ]
  },
  "assumptions": [
    "Location names are exact matches (case-sensitive or normalized consistently)",
    "Date format is always valid YYYY-MM-DD",
    "Trip expenses details include 'nights' for hotel and 'days' for meals, or we infer from trip dates",
    "All amounts are positive",
    "One currency per trip (or pre-converted to USD)",
    "Trip IDs are sequential: trip_1, trip_2, etc."
  ],
  "tradeoffs": [
    {
      "decision": "Store per-diem as separate config vs. embedding in strategies",
      "chosen": "Separate LocationPerDiem config map",
      "why": "Allows runtime configuration without recreating strategy objects; cleaner separation of policy from calculation logic",
      "alternative": "Create location-specific strategy instances",
      "when_to_switch": "If locations have fundamentally different calculation rules, not just different limits"
    },
    {
      "decision": "Trip-centric vs expense-centric storage",
      "chosen": "Trip contains list of expenses",
      "why": "Natural for calculating trip totals; matches domain model",
      "alternative": "Global expense list with trip_id foreign key",
      "when_to_switch": "If need to query expenses across trips frequently"
    },
    {
      "decision": "Infer days/nights from trip vs. require in details",
      "chosen": "Use details if provided, fallback to trip dates",
      "why": "Flexibility for partial-day scenarios while maintaining simple default",
      "alternative": "Always calculate from trip dates",
      "when_to_switch": "If strict consistency is required across all trips"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures (setLocationPerDiem, createTrip, addExpenseToTrip, calculateTripReimbursement)",
      "Trip ID format (trip_N)",
      "Default per-diem values",
      "Meal 50% reimbursement rate constant"
    ],
    "what_to_change": [
      "LocationPerDiem dataclass - new fields for other expense limits",
      "Trip class - new fields for trip status, approval workflow",
      "Expense details schema - new fields for receipts, notes"
    ],
    "interfaces_and_boundaries": "The LocationPerDiem lookup is isolated in _get_per_diem_for_location(). Part 4 could add seasonal rates or tiered limits by modifying only this lookup without touching calculation logic.",
    "invariants": [
      "Trip expenses are immutable once added",
      "Location per-diem can be updated anytime before calculation",
      "Trip ID uniqueness guaranteed by counter",
      "Default per-diem always available for unknown locations"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     BEFORE (Part 2)                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  ExpenseManager                                              \u2502\n\u2502  \u251c\u2500\u2500 _strategies: {FLIGHT, HOTEL, MEAL, TRANSPORT}          \u2502\n\u2502  \u251c\u2500\u2500 _currency_converter                                     \u2502\n\u2502  \u2514\u2500\u2500 Fixed limits: Hotel $200/night, Meal $50/day           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     AFTER (Part 3)                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  ExpenseManager                                              \u2502\n\u2502  \u251c\u2500\u2500 _strategies: {FLIGHT, HOTEL, MEAL, TRANSPORT}          \u2502\n\u2502  \u251c\u2500\u2500 _currency_converter                                     \u2502\n\u2502  \u251c\u2500\u2500 _location_per_diems: {                                 \u2502\n\u2502  \u2502       \"NYC\": {hotel: $350, meal: $80}                    \u2502\n\u2502  \u2502       \"SF\":  {hotel: $300, meal: $75}                    \u2502\n\u2502  \u2502   }                                                       \u2502\n\u2502  \u251c\u2500\u2500 _trips: {                                               \u2502\n\u2502  \u2502       \"trip_1\": Trip(emp001, NYC, 03/15-03/18, [...])    \u2502\n\u2502  \u2502   }                                                       \u2502\n\u2502  \u2514\u2500\u2500 Dynamic limits: Looked up by trip.location             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          calculateTripReimbursement(\"trip_1\") FLOW              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                   \u2502\n\u2502  Step 1: Lookup Trip                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  trips[\"trip_1\"] \u2192 Trip(NYC, 2024-03-15 to 2024-03-18)     \u2502 \u2502\n\u2502  \u2502  Days: 4, Nights: 3                                         \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                              \u2502                                    \u2502\n\u2502                              \u25bc                                    \u2502\n\u2502  Step 2: Lookup Per-Diem                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  location_per_diems[\"NYC\"] \u2192 {hotel: $350, meal: $80}      \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                              \u2502                                    \u2502\n\u2502                              \u25bc                                    \u2502\n\u2502  Step 3: Process Each Expense                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  HOTEL $1200 (3 nights)                                     \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500 per_night = $1200 / 3 = $400                          \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500 capped = min($400, $350) = $350                       \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500 total = $350 \u00d7 3 = $1050                              \u2502 \u2502\n\u2502  \u2502                                                             \u2502 \u2502\n\u2502  \u2502  MEAL $400 (4 days)                                         \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500 per_day = $400 / 4 = $100                             \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500 after_50% = $100 \u00d7 0.5 = $50                          \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500 capped = min($50, $80) = $50                          \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500 total = $50 \u00d7 4 = $200                                \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                              \u2502                                    \u2502\n\u2502                              \u25bc                                    \u2502\n\u2502  Step 4: Sum Results                                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  Total = $1050 + $200 = $1250                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Create new HotelExpenseStrategy and MealExpenseStrategy instances for each location with hardcoded limits. When calculating, switch strategies based on location.",
      "time_complexity": "O(n) for calculation",
      "space_complexity": "O(L \u00d7 S) where L=locations, S=strategy types",
      "why_not_optimal": "Duplicates strategy objects for each location; coupling between location config and strategy instances; difficult to update limits at runtime; violates Open-Closed Principle when adding new locations."
    },
    {
      "name": "Optimal Approach",
      "description": "Separate location configuration from calculation logic. Store LocationPerDiem configs in a map, create Trip objects to associate expenses with locations, and pass the appropriate limits into calculation methods at runtime.",
      "time_complexity": "O(n) for calculation where n=expenses in trip",
      "space_complexity": "O(L + T + E) where L=locations, T=trips, E=total expenses",
      "key_insight": "Treat per-diem limits as data, not code. Lookup at calculation time, inject into generic calculation logic. This follows the Strategy pattern but parameterizes the strategy with runtime data."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution Design\n\n### Core Architecture\n\nThe solution introduces three new concepts:\n\n1. **LocationPerDiem**: A configuration object storing hotel and meal limits for a location\n2. **Trip**: An entity tracking employee, location, dates, and associated expenses\n3. **TripExpense**: A lightweight expense record associated with a trip\n\n### Key Design Decisions\n\n**1. Configuration Lookup Pattern**\n```python\ndef _get_per_diem_for_location(self, location: str) -> LocationPerDiem:\n    return self._location_per_diems.get(\n        location,\n        LocationPerDiem(DEFAULT_HOTEL, DEFAULT_MEAL)\n    )\n```\nThis provides **default fallback** for unknown locations, making the system robust.\n\n**2. Calculation Order for Meals**\n```\nreimbursed_per_day = min(per_day * 0.5, location_meal_limit)\n```\nThe **50% rule applies FIRST**, then we cap at the location limit. This is crucial for correct calculations.\n\n**3. Trip Date Calculations**\n```python\ndays = (end_date - start_date).days + 1  # Inclusive\nnights = (end_date - start_date).days     # Exclusive of last day\n```\nTrip March 15-18 = **4 days** (15, 16, 17, 18) but **3 nights** (15-16, 16-17, 17-18).\n\n### Data Flow\n\n```\nsetLocationPerDiem(\"NYC\", 350, 80)\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _location_per_diems          \u2502\n\u2502 {\"NYC\": {350, 80}}          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ncreateTrip(\"emp001\", \"NYC\", \"2024-03-15\", \"2024-03-18\")\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 _trips                       \u2502\n\u2502 {\"trip_1\": Trip(...)}       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\ncalculateTripReimbursement(\"trip_1\")\n         \u2502\n         \u25bc\nLookup trip \u2192 Lookup per-diem \u2192 Calculate each expense \u2192 Sum\n```",
    "data_structures": [
      {
        "structure": "Dict[str, LocationPerDiem]",
        "purpose": "O(1) lookup of per-diem config by location name"
      },
      {
        "structure": "Dict[str, Trip]",
        "purpose": "O(1) lookup of trips by trip ID"
      },
      {
        "structure": "List[TripExpense] in Trip",
        "purpose": "Sequential storage of trip expenses for iteration"
      },
      {
        "structure": "dataclass LocationPerDiem",
        "purpose": "Immutable config holder for hotel/meal limits"
      },
      {
        "structure": "dataclass Trip",
        "purpose": "Entity grouping location, dates, and expenses"
      }
    ],
    "algorithm_steps": [
      "Step 1: setLocationPerDiem stores {location \u2192 LocationPerDiem(hotel_limit, meal_limit)} in HashMap",
      "Step 2: createTrip parses dates, generates unique ID, creates Trip object, stores in HashMap",
      "Step 3: addExpenseToTrip validates trip exists, creates TripExpense, appends to trip.expenses",
      "Step 4: calculateTripReimbursement retrieves trip from HashMap",
      "Step 5: Lookup LocationPerDiem for trip.location (or use default)",
      "Step 6: For each expense in trip: dispatch to appropriate calculation method",
      "Step 7: Hotel: cap (amount/nights) at location hotel_limit, multiply by nights",
      "Step 8: Meal: apply 50% to (amount/days), cap at location meal_limit, multiply by days",
      "Step 9: Flight/Transport: use existing Part 1/2 logic",
      "Step 10: Sum all expense reimbursements, round to 2 decimal places"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Travel Expense Calculation System - Part 3: Per-Diem Calculations by Location",
    "",
    "This module implements location-based per-diem rates and trip management",
    "for a travel expense reimbursement system.",
    "\"\"\"",
    "",
    "from datetime import datetime",
    "from typing import Dict, List, Any, Optional",
    "from dataclasses import dataclass, field",
    "from abc import ABC, abstractmethod",
    "from enum import Enum",
    "",
    "",
    "# ============== Enums ==============",
    "",
    "class ExpenseType(Enum):",
    "    \"\"\"Supported expense types.\"\"\"",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "# ============== Data Classes ==============",
    "",
    "@dataclass(frozen=True)",
    "class LocationPerDiem:",
    "    \"\"\"",
    "    Per-diem configuration for a specific travel location.",
    "    ",
    "    Attributes:",
    "        hotel_limit: Maximum hotel reimbursement per night",
    "        meal_limit: Maximum meal reimbursement per day (after 50% rule)",
    "    \"\"\"",
    "    hotel_limit: float",
    "    meal_limit: float",
    "",
    "",
    "@dataclass",
    "class TripExpense:",
    "    \"\"\"",
    "    An expense record associated with a trip.",
    "    ",
    "    Attributes:",
    "        expense_type: Type of expense (HOTEL, MEAL, FLIGHT, TRANSPORT)",
    "        amount: Total expense amount",
    "        details: Additional details (nights, days, currency, etc.)",
    "    \"\"\"",
    "    expense_type: str",
    "    amount: float",
    "    details: Dict[str, Any] = field(default_factory=dict)",
    "",
    "",
    "@dataclass",
    "class Trip:",
    "    \"\"\"",
    "    Represents a business trip with associated expenses.",
    "    ",
    "    Attributes:",
    "        trip_id: Unique identifier for the trip",
    "        employee_id: Employee who took the trip",
    "        location: Travel destination",
    "        start_date: Trip start date",
    "        end_date: Trip end date",
    "        expenses: List of expenses for this trip",
    "    \"\"\"",
    "    trip_id: str",
    "    employee_id: str",
    "    location: str",
    "    start_date: datetime",
    "    end_date: datetime",
    "    expenses: List[TripExpense] = field(default_factory=list)",
    "    ",
    "    def get_days(self) -> int:",
    "        \"\"\"Calculate number of days (inclusive of start and end).\"\"\"",
    "        return (self.end_date - self.start_date).days + 1",
    "    ",
    "    def get_nights(self) -> int:",
    "        \"\"\"Calculate number of nights.\"\"\"",
    "        return (self.end_date - self.start_date).days",
    "",
    "",
    "# ============== Strategy Pattern for Expense Calculations ==============",
    "",
    "class ExpenseStrategy(ABC):",
    "    \"\"\"Abstract base class for expense calculation strategies.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def calculate_reimbursement(self, amount: float,",
    "                                details: Dict[str, Any]) -> float:",
    "        \"\"\"Calculate reimbursable amount for an expense.\"\"\"",
    "        pass",
    "",
    "",
    "class FlightExpenseStrategy(ExpenseStrategy):",
    "    \"\"\"Flight: 100% reimbursed up to policy limit.\"\"\"",
    "    ",
    "    def __init__(self, default_limit: float = 2000.0):",
    "        self.default_limit = default_limit",
    "    ",
    "    def calculate_reimbursement(self, amount: float,",
    "                                details: Dict[str, Any]) -> float:",
    "        limit = details.get(\"limit\", self.default_limit)",
    "        return min(amount, limit)",
    "",
    "",
    "class TransportExpenseStrategy(ExpenseStrategy):",
    "    \"\"\"Transport: 100% reimbursed, no limit.\"\"\"",
    "    ",
    "    def calculate_reimbursement(self, amount: float,",
    "                                details: Dict[str, Any]) -> float:",
    "        return amount",
    "",
    "",
    "# ============== Currency Converter (from Part 2) ==============",
    "",
    "class CurrencyConverter:",
    "    \"\"\"Handles currency conversion for expenses.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._rates: Dict[str, float] = {\"USD\": 1.0}",
    "    ",
    "    def set_exchange_rate(self, currency: str, rate_to_usd: float) -> None:",
    "        \"\"\"Set exchange rate from currency to USD.\"\"\"",
    "        self._rates[currency] = rate_to_usd",
    "    ",
    "    def convert_to_usd(self, amount: float, currency: str) -> float:",
    "        \"\"\"Convert amount from currency to USD.\"\"\"",
    "        if currency not in self._rates:",
    "            raise ValueError(f\"Unknown currency: {currency}\")",
    "        return amount * self._rates[currency]",
    "",
    "",
    "# ============== Main Expense Manager ==============",
    "",
    "class ExpenseManager:",
    "    \"\"\"",
    "    Travel expense management system with location-based per-diem support.",
    "    ",
    "    Features:",
    "    - Location-specific hotel and meal reimbursement limits",
    "    - Trip creation with date ranges",
    "    - Trip-based expense tracking and reimbursement calculation",
    "    - Multi-currency support (from Part 2)",
    "    ",
    "    Reimbursement Policies:",
    "    - Flight: 100% up to limit",
    "    - Hotel: 100% up to per-night limit (location-specific)",
    "    - Meals: 50% up to per-day limit (location-specific)",
    "    - Transport: 100% no limit",
    "    \"\"\"",
    "    ",
    "    # Default per-diem values",
    "    DEFAULT_HOTEL_LIMIT: float = 200.0",
    "    DEFAULT_MEAL_LIMIT: float = 50.0",
    "    MEAL_REIMBURSEMENT_RATE: float = 0.5",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize the expense manager.\"\"\"",
    "        # Part 2: Currency conversion",
    "        self._currency_converter = CurrencyConverter()",
    "        ",
    "        # Part 3: Location and trip management",
    "        self._location_per_diems: Dict[str, LocationPerDiem] = {}",
    "        self._trips: Dict[str, Trip] = {}",
    "        self._trip_counter: int = 0",
    "        ",
    "        # Strategy registry",
    "        self._flight_strategy = FlightExpenseStrategy()",
    "        self._transport_strategy = TransportExpenseStrategy()",
    "    ",
    "    # ============== Part 2 Methods ==============",
    "    ",
    "    def set_exchange_rate(self, currency: str, rate_to_usd: float) -> None:",
    "        \"\"\"Set exchange rate from currency to USD.\"\"\"",
    "        self._currency_converter.set_exchange_rate(currency, rate_to_usd)",
    "    ",
    "    # ============== Part 3 Methods ==============",
    "    ",
    "    def set_location_per_diem(self, location: str,",
    "                              hotel_limit: float,",
    "                              meal_limit: float) -> None:",
    "        \"\"\"",
    "        Set per-diem rates for a specific location.",
    "        ",
    "        Args:",
    "            location: City/location name (e.g., 'NYC', 'San Francisco')",
    "            hotel_limit: Maximum hotel reimbursement per night",
    "            meal_limit: Maximum meal reimbursement per day",
    "        ",
    "        Example:",
    "            manager.set_location_per_diem('NYC', 350.0, 80.0)",
    "        \"\"\"",
    "        self._location_per_diems[location] = LocationPerDiem(",
    "            hotel_limit=hotel_limit,",
    "            meal_limit=meal_limit",
    "        )",
    "    ",
    "    def create_trip(self, employee_id: str, location: str,",
    "                    start_date: str, end_date: str) -> str:",
    "        \"\"\"",
    "        Create a new trip for an employee.",
    "        ",
    "        Args:",
    "            employee_id: Employee identifier",
    "            location: Travel destination",
    "            start_date: Trip start date (YYYY-MM-DD)",
    "            end_date: Trip end date (YYYY-MM-DD)",
    "        ",
    "        Returns:",
    "            Unique trip ID (format: trip_N)",
    "        ",
    "        Example:",
    "            trip_id = manager.create_trip('emp001', 'NYC', '2024-03-15', '2024-03-18')",
    "        \"\"\"",
    "        self._trip_counter += 1",
    "        trip_id = f\"trip_{self._trip_counter}\"",
    "        ",
    "        trip = Trip(",
    "            trip_id=trip_id,",
    "            employee_id=employee_id,",
    "            location=location,",
    "            start_date=datetime.strptime(start_date, \"%Y-%m-%d\"),",
    "            end_date=datetime.strptime(end_date, \"%Y-%m-%d\"),",
    "            expenses=[]",
    "        )",
    "        ",
    "        self._trips[trip_id] = trip",
    "        return trip_id",
    "    ",
    "    def add_expense_to_trip(self, trip_id: str, expense_type: str,",
    "                            amount: float, details: Dict[str, Any]) -> None:",
    "        \"\"\"",
    "        Add an expense to an existing trip.",
    "        ",
    "        Args:",
    "            trip_id: Trip identifier",
    "            expense_type: Type of expense (HOTEL, MEAL, FLIGHT, TRANSPORT)",
    "            amount: Expense amount",
    "            details: Additional details (nights, days, currency, limit)",
    "        ",
    "        Raises:",
    "            ValueError: If trip_id not found",
    "        ",
    "        Example:",
    "            manager.add_expense_to_trip('trip_1', 'HOTEL', 1200, {'nights': 3})",
    "        \"\"\"",
    "        if trip_id not in self._trips:",
    "            raise ValueError(f\"Trip {trip_id} not found\")",
    "        ",
    "        # Handle currency conversion if specified",
    "        currency = details.get(\"currency\", \"USD\")",
    "        if currency != \"USD\":",
    "            amount = self._currency_converter.convert_to_usd(amount, currency)",
    "        ",
    "        expense = TripExpense(",
    "            expense_type=expense_type.upper(),",
    "            amount=amount,",
    "            details=details",
    "        )",
    "        ",
    "        self._trips[trip_id].expenses.append(expense)",
    "    ",
    "    def calculate_trip_reimbursement(self, trip_id: str) -> float:",
    "        \"\"\"",
    "        Calculate total reimbursement for a trip.",
    "        ",
    "        The calculation applies location-specific per-diem limits:",
    "        - Hotel: 100% up to location's nightly limit",
    "        - Meals: 50% up to location's daily limit",
    "        - Flight: 100% up to flight limit",
    "        - Transport: 100% no limit",
    "        ",
    "        Args:",
    "            trip_id: Trip identifier",
    "        ",
    "        Returns:",
    "            Total reimbursable amount (rounded to 2 decimal places)",
    "        ",
    "        Raises:",
    "            ValueError: If trip_id not found",
    "        ",
    "        Example:",
    "            total = manager.calculate_trip_reimbursement('trip_1')  # Returns 1250.0",
    "        \"\"\"",
    "        if trip_id not in self._trips:",
    "            raise ValueError(f\"Trip {trip_id} not found\")",
    "        ",
    "        trip = self._trips[trip_id]",
    "        per_diem = self._get_per_diem_for_location(trip.location)",
    "        ",
    "        total = 0.0",
    "        ",
    "        for expense in trip.expenses:",
    "            total += self._calculate_expense_reimbursement(",
    "                expense, per_diem, trip",
    "            )",
    "        ",
    "        return round(total, 2)",
    "    ",
    "    # ============== Private Helper Methods ==============",
    "    ",
    "    def _get_per_diem_for_location(self, location: str) -> LocationPerDiem:",
    "        \"\"\"",
    "        Get per-diem configuration for a location.",
    "        Falls back to default if location not configured.",
    "        \"\"\"",
    "        return self._location_per_diems.get(",
    "            location,",
    "            LocationPerDiem(",
    "                hotel_limit=self.DEFAULT_HOTEL_LIMIT,",
    "                meal_limit=self.DEFAULT_MEAL_LIMIT",
    "            )",
    "        )",
    "    ",
    "    def _calculate_expense_reimbursement(self, expense: TripExpense,",
    "                                         per_diem: LocationPerDiem,",
    "                                         trip: Trip) -> float:",
    "        \"\"\"Calculate reimbursement for a single expense.\"\"\"",
    "        expense_type = expense.expense_type.upper()",
    "        ",
    "        if expense_type == ExpenseType.HOTEL.value:",
    "            return self._calculate_hotel_reimbursement(expense, per_diem, trip)",
    "        elif expense_type == ExpenseType.MEAL.value:",
    "            return self._calculate_meal_reimbursement(expense, per_diem, trip)",
    "        elif expense_type == ExpenseType.FLIGHT.value:",
    "            return self._flight_strategy.calculate_reimbursement(",
    "                expense.amount, expense.details",
    "            )",
    "        elif expense_type == ExpenseType.TRANSPORT.value:",
    "            return self._transport_strategy.calculate_reimbursement(",
    "                expense.amount, expense.details",
    "            )",
    "        else:",
    "            return 0.0  # Unknown expense type",
    "    ",
    "    def _calculate_hotel_reimbursement(self, expense: TripExpense,",
    "                                       per_diem: LocationPerDiem,",
    "                                       trip: Trip) -> float:",
    "        \"\"\"",
    "        Calculate hotel reimbursement with location-specific limits.",
    "        ",
    "        Formula: min(amount_per_night, location_hotel_limit) \u00d7 nights",
    "        \"\"\"",
    "        nights = expense.details.get(\"nights\", trip.get_nights())",
    "        if nights <= 0:",
    "            return 0.0",
    "        ",
    "        per_night = expense.amount / nights",
    "        reimbursed_per_night = min(per_night, per_diem.hotel_limit)",
    "        return reimbursed_per_night * nights",
    "    ",
    "    def _calculate_meal_reimbursement(self, expense: TripExpense,",
    "                                      per_diem: LocationPerDiem,",
    "                                      trip: Trip) -> float:",
    "        \"\"\"",
    "        Calculate meal reimbursement with location-specific limits.",
    "        ",
    "        Formula: min(amount_per_day \u00d7 0.5, location_meal_limit) \u00d7 days",
    "        ",
    "        Note: The 50% rule is applied FIRST, then capped at location limit.",
    "        \"\"\"",
    "        days = expense.details.get(\"days\", trip.get_days())",
    "        if days <= 0:",
    "            return 0.0",
    "        ",
    "        per_day = expense.amount / days",
    "        # Apply 50% rate first, then cap at location limit",
    "        after_rate = per_day * self.MEAL_REIMBURSEMENT_RATE",
    "        reimbursed_per_day = min(after_rate, per_diem.meal_limit)",
    "        return reimbursed_per_day * days",
    "    ",
    "    # ============== Utility Methods ==============",
    "    ",
    "    def get_trip_summary(self, trip_id: str) -> Dict[str, Any]:",
    "        \"\"\"Get detailed summary of a trip for debugging/reporting.\"\"\"",
    "        if trip_id not in self._trips:",
    "            raise ValueError(f\"Trip {trip_id} not found\")",
    "        ",
    "        trip = self._trips[trip_id]",
    "        per_diem = self._get_per_diem_for_location(trip.location)",
    "        ",
    "        return {",
    "            \"trip_id\": trip.trip_id,",
    "            \"employee_id\": trip.employee_id,",
    "            \"location\": trip.location,",
    "            \"start_date\": trip.start_date.strftime(\"%Y-%m-%d\"),",
    "            \"end_date\": trip.end_date.strftime(\"%Y-%m-%d\"),",
    "            \"days\": trip.get_days(),",
    "            \"nights\": trip.get_nights(),",
    "            \"per_diem\": {",
    "                \"hotel_limit\": per_diem.hotel_limit,",
    "                \"meal_limit\": per_diem.meal_limit",
    "            },",
    "            \"expense_count\": len(trip.expenses),",
    "            \"total_reimbursement\": self.calculate_trip_reimbursement(trip_id)",
    "        }",
    "",
    "",
    "# ============== Demo and Testing ==============",
    "",
    "def main():",
    "    \"\"\"Demonstrate the expense management system.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Travel Expense System - Part 3: Per-Diem Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Create manager",
    "    manager = ExpenseManager()",
    "    ",
    "    # Set up location per-diems",
    "    print(\"\\n[1] Setting up location per-diems...\")",
    "    manager.set_location_per_diem(\"NYC\", 350.0, 80.0)",
    "    manager.set_location_per_diem(\"San Francisco\", 300.0, 75.0)",
    "    manager.set_location_per_diem(\"Austin\", 180.0, 60.0)",
    "    print(\"    NYC: Hotel $350/night, Meals $80/day\")",
    "    print(\"    San Francisco: Hotel $300/night, Meals $75/day\")",
    "    print(\"    Austin: Hotel $180/night, Meals $60/day\")",
    "    ",
    "    # Example from problem",
    "    print(\"\\n[2] Creating NYC trip (March 15-18)...\")",
    "    trip_id = manager.create_trip(\"emp001\", \"NYC\", \"2024-03-15\", \"2024-03-18\")",
    "    print(f\"    Created: {trip_id}\")",
    "    ",
    "    # Add expenses",
    "    print(\"\\n[3] Adding expenses to trip...\")",
    "    manager.add_expense_to_trip(trip_id, \"HOTEL\", 1200.0, {\"nights\": 3})",
    "    print(\"    Hotel: $1200 (3 nights = $400/night)\")",
    "    manager.add_expense_to_trip(trip_id, \"MEAL\", 400.0, {\"days\": 4})",
    "    print(\"    Meals: $400 (4 days = $100/day)\")",
    "    ",
    "    # Calculate reimbursement",
    "    print(\"\\n[4] Calculating reimbursement...\")",
    "    total = manager.calculate_trip_reimbursement(trip_id)",
    "    print(f\"\\n    Hotel: min($400, $350) \u00d7 3 = $1050\")",
    "    print(f\"    Meals: min($100 \u00d7 0.5, $80) \u00d7 4 = $200\")",
    "    print(f\"    \" + \"-\" * 30)",
    "    print(f\"    Total Reimbursement: ${total}\")",
    "    ",
    "    # Verify expected result",
    "    expected = 1250.0",
    "    assert total == expected, f\"Expected {expected}, got {total}\"",
    "    print(f\"    \u2713 Matches expected: ${expected}\")",
    "    ",
    "    # Test with default location",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"[5] Testing unknown location (uses defaults)...\")",
    "    trip2 = manager.create_trip(\"emp002\", \"Unknown City\", \"2024-04-01\", \"2024-04-03\")",
    "    manager.add_expense_to_trip(trip2, \"HOTEL\", 600.0, {\"nights\": 2})",
    "    manager.add_expense_to_trip(trip2, \"MEAL\", 200.0, {\"days\": 3})",
    "    total2 = manager.calculate_trip_reimbursement(trip2)",
    "    print(f\"    Hotel: min($300, $200) \u00d7 2 = $400\")",
    "    print(f\"    Meals: min($66.67 \u00d7 0.5, $50) \u00d7 3 = $100\")",
    "    print(f\"    Total: ${total2}\")",
    "    ",
    "    # Test with flight and transport",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"[6] Testing with all expense types...\")",
    "    trip3 = manager.create_trip(\"emp003\", \"Austin\", \"2024-05-10\", \"2024-05-12\")",
    "    manager.add_expense_to_trip(trip3, \"FLIGHT\", 450.0, {})",
    "    manager.add_expense_to_trip(trip3, \"HOTEL\", 400.0, {\"nights\": 2})",
    "    manager.add_expense_to_trip(trip3, \"MEAL\", 150.0, {\"days\": 3})",
    "    manager.add_expense_to_trip(trip3, \"TRANSPORT\", 75.0, {})",
    "    total3 = manager.calculate_trip_reimbursement(trip3)",
    "    print(f\"    Flight: $450 (100%, under limit)\")",
    "    print(f\"    Hotel: min($200, $180) \u00d7 2 = $360\")",
    "    print(f\"    Meals: min($50 \u00d7 0.5, $60) \u00d7 3 = $75\")",
    "    print(f\"    Transport: $75 (100%, no limit)\")",
    "    print(f\"    Total: ${total3}\")",
    "    ",
    "    # Print trip summary",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"[7] Trip Summary...\")",
    "    summary = manager.get_trip_summary(trip_id)",
    "    for key, value in summary.items():",
    "        print(f\"    {key}: {value}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed! \u2713\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.time.LocalDate;",
    "import java.time.format.DateTimeFormatter;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "",
    "/**",
    " * Travel Expense Calculation System - Part 3: Per-Diem Calculations",
    " * ",
    " * Supports location-based per-diem rates and trip management for",
    " * travel expense reimbursement calculations.",
    " */",
    "public class ExpenseManager {",
    "    ",
    "    // ============== Constants ==============",
    "    ",
    "    private static final double DEFAULT_HOTEL_LIMIT = 200.0;",
    "    private static final double DEFAULT_MEAL_LIMIT = 50.0;",
    "    private static final double MEAL_REIMBURSEMENT_RATE = 0.5;",
    "    private static final double DEFAULT_FLIGHT_LIMIT = 2000.0;",
    "    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");",
    "    ",
    "    // ============== Inner Classes ==============",
    "    ",
    "    /**",
    "     * Per-diem configuration for a specific location.",
    "     */",
    "    static class LocationPerDiem {",
    "        final double hotelLimit;",
    "        final double mealLimit;",
    "        ",
    "        LocationPerDiem(double hotelLimit, double mealLimit) {",
    "            this.hotelLimit = hotelLimit;",
    "            this.mealLimit = mealLimit;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Expense record associated with a trip.",
    "     */",
    "    static class TripExpense {",
    "        final String expenseType;",
    "        final double amount;",
    "        final Map<String, Object> details;",
    "        ",
    "        TripExpense(String expenseType, double amount, Map<String, Object> details) {",
    "            this.expenseType = expenseType.toUpperCase();",
    "            this.amount = amount;",
    "            this.details = details != null ? details : new HashMap<>();",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Represents a business trip.",
    "     */",
    "    static class Trip {",
    "        final String tripId;",
    "        final String employeeId;",
    "        final String location;",
    "        final LocalDate startDate;",
    "        final LocalDate endDate;",
    "        final List<TripExpense> expenses;",
    "        ",
    "        Trip(String tripId, String employeeId, String location,",
    "             LocalDate startDate, LocalDate endDate) {",
    "            this.tripId = tripId;",
    "            this.employeeId = employeeId;",
    "            this.location = location;",
    "            this.startDate = startDate;",
    "            this.endDate = endDate;",
    "            this.expenses = new ArrayList<>();",
    "        }",
    "        ",
    "        int getDays() {",
    "            return (int) ChronoUnit.DAYS.between(startDate, endDate) + 1;",
    "        }",
    "        ",
    "        int getNights() {",
    "            return (int) ChronoUnit.DAYS.between(startDate, endDate);",
    "        }",
    "        ",
    "        void addExpense(TripExpense expense) {",
    "            expenses.add(expense);",
    "        }",
    "    }",
    "    ",
    "    // ============== Instance Variables ==============",
    "    ",
    "    private final Map<String, Double> exchangeRates;",
    "    private final Map<String, LocationPerDiem> locationPerDiems;",
    "    private final Map<String, Trip> trips;",
    "    private int tripCounter;",
    "    ",
    "    // ============== Constructor ==============",
    "    ",
    "    public ExpenseManager() {",
    "        this.exchangeRates = new HashMap<>();",
    "        this.exchangeRates.put(\"USD\", 1.0);",
    "        this.locationPerDiems = new HashMap<>();",
    "        this.trips = new HashMap<>();",
    "        this.tripCounter = 0;",
    "    }",
    "    ",
    "    // ============== Part 2 Methods ==============",
    "    ",
    "    public void setExchangeRate(String currency, double rateToUsd) {",
    "        exchangeRates.put(currency, rateToUsd);",
    "    }",
    "    ",
    "    private double convertToUsd(double amount, String currency) {",
    "        Double rate = exchangeRates.get(currency);",
    "        if (rate == null) {",
    "            throw new IllegalArgumentException(\"Unknown currency: \" + currency);",
    "        }",
    "        return amount * rate;",
    "    }",
    "    ",
    "    // ============== Part 3 Methods ==============",
    "    ",
    "    /**",
    "     * Set per-diem rates for a specific location.",
    "     */",
    "    public void setLocationPerDiem(String location, double hotelLimit, double mealLimit) {",
    "        locationPerDiems.put(location, new LocationPerDiem(hotelLimit, mealLimit));",
    "    }",
    "    ",
    "    /**",
    "     * Create a new trip for an employee.",
    "     * @return Unique trip ID",
    "     */",
    "    public String createTrip(String employeeId, String location,",
    "                             String startDate, String endDate) {",
    "        tripCounter++;",
    "        String tripId = \"trip_\" + tripCounter;",
    "        ",
    "        Trip trip = new Trip(",
    "            tripId,",
    "            employeeId,",
    "            location,",
    "            LocalDate.parse(startDate, DATE_FORMAT),",
    "            LocalDate.parse(endDate, DATE_FORMAT)",
    "        );",
    "        ",
    "        trips.put(tripId, trip);",
    "        return tripId;",
    "    }",
    "    ",
    "    /**",
    "     * Add an expense to an existing trip.",
    "     */",
    "    public void addExpenseToTrip(String tripId, String type,",
    "                                 double amount, Map<String, Object> details) {",
    "        Trip trip = trips.get(tripId);",
    "        if (trip == null) {",
    "            throw new IllegalArgumentException(\"Trip \" + tripId + \" not found\");",
    "        }",
    "        ",
    "        // Handle currency conversion",
    "        String currency = (String) details.getOrDefault(\"currency\", \"USD\");",
    "        if (!\"USD\".equals(currency)) {",
    "            amount = convertToUsd(amount, currency);",
    "        }",
    "        ",
    "        trip.addExpense(new TripExpense(type, amount, details));",
    "    }",
    "    ",
    "    /**",
    "     * Calculate total reimbursement for a trip.",
    "     */",
    "    public double calculateTripReimbursement(String tripId) {",
    "        Trip trip = trips.get(tripId);",
    "        if (trip == null) {",
    "            throw new IllegalArgumentException(\"Trip \" + tripId + \" not found\");",
    "        }",
    "        ",
    "        LocationPerDiem perDiem = getPerDiemForLocation(trip.location);",
    "        double total = 0.0;",
    "        ",
    "        for (TripExpense expense : trip.expenses) {",
    "            total += calculateExpenseReimbursement(expense, perDiem, trip);",
    "        }",
    "        ",
    "        return Math.round(total * 100.0) / 100.0;",
    "    }",
    "    ",
    "    // ============== Private Helper Methods ==============",
    "    ",
    "    private LocationPerDiem getPerDiemForLocation(String location) {",
    "        return locationPerDiems.getOrDefault(",
    "            location,",
    "            new LocationPerDiem(DEFAULT_HOTEL_LIMIT, DEFAULT_MEAL_LIMIT)",
    "        );",
    "    }",
    "    ",
    "    private double calculateExpenseReimbursement(TripExpense expense,",
    "                                                 LocationPerDiem perDiem,",
    "                                                 Trip trip) {",
    "        switch (expense.expenseType) {",
    "            case \"HOTEL\":",
    "                return calculateHotelReimbursement(expense, perDiem, trip);",
    "            case \"MEAL\":",
    "                return calculateMealReimbursement(expense, perDiem, trip);",
    "            case \"FLIGHT\":",
    "                return calculateFlightReimbursement(expense);",
    "            case \"TRANSPORT\":",
    "                return expense.amount; // 100% no limit",
    "            default:",
    "                return 0.0;",
    "        }",
    "    }",
    "    ",
    "    private double calculateHotelReimbursement(TripExpense expense,",
    "                                               LocationPerDiem perDiem,",
    "                                               Trip trip) {",
    "        int nights = getIntDetail(expense.details, \"nights\", trip.getNights());",
    "        if (nights <= 0) return 0.0;",
    "        ",
    "        double perNight = expense.amount / nights;",
    "        double reimbursedPerNight = Math.min(perNight, perDiem.hotelLimit);",
    "        return reimbursedPerNight * nights;",
    "    }",
    "    ",
    "    private double calculateMealReimbursement(TripExpense expense,",
    "                                              LocationPerDiem perDiem,",
    "                                              Trip trip) {",
    "        int days = getIntDetail(expense.details, \"days\", trip.getDays());",
    "        if (days <= 0) return 0.0;",
    "        ",
    "        double perDay = expense.amount / days;",
    "        // Apply 50% rate first, then cap at location limit",
    "        double afterRate = perDay * MEAL_REIMBURSEMENT_RATE;",
    "        double reimbursedPerDay = Math.min(afterRate, perDiem.mealLimit);",
    "        return reimbursedPerDay * days;",
    "    }",
    "    ",
    "    private double calculateFlightReimbursement(TripExpense expense) {",
    "        double limit = getDoubleDetail(expense.details, \"limit\", DEFAULT_FLIGHT_LIMIT);",
    "        return Math.min(expense.amount, limit);",
    "    }",
    "    ",
    "    private int getIntDetail(Map<String, Object> details, String key, int defaultValue) {",
    "        Object value = details.get(key);",
    "        if (value instanceof Number) {",
    "            return ((Number) value).intValue();",
    "        }",
    "        return defaultValue;",
    "    }",
    "    ",
    "    private double getDoubleDetail(Map<String, Object> details, String key, double defaultValue) {",
    "        Object value = details.get(key);",
    "        if (value instanceof Number) {",
    "            return ((Number) value).doubleValue();",
    "        }",
    "        return defaultValue;",
    "    }",
    "    ",
    "    // ============== Main Method for Demo ==============",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Travel Expense System - Part 3: Per-Diem Demo\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        ExpenseManager manager = new ExpenseManager();",
    "        ",
    "        // Set up location per-diems",
    "        System.out.println(\"\\n[1] Setting up location per-diems...\");",
    "        manager.setLocationPerDiem(\"NYC\", 350.0, 80.0);",
    "        manager.setLocationPerDiem(\"San Francisco\", 300.0, 75.0);",
    "        manager.setLocationPerDiem(\"Austin\", 180.0, 60.0);",
    "        System.out.println(\"    NYC: Hotel $350/night, Meals $80/day\");",
    "        ",
    "        // Example from problem",
    "        System.out.println(\"\\n[2] Creating NYC trip (March 15-18)...\");",
    "        String tripId = manager.createTrip(\"emp001\", \"NYC\", \"2024-03-15\", \"2024-03-18\");",
    "        System.out.println(\"    Created: \" + tripId);",
    "        ",
    "        // Add expenses",
    "        System.out.println(\"\\n[3] Adding expenses to trip...\");",
    "        Map<String, Object> hotelDetails = new HashMap<>();",
    "        hotelDetails.put(\"nights\", 3);",
    "        manager.addExpenseToTrip(tripId, \"HOTEL\", 1200.0, hotelDetails);",
    "        System.out.println(\"    Hotel: $1200 (3 nights = $400/night)\");",
    "        ",
    "        Map<String, Object> mealDetails = new HashMap<>();",
    "        mealDetails.put(\"days\", 4);",
    "        manager.addExpenseToTrip(tripId, \"MEAL\", 400.0, mealDetails);",
    "        System.out.println(\"    Meals: $400 (4 days = $100/day)\");",
    "        ",
    "        // Calculate reimbursement",
    "        System.out.println(\"\\n[4] Calculating reimbursement...\");",
    "        double total = manager.calculateTripReimbursement(tripId);",
    "        System.out.println(\"    Hotel: min($400, $350) x 3 = $1050\");",
    "        System.out.println(\"    Meals: min($100 x 0.5, $80) x 4 = $200\");",
    "        System.out.println(\"    ------------------------------\");",
    "        System.out.println(\"    Total Reimbursement: $\" + total);",
    "        ",
    "        // Verify",
    "        double expected = 1250.0;",
    "        if (Math.abs(total - expected) < 0.01) {",
    "            System.out.println(\"    \u2713 Matches expected: $\" + expected);",
    "        } else {",
    "            System.out.println(\"    \u2717 MISMATCH! Expected: $\" + expected);",
    "        }",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and module docstring. We use dataclasses for clean data structures, datetime for date parsing, and ABC for the Strategy pattern."
    },
    {
      "lines": "20-30",
      "explanation": "LocationPerDiem dataclass stores hotel and meal limits per location. Marked as frozen (immutable) since config shouldn't change after creation."
    },
    {
      "lines": "32-55",
      "explanation": "TripExpense and Trip dataclasses. Trip has get_days() and get_nights() methods to calculate from date range. Days is inclusive (end - start + 1), nights is exclusive."
    },
    {
      "lines": "60-90",
      "explanation": "ExpenseStrategy abstract class and implementations for Flight and Transport. These don't need location awareness so remain simple."
    },
    {
      "lines": "95-110",
      "explanation": "CurrencyConverter from Part 2. Allows currency conversion for international trips."
    },
    {
      "lines": "115-145",
      "explanation": "ExpenseManager class initialization. Sets up default limits, strategy registry, and empty collections for per-diems and trips."
    },
    {
      "lines": "150-170",
      "explanation": "set_location_per_diem method stores LocationPerDiem config in HashMap for O(1) lookup by location name."
    },
    {
      "lines": "175-200",
      "explanation": "create_trip method parses dates, generates unique trip ID with counter, creates Trip object, and stores in HashMap."
    },
    {
      "lines": "205-230",
      "explanation": "add_expense_to_trip validates trip exists, handles currency conversion, creates TripExpense, appends to trip's expense list."
    },
    {
      "lines": "235-260",
      "explanation": "calculate_trip_reimbursement is the main calculation method. Looks up trip, gets location per-diem, iterates expenses, sums reimbursements."
    },
    {
      "lines": "265-280",
      "explanation": "_get_per_diem_for_location returns location-specific config or default. This is the key abstraction that makes the system flexible."
    },
    {
      "lines": "285-320",
      "explanation": "_calculate_hotel_reimbursement and _calculate_meal_reimbursement apply location-specific limits. Note meal applies 50% THEN caps at limit."
    },
    {
      "lines": "325-380",
      "explanation": "Demo main() function tests the NYC example from the problem, verifies expected output of $1250."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "setLocationPerDiem": {
          "complexity": "O(1)",
          "explanation": "HashMap put operation"
        },
        "createTrip": {
          "complexity": "O(1)",
          "explanation": "HashMap put with date parsing (constant operations)"
        },
        "addExpenseToTrip": {
          "complexity": "O(1)",
          "explanation": "HashMap get + list append"
        },
        "calculateTripReimbursement": {
          "complexity": "O(n)",
          "explanation": "Iterates through n expenses in the trip, each calculation is O(1)"
        }
      },
      "overall_change": "Part 3 adds O(n) calculation where n is expenses per trip. Other operations remain O(1)."
    },
    "space": {
      "additional_space": "O(L + T + E)",
      "explanation": "L = number of configured locations (LocationPerDiem objects), T = number of trips, E = total expenses across all trips. Each location config is constant size, each trip has fixed metadata plus expense list."
    }
  },
  "dry_run": {
    "example_input": "setLocationPerDiem('NYC', 350, 80), createTrip('emp001', 'NYC', '2024-03-15', '2024-03-18'), addExpenseToTrip('trip_1', 'HOTEL', 1200, {nights: 3}), addExpenseToTrip('trip_1', 'MEAL', 400, {days: 4}), calculateTripReimbursement('trip_1')",
    "steps": [
      {
        "step": 1,
        "action": "setLocationPerDiem('NYC', 350, 80)",
        "state": "_location_per_diems = {'NYC': LocationPerDiem(350, 80)}",
        "explanation": "Store NYC per-diem config"
      },
      {
        "step": 2,
        "action": "createTrip('emp001', 'NYC', '2024-03-15', '2024-03-18')",
        "state": "_trips = {'trip_1': Trip(emp001, NYC, 03-15, 03-18, [])}",
        "explanation": "Create trip, return 'trip_1'"
      },
      {
        "step": 3,
        "action": "addExpenseToTrip('trip_1', 'HOTEL', 1200, {nights: 3})",
        "state": "trip_1.expenses = [TripExpense(HOTEL, 1200, {nights: 3})]",
        "explanation": "Add hotel expense to trip"
      },
      {
        "step": 4,
        "action": "addExpenseToTrip('trip_1', 'MEAL', 400, {days: 4})",
        "state": "trip_1.expenses = [HOTEL, TripExpense(MEAL, 400, {days: 4})]",
        "explanation": "Add meal expense to trip"
      },
      {
        "step": 5,
        "action": "calculateTripReimbursement('trip_1') - lookup",
        "state": "trip = trip_1, per_diem = {hotel: 350, meal: 80}",
        "explanation": "Lookup trip and NYC per-diem"
      },
      {
        "step": 6,
        "action": "Process HOTEL expense",
        "state": "per_night = 1200/3 = 400, capped = min(400, 350) = 350, result = 350*3 = 1050",
        "explanation": "Calculate hotel: min(amount/nights, limit) * nights"
      },
      {
        "step": 7,
        "action": "Process MEAL expense",
        "state": "per_day = 400/4 = 100, after_50% = 50, capped = min(50, 80) = 50, result = 50*4 = 200",
        "explanation": "Calculate meal: min(amount/days * 0.5, limit) * days"
      },
      {
        "step": 8,
        "action": "Sum results",
        "state": "total = 1050 + 200 = 1250",
        "explanation": "Return total reimbursement"
      }
    ],
    "final_output": "1250.0"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create trip with 1 day, add $100 meal \u2192 should get $50 (or meal_limit if lower)",
      "Trip with unknown location \u2192 should use default limits ($200 hotel, $50 meal)",
      "Empty trip (no expenses) \u2192 should return 0"
    ],
    "likely_bugs": [
      "Wrong order: capping before applying 50% rate for meals",
      "Days vs nights confusion: using days for hotel or nights for meals",
      "Off-by-one in date calculation: forgetting +1 for inclusive days",
      "Case sensitivity: 'NYC' vs 'nyc' as different locations",
      "Division by zero when nights/days is 0"
    ],
    "recommended_logs_or_asserts": [
      "assert trip.get_days() == (end - start).days + 1",
      "log(f'Hotel: per_night={per_night}, limit={per_diem.hotel_limit}, result={result}')",
      "log(f'Meal: per_day={per_day}, after_rate={after_rate}, limit={per_diem.meal_limit}')"
    ],
    "how_to_localize": "1) Print per-diem lookup result to verify correct location config. 2) Print intermediate calculations for each expense. 3) Verify days/nights calculation from dates. 4) Check if 50% is applied before or after capping."
  },
  "edge_cases": [
    {
      "case": "Unknown location",
      "handling": "Falls back to default per-diem (hotel $200, meal $50)",
      "gotcha": "Forgetting to provide default"
    },
    {
      "case": "Zero nights/days",
      "handling": "Returns 0 for that expense type",
      "gotcha": "Division by zero if not checked"
    },
    {
      "case": "Single day trip",
      "handling": "days=1, nights=0 (same start and end date)",
      "gotcha": "Hotel with 0 nights should return 0"
    },
    {
      "case": "Expense below limit",
      "handling": "Full amount (after rate) is reimbursed",
      "gotcha": "Should NOT add extra to reach limit"
    },
    {
      "case": "Multiple expenses same type",
      "handling": "Each calculated independently and summed",
      "gotcha": "Don't aggregate before calculation"
    },
    {
      "case": "Trip with no expenses",
      "handling": "Returns 0.0",
      "gotcha": "Empty list iteration returns 0"
    },
    {
      "case": "Very high expense amounts",
      "handling": "Capped at per-diem limit",
      "gotcha": "No overflow with reasonable business amounts"
    }
  ],
  "test_cases": [
    {
      "name": "Main example - NYC trip",
      "input": "NYC per-diem (350, 80), trip 03/15-18, hotel $1200 (3n), meal $400 (4d)",
      "expected": "1250.0",
      "explanation": "Hotel: min(400, 350)*3=1050, Meal: min(50, 80)*4=200"
    },
    {
      "name": "Unknown location uses defaults",
      "input": "No per-diem set, trip to 'Tokyo', hotel $500 (2n), meal $200 (3d)",
      "expected": "466.67",
      "explanation": "Hotel: min(250, 200)*2=400, Meal: min(33.33, 50)*3=66.67"
    },
    {
      "name": "Meal under limit after 50%",
      "input": "Austin (180, 60), meal $80 (2d)",
      "expected": "40.0",
      "explanation": "per_day=40, after_50%=20, min(20, 60)=20, total=40"
    },
    {
      "name": "Mixed expense types",
      "input": "NYC, flight $500, hotel $700 (2n), meal $160 (4d), transport $50",
      "expected": "1270.0",
      "explanation": "Flight: 500, Hotel: min(350,350)*2=700, Meal: min(20,80)*4=80, Transport: 50"
    },
    {
      "name": "Empty trip",
      "input": "Create trip, no expenses",
      "expected": "0.0",
      "explanation": "No expenses means no reimbursement"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Applying per-diem cap before 50% rate on meals",
      "why_wrong": "Results in higher reimbursement than policy allows",
      "correct_approach": "Apply 50% FIRST, then cap at location limit",
      "code_example_wrong": "reimbursed = min(per_day, meal_limit) * 0.5 * days  # WRONG",
      "code_example_correct": "reimbursed = min(per_day * 0.5, meal_limit) * days  # CORRECT"
    },
    {
      "mistake": "Confusing days and nights",
      "why_wrong": "Hotel uses nights (n-1), meals use days (n) for n-day trip",
      "correct_approach": "days = end - start + 1, nights = end - start",
      "code_example_wrong": "hotel_total = expense.amount / trip.get_days()  # WRONG",
      "code_example_correct": "hotel_total = expense.amount / trip.get_nights()  # CORRECT"
    },
    {
      "mistake": "Forgetting default per-diem for unknown locations",
      "why_wrong": "Causes KeyError or NullPointerException",
      "correct_approach": "Use getOrDefault with default LocationPerDiem",
      "code_example_wrong": "per_diem = self._location_per_diems[location]  # WRONG",
      "code_example_correct": "per_diem = self._location_per_diems.get(location, default_per_diem)  # CORRECT"
    },
    {
      "mistake": "Capping total amount instead of per-night/day",
      "why_wrong": "Incorrect calculation - policy is per-unit, not total",
      "correct_approach": "Cap per-night/day, then multiply by count",
      "code_example_wrong": "return min(expense.amount, limit)  # WRONG for hotel",
      "code_example_correct": "return min(expense.amount / nights, limit) * nights  # CORRECT"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the core insight: 'Per-diem limits are now location-specific data, not hardcoded values. I'll create a LocationPerDiem config that gets looked up when calculating reimbursement.' Then walk through the data structures needed.",
    "what_to_mention": [
      "Separation of configuration (LocationPerDiem) from calculation logic",
      "Default fallback for unknown locations",
      "The important order: 50% rate THEN cap for meals",
      "Days vs nights distinction and why it matters"
    ],
    "time_allocation": "2 min: understand new requirements, 3 min: explain approach, 5 min: implement, 2 min: test/verify",
    "if_stuck": [
      "Think about what data you need at calculation time - the limits should come from somewhere",
      "Consider: where does the location come from? The trip! So trips need a location field",
      "The per-diem is just config - separate it from the expense object"
    ]
  },
  "connection_to_next_part": "Part 4 might add: seasonal per-diem rates (different limits by time of year), approval workflows (pending/approved status), budget tracking across trips, or audit logging. The current design supports these by: 1) LocationPerDiem can be extended with date ranges, 2) Trip can add status field, 3) ExpenseManager can track totals per employee.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2 with currency support is working. For Part 3, I need to add location-based per-diem rates. This means different cities have different hotel and meal limits. Let me explain my approach...",
    "explaining_changes": "The key change is that limits become **dynamic** - looked up by location at calculation time. I'll create a LocationPerDiem config object, store these in a HashMap by location name, and modify the reimbursement calculation to use location-specific limits from the trip's destination.",
    "while_extending_code": [
      "First, I'm adding the LocationPerDiem dataclass to hold hotel and meal limits...",
      "Now creating the Trip class to group expenses with a location and date range...",
      "The setLocationPerDiem method just stores the config in a HashMap...",
      "For createTrip, I'm parsing the dates and generating a unique ID...",
      "The key calculation change is in _calculate_meal_reimbursement - notice I apply 50% FIRST, then cap at the location limit..."
    ],
    "after_completing": "This now handles Part 3 with location-based per-diem. All new operations are O(1) except calculateTripReimbursement which is O(n) where n is expenses in the trip. Ready for the next part!"
  },
  "time_milestones": {
    "time_budget": "10-12 minutes for this part",
    "by_2_min": "Understand that per-diem becomes location-dependent, identify need for Trip entity and LocationPerDiem config",
    "by_5_min": "Explain approach, have dataclasses defined, start implementing setLocationPerDiem and createTrip",
    "by_10_min": "Implementation complete, run the NYC example to verify $1250 result",
    "warning_signs": "If still figuring out data structures at 4 min, simplify. If stuck on calculation formula, ask to verify the meal 50%-then-cap rule."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 has bugs affecting this, say: 'I need to fix a small issue in the earlier code first.' Focus on the new per-diem logic, assume currency conversion works.",
    "if_new_requirement_unclear": "Ask: 'For the meal calculation, do I apply 50% first then cap at the location limit, or cap first then apply 50%?' This clarifies the formula.",
    "if_running_behind": "Implement setLocationPerDiem and calculateTripReimbursement first - they're the core. Skip get_trip_summary and detailed docstrings."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing that per-diem limits should be config data, not strategy properties",
      "Correctly handling the meal calculation order (50% then cap)",
      "Mentioning the days vs nights distinction unprompted",
      "Adding default fallback for unknown locations without being asked",
      "Discussing how the design could extend to seasonal rates or tiered limits"
    ]
  },
  "pattern_recognition": {
    "pattern": "Configuration/Lookup Pattern + Strategy with Runtime Parameters",
    "indicators": [
      "Different limits by location \u2192 suggests lookup table",
      "Same calculation logic, different parameters \u2192 parameterized strategy",
      "Date ranges \u2192 entity with computed properties (days, nights)"
    ],
    "similar_problems": [
      "Tax calculation by region",
      "Shipping cost by zone",
      "Pricing by customer tier",
      "Rate limiting by user type"
    ],
    "template": "1. Create Config class for per-X limits\\n2. Store in HashMap<Key, Config>\\n3. Lookup at calculation time\\n4. Pass config parameters to calculation method\\n5. Provide sensible defaults for unknown keys"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'different limits by location', I immediately think of a lookup table pattern",
      "why": "Because the calculation logic is the same, only the parameters differ"
    },
    {
      "step": 2,
      "thought": "The constraint that trips have date ranges tells me I need a Trip entity",
      "why": "Date range implies state that lives longer than a single method call"
    },
    {
      "step": 3,
      "thought": "The meal formula 'min(amount\u00d70.5, limit)' means order matters",
      "why": "Apply rate first, then cap - not the other way around. This is a common gotcha."
    },
    {
      "step": 4,
      "thought": "Unknown locations should have defaults",
      "why": "Defensive programming - the system should handle unexpected inputs gracefully"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you extend existing code cleanly without rewriting?",
      "Do you recognize that per-diem limits are configuration, not code?",
      "Can you handle the meal calculation order correctly?",
      "Do you think about edge cases like unknown locations?"
    ],
    "bonus_points": [
      "Mentioning that LocationPerDiem could be extended for seasonal rates",
      "Discussing immutability of config objects",
      "Adding helper methods like get_trip_summary for debugging",
      "Clean separation between data (Trip) and logic (calculation methods)"
    ],
    "red_flags": [
      "Creating separate strategy classes for each location (code explosion)",
      "Hardcoding city names in if/else chains",
      "Confusing days and nights in calculations",
      "Not handling unknown locations"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate the dataclass boilerplate",
      "Let it help with date parsing syntax",
      "Ask for help with the dictionary get-with-default pattern"
    ],
    "what_not_to_do": [
      "Don't let AI generate the calculation formula without understanding it",
      "Verify the days/nights calculation logic yourself",
      "Check that it applies 50% before capping for meals"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Going silent while thinking - verbalize your thought process",
      "Not asking about the meal calculation order if unclear"
    ],
    "technical": [
      "Modifying Part 2 code unnecessarily",
      "Creating complex inheritance hierarchies for locations",
      "Storing limits in the Expense object instead of looking up"
    ],
    "communication": [
      "Not explaining why you chose a HashMap for per-diem storage",
      "Skipping the formula explanation (50% then cap)"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does NYC trip with hotel $1200/3n and meal $400/4d return $1250?",
      "Does unknown location fall back to default limits?",
      "Is the meal calculation: min(per_day * 0.5, limit) * days?",
      "Are days and nights calculated correctly from date range?"
    ],
    "quick_code_review": [
      "LocationPerDiem is immutable (frozen=True in Python)",
      "Trip has get_days() and get_nights() methods",
      "ExpenseManager has proper default constants",
      "All new methods have docstrings"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging for per-diem lookups and calculations",
      "Input validation (positive amounts, valid dates, start <= end)",
      "Database storage for trips and per-diem configs",
      "Audit trail for who modified per-diem rates",
      "API rate limiting on calculation endpoints"
    ],
    "why_not_in_interview": "Focus on core algorithm and data structures. These are implementation details that don't affect correctness.",
    "how_to_mention": "Say: 'In production, I'd add input validation to ensure dates are valid and amounts are positive. I'd also log each calculation for audit purposes.'"
  },
  "generated_at": "2026-01-18T19:01:02.938796",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}