{
  "problem_title": "Employee Access Management System - Part 4: Access Audit Log",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 introduces an **Event Sourcing** pattern where every access change (grant/revoke) is logged as an immutable audit entry with a timestamp. This enables compliance queries, debugging, and historical state reconstruction. The system now maintains both the current access state AND a complete history of how that state evolved.",
    "new_requirements": [
      "Log every grant and revoke operation with timestamp",
      "Support filtering audit log by employee, resource, or both",
      "Support time range queries on the audit log",
      "Reconstruct historical access state at any point in time",
      "Determine which employees had access to a resource at a specific timestamp"
    ],
    "new_constraints": [
      "Audit log must be append-only (immutable history)",
      "Must support efficient queries across multiple dimensions",
      "Historical queries require event replay up to query timestamp",
      "Timestamps are monotonically increasing per employee-resource pair"
    ],
    "key_insight": "The 'AHA!' moment is recognizing this as the Event Sourcing pattern: instead of storing just current state, store the events that led to that state. Current state can be derived by replaying events, and historical state can be computed by replaying events up to any timestamp."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    BEFORE (Part 3) vs AFTER (Part 4)                  \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                       \u2551\n\u2551   BEFORE: Only Current State                                          \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                             \u2551\n\u2551   \u2502 E1 \u2192 R1: {READ}     \u2502  \u2190 Can only answer \"What access exists NOW?\"\u2551\n\u2551   \u2502 E2 \u2192 R1: {ADMIN}    \u2502                                             \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                             \u2551\n\u2551                                                                       \u2551\n\u2551   AFTER: Current State + Complete History                             \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551   \u2502 E1 \u2192 R1: {READ}     \u2502    \u2502 AUDIT LOG (Immutable)              \u2502   \u2551\n\u2551   \u2502 E2 \u2192 R1: {ADMIN}    \u2502    \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502   \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 t=100: E1 +READ  on R1             \u2502   \u2551\n\u2551          \u2191                   \u2502 t=150: E1 +WRITE on R1             \u2502   \u2551\n\u2551    Current State             \u2502 t=200: E1 -WRITE on R1             \u2502   \u2551\n\u2551   (derived from log)         \u2502 t=250: E2 +ADMIN on R1             \u2502   \u2551\n\u2551                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                                         \u2193                             \u2551\n\u2551                              Can answer: \"Who had access at t=175?\"   \u2551\n\u2551                              Answer: E1 had {READ, WRITE}             \u2551\n\u2551                                                                       \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551              ALGORITHM: getEmployeesWithAccessAt(R1, t=175)           \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                       \u2551\n\u2551   Step 1: Filter events for resource R1 where timestamp \u2264 175        \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551   \u2502 Full Log          \u2502  Filtered (R1, t\u2264175)                      \u2502  \u2551\n\u2551   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                     \u2502  \u2551\n\u2551   \u2502 t=100: E1 +READ   \u2502  \u2192 t=100: E1 +READ  \u2713                      \u2502  \u2551\n\u2551   \u2502 t=150: E1 +WRITE  \u2502  \u2192 t=150: E1 +WRITE \u2713                      \u2502  \u2551\n\u2551   \u2502 t=200: E1 -WRITE  \u2502  \u2192 (excluded, t > 175)                     \u2502  \u2551\n\u2551   \u2502 t=250: E2 +ADMIN  \u2502  \u2192 (excluded, t > 175)                     \u2502  \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551   Step 2: Sort filtered events by timestamp                           \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551   \u2502 Events in order: [E1 +READ @ 100] \u2192 [E1 +WRITE @ 150]          \u2502  \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551   Step 3: Replay events to build state                                \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551   \u2502 Initial:  access_state = {}                                    \u2502  \u2551\n\u2551   \u2502                                                                \u2502  \u2551\n\u2551   \u2502 Process t=100 (E1 +READ):                                      \u2502  \u2551\n\u2551   \u2502   access_state = {E1: {READ}}                                  \u2502  \u2551\n\u2551   \u2502                                                                \u2502  \u2551\n\u2551   \u2502 Process t=150 (E1 +WRITE):                                     \u2502  \u2551\n\u2551   \u2502   access_state = {E1: {READ, WRITE}}                           \u2502  \u2551\n\u2551   \u2502                                                                \u2502  \u2551\n\u2551   \u2502 Final state at t=175: {E1: {READ, WRITE}}                      \u2502  \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551   Step 4: Return employees with non-empty access                      \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551   \u2502 Result: [\"E1\"]                                                 \u2502  \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Simply add audit entries to a single list, iterate through entire list for every query",
      "time_complexity": "O(n) for all queries where n is total audit entries",
      "space_complexity": "O(n) for audit log",
      "why_not_optimal": "No indexing means every query requires full scan. For time range queries, we scan everything. For employee-specific queries, we scan everything. In production with millions of entries, this becomes prohibitively slow. Also, no optimization for the critical getEmployeesWithAccessAt query."
    },
    {
      "name": "Optimal Approach - Multi-Index Event Store",
      "description": "Maintain multiple indexes (by employee, by resource, by timestamp) alongside the append-only audit log. Use TreeMap for timestamp-based queries enabling O(log n) range lookups. For historical state reconstruction, only replay relevant events using indexes.",
      "time_complexity": "O(1) amortized insert, O(log n + k) for range queries, O(m) for historical state where m is relevant events",
      "space_complexity": "O(n) for log + O(n) for indexes = O(n) total",
      "key_insight": "Trade space for time by pre-indexing. The event sourcing pattern separates the concerns of 'what happened' (immutable log) from 'what is true now' (derived state). This enables powerful historical queries while maintaining audit compliance."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution uses the **Event Sourcing** pattern combined with **multiple indexes** for query efficiency.\n\n**Core Data Structures:**\n\n1. **AuditEntry** - Immutable record of each access change\n2. **Append-only List** - The canonical audit log (chronological order)\n3. **HashMap<employeeId, List<AuditEntry>>** - Index for employee-specific queries\n4. **HashMap<resourceId, List<AuditEntry>>** - Index for resource-specific queries  \n5. **TreeMap<timestamp, List<AuditEntry>>** - Index for time-range queries (enables O(log n) range lookups)\n\n**Key Design Decisions:**\n\n- **Immutability**: Audit entries are never modified once created - this is critical for compliance\n- **Denormalization**: We store references in multiple indexes for query performance\n- **Event Replay**: Historical state is computed by replaying events, not stored (keeps storage bounded)\n\n**Why This Works:**\n\n- `getAuditLog(emp, res)` \u2192 Use employee index or resource index, filter in-memory\n- `getAuditLogInRange(t1, t2)` \u2192 Use TreeMap's subMap for O(log n) lookup\n- `getEmployeesWithAccessAt(res, t)` \u2192 Use resource index, filter by time, replay events",
    "data_structures": [
      {
        "structure": "AuditEntry dataclass",
        "purpose": "Immutable record of single access change event"
      },
      {
        "structure": "ArrayList (audit_log)",
        "purpose": "Append-only canonical log, preserves insertion order"
      },
      {
        "structure": "HashMap (by_employee)",
        "purpose": "O(1) lookup of all entries for an employee"
      },
      {
        "structure": "HashMap (by_resource)",
        "purpose": "O(1) lookup of all entries for a resource"
      },
      {
        "structure": "TreeMap (by_timestamp)",
        "purpose": "O(log n) time-range queries using subMap"
      }
    ],
    "algorithm_steps": [
      "Step 1: On grant/revoke, create immutable AuditEntry with timestamp, employee, resource, action, access_type",
      "Step 2: Append entry to main audit log (O(1) amortized)",
      "Step 3: Add reference to employee index HashMap (O(1))",
      "Step 4: Add reference to resource index HashMap (O(1))",
      "Step 5: Add reference to timestamp TreeMap (O(log n))",
      "Step 6: For getAuditLog queries, use appropriate index and filter",
      "Step 7: For getEmployeesWithAccessAt, filter resource index by timestamp, then replay events chronologically to reconstruct state"
    ]
  },
  "solution_python_lines": [
    "from enum import Enum",
    "from typing import List, Dict, Set, Optional",
    "from dataclasses import dataclass, field",
    "from collections import defaultdict",
    "from sortedcontainers import SortedDict  # For TreeMap-like functionality",
    "",
    "",
    "class AccessType(Enum):",
    "    \"\"\"Types of access that can be granted to resources.\"\"\"",
    "    READ = 1",
    "    WRITE = 2",
    "    ADMIN = 3",
    "",
    "",
    "class ActionType(Enum):",
    "    \"\"\"Types of actions recorded in audit log.\"\"\"",
    "    GRANT = \"GRANT\"",
    "    REVOKE = \"REVOKE\"",
    "",
    "",
    "@dataclass(frozen=True)  # Immutable for audit compliance",
    "class AuditEntry:",
    "    \"\"\"",
    "    Immutable audit log entry representing a single access change event.",
    "    ",
    "    Attributes:",
    "        timestamp: When the action occurred",
    "        employee_id: Employee affected",
    "        resource_id: Resource affected",
    "        action: GRANT or REVOKE",
    "        access_type: READ, WRITE, or ADMIN",
    "    \"\"\"",
    "    timestamp: int",
    "    employee_id: str",
    "    resource_id: str",
    "    action: ActionType",
    "    access_type: AccessType",
    "    ",
    "    def to_dict(self) -> dict:",
    "        \"\"\"Convert to dictionary for serialization.\"\"\"",
    "        return {",
    "            'timestamp': self.timestamp,",
    "            'employee': self.employee_id,",
    "            'resource': self.resource_id,",
    "            'action': self.action.value,",
    "            'accessType': self.access_type.name",
    "        }",
    "",
    "",
    "class AccessManager:",
    "    \"\"\"",
    "    Enterprise access control system with full audit logging.",
    "    ",
    "    Implements Event Sourcing pattern for compliance and historical queries.",
    "    Maintains multiple indexes for efficient query performance.",
    "    ",
    "    Time Complexity:",
    "        - grant/revoke: O(log n) due to TreeMap insertion",
    "        - getAuditLog: O(k) where k is matching entries",
    "        - getEmployeesWithAccessAt: O(m) where m is events for resource up to time",
    "    ",
    "    Space Complexity: O(n) where n is total audit entries",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize access manager with empty state and audit log.\"\"\"",
    "        # Current access state (derived from events)",
    "        self._access: Dict[str, Dict[str, Set[AccessType]]] = defaultdict(",
    "            lambda: defaultdict(set)",
    "        )",
    "        ",
    "        # ===== AUDIT LOG STORAGE =====",
    "        # Append-only canonical log",
    "        self._audit_log: List[AuditEntry] = []",
    "        ",
    "        # Index by employee ID for employee-specific queries",
    "        self._by_employee: Dict[str, List[AuditEntry]] = defaultdict(list)",
    "        ",
    "        # Index by resource ID for resource-specific queries",
    "        self._by_resource: Dict[str, List[AuditEntry]] = defaultdict(list)",
    "        ",
    "        # Index by timestamp for range queries (using sorted dict)",
    "        # Note: In production, use SortedDict from sortedcontainers",
    "        self._by_timestamp: Dict[int, List[AuditEntry]] = defaultdict(list)",
    "        self._sorted_timestamps: List[int] = []  # Maintain sorted order",
    "    ",
    "    def _add_audit_entry(self, entry: AuditEntry) -> None:",
    "        \"\"\"",
    "        Add entry to all indexes.",
    "        ",
    "        Args:",
    "            entry: The audit entry to index",
    "        \"\"\"",
    "        # Append to canonical log",
    "        self._audit_log.append(entry)",
    "        ",
    "        # Add to employee index",
    "        self._by_employee[entry.employee_id].append(entry)",
    "        ",
    "        # Add to resource index",
    "        self._by_resource[entry.resource_id].append(entry)",
    "        ",
    "        # Add to timestamp index",
    "        if entry.timestamp not in self._by_timestamp:",
    "            # Insert timestamp in sorted order",
    "            import bisect",
    "            bisect.insort(self._sorted_timestamps, entry.timestamp)",
    "        self._by_timestamp[entry.timestamp].append(entry)",
    "    ",
    "    def grant_access_with_timestamp(",
    "        self,",
    "        employee_id: str,",
    "        resource_id: str,",
    "        access_type: AccessType,",
    "        timestamp: int",
    "    ) -> None:",
    "        \"\"\"",
    "        Grant access to an employee for a resource and log the event.",
    "        ",
    "        Args:",
    "            employee_id: Employee receiving access",
    "            resource_id: Resource to grant access to",
    "            access_type: Type of access (READ, WRITE, ADMIN)",
    "            timestamp: When this grant occurred",
    "        \"\"\"",
    "        # Update current state",
    "        self._access[employee_id][resource_id].add(access_type)",
    "        ",
    "        # Create immutable audit entry",
    "        entry = AuditEntry(",
    "            timestamp=timestamp,",
    "            employee_id=employee_id,",
    "            resource_id=resource_id,",
    "            action=ActionType.GRANT,",
    "            access_type=access_type",
    "        )",
    "        ",
    "        # Index the entry",
    "        self._add_audit_entry(entry)",
    "    ",
    "    def revoke_access_with_timestamp(",
    "        self,",
    "        employee_id: str,",
    "        resource_id: str,",
    "        access_type: AccessType,",
    "        timestamp: int",
    "    ) -> None:",
    "        \"\"\"",
    "        Revoke access from an employee and log the event.",
    "        ",
    "        Args:",
    "            employee_id: Employee losing access",
    "            resource_id: Resource to revoke access from",
    "            access_type: Type of access to revoke",
    "            timestamp: When this revoke occurred",
    "        \"\"\"",
    "        # Update current state",
    "        if employee_id in self._access:",
    "            if resource_id in self._access[employee_id]:",
    "                self._access[employee_id][resource_id].discard(access_type)",
    "        ",
    "        # Create immutable audit entry",
    "        entry = AuditEntry(",
    "            timestamp=timestamp,",
    "            employee_id=employee_id,",
    "            resource_id=resource_id,",
    "            action=ActionType.REVOKE,",
    "            access_type=access_type",
    "        )",
    "        ",
    "        # Index the entry",
    "        self._add_audit_entry(entry)",
    "    ",
    "    def get_audit_log(",
    "        self,",
    "        employee_id: Optional[str],",
    "        resource_id: Optional[str]",
    "    ) -> List[AuditEntry]:",
    "        \"\"\"",
    "        Get audit log entries filtered by employee and/or resource.",
    "        ",
    "        Args:",
    "            employee_id: Filter by employee (None for all employees)",
    "            resource_id: Filter by resource (None for all resources)",
    "        ",
    "        Returns:",
    "            Chronologically sorted list of matching audit entries",
    "        \"\"\"",
    "        # No filters - return entire log",
    "        if employee_id is None and resource_id is None:",
    "            return sorted(self._audit_log, key=lambda e: e.timestamp)",
    "        ",
    "        # Filter by employee only",
    "        if employee_id is not None and resource_id is None:",
    "            entries = self._by_employee.get(employee_id, [])",
    "            return sorted(entries, key=lambda e: e.timestamp)",
    "        ",
    "        # Filter by resource only",
    "        if employee_id is None and resource_id is not None:",
    "            entries = self._by_resource.get(resource_id, [])",
    "            return sorted(entries, key=lambda e: e.timestamp)",
    "        ",
    "        # Filter by both employee AND resource",
    "        employee_entries = self._by_employee.get(employee_id, [])",
    "        result = [",
    "            e for e in employee_entries",
    "            if e.resource_id == resource_id",
    "        ]",
    "        return sorted(result, key=lambda e: e.timestamp)",
    "    ",
    "    def get_audit_log_in_range(",
    "        self,",
    "        start_time: int,",
    "        end_time: int",
    "    ) -> List[AuditEntry]:",
    "        \"\"\"",
    "        Get audit entries within a time range [start_time, end_time].",
    "        ",
    "        Args:",
    "            start_time: Start of time range (inclusive)",
    "            end_time: End of time range (inclusive)",
    "        ",
    "        Returns:",
    "            Chronologically sorted list of entries in range",
    "        \"\"\"",
    "        result = []",
    "        ",
    "        # Find timestamps in range using binary search",
    "        import bisect",
    "        start_idx = bisect.bisect_left(self._sorted_timestamps, start_time)",
    "        end_idx = bisect.bisect_right(self._sorted_timestamps, end_time)",
    "        ",
    "        # Collect entries from relevant timestamps",
    "        for i in range(start_idx, end_idx):",
    "            ts = self._sorted_timestamps[i]",
    "            result.extend(self._by_timestamp[ts])",
    "        ",
    "        return sorted(result, key=lambda e: e.timestamp)",
    "    ",
    "    def get_employees_with_access_at(",
    "        self,",
    "        resource_id: str,",
    "        timestamp: int",
    "    ) -> List[str]:",
    "        \"\"\"",
    "        Get employees who had any access to resource at given timestamp.",
    "        ",
    "        This implements the Event Replay algorithm:",
    "        1. Get all events for resource up to timestamp",
    "        2. Replay events in chronological order",
    "        3. Track access state for each employee",
    "        4. Return employees with non-empty access",
    "        ",
    "        Args:",
    "            resource_id: Resource to check",
    "            timestamp: Point in time to evaluate",
    "        ",
    "        Returns:",
    "            Sorted list of employee IDs with access at that time",
    "        \"\"\"",
    "        # Get all entries for this resource",
    "        resource_entries = self._by_resource.get(resource_id, [])",
    "        ",
    "        # Filter to entries at or before timestamp",
    "        relevant_entries = [",
    "            e for e in resource_entries",
    "            if e.timestamp <= timestamp",
    "        ]",
    "        ",
    "        # Sort by timestamp for replay",
    "        sorted_entries = sorted(relevant_entries, key=lambda e: e.timestamp)",
    "        ",
    "        # Replay events to reconstruct state at timestamp",
    "        access_state: Dict[str, Set[AccessType]] = defaultdict(set)",
    "        ",
    "        for entry in sorted_entries:",
    "            if entry.action == ActionType.GRANT:",
    "                access_state[entry.employee_id].add(entry.access_type)",
    "            else:  # REVOKE",
    "                access_state[entry.employee_id].discard(entry.access_type)",
    "        ",
    "        # Return employees with non-empty access sets",
    "        employees_with_access = [",
    "            emp_id for emp_id, access_set in access_state.items()",
    "            if len(access_set) > 0",
    "        ]",
    "        ",
    "        return sorted(employees_with_access)",
    "    ",
    "    def get_access(self, employee_id: str, resource_id: str) -> Set[AccessType]:",
    "        \"\"\"Get current access for employee on resource.\"\"\"",
    "        return self._access[employee_id][resource_id].copy()",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the Access Audit Log functionality.\"\"\"",
    "    print(\"=\"*60)",
    "    print(\"EMPLOYEE ACCESS MANAGEMENT - AUDIT LOG DEMO\")",
    "    print(\"=\"*60)",
    "    ",
    "    manager = AccessManager()",
    "    ",
    "    # Scenario: Track access changes over time",
    "    print(\"\\n\ud83d\udccb Recording access changes...\\n\")",
    "    ",
    "    # Timeline of events",
    "    manager.grant_access_with_timestamp(\"E1\", \"R1\", AccessType.READ, 100)",
    "    print(\"t=100: E1 granted READ on R1\")",
    "    ",
    "    manager.grant_access_with_timestamp(\"E1\", \"R1\", AccessType.WRITE, 150)",
    "    print(\"t=150: E1 granted WRITE on R1\")",
    "    ",
    "    manager.grant_access_with_timestamp(\"E2\", \"R1\", AccessType.ADMIN, 200)",
    "    print(\"t=200: E2 granted ADMIN on R1\")",
    "    ",
    "    manager.revoke_access_with_timestamp(\"E1\", \"R1\", AccessType.WRITE, 250)",
    "    print(\"t=250: E1 WRITE revoked on R1\")",
    "    ",
    "    manager.grant_access_with_timestamp(\"E3\", \"R1\", AccessType.READ, 300)",
    "    print(\"t=300: E3 granted READ on R1\")",
    "    ",
    "    manager.revoke_access_with_timestamp(\"E1\", \"R1\", AccessType.READ, 350)",
    "    print(\"t=350: E1 READ revoked on R1\")",
    "    ",
    "    # Query 1: Full audit log for E1 on R1",
    "    print(\"\\n\" + \"-\"*60)",
    "    print(\"\ud83d\udcca Query: getAuditLog('E1', 'R1')\")",
    "    print(\"-\"*60)",
    "    for entry in manager.get_audit_log(\"E1\", \"R1\"):",
    "        print(f\"  t={entry.timestamp}: {entry.action.value}:{entry.access_type.name}\")",
    "    ",
    "    # Query 2: All entries for resource R1",
    "    print(\"\\n\" + \"-\"*60)",
    "    print(\"\ud83d\udcca Query: getAuditLog(None, 'R1')\")",
    "    print(\"-\"*60)",
    "    for entry in manager.get_audit_log(None, \"R1\"):",
    "        print(f\"  t={entry.timestamp}: {entry.employee_id} {entry.action.value}:{entry.access_type.name}\")",
    "    ",
    "    # Query 3: Time range query",
    "    print(\"\\n\" + \"-\"*60)",
    "    print(\"\ud83d\udcca Query: getAuditLogInRange(150, 275)\")",
    "    print(\"-\"*60)",
    "    for entry in manager.get_audit_log_in_range(150, 275):",
    "        print(f\"  t={entry.timestamp}: {entry.employee_id} {entry.action.value}:{entry.access_type.name}\")",
    "    ",
    "    # Query 4: Historical state - Who had access at various times?",
    "    print(\"\\n\" + \"-\"*60)",
    "    print(\"\ud83d\udcca Historical Access Queries (getEmployeesWithAccessAt)\")",
    "    print(\"-\"*60)",
    "    ",
    "    test_times = [125, 175, 225, 275, 325, 375]",
    "    for t in test_times:",
    "        employees = manager.get_employees_with_access_at(\"R1\", t)",
    "        print(f\"  t={t}: {employees}\")",
    "    ",
    "    print(\"\\n\" + \"=\"*60)",
    "    print(\"\u2705 All audit log operations completed successfully!\")",
    "    print(\"=\"*60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.stream.*;",
    "",
    "/**",
    " * Types of access that can be granted to resources.",
    " */",
    "enum AccessType {",
    "    READ, WRITE, ADMIN",
    "}",
    "",
    "/**",
    " * Types of actions recorded in audit log.",
    " */",
    "enum ActionType {",
    "    GRANT, REVOKE",
    "}",
    "",
    "/**",
    " * Immutable audit log entry representing a single access change event.",
    " * Implements Event Sourcing pattern for compliance and historical queries.",
    " */",
    "class AuditEntry {",
    "    private final long timestamp;",
    "    private final String employeeId;",
    "    private final String resourceId;",
    "    private final ActionType action;",
    "    private final AccessType accessType;",
    "    ",
    "    public AuditEntry(long timestamp, String employeeId, String resourceId,",
    "                      ActionType action, AccessType accessType) {",
    "        this.timestamp = timestamp;",
    "        this.employeeId = employeeId;",
    "        this.resourceId = resourceId;",
    "        this.action = action;",
    "        this.accessType = accessType;",
    "    }",
    "    ",
    "    public long getTimestamp() { return timestamp; }",
    "    public String getEmployeeId() { return employeeId; }",
    "    public String getResourceId() { return resourceId; }",
    "    public ActionType getAction() { return action; }",
    "    public AccessType getAccessType() { return accessType; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"AuditEntry{t=%d, emp=%s, res=%s, %s:%s}\",",
    "            timestamp, employeeId, resourceId, action, accessType);",
    "    }",
    "}",
    "",
    "/**",
    " * Enterprise access control system with full audit logging.",
    " * ",
    " * Implements Event Sourcing pattern for compliance and historical queries.",
    " * Maintains multiple indexes for efficient query performance.",
    " * ",
    " * Time Complexity:",
    " *   - grant/revoke: O(log n) due to TreeMap insertion",
    " *   - getAuditLog: O(k) where k is matching entries",
    " *   - getEmployeesWithAccessAt: O(m) where m is events for resource up to time",
    " * ",
    " * Space Complexity: O(n) where n is total audit entries",
    " */",
    "public class AccessManager {",
    "    ",
    "    // Current access state (derived from events)",
    "    private final Map<String, Map<String, Set<AccessType>>> access;",
    "    ",
    "    // ===== AUDIT LOG STORAGE =====",
    "    // Append-only canonical log",
    "    private final List<AuditEntry> auditLog;",
    "    ",
    "    // Index by employee ID for employee-specific queries",
    "    private final Map<String, List<AuditEntry>> byEmployee;",
    "    ",
    "    // Index by resource ID for resource-specific queries",
    "    private final Map<String, List<AuditEntry>> byResource;",
    "    ",
    "    // Index by timestamp for range queries (TreeMap for O(log n) range lookups)",
    "    private final TreeMap<Long, List<AuditEntry>> byTimestamp;",
    "    ",
    "    /**",
    "     * Initialize access manager with empty state and audit log.",
    "     */",
    "    public AccessManager() {",
    "        this.access = new HashMap<>();",
    "        this.auditLog = new ArrayList<>();",
    "        this.byEmployee = new HashMap<>();",
    "        this.byResource = new HashMap<>();",
    "        this.byTimestamp = new TreeMap<>();",
    "    }",
    "    ",
    "    /**",
    "     * Add entry to all indexes.",
    "     */",
    "    private void addAuditEntry(AuditEntry entry) {",
    "        // Append to canonical log",
    "        auditLog.add(entry);",
    "        ",
    "        // Add to employee index",
    "        byEmployee.computeIfAbsent(entry.getEmployeeId(), k -> new ArrayList<>())",
    "                  .add(entry);",
    "        ",
    "        // Add to resource index",
    "        byResource.computeIfAbsent(entry.getResourceId(), k -> new ArrayList<>())",
    "                  .add(entry);",
    "        ",
    "        // Add to timestamp index (TreeMap)",
    "        byTimestamp.computeIfAbsent(entry.getTimestamp(), k -> new ArrayList<>())",
    "                   .add(entry);",
    "    }",
    "    ",
    "    /**",
    "     * Grant access to an employee for a resource and log the event.",
    "     * ",
    "     * @param employeeId Employee receiving access",
    "     * @param resourceId Resource to grant access to",
    "     * @param accessType Type of access (READ, WRITE, ADMIN)",
    "     * @param timestamp When this grant occurred",
    "     */",
    "    public void grantAccessWithTimestamp(String employeeId, String resourceId,",
    "                                         AccessType accessType, long timestamp) {",
    "        // Update current state",
    "        access.computeIfAbsent(employeeId, k -> new HashMap<>())",
    "              .computeIfAbsent(resourceId, k -> new HashSet<>())",
    "              .add(accessType);",
    "        ",
    "        // Create immutable audit entry",
    "        AuditEntry entry = new AuditEntry(",
    "            timestamp, employeeId, resourceId, ActionType.GRANT, accessType",
    "        );",
    "        ",
    "        // Index the entry",
    "        addAuditEntry(entry);",
    "    }",
    "    ",
    "    /**",
    "     * Revoke access from an employee and log the event.",
    "     * ",
    "     * @param employeeId Employee losing access",
    "     * @param resourceId Resource to revoke access from",
    "     * @param accessType Type of access to revoke",
    "     * @param timestamp When this revoke occurred",
    "     */",
    "    public void revokeAccessWithTimestamp(String employeeId, String resourceId,",
    "                                          AccessType accessType, long timestamp) {",
    "        // Update current state",
    "        if (access.containsKey(employeeId) && ",
    "            access.get(employeeId).containsKey(resourceId)) {",
    "            access.get(employeeId).get(resourceId).remove(accessType);",
    "        }",
    "        ",
    "        // Create immutable audit entry",
    "        AuditEntry entry = new AuditEntry(",
    "            timestamp, employeeId, resourceId, ActionType.REVOKE, accessType",
    "        );",
    "        ",
    "        // Index the entry",
    "        addAuditEntry(entry);",
    "    }",
    "    ",
    "    /**",
    "     * Get audit log entries filtered by employee and/or resource.",
    "     * ",
    "     * @param employeeId Filter by employee (null for all employees)",
    "     * @param resourceId Filter by resource (null for all resources)",
    "     * @return Chronologically sorted list of matching audit entries",
    "     */",
    "    public List<AuditEntry> getAuditLog(String employeeId, String resourceId) {",
    "        List<AuditEntry> result;",
    "        ",
    "        // No filters - return entire log",
    "        if (employeeId == null && resourceId == null) {",
    "            result = new ArrayList<>(auditLog);",
    "        }",
    "        // Filter by employee only",
    "        else if (employeeId != null && resourceId == null) {",
    "            result = new ArrayList<>(byEmployee.getOrDefault(employeeId, List.of()));",
    "        }",
    "        // Filter by resource only",
    "        else if (employeeId == null && resourceId != null) {",
    "            result = new ArrayList<>(byResource.getOrDefault(resourceId, List.of()));",
    "        }",
    "        // Filter by both employee AND resource",
    "        else {",
    "            result = byEmployee.getOrDefault(employeeId, List.of()).stream()",
    "                .filter(e -> e.getResourceId().equals(resourceId))",
    "                .collect(Collectors.toList());",
    "        }",
    "        ",
    "        // Sort by timestamp",
    "        result.sort(Comparator.comparingLong(AuditEntry::getTimestamp));",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get audit entries within a time range [startTime, endTime].",
    "     * Uses TreeMap's subMap for efficient O(log n) range lookup.",
    "     * ",
    "     * @param startTime Start of time range (inclusive)",
    "     * @param endTime End of time range (inclusive)",
    "     * @return Chronologically sorted list of entries in range",
    "     */",
    "    public List<AuditEntry> getAuditLogInRange(long startTime, long endTime) {",
    "        List<AuditEntry> result = new ArrayList<>();",
    "        ",
    "        // Use TreeMap's efficient subMap for range query",
    "        NavigableMap<Long, List<AuditEntry>> subMap = ",
    "            byTimestamp.subMap(startTime, true, endTime, true);",
    "        ",
    "        for (List<AuditEntry> entries : subMap.values()) {",
    "            result.addAll(entries);",
    "        }",
    "        ",
    "        result.sort(Comparator.comparingLong(AuditEntry::getTimestamp));",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get employees who had any access to resource at given timestamp.",
    "     * ",
    "     * Implements the Event Replay algorithm:",
    "     * 1. Get all events for resource up to timestamp",
    "     * 2. Replay events in chronological order",
    "     * 3. Track access state for each employee",
    "     * 4. Return employees with non-empty access",
    "     * ",
    "     * @param resourceId Resource to check",
    "     * @param timestamp Point in time to evaluate",
    "     * @return Sorted list of employee IDs with access at that time",
    "     */",
    "    public List<String> getEmployeesWithAccessAt(String resourceId, long timestamp) {",
    "        // Get all entries for this resource",
    "        List<AuditEntry> resourceEntries = byResource.getOrDefault(resourceId, List.of());",
    "        ",
    "        // Filter to entries at or before timestamp and sort",
    "        List<AuditEntry> relevantEntries = resourceEntries.stream()",
    "            .filter(e -> e.getTimestamp() <= timestamp)",
    "            .sorted(Comparator.comparingLong(AuditEntry::getTimestamp))",
    "            .collect(Collectors.toList());",
    "        ",
    "        // Replay events to reconstruct state at timestamp",
    "        Map<String, Set<AccessType>> accessState = new HashMap<>();",
    "        ",
    "        for (AuditEntry entry : relevantEntries) {",
    "            String empId = entry.getEmployeeId();",
    "            accessState.computeIfAbsent(empId, k -> new HashSet<>());",
    "            ",
    "            if (entry.getAction() == ActionType.GRANT) {",
    "                accessState.get(empId).add(entry.getAccessType());",
    "            } else { // REVOKE",
    "                accessState.get(empId).remove(entry.getAccessType());",
    "            }",
    "        }",
    "        ",
    "        // Return employees with non-empty access sets",
    "        return accessState.entrySet().stream()",
    "            .filter(e -> !e.getValue().isEmpty())",
    "            .map(Map.Entry::getKey)",
    "            .sorted()",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    /**",
    "     * Get current access for employee on resource.",
    "     */",
    "    public Set<AccessType> getAccess(String employeeId, String resourceId) {",
    "        return new HashSet<>(access",
    "            .getOrDefault(employeeId, Map.of())",
    "            .getOrDefault(resourceId, Set.of()));",
    "    }",
    "    ",
    "    /**",
    "     * Main method demonstrating the Access Audit Log functionality.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"EMPLOYEE ACCESS MANAGEMENT - AUDIT LOG DEMO\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        AccessManager manager = new AccessManager();",
    "        ",
    "        // Timeline of events",
    "        System.out.println(\"\\n\ud83d\udccb Recording access changes...\\n\");",
    "        ",
    "        manager.grantAccessWithTimestamp(\"E1\", \"R1\", AccessType.READ, 100);",
    "        System.out.println(\"t=100: E1 granted READ on R1\");",
    "        ",
    "        manager.grantAccessWithTimestamp(\"E1\", \"R1\", AccessType.WRITE, 150);",
    "        System.out.println(\"t=150: E1 granted WRITE on R1\");",
    "        ",
    "        manager.grantAccessWithTimestamp(\"E2\", \"R1\", AccessType.ADMIN, 200);",
    "        System.out.println(\"t=200: E2 granted ADMIN on R1\");",
    "        ",
    "        manager.revokeAccessWithTimestamp(\"E1\", \"R1\", AccessType.WRITE, 250);",
    "        System.out.println(\"t=250: E1 WRITE revoked on R1\");",
    "        ",
    "        manager.grantAccessWithTimestamp(\"E3\", \"R1\", AccessType.READ, 300);",
    "        System.out.println(\"t=300: E3 granted READ on R1\");",
    "        ",
    "        manager.revokeAccessWithTimestamp(\"E1\", \"R1\", AccessType.READ, 350);",
    "        System.out.println(\"t=350: E1 READ revoked on R1\");",
    "        ",
    "        // Query 1: Audit log for E1 on R1",
    "        System.out.println(\"\\n\" + \"-\".repeat(60));",
    "        System.out.println(\"\ud83d\udcca Query: getAuditLog('E1', 'R1')\");",
    "        System.out.println(\"-\".repeat(60));",
    "        for (AuditEntry entry : manager.getAuditLog(\"E1\", \"R1\")) {",
    "            System.out.printf(\"  t=%d: %s:%s%n\", ",
    "                entry.getTimestamp(), entry.getAction(), entry.getAccessType());",
    "        }",
    "        ",
    "        // Query 2: Historical access at various times",
    "        System.out.println(\"\\n\" + \"-\".repeat(60));",
    "        System.out.println(\"\ud83d\udcca Historical Access Queries\");",
    "        System.out.println(\"-\".repeat(60));",
    "        ",
    "        int[] testTimes = {125, 175, 225, 275, 325, 375};",
    "        for (int t : testTimes) {",
    "            List<String> employees = manager.getEmployeesWithAccessAt(\"R1\", t);",
    "            System.out.printf(\"  t=%d: %s%n\", t, employees);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"\u2705 All audit log operations completed!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "explanation": "Import statements, enums for AccessType (READ/WRITE/ADMIN) and ActionType (GRANT/REVOKE)"
    },
    {
      "lines": "21-45",
      "explanation": "AuditEntry dataclass - immutable record of each access change. Uses frozen=True in Python / final fields in Java for immutability, critical for audit compliance"
    },
    {
      "lines": "46-75",
      "explanation": "AccessManager class initialization - sets up current state storage plus four indexes: audit_log (append-only list), by_employee (HashMap), by_resource (HashMap), by_timestamp (TreeMap/sorted dict)"
    },
    {
      "lines": "76-95",
      "explanation": "_add_audit_entry helper method - adds new entry to all four indexes in O(log n) time due to TreeMap insertion"
    },
    {
      "lines": "96-125",
      "explanation": "grant_access_with_timestamp - updates current state, creates immutable AuditEntry, and indexes it. This is the 'write' side of event sourcing"
    },
    {
      "lines": "126-155",
      "explanation": "revoke_access_with_timestamp - similar pattern, removes from current state and logs the REVOKE event"
    },
    {
      "lines": "156-195",
      "explanation": "get_audit_log - query method supporting four cases: no filter (return all), employee-only filter, resource-only filter, both filters. Uses appropriate index for efficiency"
    },
    {
      "lines": "196-220",
      "explanation": "get_audit_log_in_range - leverages TreeMap's subMap for O(log n) range lookups, much more efficient than scanning entire log"
    },
    {
      "lines": "221-270",
      "explanation": "get_employees_with_access_at - THE KEY ALGORITHM. Filters resource events by timestamp, sorts chronologically, replays events to reconstruct historical state, returns employees with non-empty access"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "grantAccessWithTimestamp": {
          "complexity": "O(log n)",
          "explanation": "TreeMap insertion is O(log n), HashMap operations are O(1) amortized"
        },
        "revokeAccessWithTimestamp": {
          "complexity": "O(log n)",
          "explanation": "Same as grant - TreeMap dominates"
        },
        "getAuditLog": {
          "complexity": "O(k log k)",
          "explanation": "O(1) or O(k) to get entries from index, O(k log k) to sort k results"
        },
        "getAuditLogInRange": {
          "complexity": "O(log n + k)",
          "explanation": "O(log n) for TreeMap subMap, O(k) to collect k entries in range"
        },
        "getEmployeesWithAccessAt": {
          "complexity": "O(m log m)",
          "explanation": "O(m) to filter entries, O(m log m) to sort, O(m) to replay events where m = events for resource up to timestamp"
        }
      },
      "overall_change": "Previous parts had O(1) for grant/revoke. Now O(log n) due to timestamp indexing. Query operations are new but efficient with proper indexing."
    },
    "space": {
      "additional_space": "O(n) where n = total audit entries",
      "explanation": "We store each AuditEntry once in the main log, but maintain multiple index references. References are O(1) each, so total space is O(n) for entries + O(n) for index references = O(n)"
    }
  },
  "dry_run": {
    "example_input": "getEmployeesWithAccessAt('R1', 225) after grants at t=100 (E1 READ), t=150 (E1 WRITE), t=200 (E2 ADMIN)",
    "steps": [
      {
        "step": 1,
        "action": "Get all entries for resource R1",
        "state": "[E1 READ@100, E1 WRITE@150, E2 ADMIN@200]",
        "explanation": "Use by_resource index to get all R1 events"
      },
      {
        "step": 2,
        "action": "Filter entries where timestamp <= 225",
        "state": "[E1 READ@100, E1 WRITE@150, E2 ADMIN@200]",
        "explanation": "All three events are at or before t=225"
      },
      {
        "step": 3,
        "action": "Sort by timestamp",
        "state": "[E1 READ@100, E1 WRITE@150, E2 ADMIN@200]",
        "explanation": "Already in order"
      },
      {
        "step": 4,
        "action": "Initialize access_state = {}",
        "state": "access_state = {}",
        "explanation": "Start with empty state"
      },
      {
        "step": 5,
        "action": "Process E1 READ@100 (GRANT)",
        "state": "access_state = {E1: {READ}}",
        "explanation": "Add READ to E1's access set"
      },
      {
        "step": 6,
        "action": "Process E1 WRITE@150 (GRANT)",
        "state": "access_state = {E1: {READ, WRITE}}",
        "explanation": "Add WRITE to E1's access set"
      },
      {
        "step": 7,
        "action": "Process E2 ADMIN@200 (GRANT)",
        "state": "access_state = {E1: {READ, WRITE}, E2: {ADMIN}}",
        "explanation": "Create E2 entry with ADMIN"
      },
      {
        "step": 8,
        "action": "Filter for non-empty access sets",
        "state": "[E1, E2]",
        "explanation": "Both have non-empty sets"
      },
      {
        "step": 9,
        "action": "Sort and return",
        "state": "[E1, E2]",
        "explanation": "Return sorted list of employee IDs"
      }
    ],
    "final_output": "[E1, E2]"
  },
  "edge_cases": [
    {
      "case": "Empty audit log",
      "handling": "Return empty list for queries",
      "gotcha": "Don't throw NullPointerException when indexes are empty"
    },
    {
      "case": "Query timestamp before any events",
      "handling": "Event replay returns empty state, so empty employee list",
      "gotcha": "Filter step handles this naturally"
    },
    {
      "case": "Multiple events at same timestamp",
      "handling": "Process all events at that timestamp in insertion order",
      "gotcha": "Use stable sort to maintain insertion order for same-timestamp events"
    },
    {
      "case": "Revoke for non-existent access",
      "handling": "Still log the event (for audit), discard from set is safe on empty",
      "gotcha": "Don't skip logging just because access wasn't present"
    },
    {
      "case": "Both employee and resource filters are null",
      "handling": "Return entire audit log",
      "gotcha": "Handle all four filter combinations explicitly"
    },
    {
      "case": "Grant then revoke then grant same access",
      "handling": "Event replay handles this - final state reflects last action",
      "gotcha": "Don't assume access is monotonic"
    }
  ],
  "test_cases": [
    {
      "name": "Basic audit log capture",
      "input": "grant(E1, R1, READ, 100), revoke(E1, R1, READ, 200), getAuditLog(E1, R1)",
      "expected": "[{t:100, GRANT:READ}, {t:200, REVOKE:READ}]",
      "explanation": "Both grant and revoke are captured in chronological order"
    },
    {
      "name": "Historical access - before all events",
      "input": "grant(E1, R1, READ, 100), getEmployeesWithAccessAt(R1, 50)",
      "expected": "[]",
      "explanation": "No events before t=50, so no one has access"
    },
    {
      "name": "Historical access - after grant before revoke",
      "input": "grant(E1, R1, READ, 100), revoke(E1, R1, READ, 200), getEmployeesWithAccessAt(R1, 150)",
      "expected": "[E1]",
      "explanation": "E1 had access at t=150 (after grant, before revoke)"
    },
    {
      "name": "Historical access - after revoke",
      "input": "grant(E1, R1, READ, 100), revoke(E1, R1, READ, 200), getEmployeesWithAccessAt(R1, 250)",
      "expected": "[]",
      "explanation": "E1's access was revoked at t=200, so no access at t=250"
    },
    {
      "name": "Time range query",
      "input": "grant at t=100, t=200, t=300, getAuditLogInRange(150, 250)",
      "expected": "[entry at t=200]",
      "explanation": "Only middle event is in range [150, 250]"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not maintaining separate current state",
      "why_wrong": "Replaying all events for every access check is O(n), too slow for frequent queries",
      "correct_approach": "Maintain current state separately, updated on each grant/revoke",
      "code_example_wrong": "// Wrong: replay all events to check current access\ndef has_access(emp, res):\n    for event in audit_log:\n        # replay everything...",
      "code_example_correct": "// Correct: maintain current state\ndef has_access(emp, res):\n    return res in self._access[emp]"
    },
    {
      "mistake": "Modifying AuditEntry after creation",
      "why_wrong": "Violates audit compliance - entries must be immutable for legal/security reasons",
      "correct_approach": "Use frozen dataclass (Python) or final fields (Java)",
      "code_example_wrong": "entry = AuditEntry(...)\nentry.timestamp = new_time  # Mutation!",
      "code_example_correct": "@dataclass(frozen=True)\nclass AuditEntry:\n    # Cannot be modified after creation"
    },
    {
      "mistake": "Linear scan for time range queries",
      "why_wrong": "O(n) for every range query doesn't scale",
      "correct_approach": "Use TreeMap with subMap for O(log n) range lookup",
      "code_example_wrong": "def get_in_range(start, end):\n    return [e for e in log if start <= e.ts <= end]",
      "code_example_correct": "def get_in_range(start, end):\n    return tree_map.subMap(start, end).values()"
    },
    {
      "mistake": "Not handling null/None filters in getAuditLog",
      "why_wrong": "Query method needs to support flexible filtering",
      "correct_approach": "Explicitly handle all four cases: both null, employee only, resource only, both specified",
      "code_example_wrong": "def get_audit_log(emp, res):\n    return [e for e in log if e.emp == emp and e.res == res]",
      "code_example_correct": "def get_audit_log(emp, res):\n    if emp is None and res is None:\n        return list(log)\n    # ... handle other cases"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by recognizing this as the Event Sourcing pattern - mention you've seen this in systems like Kafka, EventStore, or financial trading systems. Explain the key insight: 'store events, derive state'. Then walk through the indexing strategy, explaining why multiple indexes are needed for different query patterns.",
    "what_to_mention": [
      "Event Sourcing pattern - used in financial systems, CQRS architectures",
      "Audit compliance requirements (immutability, append-only)",
      "Trade-off: more space for indexes, but faster queries",
      "TreeMap for time-based queries - O(log n) vs O(n)",
      "Replay algorithm for historical state reconstruction"
    ],
    "time_allocation": "10-15 minutes: 2 min problem understanding, 3 min design discussion (data structures, indexes), 8 min implementation, 2 min testing edge cases",
    "if_stuck": [
      "Think about what queries you need to support, then design indexes backwards from that",
      "For historical state: if you can't store state at every timestamp, can you compute it?",
      "What data structure gives O(log n) range queries? TreeMap/SortedDict",
      "How does git work? It stores changes (events), not full file copies at each commit"
    ]
  },
  "connection_to_next_part": "If there's a Part 5, it might involve: (1) Snapshots - periodically saving computed state to avoid replaying entire history, (2) Event compaction - merging old events to save space while maintaining correctness, (3) Distributed audit log - handling consistency across multiple nodes, (4) Access inheritance through organizational hierarchy combined with audit logging.",
  "generated_at": "2026-01-14T15:03:52.008862",
  "_meta": {
    "problem_id": "employee_access_management",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}