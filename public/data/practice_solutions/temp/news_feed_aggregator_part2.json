{
  "problem_title": "News Feed Aggregator System - Part 2: Real-Time Notifications & Breaking News",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 extends the News Aggregator to support **real-time push notifications** for breaking news. While Part 1 focused on feed generation (pull-based), Part 2 adds push-based delivery with strict latency requirements (<30 seconds). This requires new data structures for fast audience lookup, rate limiting infrastructure, and integration with push notification gateways (FCM/APNS).",
    "new_requirements": [
      "Breaking news alerts must reach users within 30 seconds of publication",
      "Personalized notification filtering - respect user preferences and don't spam",
      "Support notification preferences (daily limits, quiet hours, category filters)",
      "Track notification delivery status and user engagement metrics",
      "Handle high-priority notifications that bypass normal filters"
    ],
    "new_constraints": [
      "30-second end-to-end latency requirement for breaking news",
      "Must scale to notify millions of users per breaking news event",
      "Rate limiting: respect user-defined daily notification limits",
      "Quiet hours: no notifications during user-specified times (except urgent)",
      "Circuit breaker: gracefully handle push gateway failures"
    ],
    "key_insight": "**Pre-build inverted indexes** mapping category -> user_ids and publisher -> follower_ids. When breaking news arrives, audience lookup is O(1) instead of scanning all users. Combined with a priority message queue and parallel processing, this enables sub-30-second delivery to millions."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    BEFORE vs AFTER ARCHITECTURE                        \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                        \u2551\n\u2551  PART 1 (Before):                PART 2 (After):                       \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2551\n\u2551  \u2502   Articles  \u2502                \u2502   Articles  \u2502                        \u2551\n\u2551  \u2502   Database  \u2502                \u2502   Database  \u2502                        \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2551\n\u2551         \u2502                              \u2502                               \u2551\n\u2551         \u25bc (pull)                       \u25bc (push + pull)                 \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2551\n\u2551  \u2502  User Feed  \u2502                \u2502    Notification Pipeline    \u2502        \u2551\n\u2551  \u2502   Request   \u2502                \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502        \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502  \u2502  Inverted Indexes      \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2502  \u2022 category\u2192users      \u2502 \u2502        \u2551\n\u2551  Simple polling                 \u2502  \u2502  \u2022 publisher\u2192followers \u2502 \u2502        \u2551\n\u2551  model - user                   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502        \u2551\n\u2551  must refresh                   \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Message Queue (Kafka) \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Priority-based        \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502        \u2551\n\u2551                                 \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Rate Limiter (Redis)  \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Sliding window        \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502        \u2551\n\u2551                                 \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Push Gateway          \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2502  FCM/APNS + Circuit    \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2502  Breaker               \u2502 \u2502        \u2551\n\u2551                                 \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502        \u2551\n\u2551                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2551\n\u2551                                                                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551              BREAKING NEWS NOTIFICATION FLOW (< 30 seconds)            \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                        \u2551\n\u2551  STEP 1: PUBLISH (0-1 sec)                                            \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502  Publisher \u2192 publishBreakingNews(article, priority=10)          \u2502  \u2551\n\u2551  \u2502                     \u2502                                           \u2502  \u2551\n\u2551  \u2502                     \u25bc                                           \u2502  \u2551\n\u2551  \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2502  \u2551\n\u2551  \u2502            \u2502 Priority Check  \u2502 priority >= 8?                   \u2502  \u2551\n\u2551  \u2502            \u2502    (O(1))       \u2502 YES \u2192 Continue                   \u2502  \u2551\n\u2551  \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502  \u2551\n\u2551  \u2502                     \u25bc                                           \u2502  \u2551\n\u2551  \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2502  \u2551\n\u2551  \u2502            \u2502  Message Queue  \u2502 Enqueue with priority            \u2502  \u2551\n\u2551  \u2502            \u2502    (Kafka)      \u2502 High priority = processed first  \u2502  \u2551\n\u2551  \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                        \u2502                                              \u2551\n\u2551  STEP 2: AUDIENCE LOOKUP (1-5 sec)                                    \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                     \u25bc                                           \u2502  \u2551\n\u2551  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502  \u2551\n\u2551  \u2502  \u2502             INVERTED INDEX LOOKUP (O(1) each)            \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502                                                          \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  publisher_followers[\"NYT\"] = {user_1, user_2, user_5}   \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  category_subscribers[\"Breaking\"] = {user_1, user_3...}  \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  category_subscribers[\"Politics\"] = {user_2, user_4...}  \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502                                                          \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  audience = UNION of all sets                            \u2502   \u2502  \u2551\n\u2551  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502  \u2551\n\u2551  \u2502                     \u2502                                           \u2502  \u2551\n\u2551  \u2502                     \u25bc                                           \u2502  \u2551\n\u2551  \u2502  Example: Article categories = [\"Breaking\", \"Politics\"]         \u2502  \u2551\n\u2551  \u2502           Publisher = \"NYT\"                                     \u2502  \u2551\n\u2551  \u2502           Audience = {user_1, user_2, user_3, user_4, user_5}  \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                        \u2502                                              \u2551\n\u2551  STEP 3: FILTER BY PREFERENCES (5-15 sec)                             \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                     \u25bc                                           \u2502  \u2551\n\u2551  \u2502  For each user in audience (parallel processing):               \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502  \u2551\n\u2551  \u2502  \u2502  RATE LIMIT \u2502   \u2502 QUIET HOURS \u2502   \u2502  CATEGORY   \u2502           \u2502  \u2551\n\u2551  \u2502  \u2502   CHECK     \u2502   \u2502    CHECK    \u2502   \u2502   MATCH     \u2502           \u2502  \u2551\n\u2551  \u2502  \u2502 count < max?\u2502   \u2502 not 10pm-8am\u2502   \u2502 user wants? \u2502           \u2502  \u2551\n\u2551  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502  \u2551\n\u2551  \u2502         \u2502 \u2713               \u2502 \u2713               \u2502 \u2713                \u2502  \u2551\n\u2551  \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502  \u2551\n\u2551  \u2502                           \u2502                                     \u2502  \u2551\n\u2551  \u2502                           \u25bc                                     \u2502  \u2551\n\u2551  \u2502              All checks pass? \u2192 Create Notification             \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502  user_1: \u2713 (2/5 daily, awake, wants Breaking)                  \u2502  \u2551\n\u2551  \u2502  user_2: \u2717 (5/5 daily limit reached)                           \u2502  \u2551\n\u2551  \u2502  user_3: \u2713 (1/10 daily, awake, wants Breaking)                 \u2502  \u2551\n\u2551  \u2502  user_4: \u2717 (quiet hours - it's 11pm)                           \u2502  \u2551\n\u2551  \u2502  user_5: \u2717 (doesn't want Politics category)                    \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551  STEP 4: DELIVERY (15-30 sec)                                         \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502  Filtered Users: [user_1, user_3]                               \u2502  \u2551\n\u2551  \u2502         \u2502                                                       \u2502  \u2551\n\u2551  \u2502         \u25bc                                                       \u2502  \u2551\n\u2551  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502  \u2551\n\u2551  \u2502  \u2502              PUSH GATEWAY (with Circuit Breaker)        \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502                                                         \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  \u2502  FCM      \u2502    \u2502   APNS    \u2502    \u2502 WebSocket \u2502       \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  \u2502 (Android) \u2502    \u2502  (iOS)    \u2502    \u2502   (Web)   \u2502       \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502         \u2502              \u2502                \u2502               \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502                        \u2502                                \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502                        \u25bc                                \u2502   \u2502  \u2551\n\u2551  \u2502  \u2502         \ud83d\udcf1 Push Notification Delivered! \ud83d\udcf1              \u2502   \u2502  \u2551\n\u2551  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502  \u2713 Update notification status: DELIVERED                       \u2502  \u2551\n\u2551  \u2502  \u2713 Record in rate limiter                                      \u2502  \u2551\n\u2551  \u2502  \u2713 Log for analytics                                           \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551  TOTAL TIME: < 30 seconds \u2713                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Scan All Users",
      "description": "When breaking news is published, iterate through ALL users to check if they should receive a notification. For each user, check if they follow the publisher or have matching category interests.",
      "time_complexity": "O(U * C) per breaking news where U = total users, C = categories per user",
      "space_complexity": "O(1) additional space",
      "why_not_optimal": "With 10M users and breaking news needing <30 second delivery, scanning all users is far too slow. At 1ms per user check, 10M users = 10,000 seconds = 2.7 hours. This completely violates the 30-second SLA. We need O(1) audience lookup, not O(U) scanning."
    },
    {
      "name": "Optimal Approach - Inverted Index + Message Queue",
      "description": "Pre-build inverted indexes mapping category\u2192user_ids and publisher\u2192follower_ids. When breaking news arrives: (1) O(1) index lookup to find audience, (2) Enqueue to priority message queue, (3) Parallel workers filter by preferences and deliver. Circuit breaker protects push gateway.",
      "time_complexity": "O(1) to enqueue, O(A) to process where A = relevant audience size (much smaller than total users)",
      "space_complexity": "O(U + C) for inverted indexes where U = users, C = categories",
      "key_insight": "The key insight is that inverted indexes trade space for time. By maintaining category\u2192users and publisher\u2192followers mappings, we turn a O(U) scan into O(1) lookups. Combined with fan-out through message queues and parallel workers, we achieve sub-30-second delivery regardless of total user count."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Event-Driven Architecture with Inverted Indexes\n\n### Core Components\n\n**1. Inverted Indexes for O(1) Audience Lookup**\n- `category_subscribers`: Maps each category to set of interested user IDs\n- `publisher_followers`: Maps each publisher to set of follower IDs\n- Updated in real-time when users change preferences/follows\n\n**2. Priority Message Queue (Kafka/SQS)**\n- Breaking news enqueued with priority level\n- Higher priority = processed first\n- Enables async processing without blocking publishers\n\n**3. Rate Limiter (Redis Sorted Sets)**\n- Sliding window algorithm\n- Tracks notification count per user per time window\n- O(log N) operations for add/check\n\n**4. Circuit Breaker for Push Gateway**\n- Protects against cascade failures\n- States: CLOSED (normal) \u2192 OPEN (failing) \u2192 HALF_OPEN (testing)\n- Prevents overwhelming a degraded push service\n\n### Algorithm Flow\n\n1. **publishBreakingNews()** - O(1)\n   - Store article in database\n   - If priority >= 8, enqueue to notification queue\n   - Return immediately (async processing)\n\n2. **Queue Worker Processing** - O(A) where A = audience\n   - Consume message from queue\n   - Lookup audience using inverted indexes\n   - For each user in parallel:\n     - Check rate limit\n     - Check quiet hours\n     - Check category preferences\n     - If passes all filters, deliver notification\n\n3. **Delivery with Circuit Breaker**\n   - If circuit OPEN, fail fast\n   - Otherwise attempt push via FCM/APNS\n   - Record success/failure for circuit state\n\n### Why This Meets 30-Second SLA\n\n- **Enqueue**: ~1ms (instant return to publisher)\n- **Index Lookup**: ~1ms (O(1) hash lookups)\n- **Parallel Filtering**: ~5-10 seconds for millions of users across worker fleet\n- **Push Delivery**: ~10-15 seconds (batched API calls to FCM/APNS)\n- **Total**: ~15-25 seconds with buffer",
    "data_structures": [
      {
        "structure": "Dict[str, Set[str]] - category_subscribers",
        "purpose": "Inverted index mapping category \u2192 set of user IDs for O(1) audience lookup"
      },
      {
        "structure": "Dict[str, Set[str]] - publisher_followers",
        "purpose": "Inverted index mapping publisher \u2192 set of follower IDs for O(1) lookup"
      },
      {
        "structure": "Priority Queue (Heap)",
        "purpose": "Process highest priority notifications first (breaking news before regular)"
      },
      {
        "structure": "Dict[str, List[datetime]] - rate_limiter",
        "purpose": "Sliding window rate limiting - track timestamps of recent notifications per user"
      },
      {
        "structure": "Dict[str, NotificationPrefs]",
        "purpose": "Store user notification preferences for quick filtering"
      },
      {
        "structure": "Dict[str, List[Notification]]",
        "purpose": "Pending notifications per user for getPendingNotifications()"
      }
    ],
    "algorithm_steps": [
      "Step 1: When user follows publisher or sets interests, update inverted indexes (category\u2192users, publisher\u2192followers)",
      "Step 2: On publishBreakingNews(), check if priority >= BREAKING_THRESHOLD (8)",
      "Step 3: If breaking, create message with article_id, categories, priority and enqueue to priority queue",
      "Step 4: Worker consumes message, performs O(1) lookup in inverted indexes to find audience",
      "Step 5: For each user in audience (can parallelize), apply filter chain: rate limit \u2192 quiet hours \u2192 category match",
      "Step 6: Users passing all filters get Notification object created and stored in pending_notifications",
      "Step 7: Attempt delivery through push gateway with circuit breaker protection",
      "Step 8: Update notification status (DELIVERED/FAILED) and record in rate limiter",
      "Step 9: getPendingNotifications() returns all non-read notifications for user",
      "Step 10: markNotificationRead() updates status and records engagement metrics"
    ]
  },
  "solution_python_lines": [
    "from typing import Dict, List, Set, Optional",
    "from dataclasses import dataclass, field",
    "from datetime import datetime, timedelta",
    "from collections import defaultdict",
    "from enum import Enum",
    "import heapq",
    "import threading",
    "import uuid",
    "",
    "",
    "class NotificationStatus(Enum):",
    "    \"\"\"Status of a notification through its lifecycle.\"\"\"",
    "    PENDING = \"pending\"",
    "    DELIVERED = \"delivered\"",
    "    READ = \"read\"",
    "    FAILED = \"failed\"",
    "",
    "",
    "@dataclass",
    "class Article:",
    "    \"\"\"News article data structure.\"\"\"",
    "    article_id: str",
    "    title: str",
    "    content: str",
    "    publisher_id: str",
    "    categories: List[str]",
    "    published_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "@dataclass",
    "class NotificationPrefs:",
    "    \"\"\"User notification preferences.\"\"\"",
    "    max_daily: int = 10                    # Max notifications per day",
    "    categories: List[str] = field(default_factory=list)  # Categories to notify",
    "    quiet_hours_start: int = 22            # 10 PM",
    "    quiet_hours_end: int = 8               # 8 AM",
    "    enabled: bool = True                   # Master toggle",
    "",
    "",
    "@dataclass",
    "class Notification:",
    "    \"\"\"Notification entity with tracking.\"\"\"",
    "    notification_id: str",
    "    user_id: str",
    "    article_id: str",
    "    title: str",
    "    priority: int",
    "    created_at: datetime",
    "    status: NotificationStatus = NotificationStatus.PENDING",
    "    delivered_at: Optional[datetime] = None",
    "    read_at: Optional[datetime] = None",
    "",
    "",
    "class RateLimiter:",
    "    \"\"\"",
    "    Sliding window rate limiter.",
    "    ",
    "    In production, use Redis sorted sets with TTL for distributed rate limiting.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, window_seconds: int = 86400):",
    "        self.window_seconds = window_seconds  # Default: 24 hours",
    "        self.user_timestamps: Dict[str, List[datetime]] = defaultdict(list)",
    "        self._lock = threading.Lock()",
    "    ",
    "    def can_send(self, user_id: str, max_count: int) -> bool:",
    "        \"\"\"Check if user can receive another notification.\"\"\"",
    "        with self._lock:",
    "            now = datetime.now()",
    "            cutoff = now - timedelta(seconds=self.window_seconds)",
    "            ",
    "            # Clean expired timestamps",
    "            self.user_timestamps[user_id] = [",
    "                ts for ts in self.user_timestamps[user_id] if ts > cutoff",
    "            ]",
    "            ",
    "            return len(self.user_timestamps[user_id]) < max_count",
    "    ",
    "    def record_send(self, user_id: str) -> None:",
    "        \"\"\"Record a notification was sent.\"\"\"",
    "        with self._lock:",
    "            self.user_timestamps[user_id].append(datetime.now())",
    "",
    "",
    "class CircuitBreaker:",
    "    \"\"\"",
    "    Circuit breaker for external service protection.",
    "    ",
    "    Prevents cascading failures when push gateway is down.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, failure_threshold: int = 5, recovery_time: int = 60):",
    "        self.failure_threshold = failure_threshold",
    "        self.recovery_time = recovery_time",
    "        self.failures = 0",
    "        self.last_failure_time: Optional[datetime] = None",
    "        self.state = \"CLOSED\"  # CLOSED, OPEN, HALF_OPEN",
    "        self._lock = threading.Lock()",
    "    ",
    "    def can_execute(self) -> bool:",
    "        \"\"\"Check if circuit allows execution.\"\"\"",
    "        with self._lock:",
    "            if self.state == \"CLOSED\":",
    "                return True",
    "            elif self.state == \"OPEN\":",
    "                if self.last_failure_time:",
    "                    elapsed = (datetime.now() - self.last_failure_time).seconds",
    "                    if elapsed >= self.recovery_time:",
    "                        self.state = \"HALF_OPEN\"",
    "                        return True",
    "                return False",
    "            else:  # HALF_OPEN - allow one test request",
    "                return True",
    "    ",
    "    def record_success(self) -> None:",
    "        \"\"\"Record successful execution.\"\"\"",
    "        with self._lock:",
    "            self.failures = 0",
    "            self.state = \"CLOSED\"",
    "    ",
    "    def record_failure(self) -> None:",
    "        \"\"\"Record failed execution.\"\"\"",
    "        with self._lock:",
    "            self.failures += 1",
    "            self.last_failure_time = datetime.now()",
    "            if self.failures >= self.failure_threshold:",
    "                self.state = \"OPEN\"",
    "",
    "",
    "class MessageQueue:",
    "    \"\"\"",
    "    Priority message queue (simulates Kafka/SQS).",
    "    ",
    "    In production, use Kafka with priority topics or SQS with priority queues.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._queue: List[tuple] = []",
    "        self._lock = threading.Lock()",
    "    ",
    "    def publish(self, message: dict, priority: int = 0) -> None:",
    "        \"\"\"Publish message with priority (higher = more urgent).\"\"\"",
    "        with self._lock:",
    "            # Negative priority for max-heap behavior",
    "            heapq.heappush(self._queue, (-priority, datetime.now(), message))",
    "    ",
    "    def consume(self) -> Optional[dict]:",
    "        \"\"\"Consume highest priority message.\"\"\"",
    "        with self._lock:",
    "            if self._queue:",
    "                _, _, message = heapq.heappop(self._queue)",
    "                return message",
    "            return None",
    "    ",
    "    def size(self) -> int:",
    "        \"\"\"Get queue size.\"\"\"",
    "        return len(self._queue)",
    "",
    "",
    "class PushGateway:",
    "    \"\"\"",
    "    Push notification gateway (simulates FCM/APNS).",
    "    ",
    "    Includes circuit breaker for resilience.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.circuit_breaker = CircuitBreaker()",
    "        self.sent_notifications: List[Notification] = []",
    "    ",
    "    def send(self, notification: Notification) -> bool:",
    "        \"\"\"Send push notification.\"\"\"",
    "        if not self.circuit_breaker.can_execute():",
    "            return False",
    "        ",
    "        try:",
    "            # In production: call FCM/APNS API",
    "            self.sent_notifications.append(notification)",
    "            self.circuit_breaker.record_success()",
    "            return True",
    "        except Exception:",
    "            self.circuit_breaker.record_failure()",
    "            return False",
    "",
    "",
    "class NewsAggregator:",
    "    \"\"\"",
    "    News Feed Aggregator with Real-Time Notifications.",
    "    ",
    "    Key Design Decisions:",
    "    1. Inverted indexes for O(1) audience lookup",
    "    2. Message queue for async notification processing",
    "    3. Sliding window rate limiting",
    "    4. Circuit breaker for push gateway resilience",
    "    ",
    "    Time Complexities:",
    "    - publishBreakingNews: O(1) to enqueue",
    "    - Notification processing: O(A) where A = audience size",
    "    - setNotificationPreferences: O(C) where C = categories",
    "    - getPendingNotifications: O(N) where N = user's notifications",
    "    \"\"\"",
    "    ",
    "    BREAKING_NEWS_THRESHOLD = 8  # Priority >= 8 triggers breaking news flow",
    "    ",
    "    def __init__(self):",
    "        # Part 1: Core data structures",
    "        self.articles: Dict[str, Article] = {}",
    "        self.publisher_articles: Dict[str, List[str]] = defaultdict(list)",
    "        self.user_follows: Dict[str, Set[str]] = defaultdict(set)",
    "        self.user_interests: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Part 2: Inverted indexes for fast audience lookup",
    "        self.category_subscribers: Dict[str, Set[str]] = defaultdict(set)",
    "        self.publisher_followers: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Part 2: Notification system",
    "        self.notification_prefs: Dict[str, NotificationPrefs] = {}",
    "        self.pending_notifications: Dict[str, List[Notification]] = defaultdict(list)",
    "        self.all_notifications: Dict[str, Notification] = {}",
    "        ",
    "        # Part 2: Infrastructure components",
    "        self.notification_queue = MessageQueue()",
    "        self.rate_limiter = RateLimiter()",
    "        self.push_gateway = PushGateway()",
    "    ",
    "    # ==================== Part 1 Methods ====================",
    "    ",
    "    def add_article(self, article: Article) -> None:",
    "        \"\"\"Add article to the system.\"\"\"",
    "        self.articles[article.article_id] = article",
    "        self.publisher_articles[article.publisher_id].append(article.article_id)",
    "    ",
    "    def follow_publisher(self, user_id: str, publisher_id: str) -> None:",
    "        \"\"\"",
    "        User follows a publisher.",
    "        Updates both forward and inverted indexes.",
    "        \"\"\"",
    "        self.user_follows[user_id].add(publisher_id)",
    "        self.publisher_followers[publisher_id].add(user_id)  # Inverted index",
    "    ",
    "    def unfollow_publisher(self, user_id: str, publisher_id: str) -> None:",
    "        \"\"\"User unfollows a publisher.\"\"\"",
    "        self.user_follows[user_id].discard(publisher_id)",
    "        self.publisher_followers[publisher_id].discard(user_id)",
    "    ",
    "    def set_user_interests(self, user_id: str, categories: List[str]) -> None:",
    "        \"\"\"",
    "        Set user's category interests.",
    "        Maintains inverted index: category -> users.",
    "        \"\"\"",
    "        # Remove from old categories",
    "        for cat in self.user_interests[user_id]:",
    "            self.category_subscribers[cat].discard(user_id)",
    "        ",
    "        # Add to new categories",
    "        self.user_interests[user_id] = set(categories)",
    "        for cat in categories:",
    "            self.category_subscribers[cat].add(user_id)",
    "    ",
    "    def get_feed(self, user_id: str, limit: int = 20) -> List[Article]:",
    "        \"\"\"Get personalized feed for user.\"\"\"",
    "        followed = self.user_follows.get(user_id, set())",
    "        interests = self.user_interests.get(user_id, set())",
    "        ",
    "        feed = []",
    "        for article in self.articles.values():",
    "            if (article.publisher_id in followed or",
    "                any(cat in interests for cat in article.categories)):",
    "                feed.append(article)",
    "        ",
    "        feed.sort(key=lambda a: a.published_at, reverse=True)",
    "        return feed[:limit]",
    "    ",
    "    # ==================== Part 2 Methods ====================",
    "    ",
    "    def set_notification_preferences(self, user_id: str, prefs: NotificationPrefs) -> None:",
    "        \"\"\"",
    "        Set user's notification preferences.",
    "        ",
    "        Time Complexity: O(C) where C = number of categories",
    "        \"\"\"",
    "        self.notification_prefs[user_id] = prefs",
    "        ",
    "        # Update category subscriptions based on preferences",
    "        for cat in prefs.categories:",
    "            self.category_subscribers[cat].add(user_id)",
    "    ",
    "    def publish_breaking_news(self, publisher_id: str, article: Article, ",
    "                              priority: int) -> None:",
    "        \"\"\"",
    "        Publish breaking news and trigger notification pipeline.",
    "        ",
    "        Time Complexity: O(1) to enqueue",
    "        Processing: O(A) where A = audience size",
    "        ",
    "        Key Insight: Using inverted indexes, audience lookup is O(1)",
    "        instead of scanning all users O(U).",
    "        \"\"\"",
    "        # Store article",
    "        article.publisher_id = publisher_id",
    "        self.add_article(article)",
    "        ",
    "        # Only trigger notification pipeline for high priority",
    "        if priority >= self.BREAKING_NEWS_THRESHOLD:",
    "            message = {",
    "                \"type\": \"breaking_news\",",
    "                \"article_id\": article.article_id,",
    "                \"publisher_id\": publisher_id,",
    "                \"categories\": article.categories,",
    "                \"priority\": priority,",
    "                \"title\": article.title",
    "            }",
    "            self.notification_queue.publish(message, priority)",
    "            ",
    "            # Process immediately (in production: separate workers)",
    "            self._process_notification_queue()",
    "    ",
    "    def _process_notification_queue(self) -> None:",
    "        \"\"\"Process pending notification messages from queue.\"\"\"",
    "        while True:",
    "            message = self.notification_queue.consume()",
    "            if not message:",
    "                break",
    "            ",
    "            if message[\"type\"] == \"breaking_news\":",
    "                self._process_breaking_news(message)",
    "    ",
    "    def _process_breaking_news(self, message: dict) -> None:",
    "        \"\"\"",
    "        Process a breaking news notification.",
    "        ",
    "        Steps:",
    "        1. Find target audience using inverted indexes - O(1) per index",
    "        2. Filter by user preferences - O(1) per user",
    "        3. Create and deliver notifications",
    "        \"\"\"",
    "        article_id = message[\"article_id\"]",
    "        publisher_id = message[\"publisher_id\"]",
    "        categories = message[\"categories\"]",
    "        priority = message[\"priority\"]",
    "        title = message[\"title\"]",
    "        ",
    "        # Step 1: Find audience using inverted indexes (O(1) lookups)",
    "        audience = self._find_audience(publisher_id, categories)",
    "        ",
    "        # Step 2 & 3: Filter and deliver",
    "        for user_id in audience:",
    "            if self._should_notify_user(user_id, categories, priority):",
    "                notification = self._create_notification(",
    "                    user_id, article_id, title, priority",
    "                )",
    "                self._deliver_notification(notification)",
    "    ",
    "    def _find_audience(self, publisher_id: str, ",
    "                       categories: List[str]) -> Set[str]:",
    "        \"\"\"",
    "        Find all users who should receive this notification.",
    "        ",
    "        Uses pre-built inverted indexes for O(1) lookup per index.",
    "        \"\"\"",
    "        audience = set()",
    "        ",
    "        # Add publisher followers - O(1) lookup",
    "        audience.update(self.publisher_followers.get(publisher_id, set()))",
    "        ",
    "        # Add category subscribers - O(C) where C = categories",
    "        for category in categories:",
    "            audience.update(self.category_subscribers.get(category, set()))",
    "        ",
    "        return audience",
    "    ",
    "    def _should_notify_user(self, user_id: str, categories: List[str], ",
    "                            priority: int) -> bool:",
    "        \"\"\"",
    "        Check if user should receive notification based on preferences.",
    "        ",
    "        Filter chain:",
    "        1. Notifications enabled?",
    "        2. Under rate limit?",
    "        3. Category match?",
    "        4. Outside quiet hours? (unless very high priority)",
    "        \"\"\"",
    "        prefs = self.notification_prefs.get(user_id)",
    "        ",
    "        # Default: notify if no preferences set",
    "        if not prefs:",
    "            return True",
    "        ",
    "        # Check master toggle",
    "        if not prefs.enabled:",
    "            return False",
    "        ",
    "        # Check rate limit",
    "        if not self.rate_limiter.can_send(user_id, prefs.max_daily):",
    "            return False",
    "        ",
    "        # Check category preferences (if specified)",
    "        if prefs.categories:",
    "            if not any(cat in prefs.categories for cat in categories):",
    "                return False",
    "        ",
    "        # Check quiet hours (skip for very high priority >= 9)",
    "        if priority < 9:",
    "            current_hour = datetime.now().hour",
    "            in_quiet = (prefs.quiet_hours_start <= current_hour or ",
    "                       current_hour < prefs.quiet_hours_end)",
    "            if in_quiet:",
    "                return False",
    "        ",
    "        return True",
    "    ",
    "    def _create_notification(self, user_id: str, article_id: str,",
    "                             title: str, priority: int) -> Notification:",
    "        \"\"\"Create and store a new notification.\"\"\"",
    "        notification = Notification(",
    "            notification_id=str(uuid.uuid4()),",
    "            user_id=user_id,",
    "            article_id=article_id,",
    "            title=title,",
    "            priority=priority,",
    "            created_at=datetime.now()",
    "        )",
    "        ",
    "        self.all_notifications[notification.notification_id] = notification",
    "        self.pending_notifications[user_id].append(notification)",
    "        ",
    "        return notification",
    "    ",
    "    def _deliver_notification(self, notification: Notification) -> bool:",
    "        \"\"\"Deliver notification via push gateway with circuit breaker.\"\"\"",
    "        success = self.push_gateway.send(notification)",
    "        ",
    "        if success:",
    "            notification.status = NotificationStatus.DELIVERED",
    "            notification.delivered_at = datetime.now()",
    "            self.rate_limiter.record_send(notification.user_id)",
    "            return True",
    "        else:",
    "            notification.status = NotificationStatus.FAILED",
    "            return False",
    "    ",
    "    def get_pending_notifications(self, user_id: str) -> List[Notification]:",
    "        \"\"\"",
    "        Get all pending/unread notifications for user.",
    "        ",
    "        Time Complexity: O(N) where N = user's notifications",
    "        \"\"\"",
    "        return [",
    "            n for n in self.pending_notifications[user_id]",
    "            if n.status in [NotificationStatus.PENDING, ",
    "                           NotificationStatus.DELIVERED]",
    "        ]",
    "    ",
    "    def mark_notification_read(self, user_id: str, ",
    "                               notification_id: str) -> None:",
    "        \"\"\"",
    "        Mark notification as read.",
    "        ",
    "        Time Complexity: O(1) with direct lookup",
    "        \"\"\"",
    "        if notification_id in self.all_notifications:",
    "            notification = self.all_notifications[notification_id]",
    "            if notification.user_id == user_id:",
    "                notification.status = NotificationStatus.READ",
    "                notification.read_at = datetime.now()",
    "    ",
    "    def get_notification_stats(self, user_id: str) -> Dict:",
    "        \"\"\"Get notification engagement statistics for user.\"\"\"",
    "        notifications = self.pending_notifications[user_id]",
    "        ",
    "        return {",
    "            \"total\": len(notifications),",
    "            \"pending\": sum(1 for n in notifications ",
    "                          if n.status == NotificationStatus.PENDING),",
    "            \"delivered\": sum(1 for n in notifications ",
    "                            if n.status == NotificationStatus.DELIVERED),",
    "            \"read\": sum(1 for n in notifications ",
    "                        if n.status == NotificationStatus.READ),",
    "            \"failed\": sum(1 for n in notifications ",
    "                          if n.status == NotificationStatus.FAILED)",
    "        }",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the real-time notification system.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"NEWS AGGREGATOR - REAL-TIME NOTIFICATIONS DEMO\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Initialize system",
    "    aggregator = NewsAggregator()",
    "    ",
    "    # Setup users and follows",
    "    print(\"\\n\ud83d\udcdd Setting up test data...\")",
    "    ",
    "    aggregator.follow_publisher(\"user_1\", \"pub_nyt\")",
    "    aggregator.follow_publisher(\"user_1\", \"pub_bbc\")",
    "    aggregator.follow_publisher(\"user_2\", \"pub_nyt\")",
    "    aggregator.follow_publisher(\"user_3\", \"pub_cnn\")",
    "    ",
    "    aggregator.set_user_interests(\"user_1\", [\"Politics\", \"Breaking\", \"Tech\"])",
    "    aggregator.set_user_interests(\"user_2\", [\"Sports\", \"Breaking\"])",
    "    aggregator.set_user_interests(\"user_3\", [\"Entertainment\"])",
    "    ",
    "    print(\"  \u2713 3 users created with follows and interests\")",
    "    ",
    "    # Set notification preferences",
    "    print(\"\\n\u2699\ufe0f Setting notification preferences...\")",
    "    ",
    "    aggregator.set_notification_preferences(\"user_1\", NotificationPrefs(",
    "        max_daily=5,",
    "        categories=[\"Breaking\", \"Politics\"],",
    "        quiet_hours_start=22,",
    "        quiet_hours_end=8,",
    "        enabled=True",
    "    ))",
    "    ",
    "    aggregator.set_notification_preferences(\"user_2\", NotificationPrefs(",
    "        max_daily=10,",
    "        categories=[\"Breaking\", \"Sports\"],",
    "        enabled=True",
    "    ))",
    "    ",
    "    aggregator.set_notification_preferences(\"user_3\", NotificationPrefs(",
    "        enabled=False  # Notifications disabled",
    "    ))",
    "    ",
    "    print(\"  \u2713 user_1: max 5/day, Breaking & Politics\")",
    "    print(\"  \u2713 user_2: max 10/day, Breaking & Sports\")",
    "    print(\"  \u2713 user_3: notifications disabled\")",
    "    ",
    "    # Publish breaking news",
    "    print(\"\\n\ud83d\udd14 Publishing BREAKING NEWS (priority 10)...\")",
    "    ",
    "    breaking_article = Article(",
    "        article_id=\"article_breaking_001\",",
    "        title=\"BREAKING: Major World Event!\",",
    "        content=\"Important news content here...\",",
    "        publisher_id=\"pub_nyt\",",
    "        categories=[\"Breaking\", \"Politics\"]",
    "    )",
    "    ",
    "    aggregator.publish_breaking_news(\"pub_nyt\", breaking_article, priority=10)",
    "    print(\"  \u2713 Breaking news published and processed\")",
    "    ",
    "    # Check notifications",
    "    print(\"\\n\ud83d\udcec Checking pending notifications...\")",
    "    ",
    "    for user_id in [\"user_1\", \"user_2\", \"user_3\"]:",
    "        notifications = aggregator.get_pending_notifications(user_id)",
    "        print(f\"\\n  {user_id}:\")",
    "        if notifications:",
    "            for n in notifications:",
    "                print(f\"    \ud83d\udcf0 {n.title}\")",
    "                print(f\"       Priority: {n.priority}, Status: {n.status.value}\")",
    "        else:",
    "            print(\"    (no notifications)\")",
    "    ",
    "    # Mark as read",
    "    print(\"\\n\u2705 Marking user_1's notification as read...\")",
    "    user1_notifications = aggregator.get_pending_notifications(\"user_1\")",
    "    if user1_notifications:",
    "        aggregator.mark_notification_read(\"user_1\", ",
    "                                         user1_notifications[0].notification_id)",
    "        print(\"  \u2713 Notification marked as read\")",
    "    ",
    "    # Test rate limiting",
    "    print(\"\\n\u23f1\ufe0f Testing rate limiting (publishing 10 more articles)...\")",
    "    ",
    "    for i in range(10):",
    "        article = Article(",
    "            article_id=f\"article_rate_test_{i}\",",
    "            title=f\"Breaking News #{i+1}\",",
    "            content=\"Content...\",",
    "            publisher_id=\"pub_nyt\",",
    "            categories=[\"Breaking\"]",
    "        )",
    "        aggregator.publish_breaking_news(\"pub_nyt\", article, priority=8)",
    "    ",
    "    # Check rate limiting effect",
    "    user1_count = len(aggregator.get_pending_notifications(\"user_1\"))",
    "    print(f\"  user_1 total notifications: {user1_count}\")",
    "    print(f\"  user_1 max_daily setting: 5\")",
    "    print(\"  \u2713 Rate limiting working!\" if user1_count <= 6 else \"  \u26a0\ufe0f Check rate limiting\")",
    "    ",
    "    # Statistics",
    "    print(\"\\n\ud83d\udcca Final Statistics:\")",
    "    for user_id in [\"user_1\", \"user_2\"]:",
    "        stats = aggregator.get_notification_stats(user_id)",
    "        print(f\"  {user_id}: {stats}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"DEMO COMPLETE\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.*;",
    "import java.util.stream.*;",
    "",
    "/**",
    " * News Feed Aggregator with Real-Time Notifications.",
    " * ",
    " * Key Design Decisions:",
    " * 1. Inverted indexes for O(1) audience lookup",
    " * 2. Message queue for async notification processing",
    " * 3. Sliding window rate limiting",
    " * 4. Circuit breaker for push gateway resilience",
    " */",
    "public class NewsAggregator {",
    "    ",
    "    enum NotificationStatus {",
    "        PENDING, DELIVERED, READ, FAILED",
    "    }",
    "    ",
    "    static class Article {",
    "        String articleId;",
    "        String title;",
    "        String content;",
    "        String publisherId;",
    "        List<String> categories;",
    "        LocalDateTime publishedAt;",
    "        ",
    "        Article(String articleId, String title, String content,",
    "                String publisherId, List<String> categories) {",
    "            this.articleId = articleId;",
    "            this.title = title;",
    "            this.content = content;",
    "            this.publisherId = publisherId;",
    "            this.categories = categories;",
    "            this.publishedAt = LocalDateTime.now();",
    "        }",
    "    }",
    "    ",
    "    static class NotificationPrefs {",
    "        int maxDaily = 10;",
    "        List<String> categories = new ArrayList<>();",
    "        int quietHoursStart = 22;",
    "        int quietHoursEnd = 8;",
    "        boolean enabled = true;",
    "        ",
    "        NotificationPrefs() {}",
    "        ",
    "        NotificationPrefs(int maxDaily, List<String> categories, boolean enabled) {",
    "            this.maxDaily = maxDaily;",
    "            this.categories = categories;",
    "            this.enabled = enabled;",
    "        }",
    "    }",
    "    ",
    "    static class Notification {",
    "        String notificationId;",
    "        String userId;",
    "        String articleId;",
    "        String title;",
    "        int priority;",
    "        LocalDateTime createdAt;",
    "        NotificationStatus status = NotificationStatus.PENDING;",
    "        LocalDateTime deliveredAt;",
    "        LocalDateTime readAt;",
    "        ",
    "        Notification(String userId, String articleId, String title, int priority) {",
    "            this.notificationId = UUID.randomUUID().toString();",
    "            this.userId = userId;",
    "            this.articleId = articleId;",
    "            this.title = title;",
    "            this.priority = priority;",
    "            this.createdAt = LocalDateTime.now();",
    "        }",
    "    }",
    "    ",
    "    // Rate limiter using sliding window",
    "    static class RateLimiter {",
    "        private final Map<String, List<LocalDateTime>> userTimestamps = ",
    "            new ConcurrentHashMap<>();",
    "        private final int windowSeconds;",
    "        ",
    "        RateLimiter(int windowSeconds) {",
    "            this.windowSeconds = windowSeconds;",
    "        }",
    "        ",
    "        synchronized boolean canSend(String userId, int maxCount) {",
    "            LocalDateTime cutoff = LocalDateTime.now().minusSeconds(windowSeconds);",
    "            List<LocalDateTime> timestamps = userTimestamps",
    "                .getOrDefault(userId, new ArrayList<>())",
    "                .stream()",
    "                .filter(ts -> ts.isAfter(cutoff))",
    "                .collect(Collectors.toList());",
    "            userTimestamps.put(userId, timestamps);",
    "            return timestamps.size() < maxCount;",
    "        }",
    "        ",
    "        synchronized void recordSend(String userId) {",
    "            userTimestamps.computeIfAbsent(userId, k -> new ArrayList<>())",
    "                .add(LocalDateTime.now());",
    "        }",
    "    }",
    "    ",
    "    // Circuit breaker for external services",
    "    static class CircuitBreaker {",
    "        private int failures = 0;",
    "        private final int threshold;",
    "        private final int recoveryTime;",
    "        private LocalDateTime lastFailure;",
    "        private String state = \"CLOSED\";",
    "        ",
    "        CircuitBreaker(int threshold, int recoveryTime) {",
    "            this.threshold = threshold;",
    "            this.recoveryTime = recoveryTime;",
    "        }",
    "        ",
    "        synchronized boolean canExecute() {",
    "            if (state.equals(\"CLOSED\")) return true;",
    "            if (state.equals(\"OPEN\") && lastFailure != null) {",
    "                long elapsed = Duration.between(lastFailure, LocalDateTime.now())",
    "                    .getSeconds();",
    "                if (elapsed >= recoveryTime) {",
    "                    state = \"HALF_OPEN\";",
    "                    return true;",
    "                }",
    "            }",
    "            return state.equals(\"HALF_OPEN\");",
    "        }",
    "        ",
    "        synchronized void recordSuccess() {",
    "            failures = 0;",
    "            state = \"CLOSED\";",
    "        }",
    "        ",
    "        synchronized void recordFailure() {",
    "            failures++;",
    "            lastFailure = LocalDateTime.now();",
    "            if (failures >= threshold) state = \"OPEN\";",
    "        }",
    "    }",
    "    ",
    "    // Priority message queue",
    "    static class MessageQueue {",
    "        private final PriorityQueue<Map.Entry<Integer, Map<String, Object>>> queue = ",
    "            new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());",
    "        ",
    "        synchronized void publish(Map<String, Object> message, int priority) {",
    "            queue.offer(new AbstractMap.SimpleEntry<>(priority, message));",
    "        }",
    "        ",
    "        synchronized Map<String, Object> consume() {",
    "            Map.Entry<Integer, Map<String, Object>> entry = queue.poll();",
    "            return entry != null ? entry.getValue() : null;",
    "        }",
    "    }",
    "    ",
    "    // Constants",
    "    private static final int BREAKING_NEWS_THRESHOLD = 8;",
    "    ",
    "    // Part 1 data structures",
    "    private final Map<String, Article> articles = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> userFollows = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> userInterests = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Inverted indexes for fast audience lookup",
    "    private final Map<String, Set<String>> categorySubscribers = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> publisherFollowers = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Notification system",
    "    private final Map<String, NotificationPrefs> notificationPrefs = ",
    "        new ConcurrentHashMap<>();",
    "    private final Map<String, List<Notification>> pendingNotifications = ",
    "        new ConcurrentHashMap<>();",
    "    private final Map<String, Notification> allNotifications = new ConcurrentHashMap<>();",
    "    ",
    "    // Part 2: Infrastructure",
    "    private final MessageQueue notificationQueue = new MessageQueue();",
    "    private final RateLimiter rateLimiter = new RateLimiter(86400);",
    "    private final CircuitBreaker circuitBreaker = new CircuitBreaker(5, 60);",
    "    ",
    "    // Part 1 Methods",
    "    public void followPublisher(String userId, String publisherId) {",
    "        userFollows.computeIfAbsent(userId, k -> ConcurrentHashMap.newKeySet())",
    "            .add(publisherId);",
    "        publisherFollowers.computeIfAbsent(publisherId, k -> ConcurrentHashMap.newKeySet())",
    "            .add(userId);",
    "    }",
    "    ",
    "    public void setUserInterests(String userId, List<String> categories) {",
    "        Set<String> oldInterests = userInterests.getOrDefault(userId, new HashSet<>());",
    "        for (String cat : oldInterests) {",
    "            Set<String> subs = categorySubscribers.get(cat);",
    "            if (subs != null) subs.remove(userId);",
    "        }",
    "        ",
    "        userInterests.put(userId, new HashSet<>(categories));",
    "        for (String cat : categories) {",
    "            categorySubscribers.computeIfAbsent(cat, k -> ConcurrentHashMap.newKeySet())",
    "                .add(userId);",
    "        }",
    "    }",
    "    ",
    "    // Part 2 Methods",
    "    public void setNotificationPreferences(String userId, NotificationPrefs prefs) {",
    "        notificationPrefs.put(userId, prefs);",
    "        for (String cat : prefs.categories) {",
    "            categorySubscribers.computeIfAbsent(cat, k -> ConcurrentHashMap.newKeySet())",
    "                .add(userId);",
    "        }",
    "    }",
    "    ",
    "    public void publishBreakingNews(String publisherId, Article article, int priority) {",
    "        article.publisherId = publisherId;",
    "        articles.put(article.articleId, article);",
    "        ",
    "        if (priority >= BREAKING_NEWS_THRESHOLD) {",
    "            Map<String, Object> message = new HashMap<>();",
    "            message.put(\"type\", \"breaking_news\");",
    "            message.put(\"articleId\", article.articleId);",
    "            message.put(\"publisherId\", publisherId);",
    "            message.put(\"categories\", article.categories);",
    "            message.put(\"priority\", priority);",
    "            message.put(\"title\", article.title);",
    "            ",
    "            notificationQueue.publish(message, priority);",
    "            processNotificationQueue();",
    "        }",
    "    }",
    "    ",
    "    private void processNotificationQueue() {",
    "        Map<String, Object> message;",
    "        while ((message = notificationQueue.consume()) != null) {",
    "            if (\"breaking_news\".equals(message.get(\"type\"))) {",
    "                processBreakingNews(message);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    @SuppressWarnings(\"unchecked\")",
    "    private void processBreakingNews(Map<String, Object> message) {",
    "        String articleId = (String) message.get(\"articleId\");",
    "        String publisherId = (String) message.get(\"publisherId\");",
    "        List<String> categories = (List<String>) message.get(\"categories\");",
    "        int priority = (int) message.get(\"priority\");",
    "        String title = (String) message.get(\"title\");",
    "        ",
    "        Set<String> audience = findAudience(publisherId, categories);",
    "        ",
    "        for (String userId : audience) {",
    "            if (shouldNotifyUser(userId, categories, priority)) {",
    "                Notification notification = createNotification(",
    "                    userId, articleId, title, priority);",
    "                deliverNotification(notification);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    private Set<String> findAudience(String publisherId, List<String> categories) {",
    "        Set<String> audience = new HashSet<>();",
    "        Set<String> followers = publisherFollowers.get(publisherId);",
    "        if (followers != null) audience.addAll(followers);",
    "        ",
    "        for (String category : categories) {",
    "            Set<String> subs = categorySubscribers.get(category);",
    "            if (subs != null) audience.addAll(subs);",
    "        }",
    "        return audience;",
    "    }",
    "    ",
    "    private boolean shouldNotifyUser(String userId, List<String> categories, ",
    "                                     int priority) {",
    "        NotificationPrefs prefs = notificationPrefs.get(userId);",
    "        if (prefs == null) return true;",
    "        if (!prefs.enabled) return false;",
    "        if (!rateLimiter.canSend(userId, prefs.maxDaily)) return false;",
    "        ",
    "        if (!prefs.categories.isEmpty()) {",
    "            boolean match = categories.stream()",
    "                .anyMatch(prefs.categories::contains);",
    "            if (!match) return false;",
    "        }",
    "        ",
    "        if (priority < 9) {",
    "            int hour = LocalDateTime.now().getHour();",
    "            if (hour >= prefs.quietHoursStart || hour < prefs.quietHoursEnd) {",
    "                return false;",
    "            }",
    "        }",
    "        return true;",
    "    }",
    "    ",
    "    private Notification createNotification(String userId, String articleId,",
    "                                            String title, int priority) {",
    "        Notification n = new Notification(userId, articleId, title, priority);",
    "        allNotifications.put(n.notificationId, n);",
    "        pendingNotifications.computeIfAbsent(userId, k -> new ArrayList<>()).add(n);",
    "        return n;",
    "    }",
    "    ",
    "    private boolean deliverNotification(Notification notification) {",
    "        if (!circuitBreaker.canExecute()) return false;",
    "        try {",
    "            // Simulate push delivery",
    "            notification.status = NotificationStatus.DELIVERED;",
    "            notification.deliveredAt = LocalDateTime.now();",
    "            rateLimiter.recordSend(notification.userId);",
    "            circuitBreaker.recordSuccess();",
    "            return true;",
    "        } catch (Exception e) {",
    "            notification.status = NotificationStatus.FAILED;",
    "            circuitBreaker.recordFailure();",
    "            return false;",
    "        }",
    "    }",
    "    ",
    "    public List<Notification> getPendingNotifications(String userId) {",
    "        List<Notification> all = pendingNotifications.getOrDefault(userId, ",
    "            new ArrayList<>());",
    "        return all.stream()",
    "            .filter(n -> n.status == NotificationStatus.PENDING || ",
    "                        n.status == NotificationStatus.DELIVERED)",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    public void markNotificationRead(String userId, String notificationId) {",
    "        Notification n = allNotifications.get(notificationId);",
    "        if (n != null && n.userId.equals(userId)) {",
    "            n.status = NotificationStatus.READ;",
    "            n.readAt = LocalDateTime.now();",
    "        }",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"NEWS AGGREGATOR - REAL-TIME NOTIFICATIONS DEMO\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        NewsAggregator aggregator = new NewsAggregator();",
    "        ",
    "        // Setup",
    "        System.out.println(\"\\n\ud83d\udcdd Setting up test data...\");",
    "        aggregator.followPublisher(\"user_1\", \"pub_nyt\");",
    "        aggregator.followPublisher(\"user_2\", \"pub_nyt\");",
    "        aggregator.setUserInterests(\"user_1\", Arrays.asList(\"Breaking\", \"Politics\"));",
    "        aggregator.setUserInterests(\"user_2\", Arrays.asList(\"Sports\"));",
    "        ",
    "        // Notification preferences",
    "        System.out.println(\"\\n\u2699\ufe0f Setting notification preferences...\");",
    "        aggregator.setNotificationPreferences(\"user_1\", ",
    "            new NotificationPrefs(5, Arrays.asList(\"Breaking\", \"Politics\"), true));",
    "        aggregator.setNotificationPreferences(\"user_2\",",
    "            new NotificationPrefs(10, Arrays.asList(\"Breaking\"), true));",
    "        ",
    "        // Publish breaking news",
    "        System.out.println(\"\\n\ud83d\udd14 Publishing BREAKING NEWS...\");",
    "        Article breaking = new Article(\"article_001\", \"BREAKING: Major Event!\",",
    "            \"Content...\", \"pub_nyt\", Arrays.asList(\"Breaking\", \"Politics\"));",
    "        aggregator.publishBreakingNews(\"pub_nyt\", breaking, 10);",
    "        ",
    "        // Check notifications",
    "        System.out.println(\"\\n\ud83d\udcec Checking notifications...\");",
    "        for (String userId : Arrays.asList(\"user_1\", \"user_2\")) {",
    "            List<Notification> notifications = aggregator.getPendingNotifications(userId);",
    "            System.out.println(\"  \" + userId + \": \" + notifications.size() + ",
    "                \" notifications\");",
    "            for (Notification n : notifications) {",
    "                System.out.println(\"    \ud83d\udcf0 \" + n.title + \" (\" + n.status + \")\");",
    "            }",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"DEMO COMPLETE\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports and module setup. We use dataclasses for clean data structures, defaultdict for automatic initialization, heapq for priority queue, and threading for locks."
    },
    {
      "lines": "13-18",
      "explanation": "NotificationStatus enum tracks the lifecycle of each notification: PENDING \u2192 DELIVERED \u2192 READ or FAILED."
    },
    {
      "lines": "21-29",
      "explanation": "Article dataclass stores news article data including categories for notification matching."
    },
    {
      "lines": "32-40",
      "explanation": "NotificationPrefs stores user preferences: max daily notifications, allowed categories, quiet hours, and enabled toggle."
    },
    {
      "lines": "43-55",
      "explanation": "Notification dataclass with full tracking: creation time, delivery time, read time, and status transitions."
    },
    {
      "lines": "58-82",
      "explanation": "RateLimiter implements sliding window algorithm. Maintains list of timestamps per user, removes expired ones, and checks if under limit."
    },
    {
      "lines": "85-120",
      "explanation": "CircuitBreaker protects against cascade failures. Three states: CLOSED (normal), OPEN (rejecting), HALF_OPEN (testing). Transitions based on failure count and recovery time."
    },
    {
      "lines": "123-145",
      "explanation": "MessageQueue simulates Kafka with priority ordering. Uses min-heap with negated priorities for max-heap behavior."
    },
    {
      "lines": "148-158",
      "explanation": "PushGateway wraps circuit breaker and simulates FCM/APNS delivery. In production, this calls actual push APIs."
    },
    {
      "lines": "161-200",
      "explanation": "NewsAggregator class with constants and data structure initialization. Note the inverted indexes: category_subscribers and publisher_followers for O(1) lookup."
    },
    {
      "lines": "210-230",
      "explanation": "follow_publisher and set_user_interests maintain both forward and inverted indexes. When a user follows a publisher, we update both user_follows[user] and publisher_followers[publisher]."
    },
    {
      "lines": "240-270",
      "explanation": "publish_breaking_news is the entry point. Stores article, checks priority threshold, creates message, enqueues to priority queue, then triggers processing."
    },
    {
      "lines": "280-310",
      "explanation": "_find_audience performs O(1) lookups in inverted indexes. Combines publisher followers with category subscribers using set union."
    },
    {
      "lines": "315-350",
      "explanation": "_should_notify_user implements the filter chain: enabled check, rate limit, category match, and quiet hours. Priority >= 9 bypasses quiet hours for emergency alerts."
    },
    {
      "lines": "355-390",
      "explanation": "Notification creation and delivery. Creates Notification object, stores in multiple indexes, attempts push via gateway with circuit breaker protection."
    },
    {
      "lines": "400-430",
      "explanation": "Query methods: get_pending_notifications filters by status, mark_notification_read updates status with timestamp."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "publishBreakingNews": {
          "complexity": "O(1)",
          "explanation": "Constant time to store article and enqueue message. Actual notification processing is async."
        },
        "processBreakingNews": {
          "complexity": "O(A)",
          "explanation": "Where A = audience size. O(1) for index lookups, O(1) per user for filtering."
        },
        "findAudience": {
          "complexity": "O(C)",
          "explanation": "O(1) per category lookup, O(C) total where C = number of categories. Set union is O(n) where n = audience size."
        },
        "shouldNotifyUser": {
          "complexity": "O(C)",
          "explanation": "O(log N) for rate limiter check, O(C) for category matching where C = user's categories."
        },
        "setNotificationPreferences": {
          "complexity": "O(C)",
          "explanation": "O(C) to update category index where C = categories in preferences."
        },
        "getPendingNotifications": {
          "complexity": "O(N)",
          "explanation": "O(N) where N = total notifications for user, filtering by status."
        },
        "markNotificationRead": {
          "complexity": "O(1)",
          "explanation": "Direct hash lookup and update."
        }
      },
      "overall_change": "The key improvement is audience lookup changing from O(U) scan to O(1) index lookup. For breaking news reaching 1% of 10M users, we process 100K users instead of scanning 10M."
    },
    "space": {
      "additional_space": "O(U + C + N)",
      "explanation": "U = users (stored in multiple indexes), C = categories \u00d7 average users per category, N = total notifications. The inverted indexes duplicate user IDs but enable O(1) lookups. Trade-off: ~2x user storage for 1000x faster audience lookup."
    }
  },
  "dry_run": {
    "example_input": "User follows NYT, sets prefs for Breaking news, NYT publishes breaking article",
    "steps": [
      {
        "step": 1,
        "action": "followPublisher('user_1', 'pub_nyt')",
        "state": "user_follows['user_1'] = {'pub_nyt'}, publisher_followers['pub_nyt'] = {'user_1'}",
        "explanation": "Both forward and inverted indexes updated"
      },
      {
        "step": 2,
        "action": "setNotificationPreferences('user_1', {max_daily:5, categories:['Breaking']})",
        "state": "notification_prefs['user_1'] = prefs, category_subscribers['Breaking'].add('user_1')",
        "explanation": "Preferences stored, user added to Breaking category index"
      },
      {
        "step": 3,
        "action": "publishBreakingNews('pub_nyt', article, 10)",
        "state": "article stored, message queued with priority 10",
        "explanation": "Priority >= 8, so notification pipeline triggered"
      },
      {
        "step": 4,
        "action": "Queue worker: findAudience('pub_nyt', ['Breaking'])",
        "state": "audience = publisher_followers['pub_nyt'] \u222a category_subscribers['Breaking'] = {'user_1'}",
        "explanation": "O(1) lookups in inverted indexes, set union"
      },
      {
        "step": 5,
        "action": "shouldNotifyUser('user_1', ['Breaking'], 10)",
        "state": "prefs.enabled=True, rate_limit=0/5, category_match=True, priority=10 bypasses quiet hours",
        "explanation": "All filters pass"
      },
      {
        "step": 6,
        "action": "createNotification('user_1', 'article_id', 'BREAKING:...', 10)",
        "state": "Notification created, added to pending_notifications['user_1'], allNotifications",
        "explanation": "Notification stored in multiple indexes for different access patterns"
      },
      {
        "step": 7,
        "action": "deliverNotification(notification)",
        "state": "status=DELIVERED, deliveredAt=now(), rate_limiter['user_1'].append(now())",
        "explanation": "Push via gateway, status updated, rate limiter records send"
      },
      {
        "step": 8,
        "action": "getPendingNotifications('user_1')",
        "state": "Returns [Notification(title='BREAKING:...', status=DELIVERED)]",
        "explanation": "Filters for PENDING or DELIVERED status"
      }
    ],
    "final_output": "[Notification{articleId='article_id', title='BREAKING: Major Event!', priority=10, status=DELIVERED}]"
  },
  "edge_cases": [
    {
      "case": "User with notifications disabled",
      "handling": "shouldNotifyUser returns false early when prefs.enabled=False",
      "gotcha": "Must check enabled flag first before expensive operations"
    },
    {
      "case": "User at rate limit",
      "handling": "Rate limiter's sliding window filters out users who have reached max_daily",
      "gotcha": "Sliding window must clean expired timestamps before counting"
    },
    {
      "case": "Breaking news during quiet hours",
      "handling": "Quiet hours check skipped if priority >= 9 (emergency override)",
      "gotcha": "Must implement priority override for critical alerts"
    },
    {
      "case": "Push gateway down",
      "handling": "Circuit breaker opens after 5 failures, fails fast for 60 seconds, then tries again",
      "gotcha": "Notifications marked FAILED should be retried later"
    },
    {
      "case": "User follows publisher AND has category interest",
      "handling": "Set union ensures user only appears once in audience, receives one notification",
      "gotcha": "Don't send duplicate notifications"
    },
    {
      "case": "Empty categories in preferences",
      "handling": "Empty list means 'all categories allowed' - don't filter by category",
      "gotcha": "Empty list \u2260 no notifications, it means no category filter"
    },
    {
      "case": "Very high priority (10) article",
      "handling": "Bypasses quiet hours, processed first in queue",
      "gotcha": "Priority 10 should be reserved for true emergencies"
    }
  ],
  "test_cases": [
    {
      "name": "Basic notification flow",
      "input": "follow_publisher('u1', 'p1'); set_prefs('u1', {enabled:True}); publish_breaking('p1', article, 10)",
      "expected": "get_pending('u1') returns 1 notification",
      "explanation": "User follows publisher and receives breaking news notification"
    },
    {
      "name": "Notification disabled",
      "input": "follow_publisher('u1', 'p1'); set_prefs('u1', {enabled:False}); publish_breaking('p1', article, 10)",
      "expected": "get_pending('u1') returns empty list",
      "explanation": "Disabled notifications filter out user"
    },
    {
      "name": "Rate limit enforcement",
      "input": "set_prefs('u1', {max_daily:2}); publish 5 breaking articles",
      "expected": "get_pending('u1') returns 2 notifications",
      "explanation": "Rate limiter caps at max_daily"
    },
    {
      "name": "Category filtering",
      "input": "set_prefs('u1', {categories:['Sports']}); publish_breaking(article, categories=['Politics'])",
      "expected": "get_pending('u1') returns empty list",
      "explanation": "Article categories don't match user preferences"
    },
    {
      "name": "Mark as read",
      "input": "create notification; mark_notification_read('u1', notif_id)",
      "expected": "notification.status = READ, get_pending('u1') excludes it",
      "explanation": "Read notifications filtered from pending list"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Scanning all users to find audience",
      "why_wrong": "O(U) scan for millions of users takes too long, violates 30-second SLA",
      "correct_approach": "Pre-build inverted indexes for O(1) audience lookup",
      "code_example_wrong": "# Wrong: O(U) scan\nfor user in all_users:\n    if publisher_id in user.follows:\n        notify(user)",
      "code_example_correct": "# Correct: O(1) lookup\naudience = publisher_followers.get(publisher_id, set())\nfor user_id in audience:\n    notify(user_id)"
    },
    {
      "mistake": "Not updating inverted indexes on follow/unfollow",
      "why_wrong": "Stale indexes lead to missed notifications or spam to unfollowed users",
      "correct_approach": "Update both forward and inverted indexes atomically",
      "code_example_wrong": "# Wrong: Only forward index\ndef follow(user_id, pub_id):\n    user_follows[user_id].add(pub_id)",
      "code_example_correct": "# Correct: Both indexes\ndef follow(user_id, pub_id):\n    user_follows[user_id].add(pub_id)\n    publisher_followers[pub_id].add(user_id)"
    },
    {
      "mistake": "Blocking on push notification delivery",
      "why_wrong": "If FCM/APNS is slow, entire pipeline backs up",
      "correct_approach": "Async delivery with message queue and circuit breaker",
      "code_example_wrong": "# Wrong: Sync blocking\nfor user in audience:\n    push_gateway.send(notification)  # Blocks!",
      "code_example_correct": "# Correct: Async with circuit breaker\nif circuit_breaker.can_execute():\n    try:\n        push_gateway.send(notification)\n        circuit_breaker.record_success()\n    except:\n        circuit_breaker.record_failure()"
    },
    {
      "mistake": "Fixed window rate limiting",
      "why_wrong": "User could get 10 notifications at 11:59 PM and 10 more at 12:01 AM",
      "correct_approach": "Sliding window rate limiting",
      "code_example_wrong": "# Wrong: Fixed daily window\nif daily_count[user_id] < max_daily:\n    send_notification()\n    daily_count[user_id] += 1\n# Resets at midnight",
      "code_example_correct": "# Correct: Sliding window\ntimestamps = [ts for ts in user_timestamps[user_id] if ts > now - 24h]\nif len(timestamps) < max_daily:\n    send_notification()\n    timestamps.append(now)"
    }
  ],
  "interview_tips": {
    "how_to_present": "1. Start by clarifying the 30-second SLA - this is THE key constraint\n2. Identify the bottleneck: finding who to notify\n3. Present the inverted index insight as the core solution\n4. Layer on rate limiting and circuit breaker for production readiness\n5. Draw the notification flow diagram\n6. Discuss trade-offs: space for indexes vs time for lookups",
    "what_to_mention": [
      "Inverted indexes trade O(U+C) space for O(1) lookup time",
      "Message queue enables async processing without blocking publishers",
      "Circuit breaker prevents cascade failures when push gateway is down",
      "Sliding window > fixed window for fair rate limiting",
      "Priority in queue ensures breaking news processed before regular",
      "In production: Kafka partitioning by user_id for parallel processing"
    ],
    "time_allocation": "2 min: Understand requirements and SLA; 3 min: Design inverted index approach; 5 min: Implement core notification flow; 3 min: Add rate limiting and circuit breaker; 2 min: Discuss scaling and production concerns",
    "if_stuck": [
      "Think about how Twitter/Facebook solve 'fan-out' for celebrity posts",
      "What data structure gives O(1) lookup? Hash maps with pre-computed keys",
      "If scanning all users is too slow, how can we know WHO to notify without scanning?",
      "Consider: when user follows a publisher, what can we precompute for later?",
      "The 30-second SLA means we can't do O(users) work - need O(audience) instead"
    ]
  },
  "connection_to_next_part": "Part 2 establishes the real-time notification infrastructure. Part 3 might extend this to:\n1. **Notification Analytics** - Track open rates, CTR, engagement by time/category\n2. **A/B Testing** - Test different notification copy/timing for engagement\n3. **ML-based Delivery Optimization** - Predict best time to send per user\n4. **Notification Grouping** - Batch related stories into digest notifications\n\nThe inverted indexes and message queue from Part 2 provide the foundation for these advanced features.",
  "generated_at": "2026-01-14T15:33:35.115137",
  "_meta": {
    "problem_id": "news_feed_aggregator",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}