{
  "problem_title": "Parking Lot System - Part 2: Reserved Parking & VIP Support",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "10-15 minutes",
  "builds_on": "Part 1 - Core parking with MinHeaps",
  "part_description": "## Part 2: Reserved Parking & VIP Support ⭐\n\nExtend your parking lot system to support spot reservations and VIP customer priority.\n\n### New Requirements\n\n1. **`reserveSpot(floor, spotNumber, startTime, endTime)`**\n   - Reserve a specific spot for a time window\n   - Reserved spots cannot be assigned to walk-in customers during that window\n   - Must check for overlapping reservations\n\n2. **`parkReservedVehicle(reservationId, vehicle)`**\n   - Park using an existing reservation\n   - Vehicle must arrive within reservation time window\n\n3. **VIP Priority**\n   - When lot is >90% full, reject regular walk-ins but still allow VIPs\n   - VIPs get first choice of available spots",
  "visual_explanation": "```\n┌─────────────────────────────────────────────────────────────────────┐\n│                    RESERVED PARKING FLOW                             │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                      │\n│   TIMELINE for Spot (Floor 1, Spot 5):                              │\n│                                                                      │\n│   8:00 AM    10:00 AM    12:00 PM    2:00 PM     4:00 PM            │\n│   |          |          |          |          |                     │\n│   [===RESERVATION A===]                                             │\n│   8:00       10:00                                                  │\n│                                                                      │\n│                         [===RESERVATION B===]                       │\n│                         12:00       2:00                            │\n│                                                                      │\n│              [==CONFLICT!==]  ← Overlaps with A                     │\n│              9:00    11:00                                          │\n│                                                                      │\n│   DATA STRUCTURE:                                                   │\n│   reservations = {                                                  │\n│       (1, 5): [  # Floor 1, Spot 5                                  │\n│           TimeRange(8:00, 10:00),  # Reservation A                  │\n│           TimeRange(12:00, 14:00), # Reservation B                  │\n│       ]                                                             │\n│   }                                                                 │\n│                                                                      │\n│   VIP THRESHOLD:                                                    │\n│   ┌─────────────────────────────────────────┐                       │\n│   │  Occupancy: 92% ─────────────── 100%    │                       │\n│   │  ████████████████████░░░░░░░░░░         │                       │\n│   │           ↑                             │                       │\n│   │      VIP_THRESHOLD (90%)                │                       │\n│   │                                         │                       │\n│   │  Regular: ❌ REJECTED                   │                       │\n│   │  VIP:     ✅ ALLOWED                    │                       │\n│   └─────────────────────────────────────────┘                       │\n│                                                                      │\n└─────────────────────────────────────────────────────────────────────┘\n```",
  "approach": {
    "key_insight": "## Key Design Changes\n\n### 1. Reservation Storage\nUse a **sorted list of time ranges per spot** for O(log n) overlap checking:\n\n```python\nreservations: Dict[Tuple[floor, spot], List[TimeRange]] = {\n    (1, 5): [\n        TimeRange(start=8:00, end=10:00, reservation_id='R1'),\n        TimeRange(start=12:00, end=14:00, reservation_id='R2'),\n    ],\n    (2, 3): [...]\n}\n```\n\n### 2. Availability Check Enhancement\nWhen parking walk-in:\n1. Pop spot from heap\n2. Check if spot is reserved for current time\n3. If reserved, try next spot\n4. If not reserved, assign\n\n### 3. VIP Threshold\n```python\nVIP_THRESHOLD = 0.9  # 90%\n\ndef can_park(vehicle, is_vip):\n    occupancy = occupied / total_spots\n    if occupancy >= VIP_THRESHOLD and not is_vip:\n        return False  # Reject regular customer\n    return True  # Allow VIP or normal times\n```",
    "data_structures": [
      {
        "structure": "Dict[Tuple[floor, spot], SortedList[TimeRange]]",
        "purpose": "Store reservations per spot. Sorted by start time for efficient overlap checking."
      },
      {
        "structure": "Dict[reservationId, Reservation]",
        "purpose": "O(1) lookup of reservation details when parking reserved vehicle."
      },
      {
        "structure": "is_vip flag on Vehicle or separate parameter",
        "purpose": "Distinguish VIP customers for threshold logic."
      }
    ],
    "time_complexity": {
      "reserveSpot": "O(r log r) where r = reservations for that spot. Binary search for overlap, insert to maintain order.",
      "parkReservedVehicle": "O(log n) - same as regular park, plus O(1) reservation lookup",
      "parkVehicle_with_VIP": "O(log n) - added O(1) occupancy check"
    }
  },
  "solution_additions_python": [
    "# ============================================================",
    "# PART 2: RESERVED PARKING & VIP SUPPORT",
    "# ============================================================",
    "",
    "from dataclasses import dataclass",
    "from typing import List, Optional, Tuple",
    "from datetime import datetime",
    "from bisect import bisect_left, insort",
    "import uuid",
    "",
    "",
    "@dataclass",
    "class TimeRange:",
    "    \"\"\"Represents a time window for a reservation.\"\"\"",
    "    start_time: datetime",
    "    end_time: datetime",
    "    reservation_id: str",
    "    ",
    "    def overlaps(self, other: 'TimeRange') -> bool:",
    "        \"\"\"Check if two time ranges overlap.\"\"\"",
    "        return self.start_time < other.end_time and other.start_time < self.end_time",
    "    ",
    "    def contains_time(self, time: datetime) -> bool:",
    "        \"\"\"Check if a point in time falls within this range.\"\"\"",
    "        return self.start_time <= time < self.end_time",
    "    ",
    "    def __lt__(self, other: 'TimeRange') -> bool:",
    "        \"\"\"For sorting by start time.\"\"\"",
    "        return self.start_time < other.start_time",
    "",
    "",
    "@dataclass",
    "class Reservation:",
    "    \"\"\"A parking spot reservation.\"\"\"",
    "    reservation_id: str",
    "    floor: int",
    "    spot_number: int",
    "    spot_type: SpotType",
    "    start_time: datetime",
    "    end_time: datetime",
    "    license_plate: str",
    "    is_used: bool = False",
    "",
    "",
    "class ParkingLotWithReservations(ParkingLot):",
    "    \"\"\"",
    "    Extended Parking Lot with reservation and VIP support.",
    "    ",
    "    New Features:",
    "        - Spot reservations for specific time windows",
    "        - VIP priority when lot is nearly full",
    "    \"\"\"",
    "    ",
    "    VIP_THRESHOLD = 0.9  # 90% capacity threshold",
    "    ",
    "    def __init__(self, spots_config: List[List[SpotType]]):",
    "        super().__init__(spots_config)",
    "        ",
    "        # Reservations: (floor, spot) -> sorted list of TimeRanges",
    "        self._reservations_by_spot: Dict[Tuple[int, int], List[TimeRange]] = {}",
    "        ",
    "        # Reservation lookup: reservationId -> Reservation",
    "        self._reservations: Dict[str, Reservation] = {}",
    "    ",
    "    def reserve_spot(",
    "        self,",
    "        floor: int,",
    "        spot_number: int,",
    "        start_time: datetime,",
    "        end_time: datetime,",
    "        license_plate: str",
    "    ) -> Optional[Reservation]:",
    "        \"\"\"",
    "        Reserve a specific spot for a time window.",
    "        ",
    "        Args:",
    "            floor: Floor number",
    "            spot_number: Spot number",
    "            start_time: Reservation start time",
    "            end_time: Reservation end time",
    "            license_plate: Vehicle license plate",
    "        ",
    "        Returns:",
    "            Reservation object if successful, None if conflict",
    "        ",
    "        Time Complexity: O(r log r) where r = existing reservations for spot",
    "        \"\"\"",
    "        spot_key = (floor, spot_number)",
    "        ",
    "        # Validate spot exists",
    "        if spot_key not in self._spot_types:",
    "            raise ValueError(f\"Spot ({floor}, {spot_number}) does not exist\")",
    "        ",
    "        # Validate time range",
    "        if end_time <= start_time:",
    "            raise ValueError(\"End time must be after start time\")",
    "        ",
    "        # Create time range for new reservation",
    "        reservation_id = f\"R-{uuid.uuid4().hex[:8].upper()}\"",
    "        new_range = TimeRange(start_time, end_time, reservation_id)",
    "        ",
    "        # Get existing reservations for this spot",
    "        spot_reservations = self._reservations_by_spot.get(spot_key, [])",
    "        ",
    "        # Check for overlaps with existing reservations",
    "        for existing in spot_reservations:",
    "            if new_range.overlaps(existing):",
    "                return None  # Conflict found",
    "        ",
    "        # No conflict - add the reservation",
    "        if spot_key not in self._reservations_by_spot:",
    "            self._reservations_by_spot[spot_key] = []",
    "        ",
    "        # Insert in sorted order by start time",
    "        insort(self._reservations_by_spot[spot_key], new_range)",
    "        ",
    "        # Create and store reservation object",
    "        reservation = Reservation(",
    "            reservation_id=reservation_id,",
    "            floor=floor,",
    "            spot_number=spot_number,",
    "            spot_type=self._spot_types[spot_key],",
    "            start_time=start_time,",
    "            end_time=end_time,",
    "            license_plate=license_plate",
    "        )",
    "        self._reservations[reservation_id] = reservation",
    "        ",
    "        return reservation",
    "    ",
    "    def park_reserved_vehicle(",
    "        self,",
    "        reservation_id: str,",
    "        vehicle: Vehicle",
    "    ) -> Optional[Ticket]:",
    "        \"\"\"",
    "        Park a vehicle using an existing reservation.",
    "        ",
    "        Args:",
    "            reservation_id: ID of the reservation",
    "            vehicle: Vehicle to park",
    "        ",
    "        Returns:",
    "            Ticket if successful, None if reservation invalid/expired",
    "        ",
    "        Time Complexity: O(log n) for heap update",
    "        \"\"\"",
    "        # Look up reservation",
    "        reservation = self._reservations.get(reservation_id)",
    "        if not reservation:",
    "            raise ValueError(f\"Reservation {reservation_id} not found\")",
    "        ",
    "        # Check if already used",
    "        if reservation.is_used:",
    "            raise ValueError(\"Reservation already used\")",
    "        ",
    "        # Check if within reservation window",
    "        now = datetime.now()",
    "        if not (reservation.start_time <= now <= reservation.end_time):",
    "            raise ValueError(",
    "                f\"Current time {now} is outside reservation window \"",
    "                f\"({reservation.start_time} - {reservation.end_time})\"",
    "            )",
    "        ",
    "        # Check license plate matches (optional enforcement)",
    "        if vehicle.license_plate != reservation.license_plate:",
    "            raise ValueError(",
    "                f\"Vehicle plate {vehicle.license_plate} doesn't match \"",
    "                f\"reservation plate {reservation.license_plate}\"",
    "            )",
    "        ",
    "        # Remove spot from available heap (it should be there)",
    "        spot_key = (reservation.floor, reservation.spot_number)",
    "        spot_type = self._spot_types[spot_key]",
    "        ",
    "        # Find and remove spot from heap",
    "        # Note: heapq doesn't support efficient removal, so we use a workaround",
    "        # In production, use a more sophisticated data structure",
    "        heap = self._available[spot_type]",
    "        try:",
    "            heap.remove(spot_key)",
    "            heapq.heapify(heap)  # Restore heap property",
    "        except ValueError:",
    "            # Spot not in heap - might already be occupied",
    "            raise ValueError(\"Reserved spot is currently occupied\")",
    "        ",
    "        # Create ticket",
    "        ticket_id = self._generate_ticket_id()",
    "        ticket = Ticket(",
    "            ticket_id=ticket_id,",
    "            floor=reservation.floor,",
    "            spot_number=reservation.spot_number,",
    "            entry_time=now,",
    "            vehicle_type=vehicle.vehicle_type,",
    "            license_plate=vehicle.license_plate",
    "        )",
    "        ",
    "        # Store session",
    "        spot = ParkingSpot(reservation.floor, reservation.spot_number, spot_type)",
    "        session = ParkingSession(vehicle, spot, now)",
    "        self._active_tickets[ticket_id] = session",
    "        self._occupied_per_floor[reservation.floor] += 1",
    "        ",
    "        # Mark reservation as used",
    "        reservation.is_used = True",
    "        ",
    "        return ticket",
    "    ",
    "    def park_vehicle_vip(",
    "        self,",
    "        vehicle: Vehicle,",
    "        is_vip: bool = False",
    "    ) -> Optional[Ticket]:",
    "        \"\"\"",
    "        Park a vehicle with VIP priority consideration.",
    "        ",
    "        When lot is >90% full:",
    "        - Regular customers are rejected",
    "        - VIP customers can still park",
    "        ",
    "        Time Complexity: O(log n)",
    "        \"\"\"",
    "        # Check VIP threshold",
    "        status = self.get_capacity_status()",
    "        occupancy_ratio = status['occupied'] / status['total_spots']",
    "        ",
    "        if occupancy_ratio >= self.VIP_THRESHOLD and not is_vip:",
    "            return None  # Reject non-VIP when lot is nearly full",
    "        ",
    "        # Check for reserved spots - need to filter available spots",
    "        return self._park_vehicle_avoiding_reservations(vehicle)",
    "    ",
    "    def _park_vehicle_avoiding_reservations(",
    "        self,",
    "        vehicle: Vehicle",
    "    ) -> Optional[Ticket]:",
    "        \"\"\"",
    "        Park vehicle, avoiding spots that are currently reserved.",
    "        ",
    "        This is more complex than basic parking because we need",
    "        to check reservations before assigning each spot.",
    "        \"\"\"",
    "        compatible_types = self.VEHICLE_SPOT_COMPATIBILITY[vehicle.vehicle_type]",
    "        now = datetime.now()",
    "        ",
    "        for spot_type in compatible_types:",
    "            heap = self._available[spot_type]",
    "            ",
    "            # Try spots until we find one not reserved",
    "            temp_removed = []  # Track spots we pop but can't use",
    "            found_spot = None",
    "            ",
    "            while heap:",
    "                floor, spot_num = heapq.heappop(heap)",
    "                spot_key = (floor, spot_num)",
    "                ",
    "                # Check if spot is reserved right now",
    "                if self._is_spot_reserved_now(spot_key, now):",
    "                    temp_removed.append((floor, spot_num))",
    "                    continue",
    "                ",
    "                # Found usable spot!",
    "                found_spot = (floor, spot_num)",
    "                break",
    "            ",
    "            # Put back spots we couldn't use",
    "            for item in temp_removed:",
    "                heapq.heappush(heap, item)",
    "            ",
    "            if found_spot:",
    "                floor, spot_num = found_spot",
    "                # Rest is same as regular parking",
    "                ticket_id = self._generate_ticket_id()",
    "                entry_time = datetime.now()",
    "                ",
    "                ticket = Ticket(",
    "                    ticket_id=ticket_id,",
    "                    floor=floor,",
    "                    spot_number=spot_num,",
    "                    entry_time=entry_time,",
    "                    vehicle_type=vehicle.vehicle_type,",
    "                    license_plate=vehicle.license_plate",
    "                )",
    "                ",
    "                spot = ParkingSpot(floor, spot_num, spot_type)",
    "                session = ParkingSession(vehicle, spot, entry_time)",
    "                self._active_tickets[ticket_id] = session",
    "                self._occupied_per_floor[floor] += 1",
    "                ",
    "                return ticket",
    "        ",
    "        return None",
    "    ",
    "    def _is_spot_reserved_now(",
    "        self,",
    "        spot_key: Tuple[int, int],",
    "        current_time: datetime",
    "    ) -> bool:",
    "        \"\"\"Check if a spot is reserved at the given time.\"\"\"",
    "        reservations = self._reservations_by_spot.get(spot_key, [])",
    "        for time_range in reservations:",
    "            if time_range.contains_time(current_time):",
    "                return True",
    "        return False",
    "    ",
    "    def cancel_reservation(self, reservation_id: str) -> bool:",
    "        \"\"\"Cancel an unused reservation.\"\"\"",
    "        reservation = self._reservations.get(reservation_id)",
    "        if not reservation:",
    "            return False",
    "        ",
    "        if reservation.is_used:",
    "            return False  # Can't cancel used reservation",
    "        ",
    "        # Remove from spot's reservation list",
    "        spot_key = (reservation.floor, reservation.spot_number)",
    "        reservations = self._reservations_by_spot.get(spot_key, [])",
    "        self._reservations_by_spot[spot_key] = [",
    "            r for r in reservations if r.reservation_id != reservation_id",
    "        ]",
    "        ",
    "        # Remove from lookup",
    "        del self._reservations[reservation_id]",
    "        ",
    "        return True",
    "    ",
    "    def get_spot_availability(",
    "        self,",
    "        floor: int,",
    "        spot_number: int,",
    "        start_time: datetime,",
    "        end_time: datetime",
    "    ) -> bool:",
    "        \"\"\"Check if a spot is available for a given time window.\"\"\"",
    "        spot_key = (floor, spot_number)",
    "        ",
    "        if spot_key not in self._spot_types:",
    "            return False",
    "        ",
    "        # Check for reservation conflicts",
    "        query_range = TimeRange(start_time, end_time, 'query')",
    "        reservations = self._reservations_by_spot.get(spot_key, [])",
    "        ",
    "        for existing in reservations:",
    "            if query_range.overlaps(existing):",
    "                return False",
    "        ",
    "        return True",
    "",
    "",
    "# ============================================================",
    "# EXAMPLE USAGE",
    "# ============================================================",
    "",
    "def run_part2_example():",
    "    \"\"\"Demonstrate Part 2 features.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"PART 2: RESERVED PARKING & VIP SUPPORT\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Create lot",
    "    spots_config = [",
    "        [SpotType.SMALL, SpotType.COMPACT, SpotType.COMPACT, SpotType.LARGE, SpotType.LARGE],",
    "    ]",
    "    lot = ParkingLotWithReservations(spots_config)",
    "    ",
    "    # Make a reservation for tomorrow",
    "    from datetime import timedelta",
    "    now = datetime.now()",
    "    reservation = lot.reserve_spot(",
    "        floor=1,",
    "        spot_number=3,  # Compact spot",
    "        start_time=now + timedelta(hours=1),",
    "        end_time=now + timedelta(hours=3),",
    "        license_plate='VIP-001'",
    "    )",
    "    print(f\"Created reservation: {reservation.reservation_id}\")",
    "    print(f\"  Spot: Floor {reservation.floor}, Spot {reservation.spot_number}\")",
    "    print(f\"  Window: {reservation.start_time.strftime('%H:%M')} - {reservation.end_time.strftime('%H:%M')}\")",
    "    ",
    "    # Try to make overlapping reservation",
    "    conflict = lot.reserve_spot(",
    "        floor=1,",
    "        spot_number=3,",
    "        start_time=now + timedelta(hours=2),",
    "        end_time=now + timedelta(hours=4),",
    "        license_plate='OTHER'",
    "    )",
    "    print(f\"\\nOverlapping reservation: {'REJECTED' if conflict is None else 'CREATED'}\")",
    "    ",
    "    # VIP parking when lot is nearly full",
    "    print(\"\\n--- VIP Threshold Test ---\")",
    "    # Fill lot to 90%",
    "    for i in range(4):  # 4 of 5 spots = 80%",
    "        car = Vehicle(VehicleType.CAR, f'CAR-{i}')",
    "        lot.park_vehicle(car)",
    "    ",
    "    status = lot.get_capacity_status()",
    "    print(f\"Occupancy: {status['occupancy_percent']}%\")",
    "    ",
    "    # Regular customer at high occupancy",
    "    regular_car = Vehicle(VehicleType.CAR, 'REGULAR')",
    "    regular_ticket = lot.park_vehicle_vip(regular_car, is_vip=False)",
    "    print(f\"Regular customer: {'PARKED' if regular_ticket else 'REJECTED'}\")",
    "    ",
    "    # VIP customer at high occupancy",
    "    vip_car = Vehicle(VehicleType.CAR, 'VIP')",
    "    vip_ticket = lot.park_vehicle_vip(vip_car, is_vip=True)",
    "    print(f\"VIP customer: {'PARKED' if vip_ticket else 'REJECTED'}\")",
    "    ",
    "    print(\"\\n✓ PART 2 COMPLETE\")"
  ],
  "common_mistakes": [
    {
      "mistake": "Not checking for reservation overlaps correctly",
      "why_wrong": "Two reservations overlap if R1.start < R2.end AND R2.start < R1.end. Missing either condition causes bugs.",
      "correct_approach": "Use proper interval overlap check: `r1.start < r2.end and r2.start < r1.end`"
    },
    {
      "mistake": "Not removing reserved spots from available pool for walk-ins",
      "why_wrong": "Walk-in customers could get assigned a spot that's reserved for someone else arriving soon.",
      "correct_approach": "When parking walk-in, check if each candidate spot is reserved for current time."
    },
    {
      "mistake": "VIP threshold checked wrong",
      "why_wrong": "Checking `>= 90%` means VIPs also rejected at exactly 90%. Should reject regular only.",
      "correct_approach": "`if occupancy >= THRESHOLD and not is_vip: return None`"
    },
    {
      "mistake": "Not handling reservation cancellation properly",
      "why_wrong": "Cancelling reservation should make spot available again for walk-ins.",
      "correct_approach": "Remove reservation from both the spot's list and the lookup dict."
    }
  ],
  "interview_discussion_points": [
    "**How would you handle concurrent reservations?** - Use optimistic locking or transactions.",
    "**What if VIP arrives without reservation but lot is full?** - Could implement 'VIP hold-back' spots.",
    "**How to prevent reservation abuse?** - Limit reservations per license plate, require deposit.",
    "**Should reservations be modifiable?** - Could allow changing time window if no conflict.",
    "**How to handle no-shows?** - Auto-cancel after grace period, charge cancellation fee."
  ],
  "generated_at": "2026-01-15T10:45:00.000000",
  "_meta": {
    "problem_id": "parking_lot_system",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}
