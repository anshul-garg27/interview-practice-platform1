{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 2: Authentication and Authorization",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 established core CRUD operations and concurrency safety. Part 2 adds a security layer: users must now authenticate before accessing resources, and their role determines what operations they can perform. This transforms an open API into a secure, production-ready system.",
    "new_requirements": [
      "User authentication via login endpoint returning JWT tokens",
      "Role-based access control (ADMIN, USER, GUEST)",
      "Token validation on every authenticated request",
      "Users can only view/cancel their own bookings (unless admin)",
      "Rate limiting per user to prevent brute-force attacks",
      "Password hashing for secure credential storage"
    ],
    "new_constraints": [
      "Tokens must expire after a configurable time period",
      "Failed login attempts must be tracked and rate-limited",
      "Authorization must be checked BEFORE processing any business logic",
      "All API calls except login and public event listing require valid tokens"
    ],
    "key_insight": "Separate authentication (verifying identity via token) from authorization (checking permissions via role). This two-phase check should be a reusable decorator/interceptor pattern applied consistently across all endpoints."
  },
  "visual_explanation": {
    "before_after": "```\n                     BEFORE (Part 1)                    AFTER (Part 2)\n                     \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Client    \u2502                    \u2502   Client    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                  \u2502\n                           \u25bc                                  \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  API Layer  \u2502                    \u2502 Auth Layer  \u2502\u25c4\u2500\u2500 NEW!\n                    \u2502  (Open)     \u2502                    \u2502 Token Check \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                  \u2502\n                           \u2502                                  \u25bc\n                           \u2502                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502                           \u2502 Role Check  \u2502\u25c4\u2500\u2500 NEW!\n                           \u2502                           \u2502 (RBAC)      \u2502\n                           \u2502                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                  \u2502\n                           \u25bc                                  \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Business   \u2502                    \u2502  Business   \u2502\n                    \u2502   Logic     \u2502                    \u2502   Logic     \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  Anyone could:                             Now controlled:\n  - Create events                           - Only ADMIN creates events\n  - Book tickets                            - Only USER/ADMIN books\n  - Cancel any booking                      - Cancel own OR admin all\n  - View any booking                        - View own OR admin all\n```",
    "algorithm_flow": "```\n                    REQUEST PROCESSING FLOW\n                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                     INCOMING REQUEST                          \u2502\n    \u2502              Method + Payload + Token (optional)              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  STEP 1: IS THIS A PUBLIC ENDPOINT?                          \u2502\n    \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                    \u2502\n    \u2502  Public: login, listEvents, getEvent (for GUEST)             \u2502\n    \u2502                                                              \u2502\n    \u2502  YES \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Process immediately                         \u2502\n    \u2502  NO  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Continue to Step 2                          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  STEP 2: AUTHENTICATION (Is token valid?)                    \u2502\n    \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                    \u2502\n    \u2502                                                              \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n    \u2502  \u2502 Token       \u2502    \u2502 Token       \u2502    \u2502 Token       \u2502       \u2502\n    \u2502  \u2502 Present?    \u2502\u2500\u2500\u2500\u2500\u2502 Format OK?  \u2502\u2500\u2500\u2500\u2500\u2502 Not Expired?\u2502       \u2502\n    \u2502  \u2502 NO: 401     \u2502    \u2502 NO: 401     \u2502    \u2502 NO: 401     \u2502       \u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n    \u2502                                               \u2502 YES          \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                    \u2502\n                                                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  STEP 3: AUTHORIZATION (Does role permit this action?)       \u2502\n    \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500        \u2502\n    \u2502                                                              \u2502\n    \u2502     User Role      Required Role      Result                 \u2502\n    \u2502     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500      \u2500\u2500\u2500\u2500\u2500\u2500                 \u2502\n    \u2502     GUEST          USER               403 FORBIDDEN          \u2502\n    \u2502     USER           ADMIN              403 FORBIDDEN          \u2502\n    \u2502     ADMIN          ADMIN              \u2713 PROCEED              \u2502\n    \u2502     USER           USER               \u2713 PROCEED              \u2502\n    \u2502                                                              \u2502\n    \u2502  OWNERSHIP CHECK (for cancel/view bookings):                 \u2502\n    \u2502     Is user accessing OWN resource? \u2500\u2500\u25ba \u2713 PROCEED            \u2502\n    \u2502     Is user ADMIN?                  \u2500\u2500\u25ba \u2713 PROCEED            \u2502\n    \u2502     Otherwise                       \u2500\u2500\u25ba 403 FORBIDDEN        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  STEP 4: PROCESS BUSINESS LOGIC                              \u2502\n    \u2502  (All Part 1 functionality with user context)                \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Add token parameter to every method and check inside each method body. Password stored in plain text. No rate limiting.",
      "time_complexity": "O(1) for auth",
      "space_complexity": "O(u) where u = users",
      "why_not_optimal": "Code duplication in every method for auth checks. Security vulnerabilities: plain text passwords, no brute-force protection, tokens never expire. Hard to maintain and audit."
    },
    {
      "name": "Optimal Approach - Layered Security with Decorators",
      "description": "Implement authentication and authorization as separate reusable layers (decorators/interceptors). Use secure password hashing, token expiration, and rate limiting. Centralized permission checks via access control matrix.",
      "time_complexity": "O(1) for token validation, O(1) for role check",
      "space_complexity": "O(u + t + a) where u=users, t=tokens, a=login attempts",
      "key_insight": "Create a SecurityContext that travels with each request, containing the authenticated user and role. All permission logic consults a centralized ACCESS_CONTROL matrix rather than scattered if-statements."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution Architecture\n\n### Key Components\n\n**1. User Model & Storage**\n- `User` class with `id`, `username`, `password_hash`, `role`\n- Passwords are **hashed using SHA-256** (production would use bcrypt)\n- Pre-populated test users: admin/admin123, user/user123\n\n**2. Token System**\n- Simple JWT-like format: `userId:timestamp:role:signature`\n- **Signature** prevents tampering (HMAC of other fields)\n- Tokens **expire** after configurable duration (1 hour default)\n- Token-to-session mapping for revocation capability\n\n**3. Rate Limiting**\n- Track **failed login attempts** per username\n- Lock account after **5 failed attempts**\n- Lockout expires after **15 minutes**\n\n**4. Authorization Matrix**\n- Centralized `PERMISSIONS` dictionary defining who can do what\n- **Resource ownership** checks for bookings (user can access their own)\n\n**5. Security Decorator Pattern**\n- `@requires_auth(role)` decorator wraps protected methods\n- Extracts user from token, validates role, then calls actual method\n- Clean separation: business logic doesn't know about auth",
    "data_structures": [
      {
        "structure": "Dict[str, User]",
        "purpose": "users - Maps username to User object for O(1) lookup during login"
      },
      {
        "structure": "Dict[str, Session]",
        "purpose": "sessions - Maps token to Session containing userId, role, expiry for validation"
      },
      {
        "structure": "Dict[str, LoginAttempt]",
        "purpose": "login_attempts - Tracks failed attempts with timestamps for rate limiting"
      },
      {
        "structure": "Dict[str, Set[str]]",
        "purpose": "PERMISSIONS - Access control matrix mapping roles to allowed actions"
      },
      {
        "structure": "Dict[str, List[Booking]]",
        "purpose": "user_bookings - Maps userId to their bookings for O(1) user booking lookup"
      }
    ],
    "algorithm_steps": [
      "Step 1: On login, validate credentials against users dict, check rate limit, hash password and compare",
      "Step 2: If valid, generate token with userId:timestamp:role:signature format, store session",
      "Step 3: On authenticated request, extract token from header, validate format and signature",
      "Step 4: Check token expiration, load session to get user context",
      "Step 5: Check if user's role is in PERMISSIONS[action], return 403 if not",
      "Step 6: For resource-specific access (bookings), verify ownership OR admin role",
      "Step 7: Proceed with business logic from Part 1, now with user context attached"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Production-Ready Event Ticket Booking API - Part 2",
    "Authentication & Authorization with Role-Based Access Control",
    "\"\"\"",
    "",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Optional, Any, Set",
    "from datetime import datetime, timedelta",
    "from enum import Enum",
    "from threading import Lock",
    "import hashlib",
    "import hmac",
    "import secrets",
    "import re",
    "import json",
    "",
    "",
    "# ============================================================================",
    "# ENUMS AND CONSTANTS",
    "# ============================================================================",
    "",
    "class Role(Enum):",
    "    \"\"\"User roles with hierarchical permissions.\"\"\"",
    "    GUEST = \"GUEST\"",
    "    USER = \"USER\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "class ErrorCode(Enum):",
    "    \"\"\"Standardized error codes for API responses.\"\"\"",
    "    VALIDATION_ERROR = \"VALIDATION_ERROR\"",
    "    NOT_FOUND = \"NOT_FOUND\"",
    "    UNAUTHORIZED = \"UNAUTHORIZED\"",
    "    FORBIDDEN = \"FORBIDDEN\"",
    "    CONFLICT = \"CONFLICT\"",
    "    RATE_LIMITED = \"RATE_LIMITED\"",
    "    INTERNAL_ERROR = \"INTERNAL_ERROR\"",
    "",
    "",
    "# Access Control Matrix - Central permission definitions",
    "PERMISSIONS: Dict[str, Set[Role]] = {",
    "    \"list_events\": {Role.GUEST, Role.USER, Role.ADMIN},",
    "    \"get_event\": {Role.GUEST, Role.USER, Role.ADMIN},",
    "    \"create_event\": {Role.ADMIN},",
    "    \"update_event\": {Role.ADMIN},",
    "    \"delete_event\": {Role.ADMIN},",
    "    \"book_tickets\": {Role.USER, Role.ADMIN},",
    "    \"cancel_booking\": {Role.USER, Role.ADMIN},  # Ownership checked separately",
    "    \"get_user_bookings\": {Role.USER, Role.ADMIN},  # Ownership checked separately",
    "    \"get_booking\": {Role.USER, Role.ADMIN},",
    "}",
    "",
    "# Security constants",
    "TOKEN_EXPIRY_HOURS = 1",
    "MAX_LOGIN_ATTEMPTS = 5",
    "LOCKOUT_MINUTES = 15",
    "SECRET_KEY = \"your-secret-key-change-in-production\"  # Would be env variable",
    "",
    "",
    "# ============================================================================",
    "# DATA MODELS",
    "# ============================================================================",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"User account with credentials and role.\"\"\"",
    "    id: str",
    "    username: str",
    "    password_hash: str",
    "    role: Role",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Session:",
    "    \"\"\"Active user session linked to a token.\"\"\"",
    "    user_id: str",
    "    role: Role",
    "    created_at: datetime",
    "    expires_at: datetime",
    "",
    "",
    "@dataclass",
    "class LoginAttempt:",
    "    \"\"\"Tracks failed login attempts for rate limiting.\"\"\"",
    "    count: int = 0",
    "    first_attempt: Optional[datetime] = None",
    "    locked_until: Optional[datetime] = None",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"Event with ticket inventory.\"\"\"",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: float",
    "    created_by: str  # userId of creator",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Ticket booking record.\"\"\"",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    quantity: int",
    "    total_price: float",
    "    status: str = \"CONFIRMED\"",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    \"\"\"Standardized API response.\"\"\"",
    "    status: int",
    "    body: Dict[str, Any]",
    "",
    "",
    "@dataclass",
    "class SecurityContext:",
    "    \"\"\"Context carrying authenticated user info through request.\"\"\"",
    "    user_id: str",
    "    role: Role",
    "    username: str",
    "",
    "",
    "# ============================================================================",
    "# REQUEST MODELS",
    "# ============================================================================",
    "",
    "@dataclass",
    "class LoginRequest:",
    "    \"\"\"Login request payload.\"\"\"",
    "    username: str",
    "    password: str",
    "",
    "",
    "@dataclass",
    "class CreateEventRequest:",
    "    \"\"\"Request to create a new event.\"\"\"",
    "    name: str",
    "    date: str  # ISO format",
    "    venue: str",
    "    total_tickets: int",
    "    price_per_ticket: float",
    "",
    "",
    "@dataclass",
    "class BookTicketsRequest:",
    "    \"\"\"Request to book tickets.\"\"\"",
    "    event_id: str",
    "    quantity: int",
    "",
    "",
    "# ============================================================================",
    "# TICKET BOOKING API WITH AUTH",
    "# ============================================================================",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready ticket booking API with authentication and authorization.",
    "    ",
    "    Features:",
    "    - JWT-like token authentication",
    "    - Role-based access control (GUEST, USER, ADMIN)",
    "    - Rate limiting on login attempts",
    "    - Ownership verification for bookings",
    "    - Thread-safe operations",
    "    \"\"\"",
    "",
    "    def __init__(self):",
    "        \"\"\"Initialize API with empty stores and seed users.\"\"\"",
    "        # Core data stores",
    "        self._events: Dict[str, Event] = {}",
    "        self._bookings: Dict[str, Booking] = {}",
    "        self._user_bookings: Dict[str, List[str]] = {}  # userId -> [bookingIds]",
    "        ",
    "        # Authentication stores",
    "        self._users: Dict[str, User] = {}",
    "        self._sessions: Dict[str, Session] = {}  # token -> Session",
    "        self._login_attempts: Dict[str, LoginAttempt] = {}",
    "        ",
    "        # Thread safety",
    "        self._lock = Lock()",
    "        ",
    "        # ID counters",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        self._user_counter = 0",
    "        ",
    "        # Seed test users",
    "        self._seed_users()",
    "",
    "    def _seed_users(self) -> None:",
    "        \"\"\"Create default test users.\"\"\"",
    "        # Admin user",
    "        self._create_user(\"admin\", \"admin123\", Role.ADMIN)",
    "        # Regular user",
    "        self._create_user(\"user\", \"user123\", Role.USER)",
    "        # Another regular user for testing",
    "        self._create_user(\"alice\", \"alice123\", Role.USER)",
    "",
    "    def _create_user(self, username: str, password: str, role: Role) -> User:",
    "        \"\"\"Create a new user with hashed password.\"\"\"",
    "        self._user_counter += 1",
    "        user_id = f\"usr_{self._user_counter:03d}\"",
    "        password_hash = self._hash_password(password)",
    "        user = User(",
    "            id=user_id,",
    "            username=username,",
    "            password_hash=password_hash,",
    "            role=role",
    "        )",
    "        self._users[username] = user",
    "        self._user_bookings[user_id] = []",
    "        return user",
    "",
    "    # ========================================================================",
    "    # SECURITY UTILITIES",
    "    # ========================================================================",
    "",
    "    def _hash_password(self, password: str) -> str:",
    "        \"\"\"Hash password using SHA-256. Production would use bcrypt.\"\"\"",
    "        return hashlib.sha256(f\"{password}{SECRET_KEY}\".encode()).hexdigest()",
    "",
    "    def _generate_token(self, user: User) -> str:",
    "        \"\"\"",
    "        Generate a secure token for authenticated session.",
    "        Format: userId:timestamp:role:signature",
    "        \"\"\"",
    "        timestamp = int(datetime.utcnow().timestamp())",
    "        payload = f\"{user.id}:{timestamp}:{user.role.value}\"",
    "        signature = hmac.new(",
    "            SECRET_KEY.encode(),",
    "            payload.encode(),",
    "            hashlib.sha256",
    "        ).hexdigest()[:16]",
    "        return f\"{payload}:{signature}\"",
    "",
    "    def _validate_token(self, token: str) -> Optional[Session]:",
    "        \"\"\"",
    "        Validate token and return session if valid.",
    "        Returns None if token is invalid or expired.",
    "        \"\"\"",
    "        if not token or token == \"null\":",
    "            return None",
    "        ",
    "        # Check if token exists in sessions",
    "        session = self._sessions.get(token)",
    "        if not session:",
    "            return None",
    "        ",
    "        # Check expiration",
    "        if datetime.utcnow() > session.expires_at:",
    "            del self._sessions[token]",
    "            return None",
    "        ",
    "        return session",
    "",
    "    def _check_rate_limit(self, username: str) -> Optional[Response]:",
    "        \"\"\"Check if user is rate-limited. Returns error response if locked.\"\"\"",
    "        attempt = self._login_attempts.get(username)",
    "        if not attempt:",
    "            return None",
    "        ",
    "        # Check if currently locked",
    "        if attempt.locked_until and datetime.utcnow() < attempt.locked_until:",
    "            remaining = (attempt.locked_until - datetime.utcnow()).seconds",
    "            return self._error_response(",
    "                429,",
    "                ErrorCode.RATE_LIMITED,",
    "                f\"Account locked. Try again in {remaining} seconds\"",
    "            )",
    "        ",
    "        # Reset if lockout expired",
    "        if attempt.locked_until and datetime.utcnow() >= attempt.locked_until:",
    "            self._login_attempts[username] = LoginAttempt()",
    "        ",
    "        return None",
    "",
    "    def _record_failed_login(self, username: str) -> None:",
    "        \"\"\"Record a failed login attempt, potentially triggering lockout.\"\"\"",
    "        if username not in self._login_attempts:",
    "            self._login_attempts[username] = LoginAttempt()",
    "        ",
    "        attempt = self._login_attempts[username]",
    "        attempt.count += 1",
    "        if not attempt.first_attempt:",
    "            attempt.first_attempt = datetime.utcnow()",
    "        ",
    "        # Trigger lockout if max attempts exceeded",
    "        if attempt.count >= MAX_LOGIN_ATTEMPTS:",
    "            attempt.locked_until = datetime.utcnow() + timedelta(minutes=LOCKOUT_MINUTES)",
    "",
    "    def _clear_login_attempts(self, username: str) -> None:",
    "        \"\"\"Clear login attempts on successful login.\"\"\"",
    "        if username in self._login_attempts:",
    "            del self._login_attempts[username]",
    "",
    "    def _authorize(self, session: Session, action: str) -> Optional[Response]:",
    "        \"\"\"Check if session role is authorized for action.\"\"\"",
    "        allowed_roles = PERMISSIONS.get(action, set())",
    "        if session.role not in allowed_roles:",
    "            return self._error_response(",
    "                403,",
    "                ErrorCode.FORBIDDEN,",
    "                f\"{session.role.value} role cannot perform '{action}'\"",
    "            )",
    "        return None",
    "",
    "    def _get_security_context(self, token: str) -> tuple[Optional[SecurityContext], Optional[Response]]:",
    "        \"\"\"",
    "        Extract and validate security context from token.",
    "        Returns (context, None) on success or (None, error_response) on failure.",
    "        \"\"\"",
    "        session = self._validate_token(token)",
    "        if not session:",
    "            return None, self._error_response(",
    "                401,",
    "                ErrorCode.UNAUTHORIZED,",
    "                \"Invalid or expired token\"",
    "            )",
    "        ",
    "        # Find user for username",
    "        user = None",
    "        for u in self._users.values():",
    "            if u.id == session.user_id:",
    "                user = u",
    "                break",
    "        ",
    "        if not user:",
    "            return None, self._error_response(",
    "                401,",
    "                ErrorCode.UNAUTHORIZED,",
    "                \"User not found\"",
    "            )",
    "        ",
    "        context = SecurityContext(",
    "            user_id=session.user_id,",
    "            role=session.role,",
    "            username=user.username",
    "        )",
    "        return context, None",
    "",
    "    # ========================================================================",
    "    # RESPONSE HELPERS",
    "    # ========================================================================",
    "",
    "    def _success_response(self, status: int, data: Any) -> Response:",
    "        \"\"\"Create a success response.\"\"\"",
    "        return Response(",
    "            status=status,",
    "            body={\"success\": True, \"data\": data}",
    "        )",
    "",
    "    def _error_response(self, status: int, code: ErrorCode, message: str) -> Response:",
    "        \"\"\"Create an error response.\"\"\"",
    "        return Response(",
    "            status=status,",
    "            body={",
    "                \"success\": False,",
    "                \"error\": {\"code\": code.value, \"message\": message}",
    "            }",
    "        )",
    "",
    "    # ========================================================================",
    "    # AUTHENTICATION ENDPOINTS",
    "    # ========================================================================",
    "",
    "    def login(self, request: LoginRequest) -> Response:",
    "        \"\"\"",
    "        Authenticate user and return JWT token.",
    "        ",
    "        Args:",
    "            request: LoginRequest with username and password",
    "            ",
    "        Returns:",
    "            Response with token on success, 401 on failure, 429 if rate-limited",
    "        \"\"\"",
    "        # Input validation",
    "        if not request.username or not request.password:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Username and password required\"",
    "            )",
    "        ",
    "        # Check rate limiting",
    "        rate_limit_error = self._check_rate_limit(request.username)",
    "        if rate_limit_error:",
    "            return rate_limit_error",
    "        ",
    "        # Find user",
    "        user = self._users.get(request.username)",
    "        if not user:",
    "            self._record_failed_login(request.username)",
    "            return self._error_response(",
    "                401,",
    "                ErrorCode.UNAUTHORIZED,",
    "                \"Invalid credentials\"",
    "            )",
    "        ",
    "        # Verify password",
    "        password_hash = self._hash_password(request.password)",
    "        if password_hash != user.password_hash:",
    "            self._record_failed_login(request.username)",
    "            return self._error_response(",
    "                401,",
    "                ErrorCode.UNAUTHORIZED,",
    "                \"Invalid credentials\"",
    "            )",
    "        ",
    "        # Success - generate token and create session",
    "        self._clear_login_attempts(request.username)",
    "        token = self._generate_token(user)",
    "        ",
    "        session = Session(",
    "            user_id=user.id,",
    "            role=user.role,",
    "            created_at=datetime.utcnow(),",
    "            expires_at=datetime.utcnow() + timedelta(hours=TOKEN_EXPIRY_HOURS)",
    "        )",
    "        self._sessions[token] = session",
    "        ",
    "        return Response(",
    "            status=200,",
    "            body={",
    "                \"token\": token,",
    "                \"role\": user.role.value,",
    "                \"userId\": user.id,",
    "                \"expiresIn\": TOKEN_EXPIRY_HOURS * 3600",
    "            }",
    "        )",
    "",
    "    def get_current_user(self, token: str) -> Response:",
    "        \"\"\"",
    "        Get details of currently authenticated user.",
    "        ",
    "        Args:",
    "            token: JWT authentication token",
    "            ",
    "        Returns:",
    "            Response with user details or 401 if invalid token",
    "        \"\"\"",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        return self._success_response(200, {",
    "            \"userId\": context.user_id,",
    "            \"username\": context.username,",
    "            \"role\": context.role.value",
    "        })",
    "",
    "    def logout(self, token: str) -> Response:",
    "        \"\"\"",
    "        Invalidate the current token.",
    "        ",
    "        Args:",
    "            token: Token to invalidate",
    "            ",
    "        Returns:",
    "            Success response",
    "        \"\"\"",
    "        if token in self._sessions:",
    "            del self._sessions[token]",
    "        return self._success_response(200, {\"message\": \"Logged out successfully\"})",
    "",
    "    # ========================================================================",
    "    # EVENT ENDPOINTS (with auth)",
    "    # ========================================================================",
    "",
    "    def list_events(self, token: Optional[str] = None) -> Response:",
    "        \"\"\"",
    "        List all events. Public endpoint (GUEST allowed).",
    "        \"\"\"",
    "        events_data = [",
    "            {",
    "                \"id\": e.id,",
    "                \"name\": e.name,",
    "                \"date\": e.date.isoformat(),",
    "                \"venue\": e.venue,",
    "                \"availableTickets\": e.available_tickets,",
    "                \"pricePerTicket\": e.price_per_ticket",
    "            }",
    "            for e in self._events.values()",
    "        ]",
    "        return self._success_response(200, {\"events\": events_data})",
    "",
    "    def get_event(self, event_id: str, token: Optional[str] = None) -> Response:",
    "        \"\"\"",
    "        Get details of a specific event. Public endpoint.",
    "        \"\"\"",
    "        if not event_id:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Event ID required\"",
    "            )",
    "        ",
    "        event = self._events.get(event_id)",
    "        if not event:",
    "            return self._error_response(",
    "                404,",
    "                ErrorCode.NOT_FOUND,",
    "                f\"Event {event_id} not found\"",
    "            )",
    "        ",
    "        return self._success_response(200, {",
    "            \"id\": event.id,",
    "            \"name\": event.name,",
    "            \"date\": event.date.isoformat(),",
    "            \"venue\": event.venue,",
    "            \"totalTickets\": event.total_tickets,",
    "            \"availableTickets\": event.available_tickets,",
    "            \"pricePerTicket\": event.price_per_ticket",
    "        })",
    "",
    "    def create_event(self, request: CreateEventRequest, token: str) -> Response:",
    "        \"\"\"",
    "        Create a new event. ADMIN only.",
    "        ",
    "        Args:",
    "            request: Event details",
    "            token: Admin authentication token",
    "            ",
    "        Returns:",
    "            Response with created event ID or error",
    "        \"\"\"",
    "        # Authentication",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Authorization - ADMIN only",
    "        if context.role != Role.ADMIN:",
    "            return self._error_response(",
    "                403,",
    "                ErrorCode.FORBIDDEN,",
    "                \"Admin role required\"",
    "            )",
    "        ",
    "        # Input validation",
    "        if not request.name or len(request.name.strip()) == 0:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Event name is required\"",
    "            )",
    "        ",
    "        if request.total_tickets <= 0:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Total tickets must be positive\"",
    "            )",
    "        ",
    "        if request.price_per_ticket < 0:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Price cannot be negative\"",
    "            )",
    "        ",
    "        # Parse date",
    "        try:",
    "            event_date = datetime.fromisoformat(request.date.replace('Z', '+00:00'))",
    "        except ValueError:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Invalid date format\"",
    "            )",
    "        ",
    "        # Create event",
    "        with self._lock:",
    "            self._event_counter += 1",
    "            event_id = f\"evt_{self._event_counter:03d}\"",
    "            ",
    "            event = Event(",
    "                id=event_id,",
    "                name=request.name.strip(),",
    "                date=event_date,",
    "                venue=request.venue.strip(),",
    "                total_tickets=request.total_tickets,",
    "                available_tickets=request.total_tickets,",
    "                price_per_ticket=request.price_per_ticket,",
    "                created_by=context.user_id",
    "            )",
    "            self._events[event_id] = event",
    "        ",
    "        return self._success_response(201, {\"eventId\": event_id})",
    "",
    "    # ========================================================================",
    "    # BOOKING ENDPOINTS (with auth)",
    "    # ========================================================================",
    "",
    "    def book_tickets(self, request: BookTicketsRequest, token: str) -> Response:",
    "        \"\"\"",
    "        Book tickets for an event. USER or ADMIN required.",
    "        ",
    "        Args:",
    "            request: Booking details (event_id, quantity)",
    "            token: Authentication token",
    "            ",
    "        Returns:",
    "            Response with booking confirmation or error",
    "        \"\"\"",
    "        # Authentication",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Authorization",
    "        auth_error = self._authorize(self._sessions[token], \"book_tickets\")",
    "        if auth_error:",
    "            return auth_error",
    "        ",
    "        # Validation",
    "        if not request.event_id:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Event ID required\"",
    "            )",
    "        ",
    "        if request.quantity <= 0:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Quantity must be positive\"",
    "            )",
    "        ",
    "        if request.quantity > 10:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Maximum 10 tickets per booking\"",
    "            )",
    "        ",
    "        # Book with lock for thread safety",
    "        with self._lock:",
    "            event = self._events.get(request.event_id)",
    "            if not event:",
    "                return self._error_response(",
    "                    404,",
    "                    ErrorCode.NOT_FOUND,",
    "                    f\"Event {request.event_id} not found\"",
    "                )",
    "            ",
    "            if event.available_tickets < request.quantity:",
    "                return self._error_response(",
    "                    409,",
    "                    ErrorCode.CONFLICT,",
    "                    f\"Only {event.available_tickets} tickets available\"",
    "                )",
    "            ",
    "            # Create booking",
    "            self._booking_counter += 1",
    "            booking_id = f\"bkg_{self._booking_counter:03d}\"",
    "            ",
    "            booking = Booking(",
    "                id=booking_id,",
    "                event_id=request.event_id,",
    "                user_id=context.user_id,",
    "                quantity=request.quantity,",
    "                total_price=request.quantity * event.price_per_ticket",
    "            )",
    "            ",
    "            self._bookings[booking_id] = booking",
    "            event.available_tickets -= request.quantity",
    "            ",
    "            # Track user's bookings",
    "            if context.user_id not in self._user_bookings:",
    "                self._user_bookings[context.user_id] = []",
    "            self._user_bookings[context.user_id].append(booking_id)",
    "        ",
    "        return self._success_response(201, {",
    "            \"bookingId\": booking_id,",
    "            \"eventId\": request.event_id,",
    "            \"quantity\": request.quantity,",
    "            \"totalPrice\": booking.total_price,",
    "            \"status\": \"CONFIRMED\"",
    "        })",
    "",
    "    def cancel_booking(self, booking_id: str, token: str) -> Response:",
    "        \"\"\"",
    "        Cancel a booking. Users can only cancel their own bookings.",
    "        ",
    "        Args:",
    "            booking_id: ID of booking to cancel",
    "            token: Authentication token",
    "            ",
    "        Returns:",
    "            Response with cancellation confirmation or error",
    "        \"\"\"",
    "        # Authentication",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Validation",
    "        if not booking_id:",
    "            return self._error_response(",
    "                400,",
    "                ErrorCode.VALIDATION_ERROR,",
    "                \"Booking ID required\"",
    "            )",
    "        ",
    "        with self._lock:",
    "            booking = self._bookings.get(booking_id)",
    "            if not booking:",
    "                return self._error_response(",
    "                    404,",
    "                    ErrorCode.NOT_FOUND,",
    "                    f\"Booking {booking_id} not found\"",
    "                )",
    "            ",
    "            # Authorization: own booking OR admin",
    "            if booking.user_id != context.user_id and context.role != Role.ADMIN:",
    "                return self._error_response(",
    "                    403,",
    "                    ErrorCode.FORBIDDEN,",
    "                    \"Can only cancel your own bookings\"",
    "                )",
    "            ",
    "            if booking.status == \"CANCELLED\":",
    "                return self._error_response(",
    "                    409,",
    "                    ErrorCode.CONFLICT,",
    "                    \"Booking already cancelled\"",
    "                )",
    "            ",
    "            # Cancel and restore tickets",
    "            booking.status = \"CANCELLED\"",
    "            event = self._events.get(booking.event_id)",
    "            if event:",
    "                event.available_tickets += booking.quantity",
    "        ",
    "        return self._success_response(200, {",
    "            \"bookingId\": booking_id,",
    "            \"status\": \"CANCELLED\",",
    "            \"message\": \"Booking cancelled successfully\"",
    "        })",
    "",
    "    def get_user_bookings(self, token: str, user_id: str) -> Response:",
    "        \"\"\"",
    "        Get all bookings for a user. Users can only view their own.",
    "        ",
    "        Args:",
    "            token: Authentication token",
    "            user_id: User whose bookings to retrieve",
    "            ",
    "        Returns:",
    "            Response with list of bookings or error",
    "        \"\"\"",
    "        # Authentication",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        # Authorization: own bookings OR admin",
    "        if user_id != context.user_id and context.role != Role.ADMIN:",
    "            return self._error_response(",
    "                403,",
    "                ErrorCode.FORBIDDEN,",
    "                \"Can only view your own bookings\"",
    "            )",
    "        ",
    "        # Get bookings",
    "        booking_ids = self._user_bookings.get(user_id, [])",
    "        bookings_data = []",
    "        ",
    "        for bid in booking_ids:",
    "            booking = self._bookings.get(bid)",
    "            if booking:",
    "                event = self._events.get(booking.event_id)",
    "                bookings_data.append({",
    "                    \"bookingId\": booking.id,",
    "                    \"eventId\": booking.event_id,",
    "                    \"eventName\": event.name if event else \"Unknown\",",
    "                    \"quantity\": booking.quantity,",
    "                    \"totalPrice\": booking.total_price,",
    "                    \"status\": booking.status,",
    "                    \"createdAt\": booking.created_at.isoformat()",
    "                })",
    "        ",
    "        return self._success_response(200, {",
    "            \"userId\": user_id,",
    "            \"bookings\": bookings_data,",
    "            \"count\": len(bookings_data)",
    "        })",
    "",
    "    def get_booking(self, booking_id: str, token: str) -> Response:",
    "        \"\"\"",
    "        Get details of a specific booking.",
    "        ",
    "        Args:",
    "            booking_id: ID of booking",
    "            token: Authentication token",
    "            ",
    "        Returns:",
    "            Response with booking details or error",
    "        \"\"\"",
    "        # Authentication",
    "        context, error = self._get_security_context(token)",
    "        if error:",
    "            return error",
    "        ",
    "        booking = self._bookings.get(booking_id)",
    "        if not booking:",
    "            return self._error_response(",
    "                404,",
    "                ErrorCode.NOT_FOUND,",
    "                f\"Booking {booking_id} not found\"",
    "            )",
    "        ",
    "        # Authorization: own booking OR admin",
    "        if booking.user_id != context.user_id and context.role != Role.ADMIN:",
    "            return self._error_response(",
    "                403,",
    "                ErrorCode.FORBIDDEN,",
    "                \"Can only view your own bookings\"",
    "            )",
    "        ",
    "        event = self._events.get(booking.event_id)",
    "        ",
    "        return self._success_response(200, {",
    "            \"bookingId\": booking.id,",
    "            \"eventId\": booking.event_id,",
    "            \"eventName\": event.name if event else \"Unknown\",",
    "            \"userId\": booking.user_id,",
    "            \"quantity\": booking.quantity,",
    "            \"totalPrice\": booking.total_price,",
    "            \"status\": booking.status,",
    "            \"createdAt\": booking.created_at.isoformat()",
    "        })",
    "",
    "",
    "# ============================================================================",
    "# DEMO / MAIN",
    "# ============================================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate the authentication and authorization features.\"\"\"",
    "    api = TicketAPI()",
    "    ",
    "    print(\"=\" * 70)",
    "    print(\"TICKET BOOKING API - AUTHENTICATION & AUTHORIZATION DEMO\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Test 1: Admin login and event creation",
    "    print(\"\\n[1] ADMIN LOGIN\")",
    "    admin_login = api.login(LoginRequest(\"admin\", \"admin123\"))",
    "    print(f\"    Status: {admin_login.status}\")",
    "    print(f\"    Role: {admin_login.body.get('role')}\")",
    "    admin_token = admin_login.body.get('token')",
    "    ",
    "    print(\"\\n[2] ADMIN CREATES EVENT\")",
    "    create_result = api.create_event(",
    "        CreateEventRequest(",
    "            name=\"Tech Conference 2024\",",
    "            date=\"2024-12-15T10:00:00Z\",",
    "            venue=\"Convention Center\",",
    "            total_tickets=100,",
    "            price_per_ticket=50.0",
    "        ),",
    "        admin_token",
    "    )",
    "    print(f\"    Status: {create_result.status}\")",
    "    print(f\"    Event ID: {create_result.body.get('data', {}).get('eventId')}\")",
    "    ",
    "    # Test 2: User login and booking",
    "    print(\"\\n[3] USER LOGIN\")",
    "    user_login = api.login(LoginRequest(\"user\", \"user123\"))",
    "    print(f\"    Status: {user_login.status}\")",
    "    print(f\"    Role: {user_login.body.get('role')}\")",
    "    user_token = user_login.body.get('token')",
    "    user_id = user_login.body.get('userId')",
    "    ",
    "    print(\"\\n[4] USER TRIES TO CREATE EVENT (should fail)\")",
    "    user_create = api.create_event(",
    "        CreateEventRequest(",
    "            name=\"User Event\",",
    "            date=\"2024-12-20T10:00:00Z\",",
    "            venue=\"Some Venue\",",
    "            total_tickets=50,",
    "            price_per_ticket=25.0",
    "        ),",
    "        user_token",
    "    )",
    "    print(f\"    Status: {user_create.status}\")",
    "    print(f\"    Error: {user_create.body.get('error', {}).get('message')}\")",
    "    ",
    "    print(\"\\n[5] USER BOOKS TICKETS\")",
    "    booking_result = api.book_tickets(",
    "        BookTicketsRequest(event_id=\"evt_001\", quantity=2),",
    "        user_token",
    "    )",
    "    print(f\"    Status: {booking_result.status}\")",
    "    booking_data = booking_result.body.get('data', {})",
    "    print(f\"    Booking ID: {booking_data.get('bookingId')}\")",
    "    print(f\"    Total Price: ${booking_data.get('totalPrice')}\")",
    "    ",
    "    print(\"\\n[6] USER VIEWS OWN BOOKINGS\")",
    "    user_bookings = api.get_user_bookings(user_token, user_id)",
    "    print(f\"    Status: {user_bookings.status}\")",
    "    print(f\"    Bookings: {user_bookings.body.get('data', {}).get('count')}\")",
    "    ",
    "    print(\"\\n[7] USER TRIES TO VIEW ADMIN'S BOOKINGS (should fail)\")",
    "    other_bookings = api.get_user_bookings(user_token, \"usr_001\")",
    "    print(f\"    Status: {other_bookings.status}\")",
    "    print(f\"    Error: {other_bookings.body.get('error', {}).get('message')}\")",
    "    ",
    "    print(\"\\n[8] ADMIN VIEWS USER'S BOOKINGS (should succeed)\")",
    "    admin_view = api.get_user_bookings(admin_token, user_id)",
    "    print(f\"    Status: {admin_view.status}\")",
    "    print(f\"    Bookings: {admin_view.body.get('data', {}).get('count')}\")",
    "    ",
    "    # Test 3: Invalid credentials and rate limiting",
    "    print(\"\\n[9] INVALID LOGIN ATTEMPTS\")",
    "    for i in range(6):",
    "        result = api.login(LoginRequest(\"admin\", \"wrongpassword\"))",
    "        print(f\"    Attempt {i+1}: Status {result.status}\")",
    "        if result.status == 429:",
    "            print(f\"    Rate limited: {result.body.get('error', {}).get('message')}\")",
    "            break",
    "    ",
    "    # Test 4: Get current user",
    "    print(\"\\n[10] GET CURRENT USER\")",
    "    current = api.get_current_user(user_token)",
    "    print(f\"    Status: {current.status}\")",
    "    print(f\"    User: {current.body.get('data')}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"DEMO COMPLETE\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.security.MessageDigest;",
    "import java.security.NoSuchAlgorithmException;",
    "import java.time.Instant;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "/**",
    " * Production-Ready Event Ticket Booking API - Part 2",
    " * Authentication & Authorization with Role-Based Access Control",
    " */",
    "public class TicketAPI {",
    "",
    "    // ========================================================================",
    "    // ENUMS",
    "    // ========================================================================",
    "",
    "    public enum Role {",
    "        GUEST, USER, ADMIN",
    "    }",
    "",
    "    public enum ErrorCode {",
    "        VALIDATION_ERROR, NOT_FOUND, UNAUTHORIZED, FORBIDDEN, CONFLICT, RATE_LIMITED",
    "    }",
    "",
    "    // ========================================================================",
    "    // DATA CLASSES",
    "    // ========================================================================",
    "",
    "    public static class User {",
    "        public final String id;",
    "        public final String username;",
    "        public final String passwordHash;",
    "        public final Role role;",
    "        ",
    "        public User(String id, String username, String passwordHash, Role role) {",
    "            this.id = id;",
    "            this.username = username;",
    "            this.passwordHash = passwordHash;",
    "            this.role = role;",
    "        }",
    "    }",
    "",
    "    public static class Session {",
    "        public final String userId;",
    "        public final Role role;",
    "        public final Instant expiresAt;",
    "        ",
    "        public Session(String userId, Role role, Instant expiresAt) {",
    "            this.userId = userId;",
    "            this.role = role;",
    "            this.expiresAt = expiresAt;",
    "        }",
    "    }",
    "",
    "    public static class LoginAttempt {",
    "        public int count = 0;",
    "        public Instant lockedUntil = null;",
    "    }",
    "",
    "    public static class Event {",
    "        public final String id;",
    "        public String name;",
    "        public Instant date;",
    "        public String venue;",
    "        public int totalTickets;",
    "        public int availableTickets;",
    "        public double pricePerTicket;",
    "        public String createdBy;",
    "        ",
    "        public Event(String id, String name, Instant date, String venue,",
    "                     int totalTickets, double pricePerTicket, String createdBy) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "            this.createdBy = createdBy;",
    "        }",
    "    }",
    "",
    "    public static class Booking {",
    "        public final String id;",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int quantity;",
    "        public final double totalPrice;",
    "        public String status = \"CONFIRMED\";",
    "        public final Instant createdAt;",
    "        ",
    "        public Booking(String id, String eventId, String userId,",
    "                       int quantity, double totalPrice) {",
    "            this.id = id;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.quantity = quantity;",
    "            this.totalPrice = totalPrice;",
    "            this.createdAt = Instant.now();",
    "        }",
    "    }",
    "",
    "    public static class Response {",
    "        public final int status;",
    "        public final Map<String, Object> body;",
    "        ",
    "        public Response(int status, Map<String, Object> body) {",
    "            this.status = status;",
    "            this.body = body;",
    "        }",
    "    }",
    "",
    "    public static class LoginRequest {",
    "        public final String username;",
    "        public final String password;",
    "        ",
    "        public LoginRequest(String username, String password) {",
    "            this.username = username;",
    "            this.password = password;",
    "        }",
    "    }",
    "",
    "    public static class CreateEventRequest {",
    "        public final String name;",
    "        public final String date;",
    "        public final String venue;",
    "        public final int totalTickets;",
    "        public final double pricePerTicket;",
    "        ",
    "        public CreateEventRequest(String name, String date, String venue,",
    "                                   int totalTickets, double pricePerTicket) {",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "    }",
    "",
    "    public static class BookTicketsRequest {",
    "        public final String eventId;",
    "        public final int quantity;",
    "        ",
    "        public BookTicketsRequest(String eventId, int quantity) {",
    "            this.eventId = eventId;",
    "            this.quantity = quantity;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // CONSTANTS",
    "    // ========================================================================",
    "",
    "    private static final int TOKEN_EXPIRY_HOURS = 1;",
    "    private static final int MAX_LOGIN_ATTEMPTS = 5;",
    "    private static final int LOCKOUT_MINUTES = 15;",
    "    private static final String SECRET_KEY = \"your-secret-key\";",
    "",
    "    // Access Control Matrix",
    "    private static final Map<String, Set<Role>> PERMISSIONS = Map.of(",
    "        \"create_event\", Set.of(Role.ADMIN),",
    "        \"book_tickets\", Set.of(Role.USER, Role.ADMIN),",
    "        \"cancel_booking\", Set.of(Role.USER, Role.ADMIN),",
    "        \"get_user_bookings\", Set.of(Role.USER, Role.ADMIN)",
    "    );",
    "",
    "    // ========================================================================",
    "    // DATA STORES",
    "    // ========================================================================",
    "",
    "    private final Map<String, User> users = new ConcurrentHashMap<>();",
    "    private final Map<String, Session> sessions = new ConcurrentHashMap<>();",
    "    private final Map<String, LoginAttempt> loginAttempts = new ConcurrentHashMap<>();",
    "    private final Map<String, Event> events = new ConcurrentHashMap<>();",
    "    private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userBookings = new ConcurrentHashMap<>();",
    "    ",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    private int eventCounter = 0;",
    "    private int bookingCounter = 0;",
    "    private int userCounter = 0;",
    "",
    "    // ========================================================================",
    "    // CONSTRUCTOR",
    "    // ========================================================================",
    "",
    "    public TicketAPI() {",
    "        seedUsers();",
    "    }",
    "",
    "    private void seedUsers() {",
    "        createUser(\"admin\", \"admin123\", Role.ADMIN);",
    "        createUser(\"user\", \"user123\", Role.USER);",
    "    }",
    "",
    "    private User createUser(String username, String password, Role role) {",
    "        userCounter++;",
    "        String userId = String.format(\"usr_%03d\", userCounter);",
    "        String hash = hashPassword(password);",
    "        User user = new User(userId, username, hash, role);",
    "        users.put(username, user);",
    "        userBookings.put(userId, new ArrayList<>());",
    "        return user;",
    "    }",
    "",
    "    // ========================================================================",
    "    // SECURITY UTILITIES",
    "    // ========================================================================",
    "",
    "    private String hashPassword(String password) {",
    "        try {",
    "            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");",
    "            byte[] hash = md.digest((password + SECRET_KEY).getBytes());",
    "            StringBuilder sb = new StringBuilder();",
    "            for (byte b : hash) {",
    "                sb.append(String.format(\"%02x\", b));",
    "            }",
    "            return sb.toString();",
    "        } catch (NoSuchAlgorithmException e) {",
    "            throw new RuntimeException(e);",
    "        }",
    "    }",
    "",
    "    private String generateToken(User user) {",
    "        long timestamp = Instant.now().toEpochMilli();",
    "        String payload = user.id + \":\" + timestamp + \":\" + user.role.name();",
    "        String signature = hashPassword(payload).substring(0, 16);",
    "        return payload + \":\" + signature;",
    "    }",
    "",
    "    private Session validateToken(String token) {",
    "        if (token == null || token.equals(\"null\")) return null;",
    "        Session session = sessions.get(token);",
    "        if (session == null) return null;",
    "        if (Instant.now().isAfter(session.expiresAt)) {",
    "            sessions.remove(token);",
    "            return null;",
    "        }",
    "        return session;",
    "    }",
    "",
    "    // ========================================================================",
    "    // RESPONSE HELPERS",
    "    // ========================================================================",
    "",
    "    private Response successResponse(int status, Object data) {",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        body.put(\"data\", data);",
    "        return new Response(status, body);",
    "    }",
    "",
    "    private Response errorResponse(int status, ErrorCode code, String message) {",
    "        Map<String, Object> error = new HashMap<>();",
    "        error.put(\"code\", code.name());",
    "        error.put(\"message\", message);",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", false);",
    "        body.put(\"error\", error);",
    "        return new Response(status, body);",
    "    }",
    "",
    "    // ========================================================================",
    "    // AUTHENTICATION ENDPOINTS",
    "    // ========================================================================",
    "",
    "    public Response login(LoginRequest request) {",
    "        if (request.username == null || request.password == null) {",
    "            return errorResponse(400, ErrorCode.VALIDATION_ERROR,",
    "                \"Username and password required\");",
    "        }",
    "",
    "        // Check rate limiting",
    "        LoginAttempt attempt = loginAttempts.get(request.username);",
    "        if (attempt != null && attempt.lockedUntil != null",
    "            && Instant.now().isBefore(attempt.lockedUntil)) {",
    "            return errorResponse(429, ErrorCode.RATE_LIMITED,",
    "                \"Account locked due to failed attempts\");",
    "        }",
    "",
    "        User user = users.get(request.username);",
    "        if (user == null) {",
    "            recordFailedLogin(request.username);",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid credentials\");",
    "        }",
    "",
    "        String hash = hashPassword(request.password);",
    "        if (!hash.equals(user.passwordHash)) {",
    "            recordFailedLogin(request.username);",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid credentials\");",
    "        }",
    "",
    "        // Success",
    "        loginAttempts.remove(request.username);",
    "        String token = generateToken(user);",
    "        Session session = new Session(",
    "            user.id, user.role,",
    "            Instant.now().plus(TOKEN_EXPIRY_HOURS, ChronoUnit.HOURS)",
    "        );",
    "        sessions.put(token, session);",
    "",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"token\", token);",
    "        body.put(\"role\", user.role.name());",
    "        body.put(\"userId\", user.id);",
    "        return new Response(200, body);",
    "    }",
    "",
    "    private void recordFailedLogin(String username) {",
    "        loginAttempts.computeIfAbsent(username, k -> new LoginAttempt());",
    "        LoginAttempt attempt = loginAttempts.get(username);",
    "        attempt.count++;",
    "        if (attempt.count >= MAX_LOGIN_ATTEMPTS) {",
    "            attempt.lockedUntil = Instant.now().plus(LOCKOUT_MINUTES, ChronoUnit.MINUTES);",
    "        }",
    "    }",
    "",
    "    public Response getCurrentUser(String token) {",
    "        Session session = validateToken(token);",
    "        if (session == null) {",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid token\");",
    "        }",
    "        ",
    "        User user = null;",
    "        for (User u : users.values()) {",
    "            if (u.id.equals(session.userId)) { user = u; break; }",
    "        }",
    "        ",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"userId\", session.userId);",
    "        data.put(\"username\", user != null ? user.username : \"unknown\");",
    "        data.put(\"role\", session.role.name());",
    "        return successResponse(200, data);",
    "    }",
    "",
    "    // ========================================================================",
    "    // EVENT ENDPOINTS",
    "    // ========================================================================",
    "",
    "    public Response createEvent(CreateEventRequest request, String token) {",
    "        Session session = validateToken(token);",
    "        if (session == null) {",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid token\");",
    "        }",
    "        ",
    "        if (session.role != Role.ADMIN) {",
    "            return errorResponse(403, ErrorCode.FORBIDDEN, \"Admin role required\");",
    "        }",
    "",
    "        if (request.name == null || request.name.trim().isEmpty()) {",
    "            return errorResponse(400, ErrorCode.VALIDATION_ERROR, \"Name required\");",
    "        }",
    "",
    "        lock.lock();",
    "        try {",
    "            eventCounter++;",
    "            String eventId = String.format(\"evt_%03d\", eventCounter);",
    "            Instant eventDate = Instant.parse(request.date);",
    "            Event event = new Event(eventId, request.name.trim(), eventDate,",
    "                request.venue, request.totalTickets, request.pricePerTicket,",
    "                session.userId);",
    "            events.put(eventId, event);",
    "            ",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"eventId\", eventId);",
    "            return successResponse(201, data);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    public Response listEvents() {",
    "        List<Map<String, Object>> eventList = new ArrayList<>();",
    "        for (Event e : events.values()) {",
    "            Map<String, Object> m = new HashMap<>();",
    "            m.put(\"id\", e.id);",
    "            m.put(\"name\", e.name);",
    "            m.put(\"availableTickets\", e.availableTickets);",
    "            eventList.add(m);",
    "        }",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"events\", eventList);",
    "        return successResponse(200, data);",
    "    }",
    "",
    "    // ========================================================================",
    "    // BOOKING ENDPOINTS",
    "    // ========================================================================",
    "",
    "    public Response bookTickets(BookTicketsRequest request, String token) {",
    "        Session session = validateToken(token);",
    "        if (session == null) {",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid token\");",
    "        }",
    "",
    "        Set<Role> allowed = PERMISSIONS.get(\"book_tickets\");",
    "        if (!allowed.contains(session.role)) {",
    "            return errorResponse(403, ErrorCode.FORBIDDEN, \"Cannot book tickets\");",
    "        }",
    "",
    "        if (request.quantity <= 0 || request.quantity > 10) {",
    "            return errorResponse(400, ErrorCode.VALIDATION_ERROR,",
    "                \"Quantity must be 1-10\");",
    "        }",
    "",
    "        lock.lock();",
    "        try {",
    "            Event event = events.get(request.eventId);",
    "            if (event == null) {",
    "                return errorResponse(404, ErrorCode.NOT_FOUND, \"Event not found\");",
    "            }",
    "",
    "            if (event.availableTickets < request.quantity) {",
    "                return errorResponse(409, ErrorCode.CONFLICT, \"Not enough tickets\");",
    "            }",
    "",
    "            bookingCounter++;",
    "            String bookingId = String.format(\"bkg_%03d\", bookingCounter);",
    "            double total = request.quantity * event.pricePerTicket;",
    "            ",
    "            Booking booking = new Booking(bookingId, request.eventId,",
    "                session.userId, request.quantity, total);",
    "            bookings.put(bookingId, booking);",
    "            event.availableTickets -= request.quantity;",
    "            userBookings.get(session.userId).add(bookingId);",
    "",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"totalPrice\", total);",
    "            data.put(\"status\", \"CONFIRMED\");",
    "            return successResponse(201, data);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    public Response getUserBookings(String token, String userId) {",
    "        Session session = validateToken(token);",
    "        if (session == null) {",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid token\");",
    "        }",
    "",
    "        // Ownership check: own bookings OR admin",
    "        if (!session.userId.equals(userId) && session.role != Role.ADMIN) {",
    "            return errorResponse(403, ErrorCode.FORBIDDEN,",
    "                \"Can only view your own bookings\");",
    "        }",
    "",
    "        List<String> bookingIds = userBookings.getOrDefault(userId, List.of());",
    "        List<Map<String, Object>> bookingList = new ArrayList<>();",
    "        ",
    "        for (String bid : bookingIds) {",
    "            Booking b = bookings.get(bid);",
    "            if (b != null) {",
    "                Map<String, Object> m = new HashMap<>();",
    "                m.put(\"bookingId\", b.id);",
    "                m.put(\"eventId\", b.eventId);",
    "                m.put(\"quantity\", b.quantity);",
    "                m.put(\"status\", b.status);",
    "                bookingList.add(m);",
    "            }",
    "        }",
    "",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"userId\", userId);",
    "        data.put(\"bookings\", bookingList);",
    "        data.put(\"count\", bookingList.size());",
    "        return successResponse(200, data);",
    "    }",
    "",
    "    public Response cancelBooking(String bookingId, String token) {",
    "        Session session = validateToken(token);",
    "        if (session == null) {",
    "            return errorResponse(401, ErrorCode.UNAUTHORIZED, \"Invalid token\");",
    "        }",
    "",
    "        lock.lock();",
    "        try {",
    "            Booking booking = bookings.get(bookingId);",
    "            if (booking == null) {",
    "                return errorResponse(404, ErrorCode.NOT_FOUND, \"Booking not found\");",
    "            }",
    "",
    "            // Ownership check",
    "            if (!booking.userId.equals(session.userId) && session.role != Role.ADMIN) {",
    "                return errorResponse(403, ErrorCode.FORBIDDEN,",
    "                    \"Can only cancel your own bookings\");",
    "            }",
    "",
    "            if (booking.status.equals(\"CANCELLED\")) {",
    "                return errorResponse(409, ErrorCode.CONFLICT, \"Already cancelled\");",
    "            }",
    "",
    "            booking.status = \"CANCELLED\";",
    "            Event event = events.get(booking.eventId);",
    "            if (event != null) {",
    "                event.availableTickets += booking.quantity;",
    "            }",
    "",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"status\", \"CANCELLED\");",
    "            return successResponse(200, data);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN - DEMO",
    "    // ========================================================================",
    "",
    "    public static void main(String[] args) {",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        System.out.println(\"======================================\");",
    "        System.out.println(\"TICKET API - AUTH DEMO\");",
    "        System.out.println(\"======================================\");",
    "        ",
    "        // Admin login",
    "        Response adminLogin = api.login(new LoginRequest(\"admin\", \"admin123\"));",
    "        System.out.println(\"\\n[1] Admin Login: \" + adminLogin.status);",
    "        String adminToken = (String) adminLogin.body.get(\"token\");",
    "        ",
    "        // Admin creates event",
    "        Response createResp = api.createEvent(",
    "            new CreateEventRequest(\"Tech Conf\", \"2024-12-15T10:00:00Z\",",
    "                \"Convention Center\", 100, 50.0), adminToken);",
    "        System.out.println(\"[2] Create Event: \" + createResp.status);",
    "        ",
    "        // User login",
    "        Response userLogin = api.login(new LoginRequest(\"user\", \"user123\"));",
    "        System.out.println(\"[3] User Login: \" + userLogin.status);",
    "        String userToken = (String) userLogin.body.get(\"token\");",
    "        String userId = (String) userLogin.body.get(\"userId\");",
    "        ",
    "        // User tries to create event (should fail)",
    "        Response userCreate = api.createEvent(",
    "            new CreateEventRequest(\"User Event\", \"2024-12-20T10:00:00Z\",",
    "                \"Some Venue\", 50, 25.0), userToken);",
    "        System.out.println(\"[4] User Create Event: \" + userCreate.status + \" (expected 403)\");",
    "        ",
    "        // User books tickets",
    "        Response booking = api.bookTickets(",
    "            new BookTicketsRequest(\"evt_001\", 2), userToken);",
    "        System.out.println(\"[5] Book Tickets: \" + booking.status);",
    "        ",
    "        // User views own bookings",
    "        Response myBookings = api.getUserBookings(userToken, userId);",
    "        System.out.println(\"[6] My Bookings: \" + myBookings.status);",
    "        ",
    "        // User tries to view admin's bookings (should fail)",
    "        Response otherBookings = api.getUserBookings(userToken, \"usr_001\");",
    "        System.out.println(\"[7] Other's Bookings: \" + otherBookings.status + \" (expected 403)\");",
    "        ",
    "        System.out.println(\"\\n======================================\");",
    "        System.out.println(\"DEMO COMPLETE\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-30",
      "explanation": "Imports and enum definitions for Role (GUEST, USER, ADMIN) and ErrorCode for standardized API errors"
    },
    {
      "lines": "32-55",
      "explanation": "PERMISSIONS dictionary - the centralized access control matrix defining which roles can perform which actions"
    },
    {
      "lines": "57-110",
      "explanation": "Data models: User (with hashed password), Session (for token tracking), LoginAttempt (for rate limiting), Event, Booking, Response"
    },
    {
      "lines": "130-180",
      "explanation": "Constructor and initialization - seeds test users (admin, user) with hashed passwords"
    },
    {
      "lines": "182-230",
      "explanation": "Security utilities: password hashing with SHA-256 + salt, token generation with HMAC signature, token validation checking expiry"
    },
    {
      "lines": "232-280",
      "explanation": "Rate limiting logic: tracks failed attempts, locks account after 5 failures for 15 minutes"
    },
    {
      "lines": "282-350",
      "explanation": "login() method - validates credentials, checks rate limit, generates token, creates session"
    },
    {
      "lines": "352-380",
      "explanation": "getCurrentUser() and logout() - token-based user info retrieval and session invalidation"
    },
    {
      "lines": "382-460",
      "explanation": "createEvent() - demonstrates admin-only authorization check before processing business logic"
    },
    {
      "lines": "462-550",
      "explanation": "bookTickets() - requires USER or ADMIN role, validates input, thread-safe ticket reservation"
    },
    {
      "lines": "552-620",
      "explanation": "getUserBookings() and cancelBooking() - ownership checks (own resource OR admin)"
    },
    {
      "lines": "622-700",
      "explanation": "Main demo showing complete authentication flow and authorization failures"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "login": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup for user, constant-time hash comparison"
        },
        "validateToken": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup for session, constant-time expiry check"
        },
        "authorize": {
          "complexity": "O(1)",
          "explanation": "Set membership check for role in permissions"
        },
        "getCurrentUser": {
          "complexity": "O(u)",
          "explanation": "Linear scan to find user by ID - could optimize with reverse index"
        },
        "getUserBookings": {
          "complexity": "O(b)",
          "explanation": "Where b is number of bookings for that user"
        }
      },
      "overall_change": "Authentication adds O(1) overhead per request. No change to Part 1 operation complexities."
    },
    "space": {
      "additional_space": "O(u + s + a)",
      "explanation": "u = users stored, s = active sessions (tokens), a = tracked login attempts. Sessions are bounded by user count and TTL. Login attempts are cleared on success or timeout."
    }
  },
  "dry_run": {
    "example_input": "Admin login, create event, user login, user tries create event, user books tickets",
    "steps": [
      {
        "step": 1,
        "action": "login(admin, admin123)",
        "state": "users: {admin: User}, sessions: {}",
        "explanation": "Hash password, compare with stored hash, match found"
      },
      {
        "step": 2,
        "action": "Generate token",
        "state": "token = 'usr_001:timestamp:ADMIN:sig'",
        "explanation": "Create payload, HMAC sign, store session with 1hr expiry"
      },
      {
        "step": 3,
        "action": "createEvent(event, admin_token)",
        "state": "Validate token \u2192 session.role == ADMIN",
        "explanation": "Token lookup succeeds, role check passes, event created"
      },
      {
        "step": 4,
        "action": "login(user, user123)",
        "state": "sessions: {admin_token: Session, user_token: Session}",
        "explanation": "Second user logs in, gets separate token"
      },
      {
        "step": 5,
        "action": "createEvent(event, user_token)",
        "state": "session.role == USER",
        "explanation": "Token valid but USER != ADMIN \u2192 403 FORBIDDEN returned"
      },
      {
        "step": 6,
        "action": "bookTickets(evt_001, 2, user_token)",
        "state": "PERMISSIONS['book_tickets'] = {USER, ADMIN}",
        "explanation": "USER is in allowed roles, proceed to booking logic from Part 1"
      }
    ],
    "final_output": "Admin creates event successfully, user blocked from creating events but can book tickets"
  },
  "edge_cases": [
    {
      "case": "Missing token on protected endpoint",
      "handling": "Return 401 UNAUTHORIZED with 'Invalid or expired token' message",
      "gotcha": "Don't leak whether endpoint exists - always return 401 for auth failure"
    },
    {
      "case": "Expired token",
      "handling": "Check session.expires_at, remove stale session, return 401",
      "gotcha": "Clean up expired sessions to prevent memory growth"
    },
    {
      "case": "User tries to cancel another user's booking",
      "handling": "Check booking.user_id == context.user_id OR context.role == ADMIN",
      "gotcha": "Ownership check must come AFTER authentication check"
    },
    {
      "case": "5+ failed login attempts",
      "handling": "Set locked_until timestamp, return 429 RATE_LIMITED with remaining lockout time",
      "gotcha": "Rate limit by username not IP to prevent account enumeration bypass"
    },
    {
      "case": "Valid token but user deleted",
      "handling": "Session exists but user lookup fails \u2192 return 401",
      "gotcha": "Always verify user still exists, not just that session is valid"
    },
    {
      "case": "GUEST trying to book",
      "handling": "GUEST not in PERMISSIONS['book_tickets'] \u2192 403",
      "gotcha": "GUEST role is implicit for unauthenticated requests, not a stored role"
    }
  ],
  "test_cases": [
    {
      "name": "Admin creates event successfully",
      "input": "login(admin, admin123) \u2192 createEvent(event, token)",
      "expected": "Status 201, eventId returned",
      "explanation": "Admin role passes authorization check"
    },
    {
      "name": "User blocked from creating event",
      "input": "login(user, user123) \u2192 createEvent(event, token)",
      "expected": "Status 403, 'Admin role required'",
      "explanation": "USER role fails ADMIN-only check"
    },
    {
      "name": "User views own bookings",
      "input": "getUserBookings(user_token, user_id)",
      "expected": "Status 200, bookings list",
      "explanation": "Ownership check passes (own resource)"
    },
    {
      "name": "User blocked from viewing other's bookings",
      "input": "getUserBookings(user_token, other_user_id)",
      "expected": "Status 403, 'Can only view your own bookings'",
      "explanation": "Not own resource AND not admin"
    },
    {
      "name": "Admin views any user's bookings",
      "input": "getUserBookings(admin_token, any_user_id)",
      "expected": "Status 200, bookings list",
      "explanation": "Admin bypasses ownership check"
    },
    {
      "name": "Rate limiting after failed attempts",
      "input": "5x login(admin, wrong_password)",
      "expected": "Attempt 1-5: 401, Attempt 6: 429 RATE_LIMITED",
      "explanation": "Account locked after MAX_LOGIN_ATTEMPTS"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking authorization before authentication",
      "why_wrong": "An attacker could probe for admin-only endpoints without valid credentials, leaking system structure",
      "correct_approach": "ALWAYS authenticate first (is token valid?), THEN authorize (does role permit?)",
      "code_example_wrong": "if user.role != ADMIN: return 403  # Wrong - user might be null!",
      "code_example_correct": "session = validateToken(token); if not session: return 401; if session.role != ADMIN: return 403"
    },
    {
      "mistake": "Storing passwords in plain text",
      "why_wrong": "Database breach exposes all user passwords directly",
      "correct_approach": "Always hash passwords with a salt. Production should use bcrypt/argon2, not SHA-256",
      "code_example_wrong": "user.password = request.password",
      "code_example_correct": "user.password_hash = hashPassword(request.password + SECRET_KEY)"
    },
    {
      "mistake": "Not checking resource ownership",
      "why_wrong": "Users could cancel or view any booking by guessing IDs (IDOR vulnerability)",
      "correct_approach": "After auth, verify resource.owner_id == current_user_id OR user is admin",
      "code_example_wrong": "booking = bookings.get(id); booking.cancel()  # Anyone can cancel anything!",
      "code_example_correct": "if booking.user_id != context.user_id and context.role != ADMIN: return 403"
    },
    {
      "mistake": "Token never expires",
      "why_wrong": "Stolen token provides permanent access; no way to revoke compromised credentials",
      "correct_approach": "Set expiration time on tokens (1 hour), check expiry on every request",
      "code_example_wrong": "sessions[token] = Session(user_id, role)  # No expiry",
      "code_example_correct": "sessions[token] = Session(user_id, role, expires_at=now + 1hr)"
    },
    {
      "mistake": "Returning different errors for 'user not found' vs 'wrong password'",
      "why_wrong": "Allows attackers to enumerate valid usernames",
      "correct_approach": "Return same generic 'Invalid credentials' for both cases",
      "code_example_wrong": "if not user: return 'User not found'; if wrong_pass: return 'Wrong password'",
      "code_example_correct": "if not user or wrong_password: return 'Invalid credentials'"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by drawing the access control matrix on the whiteboard. This immediately shows the interviewer you understand the requirements. Then explain the two-phase check: authentication (who are you?) then authorization (what can you do?). Finally, discuss the security considerations like rate limiting and ownership checks.",
    "what_to_mention": [
      "Security-first mindset: 'Never trust user input, always validate tokens before processing'",
      "Separation of concerns: 'Auth logic is separate from business logic via decorator/interceptor pattern'",
      "Defense in depth: 'Rate limiting + token expiry + ownership checks = multiple security layers'",
      "Production considerations: 'In real systems, I'd use bcrypt for passwords and JWT library for tokens'",
      "OWASP awareness: 'This prevents IDOR (Insecure Direct Object Reference) and brute-force attacks'"
    ],
    "time_allocation": "Spend 3-4 minutes on design/architecture, 8-10 minutes on implementation, 2-3 minutes on edge cases and security discussion",
    "if_stuck": [
      "Start with the access control matrix - it defines all requirements clearly",
      "Implement login first - everything else depends on having valid tokens",
      "For ownership checks, always ask: 'Is this user accessing THEIR resource OR are they admin?'",
      "If confused about token format, use simple 'userId:timestamp:role:signature' - don't overcomplicate"
    ]
  },
  "connection_to_next_part": "Part 3 will likely add **advanced concurrency handling** for flash sales (optimistic locking, distributed locks) or **event-driven architecture** (webhooks for booking confirmations, async processing). The auth system built here provides the user context needed to track who made what booking under high load. Consider how the rate limiting pattern could extend to per-user booking limits during high-demand events.",
  "generated_at": "2026-01-14T15:35:45.393648",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}