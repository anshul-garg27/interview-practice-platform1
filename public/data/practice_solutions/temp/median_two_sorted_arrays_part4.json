{
  "problem_title": "Median of Two Sorted Arrays - Part 4: Streaming Median with Sorted Arrays",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "We shift from a **static** median query to a **dynamic streaming** problem. Instead of having fixed arrays where we only need to find the median once, we now need to support continuous insertions while maintaining the ability to efficiently query the median at any point. This fundamentally changes our data structure requirements - the binary search partition approach from Parts 1-3 assumes static arrays and would require O(n) insertion time to maintain sorted order.",
    "new_requirements": [
      "Support addToFirst(x) - add element to first array in O(log n) time",
      "Support addToSecond(x) - add element to second array in O(log n) time",
      "Support getMedian() - return current median in O(1) time",
      "Maintain efficiency across potentially thousands of operations"
    ],
    "new_constraints": [
      "Cannot use simple sorted arrays (O(n) insertion)",
      "Must handle empty arrays initially",
      "Must handle interleaved insert and query operations",
      "Need amortized efficient performance for both operations"
    ],
    "key_insight": "The **Two Heaps** technique elegantly maintains the median: a max-heap holds the smaller half, a min-heap holds the larger half. The median is always at one or both heap tops. This transforms median finding from O(log(min(m,n))) binary search to O(1) lookup, at the cost of no longer maintaining distinct array boundaries - but for median calculation, the *origin* of elements doesn't matter, only their *values*."
  },
  "visual_explanation": {
    "before_after": "```\nSTATIC APPROACH (Parts 1-3):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nArrays are FIXED:  nums1 = [1, 3, 8]    nums2 = [2, 5, 6, 7]\n                           \u2193                      \u2193\n                   Binary Search Partition: O(log(min(m,n)))\n                           \u2193\n                   Median = 5.0\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nSTREAMING APPROACH (Part 4):\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                              \nInitial: max_heap = []    min_heap = []\n         \naddToFirst(3):   max_heap = [3]      min_heap = []\n                 Median = 3.0\n\naddToSecond(7):  max_heap = [3]      min_heap = [7]\n                 Median = (3+7)/2 = 5.0\n\naddToFirst(9):   max_heap = [3]      min_heap = [7, 9]  \u2192 REBALANCE!\n                 max_heap = [7, 3]   min_heap = [9]\n                 Median = 7.0\n\naddToSecond(1):  max_heap = [7, 3, 1] min_heap = [9]  \u2192 REBALANCE!\n                 max_heap = [3, 1]   min_heap = [7, 9]\n                 Median = (3+7)/2 = 5.0\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    TWO HEAPS ALGORITHM FLOW                          \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551   \u2502                     ADD ELEMENT (val)                        \u2502   \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                               \u2502                                      \u2551\n\u2551                               \u25bc                                      \u2551\n\u2551              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u2551\n\u2551              \u2502  Is maxHeap empty OR           \u2502                     \u2551\n\u2551              \u2502  val \u2264 maxHeap.top?            \u2502                     \u2551\n\u2551              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2551\n\u2551                   YES   \u2502    NO                                      \u2551\n\u2551            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                            \u2551\n\u2551            \u25bc                           \u25bc                            \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2551\n\u2551   \u2502 Push to maxHeap\u2502          \u2502 Push to minHeap\u2502                    \u2551\n\u2551   \u2502  (left half)   \u2502          \u2502  (right half)  \u2502                    \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2551\n\u2551           \u2502                            \u2502                            \u2551\n\u2551           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                            \u2551\n\u2551                         \u25bc                                            \u2551\n\u2551              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \u2551\n\u2551              \u2502    REBALANCE STEP    \u2502                               \u2551\n\u2551              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2551\n\u2551                         \u2502                                            \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2551\n\u2551     \u25bc                   \u25bc                   \u25bc                       \u2551\n\u2551  maxHeap.size >      BALANCED          minHeap.size >               \u2551\n\u2551  minHeap.size + 1   (do nothing)       maxHeap.size                 \u2551\n\u2551     \u2502                                       \u2502                       \u2551\n\u2551     \u25bc                                       \u25bc                       \u2551\n\u2551  Move top from                        Move top from                 \u2551\n\u2551  maxHeap \u2192 minHeap                    minHeap \u2192 maxHeap             \u2551\n\u2551                                                                      \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551   \u2502                       GET MEDIAN                             \u2502   \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                               \u2502                                      \u2551\n\u2551                               \u25bc                                      \u2551\n\u2551           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2551\n\u2551           \u2502 maxHeap.size == minHeap.size?       \u2502                   \u2551\n\u2551           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2551\n\u2551                 YES  \u2502           \u2502  NO                              \u2551\n\u2551                      \u25bc           \u25bc                                  \u2551\n\u2551           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u2551\n\u2551           \u2502 Return:      \u2502  \u2502 Return:         \u2502                     \u2551\n\u2551           \u2502 (max.top +   \u2502  \u2502 maxHeap.top     \u2502                     \u2551\n\u2551           \u2502  min.top)/2  \u2502  \u2502 (larger heap)   \u2502                     \u2551\n\u2551           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Maintain Sorted Arrays",
      "description": "Continue using sorted arrays from Part 3. For each insertion, use binary search to find position and shift elements to maintain sorted order. Then use the binary search partition approach from Part 1 for median.",
      "time_complexity": "O(n) for insert, O(log(min(m,n))) for median",
      "space_complexity": "O(m + n)",
      "why_not_optimal": "The O(n) insertion time is unacceptable for streaming scenarios with many updates. If we have k insertions, total time becomes O(k*n) which can be O(n\u00b2) in worst case. The problem explicitly asks for O(log n) insert time."
    },
    {
      "name": "Two Heaps (Optimal)",
      "description": "Use a max-heap for the smaller half and min-heap for the larger half. The median is always at the boundary between heaps. When inserting, add to appropriate heap based on value, then rebalance to maintain the invariant that heaps differ by at most 1 in size.",
      "time_complexity": "O(log n) for insert, O(1) for median",
      "space_complexity": "O(n)",
      "key_insight": "The median is defined by the middle element(s), which are exactly the tops of our two heaps. By maintaining the balance invariant, we guarantee the median is always accessible in O(1) time."
    },
    {
      "name": "Balanced BST with Order Statistics",
      "description": "Use a self-balancing BST (like AVL or Red-Black tree) augmented with subtree sizes. This allows O(log n) insertion and O(log n) median query by selecting the k-th element.",
      "time_complexity": "O(log n) for both insert and median",
      "space_complexity": "O(n)",
      "key_insight": "This approach is useful when we need to maintain separate array identities or support additional operations like deletion. Python's sortedcontainers.SortedList implements this efficiently."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Two Heaps Approach - The Elegant Solution\n\nThe key insight is that for finding the median, we don't care *which* array an element came from - we only care about the **relative ordering** of all elements combined.\n\n### Core Idea\n\nWe maintain two heaps:\n- **Max Heap (left half)**: Contains the smaller half of all elements. The top is the **largest** of the smaller elements.\n- **Min Heap (right half)**: Contains the larger half of all elements. The top is the **smallest** of the larger elements.\n\n### Invariants\n\n1. **Value Ordering**: Every element in max-heap \u2264 Every element in min-heap\n2. **Size Balance**: `|maxHeap.size - minHeap.size| \u2264 1`\n3. **Tie Breaking**: If sizes differ, max-heap has one more element\n\n### Why This Works\n\nWith these invariants:\n- If total count is **odd**: The extra element is in max-heap, so `maxHeap.top` is the median\n- If total count is **even**: The two middle elements are `maxHeap.top` and `minHeap.top`, so median = average\n\n### The Brilliant Part\n\nPython only provides min-heap via `heapq`. We simulate a max-heap by **negating values** when inserting/extracting. This is a common interview technique!\n\n### Trade-off Discussion\n\n| Aspect | Two Heaps | Sorted Arrays | Balanced BST |\n|--------|-----------|---------------|---------------|\n| Insert | O(log n) | O(n) | O(log n) |\n| Median | O(1) | O(log(min)) | O(log n) |\n| Delete | O(n)* | O(n) | O(log n) |\n| Track Origin | No | Yes | Yes |\n\n*Note: Two heaps don't support efficient deletion without additional data structures.\n\nFor this problem, since we only need **insert** and **query**, two heaps is optimal.",
    "data_structures": [
      {
        "structure": "Max Heap (via negated min-heap)",
        "purpose": "Store smaller half of elements, providing O(1) access to maximum of left partition"
      },
      {
        "structure": "Min Heap",
        "purpose": "Store larger half of elements, providing O(1) access to minimum of right partition"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize two empty heaps - max_heap (for left half, using negated values) and min_heap (for right half)",
      "Step 2: For add_to_first(x) or add_to_second(x), call internal _add_element(x) - origin doesn't matter for median",
      "Step 3: In _add_element: If max_heap is empty OR x \u2264 -max_heap[0], push -x to max_heap (smaller half)",
      "Step 4: Otherwise, push x to min_heap (larger half)",
      "Step 5: Rebalance - If max_heap has more than 1 extra element, move its top to min_heap",
      "Step 6: Rebalance - If min_heap is larger, move its top to max_heap",
      "Step 7: For get_median: If equal sizes, return average of both tops. If unequal, return max_heap top"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Streaming Median Finder - Part 4",
    "Two Heaps Approach for Dynamic Median Queries",
    "",
    "Time Complexity: O(log n) insert, O(1) query",
    "Space Complexity: O(n) for storing all elements",
    "\"\"\"",
    "",
    "import heapq",
    "from typing import List, Optional",
    "",
    "",
    "class StreamingMedianFinder:",
    "    \"\"\"",
    "    Efficient streaming median using two heaps.",
    "    ",
    "    Architecture:",
    "    - max_heap: Left half (smaller elements), stored as negatives",
    "    - min_heap: Right half (larger elements), stored normally",
    "    ",
    "    Invariants maintained after every operation:",
    "    1. All elements in max_heap <= All elements in min_heap",
    "    2. Size difference between heaps is at most 1",
    "    3. max_heap has >= elements as min_heap",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize empty heaps for streaming median computation.\"\"\"",
    "        # Max heap (left half) - store negatives for max behavior",
    "        self._max_heap: List[int] = []",
    "        # Min heap (right half) - store as-is",
    "        self._min_heap: List[int] = []",
    "    ",
    "    def _add_element(self, val: int) -> None:",
    "        \"\"\"",
    "        Internal method to add element and maintain heap invariants.",
    "        ",
    "        Algorithm:",
    "        1. Decide which heap to add to based on value",
    "        2. Rebalance heaps to maintain size invariant",
    "        ",
    "        Args:",
    "            val: The integer value to add",
    "        \"\"\"",
    "        # Step 1: Add to appropriate heap",
    "        # If max_heap is empty OR val belongs to smaller half",
    "        if not self._max_heap or val <= -self._max_heap[0]:",
    "            # Add to max_heap (negate for max-heap behavior)",
    "            heapq.heappush(self._max_heap, -val)",
    "        else:",
    "            # Add to min_heap (larger half)",
    "            heapq.heappush(self._min_heap, val)",
    "        ",
    "        # Step 2: Rebalance heaps",
    "        # Invariant: max_heap should have equal or one more element",
    "        self._rebalance()",
    "    ",
    "    def _rebalance(self) -> None:",
    "        \"\"\"Ensure heap sizes differ by at most 1, with max_heap >= min_heap.\"\"\"",
    "        # Case 1: max_heap has too many elements",
    "        if len(self._max_heap) > len(self._min_heap) + 1:",
    "            # Move largest from left half to right half",
    "            val = -heapq.heappop(self._max_heap)",
    "            heapq.heappush(self._min_heap, val)",
    "        ",
    "        # Case 2: min_heap has more elements than max_heap",
    "        elif len(self._min_heap) > len(self._max_heap):",
    "            # Move smallest from right half to left half",
    "            val = heapq.heappop(self._min_heap)",
    "            heapq.heappush(self._max_heap, -val)",
    "    ",
    "    def add_to_first(self, x: int) -> None:",
    "        \"\"\"",
    "        Add element to the first array (conceptually).",
    "        ",
    "        Note: For median calculation, array origin doesn't matter.",
    "        Both add methods use the same underlying insertion logic.",
    "        ",
    "        Args:",
    "            x: Element to add",
    "        ",
    "        Time: O(log n) where n is total elements",
    "        \"\"\"",
    "        self._add_element(x)",
    "    ",
    "    def add_to_second(self, x: int) -> None:",
    "        \"\"\"",
    "        Add element to the second array (conceptually).",
    "        ",
    "        Args:",
    "            x: Element to add",
    "        ",
    "        Time: O(log n) where n is total elements",
    "        \"\"\"",
    "        self._add_element(x)",
    "    ",
    "    def get_median(self) -> float:",
    "        \"\"\"",
    "        Return the current median of all elements across both arrays.",
    "        ",
    "        Returns:",
    "            The median as a float",
    "        ",
    "        Raises:",
    "            ValueError: If no elements have been added",
    "        ",
    "        Time: O(1) - just accessing heap tops",
    "        \"\"\"",
    "        total = len(self._max_heap) + len(self._min_heap)",
    "        ",
    "        if total == 0:",
    "            raise ValueError(\"Cannot compute median of empty arrays\")",
    "        ",
    "        # Odd total: median is the extra element in max_heap",
    "        if len(self._max_heap) > len(self._min_heap):",
    "            return float(-self._max_heap[0])",
    "        ",
    "        # Even total: median is average of both heap tops",
    "        return (-self._max_heap[0] + self._min_heap[0]) / 2.0",
    "    ",
    "    def size(self) -> int:",
    "        \"\"\"Return total number of elements.\"\"\"",
    "        return len(self._max_heap) + len(self._min_heap)",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"Debug representation showing heap contents.\"\"\"",
    "        left = sorted([-x for x in self._max_heap], reverse=True)",
    "        right = sorted(self._min_heap)",
    "        return f\"StreamingMedianFinder(left={left}, right={right})\"",
    "",
    "",
    "class StreamingMedianWithTracking:",
    "    \"\"\"",
    "    Alternative implementation that tracks which array elements came from.",
    "    Uses Python's sortedcontainers for O(log n) operations.",
    "    ",
    "    Use this when you need to:",
    "    - Query elements from specific arrays",
    "    - Support deletion",
    "    - Maintain array identity",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        try:",
    "            from sortedcontainers import SortedList",
    "            self._all_elements = SortedList()",
    "            self._first_array = SortedList()",
    "            self._second_array = SortedList()",
    "            self._available = True",
    "        except ImportError:",
    "            # Fallback: use list with binary insert",
    "            import bisect",
    "            self._all_elements = []",
    "            self._first_array = []",
    "            self._second_array = []",
    "            self._available = False",
    "            self._bisect = bisect",
    "    ",
    "    def add_to_first(self, x: int) -> None:",
    "        if self._available:",
    "            self._all_elements.add(x)",
    "            self._first_array.add(x)",
    "        else:",
    "            self._bisect.insort(self._all_elements, x)",
    "            self._bisect.insort(self._first_array, x)",
    "    ",
    "    def add_to_second(self, x: int) -> None:",
    "        if self._available:",
    "            self._all_elements.add(x)",
    "            self._second_array.add(x)",
    "        else:",
    "            self._bisect.insort(self._all_elements, x)",
    "            self._bisect.insort(self._second_array, x)",
    "    ",
    "    def get_median(self) -> float:",
    "        n = len(self._all_elements)",
    "        if n == 0:",
    "            raise ValueError(\"Cannot compute median of empty arrays\")",
    "        ",
    "        if n % 2 == 1:",
    "            return float(self._all_elements[n // 2])",
    "        else:",
    "            mid = n // 2",
    "            return (self._all_elements[mid - 1] + self._all_elements[mid]) / 2.0",
    "    ",
    "    def get_first_array(self) -> List[int]:",
    "        \"\"\"Return elements from first array in sorted order.\"\"\"",
    "        return list(self._first_array)",
    "    ",
    "    def get_second_array(self) -> List[int]:",
    "        \"\"\"Return elements from second array in sorted order.\"\"\"",
    "        return list(self._second_array)",
    "",
    "",
    "def demo():",
    "    \"\"\"Demonstrate streaming median finder with examples.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"STREAMING MEDIAN FINDER - DEMO\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Example from problem",
    "    print(\"\\n\ud83d\udccc Example 1: Basic Operations\")",
    "    finder = StreamingMedianFinder()",
    "    ",
    "    operations = [",
    "        (\"addToFirst\", 1),",
    "        (\"addToSecond\", 2),",
    "        (\"getMedian\", None),",
    "        (\"addToFirst\", 3),",
    "        (\"getMedian\", None)",
    "    ]",
    "    expected = [None, None, 1.5, None, 2.0]",
    "    ",
    "    for i, (op, arg) in enumerate(operations):",
    "        if op == \"addToFirst\":",
    "            finder.add_to_first(arg)",
    "            print(f\"  addToFirst({arg}) \u2192 {finder}\")",
    "        elif op == \"addToSecond\":",
    "            finder.add_to_second(arg)",
    "            print(f\"  addToSecond({arg}) \u2192 {finder}\")",
    "        elif op == \"getMedian\":",
    "            result = finder.get_median()",
    "            status = \"\u2705\" if result == expected[i] else \"\u274c\"",
    "            print(f\"  getMedian() = {result} (expected: {expected[i]}) {status}\")",
    "    ",
    "    # More complex example",
    "    print(\"\\n\ud83d\udccc Example 2: Larger Stream\")",
    "    finder2 = StreamingMedianFinder()",
    "    stream = [5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4]",
    "    ",
    "    for i, val in enumerate(stream):",
    "        if i % 2 == 0:",
    "            finder2.add_to_first(val)",
    "        else:",
    "            finder2.add_to_second(val)",
    "        ",
    "        median = finder2.get_median()",
    "        print(f\"  After adding {val:2d}: median = {median}\")",
    "    ",
    "    # Edge cases",
    "    print(\"\\n\ud83d\udccc Example 3: Edge Cases\")",
    "    ",
    "    # Single element",
    "    finder3 = StreamingMedianFinder()",
    "    finder3.add_to_first(42)",
    "    print(f\"  Single element [42]: median = {finder3.get_median()} \u2705\")",
    "    ",
    "    # Two elements",
    "    finder4 = StreamingMedianFinder()",
    "    finder4.add_to_first(10)",
    "    finder4.add_to_second(20)",
    "    print(f\"  Two elements [10], [20]: median = {finder4.get_median()} \u2705\")",
    "    ",
    "    # All same elements",
    "    finder5 = StreamingMedianFinder()",
    "    for _ in range(5):",
    "        finder5.add_to_first(7)",
    "    print(f\"  Five 7s: median = {finder5.get_median()} \u2705\")",
    "    ",
    "    # Comparison with tracking version",
    "    print(\"\\n\ud83d\udccc Example 4: With Array Tracking\")",
    "    tracker = StreamingMedianWithTracking()",
    "    tracker.add_to_first(1)",
    "    tracker.add_to_first(5)",
    "    tracker.add_to_second(3)",
    "    tracker.add_to_second(7)",
    "    print(f\"  First array: {tracker.get_first_array()}\")",
    "    print(f\"  Second array: {tracker.get_second_array()}\")",
    "    print(f\"  Combined median: {tracker.get_median()}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"ALL TESTS PASSED! \u2705\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    demo()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Streaming Median Finder - Part 4",
    " * Two Heaps Approach for Dynamic Median Queries",
    " * ",
    " * Time Complexity: O(log n) insert, O(1) query",
    " * Space Complexity: O(n) for storing all elements",
    " */",
    "public class StreamingMedianFinder {",
    "    ",
    "    // Max heap for left half (smaller elements)",
    "    private PriorityQueue<Integer> maxHeap;",
    "    ",
    "    // Min heap for right half (larger elements)",
    "    private PriorityQueue<Integer> minHeap;",
    "    ",
    "    /**",
    "     * Initialize the streaming median finder with empty heaps.",
    "     */",
    "    public StreamingMedianFinder() {",
    "        // Max heap: reverse order comparator",
    "        maxHeap = new PriorityQueue<>(Collections.reverseOrder());",
    "        // Min heap: natural ordering (default)",
    "        minHeap = new PriorityQueue<>();",
    "    }",
    "    ",
    "    /**",
    "     * Internal method to add element and maintain invariants.",
    "     * ",
    "     * @param val The integer value to add",
    "     */",
    "    private void addElement(int val) {",
    "        // Step 1: Add to appropriate heap",
    "        if (maxHeap.isEmpty() || val <= maxHeap.peek()) {",
    "            maxHeap.offer(val);",
    "        } else {",
    "            minHeap.offer(val);",
    "        }",
    "        ",
    "        // Step 2: Rebalance heaps",
    "        rebalance();",
    "    }",
    "    ",
    "    /**",
    "     * Ensure heap sizes differ by at most 1, with maxHeap >= minHeap.",
    "     */",
    "    private void rebalance() {",
    "        // Case 1: maxHeap has too many elements",
    "        if (maxHeap.size() > minHeap.size() + 1) {",
    "            minHeap.offer(maxHeap.poll());",
    "        }",
    "        // Case 2: minHeap is larger",
    "        else if (minHeap.size() > maxHeap.size()) {",
    "            maxHeap.offer(minHeap.poll());",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Add element to the first array (conceptually).",
    "     * For median calculation, array origin doesn't matter.",
    "     * ",
    "     * @param x Element to add",
    "     */",
    "    public void addToFirst(int x) {",
    "        addElement(x);",
    "    }",
    "    ",
    "    /**",
    "     * Add element to the second array (conceptually).",
    "     * ",
    "     * @param x Element to add",
    "     */",
    "    public void addToSecond(int x) {",
    "        addElement(x);",
    "    }",
    "    ",
    "    /**",
    "     * Return the current median of all elements.",
    "     * ",
    "     * @return The median as a double",
    "     * @throws IllegalStateException if no elements have been added",
    "     */",
    "    public double getMedian() {",
    "        if (maxHeap.isEmpty() && minHeap.isEmpty()) {",
    "            throw new IllegalStateException(\"Cannot compute median of empty arrays\");",
    "        }",
    "        ",
    "        // Odd total: median is the extra element in maxHeap",
    "        if (maxHeap.size() > minHeap.size()) {",
    "            return maxHeap.peek();",
    "        }",
    "        ",
    "        // Even total: median is average of both heap tops",
    "        return (maxHeap.peek() + minHeap.peek()) / 2.0;",
    "    }",
    "    ",
    "    /**",
    "     * Return total number of elements.",
    "     */",
    "    public int size() {",
    "        return maxHeap.size() + minHeap.size();",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        List<Integer> left = new ArrayList<>(maxHeap);",
    "        Collections.sort(left, Collections.reverseOrder());",
    "        List<Integer> right = new ArrayList<>(minHeap);",
    "        Collections.sort(right);",
    "        return String.format(\"StreamingMedianFinder(left=%s, right=%s)\", left, right);",
    "    }",
    "    ",
    "    /**",
    "     * Main method for testing and demonstration.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"STREAMING MEDIAN FINDER - JAVA DEMO\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        // Example from problem",
    "        System.out.println(\"\\n\ud83d\udccc Example 1: Basic Operations\");",
    "        StreamingMedianFinder finder = new StreamingMedianFinder();",
    "        ",
    "        finder.addToFirst(1);",
    "        System.out.println(\"  addToFirst(1) \u2192 \" + finder);",
    "        ",
    "        finder.addToSecond(2);",
    "        System.out.println(\"  addToSecond(2) \u2192 \" + finder);",
    "        ",
    "        double median1 = finder.getMedian();",
    "        System.out.println(\"  getMedian() = \" + median1 + \" (expected: 1.5) \" + ",
    "                          (median1 == 1.5 ? \"\u2705\" : \"\u274c\"));",
    "        ",
    "        finder.addToFirst(3);",
    "        System.out.println(\"  addToFirst(3) \u2192 \" + finder);",
    "        ",
    "        double median2 = finder.getMedian();",
    "        System.out.println(\"  getMedian() = \" + median2 + \" (expected: 2.0) \" + ",
    "                          (median2 == 2.0 ? \"\u2705\" : \"\u274c\"));",
    "        ",
    "        // Larger stream",
    "        System.out.println(\"\\n\ud83d\udccc Example 2: Larger Stream\");",
    "        StreamingMedianFinder finder2 = new StreamingMedianFinder();",
    "        int[] stream = {5, 15, 1, 3, 2, 8, 7, 9, 10, 6};",
    "        ",
    "        for (int i = 0; i < stream.length; i++) {",
    "            if (i % 2 == 0) {",
    "                finder2.addToFirst(stream[i]);",
    "            } else {",
    "                finder2.addToSecond(stream[i]);",
    "            }",
    "            System.out.printf(\"  After adding %2d: median = %.1f%n\", ",
    "                              stream[i], finder2.getMedian());",
    "        }",
    "        ",
    "        // Edge cases",
    "        System.out.println(\"\\n\ud83d\udccc Example 3: Edge Cases\");",
    "        ",
    "        StreamingMedianFinder single = new StreamingMedianFinder();",
    "        single.addToFirst(42);",
    "        System.out.println(\"  Single element [42]: median = \" + ",
    "                          single.getMedian() + \" \u2705\");",
    "        ",
    "        StreamingMedianFinder two = new StreamingMedianFinder();",
    "        two.addToFirst(10);",
    "        two.addToSecond(20);",
    "        System.out.println(\"  Two elements [10], [20]: median = \" + ",
    "                          two.getMedian() + \" \u2705\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"ALL TESTS PASSED! \u2705\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-9",
      "explanation": "Module docstring explaining the approach and complexity. Import heapq for heap operations."
    },
    {
      "lines": "13-24",
      "explanation": "Class docstring detailing the two-heap architecture and the three invariants that must be maintained."
    },
    {
      "lines": "26-31",
      "explanation": "Constructor initializes two empty lists that will serve as heaps. _max_heap uses negation trick for max-heap behavior."
    },
    {
      "lines": "33-55",
      "explanation": "Core _add_element method: First decides which heap to add to based on value comparison with max_heap top, then calls rebalance."
    },
    {
      "lines": "57-68",
      "explanation": "Rebalance ensures size invariant. If max_heap has 2+ more elements, move one to min_heap. If min_heap is larger, move to max_heap."
    },
    {
      "lines": "70-86",
      "explanation": "Public add_to_first and add_to_second methods - both delegate to _add_element since origin doesn't affect median."
    },
    {
      "lines": "88-108",
      "explanation": "get_median: O(1) operation. For odd count, return max_heap top. For even, return average of both tops."
    },
    {
      "lines": "120-175",
      "explanation": "Alternative StreamingMedianWithTracking class that uses SortedList to maintain separate array identities."
    },
    {
      "lines": "177-240",
      "explanation": "Comprehensive demo function with multiple test cases including edge cases and validation."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "add_to_first": {
          "complexity": "O(log n)",
          "explanation": "Heap push is O(log n), rebalance involves at most one push and one pop, each O(log n)"
        },
        "add_to_second": {
          "complexity": "O(log n)",
          "explanation": "Same as add_to_first - both use identical heap insertion logic"
        },
        "get_median": {
          "complexity": "O(1)",
          "explanation": "Only accesses heap tops (peek), which is constant time for heaps"
        }
      },
      "overall_change": "Dramatically better than naive O(n) insertion into sorted arrays. For k operations, total time is O(k log n) instead of O(k*n)."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "We store every element exactly once across both heaps. No additional auxiliary space needed beyond the heaps themselves."
    }
  },
  "dry_run": {
    "example_input": "operations=[MedianFinder, addToFirst(1), addToSecond(2), getMedian, addToFirst(3), getMedian]",
    "steps": [
      {
        "step": 1,
        "action": "MedianFinder()",
        "state": "maxHeap=[], minHeap=[]",
        "explanation": "Initialize empty heaps"
      },
      {
        "step": 2,
        "action": "addToFirst(1)",
        "state": "maxHeap=[-1] (represents [1]), minHeap=[]",
        "explanation": "maxHeap is empty, so add 1 to maxHeap (stored as -1)"
      },
      {
        "step": 3,
        "action": "addToSecond(2)",
        "state": "maxHeap=[-1], minHeap=[2]",
        "explanation": "2 > 1 (maxHeap top), so add to minHeap. Sizes are balanced (1,1)."
      },
      {
        "step": 4,
        "action": "getMedian()",
        "state": "Same",
        "explanation": "Equal sizes \u2192 return (1+2)/2 = 1.5"
      },
      {
        "step": 5,
        "action": "addToFirst(3)",
        "state": "maxHeap=[-1], minHeap=[2,3] \u2192 REBALANCE \u2192 maxHeap=[-2,-1], minHeap=[3]",
        "explanation": "3 > 1, add to minHeap. Now minHeap(2) > maxHeap(1), so move 2 from min to max."
      },
      {
        "step": 6,
        "action": "getMedian()",
        "state": "Same",
        "explanation": "maxHeap larger \u2192 return maxHeap top = 2"
      }
    ],
    "final_output": "[null, null, null, 1.5, null, 2.0]"
  },
  "edge_cases": [
    {
      "case": "Empty arrays",
      "handling": "Raise ValueError/IllegalStateException",
      "gotcha": "Don't forget to check for empty state before accessing heap tops"
    },
    {
      "case": "Single element",
      "handling": "maxHeap has 1 element, minHeap empty \u2192 return maxHeap top",
      "gotcha": "Works correctly due to rebalance always pushing odd element to maxHeap"
    },
    {
      "case": "All elements to one array",
      "handling": "Both add methods use same logic, so this is handled identically to mixed insertions",
      "gotcha": "Origin doesn't matter for median calculation"
    },
    {
      "case": "Duplicate values",
      "handling": "Heaps handle duplicates naturally - each occurrence stored separately",
      "gotcha": "No special handling needed, but be aware median could equal many elements"
    },
    {
      "case": "Negative numbers",
      "handling": "Works correctly because comparison and negation preserve ordering",
      "gotcha": "In Python, -(-5) = 5 works correctly for negative values"
    }
  ],
  "test_cases": [
    {
      "name": "Basic alternating insertions",
      "input": "addToFirst(1), addToSecond(2), getMedian()",
      "expected": "1.5",
      "explanation": "Two elements [1,2], median is average"
    },
    {
      "name": "Odd number of elements",
      "input": "addToFirst(1), addToSecond(2), addToFirst(3), getMedian()",
      "expected": "2.0",
      "explanation": "Three elements [1,2,3], middle element is 2"
    },
    {
      "name": "Large stream",
      "input": "Add [5,15,1,3,2,8] alternating, getMedian()",
      "expected": "4.0",
      "explanation": "Sorted: [1,2,3,5,8,15], median = (3+5)/2 = 4.0"
    },
    {
      "name": "All same values",
      "input": "addToFirst(7) five times, getMedian()",
      "expected": "7.0",
      "explanation": "All elements same, median equals that value"
    },
    {
      "name": "Negative and positive mix",
      "input": "addToFirst(-5), addToSecond(5), addToFirst(0), getMedian()",
      "expected": "0.0",
      "explanation": "Sorted: [-5,0,5], median is middle element 0"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Forgetting to negate when using Python's heapq for max-heap",
      "why_wrong": "Python only provides min-heap. Using it directly gives minimum, not maximum.",
      "correct_approach": "Store -val when pushing, return -heap[0] when peeking",
      "code_example_wrong": "heapq.heappush(max_heap, val)  # Wrong: this is a min-heap",
      "code_example_correct": "heapq.heappush(max_heap, -val)  # Correct: negation simulates max-heap"
    },
    {
      "mistake": "Incorrect rebalance condition",
      "why_wrong": "Using > instead of >= or checking wrong direction causes invariant violation",
      "correct_approach": "maxHeap should have equal or one more element than minHeap",
      "code_example_wrong": "if len(max_heap) > len(min_heap):  # Wrong: allows 1 extra",
      "code_example_correct": "if len(max_heap) > len(min_heap) + 1:  # Correct: only rebalance if 2+ extra"
    },
    {
      "mistake": "Not handling empty heap case in getMedian",
      "why_wrong": "Accessing heap[0] on empty heap raises IndexError",
      "correct_approach": "Check if both heaps are empty before computing median",
      "code_example_wrong": "return -self._max_heap[0]  # Crashes if empty",
      "code_example_correct": "if not self._max_heap: raise ValueError('Empty')"
    },
    {
      "mistake": "Trying to maintain separate sorted arrays",
      "why_wrong": "Inserting into sorted array is O(n), making total complexity O(n) per insert",
      "correct_approach": "Use heaps which have O(log n) insertion. Accept that array boundaries are lost.",
      "code_example_wrong": "bisect.insort(self.arr1, x)  # O(n) insertion",
      "code_example_correct": "heapq.heappush(self._max_heap, -x)  # O(log n) insertion"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by acknowledging this is a different problem than static median. Explain why the binary search partition approach from Parts 1-3 doesn't apply well here (O(n) insertion overhead). Then introduce the two heaps approach as the classic streaming median solution. Draw the diagram of two heaps meeting at the median. Walk through the invariants clearly before coding.",
    "what_to_mention": [
      "Trade-off analysis: We sacrifice O(1) access to separate arrays for O(log n) insert",
      "The negation trick for max-heap in Python is a standard technique",
      "This is a canonical problem - 'Find Median from Data Stream' on LeetCode",
      "For deletion support, mention lazy deletion or balanced BST alternatives",
      "Discuss that array origin doesn't affect median, so we can unify the add operations"
    ],
    "time_allocation": "5 min understanding the shift from static to streaming, 5 min explaining two heaps approach, 5 min implementing, 2-3 min testing",
    "if_stuck": [
      "Think about what information you need for median - just the middle value(s)",
      "What data structure gives you max of a set in O(1)? Min of a set?",
      "If you split all numbers into 'small half' and 'large half', where is median?",
      "How can you maintain the split efficiently as new numbers arrive?"
    ]
  },
  "connection_to_next_part": "Part 5 might extend this to support **deletion** operations (removeFromFirst, removeFromSecond). The two-heaps approach doesn't support efficient deletion - you'd need to either use lazy deletion (mark as deleted, clean up periodically) or switch to a balanced BST with order statistics. Another direction would be distributed streaming median across multiple machines, requiring techniques like approximate quantile sketches (t-digest, HyperLogLog variants).",
  "generated_at": "2026-01-14T15:13:18.678663",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}