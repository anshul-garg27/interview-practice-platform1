{
  "problem_title": "Parking Lot System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic LLD/OOP Design problem** that tests your ability to model real-world entities and design efficient allocation algorithms. The key challenge is achieving O(log n) spot allocation while maintaining the \"lowest floor, lowest spot\" ordering requirement. This separates candidates who just code from those who think about efficiency.",
    "pattern_recognition": "**MinHeap + HashMap + OOP Design**. This combines: (1) MinHeap for ordered resource allocation, (2) HashMap for O(1) ticket lookups, (3) Clean OOP modeling with proper encapsulation and single responsibility.",
    "key_constraints": [
      "**Lowest floor, lowest spot first** - Forces ordered allocation. Random assignment won't work. MinHeap ordered by (floor, spot) is the key insight.",
      "**Vehicle-Spot compatibility** - Motorcycle can use any spot, Car needs Compact+, Truck needs Large only. Must check heaps in preference order.",
      "**O(log n) or O(1) operations** - Cannot iterate all spots on each park. Heap gives O(log n) allocation.",
      "**Fee rounding** - Round UP partial hours. 30 min = 1 hour. Common mistake is to truncate.",
      "**Spot reuse** - When unparking, spot must return to correct heap based on SPOT type, not vehicle type."
    ],
    "clarifying_questions": [
      "**What vehicle and spot types do we support?** - Reveals scope. Motorcycle/Car/Truck and Small/Compact/Large.",
      "**Is there a preference for spot selection?** - Critical! Lowest floor first, then lowest spot number.",
      "**Can vehicles use larger spots?** - Yes: Motorcycle â†’ any, Car â†’ Compact/Large, Truck â†’ Large only.",
      "**How is fee calculated?** - Hourly rates, round UP partial hours. Motorcycle $1, Car $2, Truck $3.",
      "**What happens when lot is full?** - Return None or throw exception.",
      "**Single-threaded or concurrent?** - Start with single-threaded, discuss concurrency as follow-up."
    ],
    "edge_cases_to_consider": [
      "Parking lot is completely full",
      "No spot available for specific vehicle type (e.g., no Large spots for Truck)",
      "Invalid ticket ID on unpark",
      "Zero-duration parking (immediate unpark)",
      "Vehicle type can't fit anywhere (all spots smaller)",
      "Same vehicle trying to park twice"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                      PARKING LOT SYSTEM OVERVIEW                         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                          â”‚\nâ”‚   FLOOR 1 (Ground - Fill First):                                        â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”        â”‚\nâ”‚   â”‚  S  â”‚  S  â”‚  C  â”‚  C  â”‚  C  â”‚  C  â”‚  L  â”‚  L  â”‚  L  â”‚  L  â”‚        â”‚\nâ”‚   â”‚  1  â”‚  2  â”‚  3  â”‚  4  â”‚  5  â”‚  6  â”‚  7  â”‚  8  â”‚  9  â”‚ 10  â”‚        â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜        â”‚\nâ”‚     â–²         â–²               â–²                                         â”‚\nâ”‚   Small     Compact         Large                                       â”‚\nâ”‚   (Moto)   (Moto,Car)    (Moto,Car,Truck)                              â”‚\nâ”‚                                                                          â”‚\nâ”‚   FLOOR 2 (Fill After Floor 1):                                         â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”        â”‚\nâ”‚   â”‚  S  â”‚  C  â”‚  C  â”‚  L  â”‚  L  â”‚  L  â”‚  L  â”‚  L  â”‚  L  â”‚  L  â”‚        â”‚\nâ”‚   â”‚  1  â”‚  2  â”‚  3  â”‚  4  â”‚  5  â”‚  6  â”‚  7  â”‚  8  â”‚  9  â”‚ 10  â”‚        â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜        â”‚\nâ”‚                                                                          â”‚\nâ”‚   ALLOCATION PRIORITY:                                                   â”‚\nâ”‚   1. Lowest floor number                                                 â”‚\nâ”‚   2. Smallest spot that fits vehicle                                     â”‚\nâ”‚   3. Lowest spot number                                                  â”‚\nâ”‚                                                                          â”‚\nâ”‚   VEHICLE COMPATIBILITY:                                                 â”‚\nâ”‚   ğŸï¸ Motorcycle â†’ S, C, or L (prefers S)                                â”‚\nâ”‚   ğŸš— Car â†’ C or L (prefers C)                                           â”‚\nâ”‚   ğŸšš Truck â†’ L only                                                     â”‚\nâ”‚                                                                          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```",
    "data_structure_state": "```\n                    DATA STRUCTURE STATES\n                    \nINITIAL STATE (Empty lot with 2 floors, 5 spots each):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  available_small:   MinHeap[(1,1), (1,2), (2,1)]                        â”‚\nâ”‚  available_compact: MinHeap[(1,3), (1,4), (2,2), (2,3)]                 â”‚\nâ”‚  available_large:   MinHeap[(1,5), (2,4), (2,5)]                        â”‚\nâ”‚  active_tickets:    {}                                                  â”‚\nâ”‚  occupied:          {1: 0, 2: 0}                                        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAFTER parkVehicle(Car, 'ABC-123'):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  available_small:   MinHeap[(1,1), (1,2), (2,1)]                        â”‚\nâ”‚  available_compact: MinHeap[(1,4), (2,2), (2,3)]  â† (1,3) REMOVED       â”‚\nâ”‚  available_large:   MinHeap[(1,5), (2,4), (2,5)]                        â”‚\nâ”‚  active_tickets:    {                                                   â”‚\nâ”‚      'T1': Session(car, spot=(1,3), entry=10:00)  â† NEW                 â”‚\nâ”‚  }                                                                      â”‚\nâ”‚  occupied:          {1: 1, 2: 0}  â† Floor 1 incremented                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAFTER parkVehicle(Motorcycle, 'XYZ-789'):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  available_small:   MinHeap[(1,2), (2,1)]  â† (1,1) REMOVED              â”‚\nâ”‚  available_compact: MinHeap[(1,4), (2,2), (2,3)]                        â”‚\nâ”‚  available_large:   MinHeap[(1,5), (2,4), (2,5)]                        â”‚\nâ”‚  active_tickets:    {                                                   â”‚\nâ”‚      'T1': Session(car, spot=(1,3), entry=10:00),                       â”‚\nâ”‚      'T2': Session(moto, spot=(1,1), entry=10:15)  â† NEW                â”‚\nâ”‚  }                                                                      â”‚\nâ”‚  occupied:          {1: 2, 2: 0}                                        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nAFTER unparkVehicle('T1'):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  available_small:   MinHeap[(1,2), (2,1)]                               â”‚\nâ”‚  available_compact: MinHeap[(1,3), (1,4), (2,2), (2,3)]  â† (1,3) BACK!  â”‚\nâ”‚  available_large:   MinHeap[(1,5), (2,4), (2,5)]                        â”‚\nâ”‚  active_tickets:    {                                                   â”‚\nâ”‚      'T2': Session(moto, spot=(1,1), entry=10:15)  â† T1 REMOVED         â”‚\nâ”‚  }                                                                      â”‚\nâ”‚  occupied:          {1: 1, 2: 0}  â† Floor 1 decremented                 â”‚\nâ”‚                                                                         â”‚\nâ”‚  RETURNED: Receipt(ticket='T1', duration=1hr, fee=$2.00)                â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**Initialize**: Create MinHeaps for each spot type, populate with (floor, spot) tuples",
        "visualization": "```\navailable_small = MinHeap([(1,1), (1,2), (2,1)])\navailable_compact = MinHeap([(1,3), (1,4), (2,2)])\navailable_large = MinHeap([(1,5), (2,3)])\n```",
        "key_point": "Heap ordering ensures lowest floor & spot comes first"
      },
      {
        "step": 2,
        "description": "**parkVehicle**: Determine compatible spot types, try heaps in preference order",
        "visualization": "```\nif vehicle == MOTORCYCLE:\n    try: small_heap.pop()    # Prefer smallest\n    else: compact_heap.pop()\n    else: large_heap.pop()\n\nif vehicle == CAR:\n    try: compact_heap.pop()  # Can't use small\n    else: large_heap.pop()\n\nif vehicle == TRUCK:\n    try: large_heap.pop()    # Only option\n```",
        "key_point": "Check heaps in order of preference (smallest first)"
      },
      {
        "step": 3,
        "description": "**Create Ticket**: Store session with vehicle, spot, and entry time",
        "visualization": "```\nticket_id = generate_unique_id()\nsession = ParkingSession(\n    vehicle=vehicle,\n    spot=Spot(floor, number, type),\n    entry_time=now()\n)\nactive_tickets[ticket_id] = session\noccupied[floor] += 1\nreturn Ticket(ticket_id, floor, number)\n```",
        "key_point": "HashMap allows O(1) lookup on unpark"
      },
      {
        "step": 4,
        "description": "**unparkVehicle**: Lookup session, calculate fee, return spot to heap",
        "visualization": "```\nsession = active_tickets.pop(ticket_id)  # O(1)\n\n# Calculate fee (round UP!)\nhours = ceil((now() - session.entry_time).seconds / 3600)\nfee = hours * RATES[session.vehicle.type]\n\n# Return spot to CORRECT heap (by spot type, not vehicle type!)\navailable[session.spot.type].push((floor, number))  # O(log n)\n\noccupied[floor] -= 1\nreturn Receipt(ticket_id, hours, fee)\n```",
        "key_point": "Return spot to heap based on SPOT type"
      }
    ],
    "dry_run_table": "| Step | Operation | Heap State (simplified) | Active Tickets | Occupied | Result |\n|------|-----------|------------------------|----------------|----------|--------|\n| 0 | Init (2 floors) | S:[(1,1),(1,2)], C:[(1,3)], L:[(1,4)] | {} | {1:0, 2:0} | Lot ready |\n| 1 | parkVehicle(Car, 'A') | S:[(1,1),(1,2)], **C:[]**, L:[(1,4)] | {T1: (Car,1,3)} | {1:1, 2:0} | Ticket(T1,1,3) |\n| 2 | parkVehicle(Moto, 'B') | **S:[(1,2)]**, C:[], L:[(1,4)] | {T1,T2: (Moto,1,1)} | {1:2, 2:0} | Ticket(T2,1,1) |\n| 3 | parkVehicle(Truck, 'C') | S:[(1,2)], C:[], **L:[]** | {T1,T2,T3: (Truck,1,4)} | {1:3, 2:0} | Ticket(T3,1,4) |\n| 4 | getAvailableSpots(CAR) | (count C + L heaps) | - | - | **1** (spot 1,2 is Small) |\n| 5 | unparkVehicle(T1) | S:[(1,2)], **C:[(1,3)]**, L:[] | {T2,T3} | {1:2, 2:0} | Receipt($2) |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'lowest floor, lowest spot first'**, I immediately think: this is an ORDERING problem. I need a data structure that gives me the minimum efficiently. MinHeap is perfect!",
      "**When I see 'different spot types with compatibility'**, I think: I need SEPARATE heaps for each spot type. Then I can check them in preference order.",
      "**When I see 'motorcycle can use any spot'**, I think: motorcycles should TRY small first, then compact, then large. This reduces fragmentation.",
      "**When I see 'O(log n) or O(1) operations'**, I think: heap pop/push is O(log n), HashMap lookup is O(1). Both meet the requirement.",
      "**When I see 'unpark by ticket ID'**, I think: I need O(1) lookup. HashMap<ticketId, Session> is perfect.",
      "**The data structure emerges**: Three MinHeaps + One HashMap + Floor occupancy counter."
    ],
    "key_insight": "## The Aha! Moment\n\nThe constraint **'lowest floor, lowest spot'** is the puzzle key. The naive approach iterates all floors and spots:\n\n```python\n# âŒ WRONG - O(n) per park\nfor floor in floors:\n    for spot in floor.spots:\n        if spot.available and spot.fits(vehicle):\n            return spot  # O(n)!\n```\n\nBut with 10,000 spots and frequent parking, this is too slow.\n\n**The insight**: A MinHeap naturally orders by (floor, spot_number), so popping gives the 'best' spot instantly:\n\n```python\n# âœ… CORRECT - O(log n)\nspot = available_compact.pop()  # Always returns lowest floor, lowest spot!\n```\n\nHaving SEPARATE heaps per spot type also solves the compatibility problem elegantly:\n- Motorcycle: Try `small` heap â†’ `compact` heap â†’ `large` heap\n- Car: Try `compact` heap â†’ `large` heap\n- Truck: Try `large` heap only",
    "why_this_works": "## Why This Approach is Correct\n\n1. **Correctness**: MinHeap ordering by (floor, spot) guarantees we always get the lowest floor first, then lowest spot.\n\n2. **Efficiency**: \n   - parkVehicle: O(log n) - heap pop\n   - unparkVehicle: O(log n) - heap push + O(1) HashMap lookup\n   - getAvailableSpots: O(1) - just return heap sizes\n\n3. **Spot Preference**: Checking heaps in order (Small â†’ Compact â†’ Large for motorcycles) ensures we always use the smallest fitting spot.\n\n4. **Correct Spot Recycling**: When unparking, we push to heap based on SPOT type (from session.spot), not vehicle type. This prevents corruption."
  },
  "approaches": [
    {
      "name": "Brute Force - Linear Scan",
      "description": "Iterate through all floors and spots on every park operation to find the first available spot.",
      "pseudocode": "```\ndef park_vehicle(vehicle):\n    for floor in range(1, num_floors + 1):\n        for spot in floor.spots:\n            if spot.available and spot.fits(vehicle):\n                spot.available = False\n                return Ticket(floor, spot.number)\n    return None\n```",
      "time_complexity": "O(n) per park, where n = total spots",
      "space_complexity": "O(n) to store all spots",
      "pros": [
        "Simple to implement",
        "Easy to understand",
        "Naturally gives lowest floor, lowest spot"
      ],
      "cons": [
        "**FAILS performance requirement** - O(n) per operation",
        "Slow with 10,000 spots",
        "Gets worse as lot fills up (must scan all occupied spots)"
      ],
      "when_to_use": "Only acceptable for very small parking lots (< 100 spots)"
    },
    {
      "name": "Optimal: MinHeap per Spot Type",
      "description": "Use separate MinHeaps for each spot type, ordered by (floor, spot_number). Pop from heap to allocate, push to heap on deallocation.",
      "pseudocode": "```\nclass ParkingLot:\n    def __init__(self):\n        self.available = {\n            SMALL: MinHeap(),   # [(floor, spot), ...]\n            COMPACT: MinHeap(),\n            LARGE: MinHeap()\n        }\n        self.tickets = {}  # ticketId â†’ Session\n    \n    def park_vehicle(vehicle):\n        heaps_to_try = get_compatible_heaps(vehicle.type)\n        for heap in heaps_to_try:\n            if heap:\n                floor, spot = heap.pop()  # O(log n)\n                ticket = create_ticket(floor, spot)\n                self.tickets[ticket.id] = Session(vehicle, spot)\n                return ticket\n        return None\n    \n    def unpark_vehicle(ticket_id):\n        session = self.tickets.pop(ticket_id)  # O(1)\n        heap = self.available[session.spot.type]\n        heap.push((session.spot.floor, session.spot.number))  # O(log n)\n        return calculate_receipt(session)\n```",
      "time_complexity": "O(log n) for park and unpark",
      "space_complexity": "O(n) total spots",
      "pros": [
        "**Meets O(log n) requirement**",
        "Efficient allocation regardless of lot size",
        "Clean separation of spot types"
      ],
      "cons": [
        "Slightly more complex to implement",
        "Requires careful handling of spot type on unpark"
      ],
      "key_insight": "**The heap naturally maintains ordering** - no explicit sorting needed. Pop always gives minimum (lowest floor, lowest spot)."
    }
  ],
  "optimal_solution": {
    "name": "MinHeap per Spot Type with HashMap Ticket Tracking",
    "explanation_md": "## Solution Overview\n\nThe optimal solution uses three key data structures:\n\n### 1. MinHeaps for Spot Allocation\n```\navailable_small:   [(1,1), (1,2), (2,1)]  â† Sorted by (floor, spot)\navailable_compact: [(1,3), (1,4), (2,2)]\navailable_large:   [(1,5), (2,3), (2,4)]\n```\n\nPopping from heap always returns the lowest floor, lowest spot number. O(log n).\n\n### 2. HashMap for Ticket Lookup\n```\nactive_tickets = {\n    'T1': Session(vehicle=Car, spot=(1,3), entry=10:00),\n    'T2': Session(vehicle=Moto, spot=(1,1), entry=10:15)\n}\n```\n\nO(1) lookup when unparking.\n\n### 3. Floor Occupancy Counter\n```\noccupied = {1: 2, 2: 0}  # floor â†’ count\n```\n\nO(1) for getOccupiedSpots().\n\n### Why This Design?\n\n| Operation | Brute Force | Optimal |\n|-----------|-------------|----------|\n| parkVehicle | O(n) scan | O(log n) heap pop |\n| unparkVehicle | O(n) search | O(1) lookup + O(log n) push |\n| getAvailableSpots | O(n) count | O(1) heap sizes |",
    "data_structures": [
      {
        "structure": "MinHeap<(floor, spot)> for each SpotType",
        "purpose": "O(log n) allocation of lowest available spot. Separate heaps allow vehicle-specific preference order."
      },
      {
        "structure": "HashMap<ticketId, ParkingSession>",
        "purpose": "O(1) lookup of parking session when unparking. Session stores vehicle, spot, and entry time."
      },
      {
        "structure": "Dict<floor, count> for occupancy",
        "purpose": "O(1) query of occupied spots per floor. Updated on park/unpark."
      }
    ],
    "algorithm_steps": [
      "**1. Initialize**: Create MinHeap per spot type, populate with (floor, spot) tuples from configuration.",
      "**2. parkVehicle**: Get compatible spot types for vehicle. Try heaps in preference order. Pop from first non-empty heap. Create ticket, store session, update occupancy.",
      "**3. unparkVehicle**: Look up session by ticket ID (O(1)). Calculate duration and fee. Push spot back to correct heap (by spot.type). Update occupancy. Return receipt.",
      "**4. getAvailableSpots**: Sum sizes of compatible heaps for vehicle type.",
      "**5. getOccupiedSpots**: Return the occupancy counter directly."
    ],
    "why_heap": "## Why MinHeap is the Right Choice\n\n### The Ordering Requirement\nThe problem says: \"lowest floor first, then lowest spot number\"\n\nThis is EXACTLY what a MinHeap gives us when we order by (floor, spot_number):\n```\nHeap: [(1,1), (1,3), (2,1), (2,5)]\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n        Ordered: (1,1) < (1,3) < (2,1) < (2,5)\n```\n\n### Alternative: Sorted List?\nYou could use a sorted list, but:\n- Insert is O(n) (need to maintain order)\n- Delete arbitrary element is O(n)\n\nHeap is better:\n- Insert (push): O(log n)\n- Delete min (pop): O(log n)"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Parking Lot System",
    "",
    "A production-quality implementation of a multi-floor parking lot system",
    "with O(log n) allocation using MinHeaps.",
    "",
    "Author: Interview Solution",
    "Time Complexity: O(log n) for park/unpark",
    "Space Complexity: O(n) where n = total spots",
    "\"\"\"",
    "",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Optional, Tuple",
    "from datetime import datetime",
    "import heapq",
    "from math import ceil",
    "import uuid",
    "",
    "",
    "# ============================================================",
    "# ENUMS",
    "# ============================================================",
    "",
    "class VehicleType(Enum):",
    "    \"\"\"Types of vehicles that can park.\"\"\"",
    "    MOTORCYCLE = 1",
    "    CAR = 2",
    "    TRUCK = 3",
    "",
    "",
    "class SpotType(Enum):",
    "    \"\"\"Types of parking spots. Order matters for heap preference.\"\"\"",
    "    SMALL = 1      # Motorcycles only",
    "    COMPACT = 2    # Motorcycles and Cars",
    "    LARGE = 3      # All vehicles including Trucks",
    "",
    "",
    "# ============================================================",
    "# VALUE OBJECTS",
    "# ============================================================",
    "",
    "@dataclass",
    "class Vehicle:",
    "    \"\"\"Represents a vehicle to be parked.\"\"\"",
    "    vehicle_type: VehicleType",
    "    license_plate: str",
    "",
    "",
    "@dataclass",
    "class ParkingSpot:",
    "    \"\"\"Represents a parking spot in the lot.\"\"\"",
    "    floor: int",
    "    spot_number: int",
    "    spot_type: SpotType",
    "",
    "",
    "@dataclass",
    "class Ticket:",
    "    \"\"\"Issued when a vehicle parks successfully.\"\"\"",
    "    ticket_id: str",
    "    floor: int",
    "    spot_number: int",
    "    entry_time: datetime",
    "    vehicle_type: VehicleType",
    "    license_plate: str",
    "",
    "",
    "@dataclass",
    "class Receipt:",
    "    \"\"\"Issued when a vehicle exits the lot.\"\"\"",
    "    ticket_id: str",
    "    entry_time: datetime",
    "    exit_time: datetime",
    "    duration_hours: int",
    "    fee: float",
    "",
    "",
    "@dataclass",
    "class ParkingSession:",
    "    \"\"\"Internal tracking of an active parking session.\"\"\"",
    "    vehicle: Vehicle",
    "    spot: ParkingSpot",
    "    entry_time: datetime",
    "",
    "",
    "# ============================================================",
    "# MAIN PARKING LOT CLASS",
    "# ============================================================",
    "",
    "class ParkingLot:",
    "    \"\"\"",
    "    Multi-floor Parking Lot System.",
    "    ",
    "    Key Design Decisions:",
    "        1. MinHeaps per spot type for O(log n) allocation",
    "        2. HashMap for O(1) ticket lookup on unpark",
    "        3. Separate heaps allow vehicle-type preference order",
    "    ",
    "    Time Complexity:",
    "        - parkVehicle: O(log n)",
    "        - unparkVehicle: O(log n)",
    "        - getAvailableSpots: O(1)",
    "    ",
    "    Example:",
    "        >>> lot = ParkingLot.create_default(2, 5)",
    "        >>> car = Vehicle(VehicleType.CAR, 'ABC-123')",
    "        >>> ticket = lot.park_vehicle(car)",
    "        >>> print(ticket.floor, ticket.spot_number)",
    "        1 3",
    "    \"\"\"",
    "    ",
    "    # Fee rates per hour by vehicle type",
    "    HOURLY_RATES: Dict[VehicleType, float] = {",
    "        VehicleType.MOTORCYCLE: 1.0,",
    "        VehicleType.CAR: 2.0,",
    "        VehicleType.TRUCK: 3.0,",
    "    }",
    "    ",
    "    # Which spot types can each vehicle use (in preference order)",
    "    VEHICLE_SPOT_COMPATIBILITY: Dict[VehicleType, List[SpotType]] = {",
    "        VehicleType.MOTORCYCLE: [SpotType.SMALL, SpotType.COMPACT, SpotType.LARGE],",
    "        VehicleType.CAR: [SpotType.COMPACT, SpotType.LARGE],",
    "        VehicleType.TRUCK: [SpotType.LARGE],",
    "    }",
    "    ",
    "    def __init__(self, spots_config: List[List[SpotType]]):",
    "        \"\"\"",
    "        Initialize parking lot with given spot configuration.",
    "        ",
    "        Args:",
    "            spots_config: List of spot types per floor.",
    "                         e.g., [[SMALL, COMPACT, LARGE], [SMALL, LARGE]]",
    "        \"\"\"",
    "        # MinHeap per spot type: stores (floor, spot_number) tuples",
    "        # Python heapq is a min-heap, so (1, 3) < (1, 5) < (2, 1)",
    "        self._available: Dict[SpotType, List[Tuple[int, int]]] = {",
    "            SpotType.SMALL: [],",
    "            SpotType.COMPACT: [],",
    "            SpotType.LARGE: [],",
    "        }",
    "        ",
    "        # Store spot metadata for type lookup on unpark",
    "        self._spot_types: Dict[Tuple[int, int], SpotType] = {}",
    "        ",
    "        # Active parking sessions: ticketId -> ParkingSession",
    "        self._active_tickets: Dict[str, ParkingSession] = {}",
    "        ",
    "        # Occupied count per floor for quick queries",
    "        self._occupied_per_floor: Dict[int, int] = {}",
    "        ",
    "        # Total spots per floor for capacity checks",
    "        self._total_per_floor: Dict[int, int] = {}",
    "        ",
    "        # Initialize floors with spots",
    "        for floor_num, floor_spots in enumerate(spots_config, start=1):",
    "            self._occupied_per_floor[floor_num] = 0",
    "            self._total_per_floor[floor_num] = len(floor_spots)",
    "            ",
    "            for spot_num, spot_type in enumerate(floor_spots, start=1):",
    "                # Push to appropriate heap",
    "                heapq.heappush(",
    "                    self._available[spot_type],",
    "                    (floor_num, spot_num)",
    "                )",
    "                # Store spot type for later lookup",
    "                self._spot_types[(floor_num, spot_num)] = spot_type",
    "    ",
    "    @classmethod",
    "    def create_default(cls, num_floors: int, spots_per_floor: int) -> 'ParkingLot':",
    "        \"\"\"",
    "        Factory method to create a parking lot with default spot distribution.",
    "        ",
    "        Distribution: 20% Small, 40% Compact, 40% Large",
    "        \"\"\"",
    "        spots_config = []",
    "        for _ in range(num_floors):",
    "            floor_spots = []",
    "            num_small = spots_per_floor // 5      # 20%",
    "            num_compact = spots_per_floor * 2 // 5  # 40%",
    "            num_large = spots_per_floor - num_small - num_compact  # 40%",
    "            ",
    "            floor_spots.extend([SpotType.SMALL] * num_small)",
    "            floor_spots.extend([SpotType.COMPACT] * num_compact)",
    "            floor_spots.extend([SpotType.LARGE] * num_large)",
    "            spots_config.append(floor_spots)",
    "        ",
    "        return cls(spots_config)",
    "    ",
    "    def park_vehicle(self, vehicle: Vehicle) -> Optional[Ticket]:",
    "        \"\"\"",
    "        Park a vehicle in the lot.",
    "        ",
    "        Args:",
    "            vehicle: Vehicle to park",
    "        ",
    "        Returns:",
    "            Ticket if parking successful, None if no spot available",
    "        ",
    "        Time Complexity: O(log n) - heap pop",
    "        \"\"\"",
    "        # Get compatible spot types in preference order",
    "        compatible_types = self.VEHICLE_SPOT_COMPATIBILITY[vehicle.vehicle_type]",
    "        ",
    "        # Try each spot type in order (smallest first)",
    "        for spot_type in compatible_types:",
    "            heap = self._available[spot_type]",
    "            if heap:  # If heap is not empty",
    "                # Pop the lowest (floor, spot) from heap",
    "                floor, spot_num = heapq.heappop(heap)",
    "                ",
    "                # Create ticket",
    "                ticket_id = self._generate_ticket_id()",
    "                entry_time = datetime.now()",
    "                ",
    "                ticket = Ticket(",
    "                    ticket_id=ticket_id,",
    "                    floor=floor,",
    "                    spot_number=spot_num,",
    "                    entry_time=entry_time,",
    "                    vehicle_type=vehicle.vehicle_type,",
    "                    license_plate=vehicle.license_plate",
    "                )",
    "                ",
    "                # Store parking session",
    "                spot = ParkingSpot(floor, spot_num, spot_type)",
    "                session = ParkingSession(",
    "                    vehicle=vehicle,",
    "                    spot=spot,",
    "                    entry_time=entry_time",
    "                )",
    "                self._active_tickets[ticket_id] = session",
    "                ",
    "                # Update occupancy counter",
    "                self._occupied_per_floor[floor] += 1",
    "                ",
    "                return ticket",
    "        ",
    "        # No spot available for this vehicle type",
    "        return None",
    "    ",
    "    def unpark_vehicle(self, ticket_id: str) -> Receipt:",
    "        \"\"\"",
    "        Remove vehicle from lot and return receipt with fee.",
    "        ",
    "        Args:",
    "            ticket_id: ID of the parking ticket",
    "        ",
    "        Returns:",
    "            Receipt with duration and fee",
    "        ",
    "        Raises:",
    "            ValueError: If ticket not found",
    "        ",
    "        Time Complexity: O(log n) - heap push",
    "        \"\"\"",
    "        if ticket_id not in self._active_tickets:",
    "            raise ValueError(f\"Ticket {ticket_id} not found\")",
    "        ",
    "        # Get and remove the session",
    "        session = self._active_tickets.pop(ticket_id)",
    "        exit_time = datetime.now()",
    "        ",
    "        # Calculate duration (round UP to nearest hour)",
    "        duration_seconds = (exit_time - session.entry_time).total_seconds()",
    "        duration_hours = max(1, ceil(duration_seconds / 3600))  # Minimum 1 hour",
    "        ",
    "        # Calculate fee based on vehicle type",
    "        hourly_rate = self.HOURLY_RATES[session.vehicle.vehicle_type]",
    "        fee = duration_hours * hourly_rate",
    "        ",
    "        # Return spot to the correct heap (by SPOT type, not vehicle type!)",
    "        spot = session.spot",
    "        heapq.heappush(",
    "            self._available[spot.spot_type],",
    "            (spot.floor, spot.spot_number)",
    "        )",
    "        ",
    "        # Update occupancy counter",
    "        self._occupied_per_floor[spot.floor] -= 1",
    "        ",
    "        return Receipt(",
    "            ticket_id=ticket_id,",
    "            entry_time=session.entry_time,",
    "            exit_time=exit_time,",
    "            duration_hours=duration_hours,",
    "            fee=fee",
    "        )",
    "    ",
    "    def get_available_spots(self, vehicle_type: VehicleType) -> int:",
    "        \"\"\"",
    "        Get count of available spots for a vehicle type.",
    "        ",
    "        Args:",
    "            vehicle_type: Type of vehicle",
    "        ",
    "        Returns:",
    "            Number of available spots",
    "        ",
    "        Time Complexity: O(1) - just sum heap sizes",
    "        \"\"\"",
    "        compatible_types = self.VEHICLE_SPOT_COMPATIBILITY[vehicle_type]",
    "        total = 0",
    "        for spot_type in compatible_types:",
    "            total += len(self._available[spot_type])",
    "        return total",
    "    ",
    "    def get_occupied_spots(self) -> Dict[int, int]:",
    "        \"\"\"",
    "        Get count of occupied spots per floor.",
    "        ",
    "        Returns:",
    "            Dict mapping floor number to occupied count",
    "        ",
    "        Time Complexity: O(1) - return cached counter",
    "        \"\"\"",
    "        return dict(self._occupied_per_floor)",
    "    ",
    "    def get_capacity_status(self) -> Dict[str, int]:",
    "        \"\"\"Get summary of parking lot capacity.\"\"\"",
    "        total_spots = sum(self._total_per_floor.values())",
    "        total_occupied = sum(self._occupied_per_floor.values())",
    "        return {",
    "            'total_spots': total_spots,",
    "            'occupied': total_occupied,",
    "            'available': total_spots - total_occupied,",
    "            'occupancy_percent': round(total_occupied / total_spots * 100, 1) if total_spots > 0 else 0",
    "        }",
    "    ",
    "    def _generate_ticket_id(self) -> str:",
    "        \"\"\"Generate a unique ticket ID.\"\"\"",
    "        return f\"T-{uuid.uuid4().hex[:8].upper()}\"",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"String representation for debugging.\"\"\"",
    "        status = self.get_capacity_status()",
    "        return (",
    "            f\"ParkingLot(floors={len(self._occupied_per_floor)}, \"",
    "            f\"occupied={status['occupied']}/{status['total_spots']}, \"",
    "            f\"occupancy={status['occupancy_percent']}%)\"",
    "        )",
    "",
    "",
    "# ============================================================",
    "# EXAMPLE USAGE AND TESTS",
    "# ============================================================",
    "",
    "def run_example_1() -> None:",
    "    \"\"\"Example 1: Basic parking flow.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"EXAMPLE 1: Basic Parking Flow\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Create parking lot with 2 floors",
    "    # Floor 1: [Small, Small, Compact, Compact, Large]",
    "    # Floor 2: [Small, Compact, Large, Large, Large]",
    "    spots_config = [",
    "        [SpotType.SMALL, SpotType.SMALL, SpotType.COMPACT, SpotType.COMPACT, SpotType.LARGE],",
    "        [SpotType.SMALL, SpotType.COMPACT, SpotType.LARGE, SpotType.LARGE, SpotType.LARGE],",
    "    ]",
    "    lot = ParkingLot(spots_config)",
    "    print(f\"Created: {lot}\")",
    "    print()",
    "    ",
    "    # Park a car",
    "    car = Vehicle(VehicleType.CAR, 'ABC-123')",
    "    ticket1 = lot.park_vehicle(car)",
    "    print(f\"Parked Car: Floor {ticket1.floor}, Spot {ticket1.spot_number}\")",
    "    print(f\"  Ticket ID: {ticket1.ticket_id}\")",
    "    print(f\"  Entry Time: {ticket1.entry_time.strftime('%H:%M:%S')}\")",
    "    print()",
    "    ",
    "    # Park a motorcycle",
    "    moto = Vehicle(VehicleType.MOTORCYCLE, 'XYZ-789')",
    "    ticket2 = lot.park_vehicle(moto)",
    "    print(f\"Parked Motorcycle: Floor {ticket2.floor}, Spot {ticket2.spot_number}\")",
    "    print(f\"  Ticket ID: {ticket2.ticket_id}\")",
    "    print()",
    "    ",
    "    # Check availability",
    "    print(f\"Available spots for TRUCK: {lot.get_available_spots(VehicleType.TRUCK)}\")",
    "    print(f\"Occupied per floor: {lot.get_occupied_spots()}\")",
    "    print()",
    "    ",
    "    # Unpark the car",
    "    receipt1 = lot.unpark_vehicle(ticket1.ticket_id)",
    "    print(f\"Unparked Car:\")",
    "    print(f\"  Duration: {receipt1.duration_hours} hour(s)\")",
    "    print(f\"  Fee: ${receipt1.fee:.2f}\")",
    "    print()",
    "    ",
    "    print(f\"Status after unpark: {lot}\")",
    "    print(\"âœ“ EXAMPLE 1 COMPLETED\")",
    "",
    "",
    "def run_example_2() -> None:",
    "    \"\"\"Example 2: Floor overflow.\"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"EXAMPLE 2: Floor Overflow Behavior\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Small lot: 2 floors, 2 spots each",
    "    spots_config = [",
    "        [SpotType.COMPACT, SpotType.COMPACT],  # Floor 1",
    "        [SpotType.COMPACT, SpotType.COMPACT],  # Floor 2",
    "    ]",
    "    lot = ParkingLot(spots_config)",
    "    print(f\"Created: {lot}\")",
    "    print()",
    "    ",
    "    # Park 4 cars",
    "    for i in range(4):",
    "        car = Vehicle(VehicleType.CAR, f'CAR-{i+1}')",
    "        ticket = lot.park_vehicle(car)",
    "        if ticket:",
    "            print(f\"Car {i+1}: Floor {ticket.floor}, Spot {ticket.spot_number}\")",
    "        else:",
    "            print(f\"Car {i+1}: No spot available!\")",
    "    ",
    "    print()",
    "    print(f\"Final status: {lot}\")",
    "    ",
    "    # Try to park one more",
    "    car5 = Vehicle(VehicleType.CAR, 'CAR-5')",
    "    ticket5 = lot.park_vehicle(car5)",
    "    print(f\"Car 5: {'No spot available!' if ticket5 is None else f'Floor {ticket5.floor}'}\")",
    "    print(\"âœ“ EXAMPLE 2 COMPLETED\")",
    "",
    "",
    "def run_example_3() -> None:",
    "    \"\"\"Example 3: Vehicle-spot compatibility.\"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"EXAMPLE 3: Vehicle-Spot Compatibility\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # All small spots",
    "    spots_config = [",
    "        [SpotType.SMALL, SpotType.SMALL, SpotType.SMALL],",
    "    ]",
    "    lot = ParkingLot(spots_config)",
    "    print(f\"Created lot with only SMALL spots\")",
    "    print()",
    "    ",
    "    # Motorcycle can park",
    "    moto = Vehicle(VehicleType.MOTORCYCLE, 'MOTO-1')",
    "    ticket1 = lot.park_vehicle(moto)",
    "    print(f\"Motorcycle: {'Parked!' if ticket1 else 'No spot!'}\")",
    "    ",
    "    # Car cannot park in small spots",
    "    car = Vehicle(VehicleType.CAR, 'CAR-1')",
    "    ticket2 = lot.park_vehicle(car)",
    "    print(f\"Car: {'Parked!' if ticket2 else 'No spot! (Small spots too small)'}\")",
    "    ",
    "    # Truck cannot park in small spots",
    "    truck = Vehicle(VehicleType.TRUCK, 'TRUCK-1')",
    "    ticket3 = lot.park_vehicle(truck)",
    "    print(f\"Truck: {'Parked!' if ticket3 else 'No spot! (Small spots too small)'}\")",
    "    ",
    "    print(\"\\nâœ“ EXAMPLE 3 COMPLETED\")",
    "",
    "",
    "def run_edge_cases() -> None:",
    "    \"\"\"Test edge cases.\"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"EDGE CASES\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Edge case 1: Invalid ticket",
    "    print(\"\\n1. Invalid ticket:\")",
    "    lot = ParkingLot.create_default(1, 5)",
    "    try:",
    "        lot.unpark_vehicle('INVALID-TICKET')",
    "        print(\"   âœ— FAILED - Should have raised ValueError\")",
    "    except ValueError as e:",
    "        print(f\"   Caught expected error: {e}\")",
    "        print(\"   âœ“ PASSED\")",
    "    ",
    "    # Edge case 2: Spot reuse",
    "    print(\"\\n2. Spot reuse after unpark:\")",
    "    lot = ParkingLot([[SpotType.COMPACT]])",
    "    car1 = Vehicle(VehicleType.CAR, 'CAR-1')",
    "    ticket1 = lot.park_vehicle(car1)",
    "    print(f\"   First car parked at: Floor {ticket1.floor}, Spot {ticket1.spot_number}\")",
    "    lot.unpark_vehicle(ticket1.ticket_id)",
    "    car2 = Vehicle(VehicleType.CAR, 'CAR-2')",
    "    ticket2 = lot.park_vehicle(car2)",
    "    print(f\"   Second car parked at: Floor {ticket2.floor}, Spot {ticket2.spot_number}\")",
    "    assert ticket1.spot_number == ticket2.spot_number",
    "    print(\"   Same spot reused!\")",
    "    print(\"   âœ“ PASSED\")",
    "    ",
    "    # Edge case 3: Motorcycle prefers small over large",
    "    print(\"\\n3. Motorcycle prefers smallest spot:\")",
    "    lot = ParkingLot([[SpotType.LARGE, SpotType.SMALL]])  # Large is spot 1, Small is spot 2",
    "    moto = Vehicle(VehicleType.MOTORCYCLE, 'MOTO')",
    "    ticket = lot.park_vehicle(moto)",
    "    # Note: Despite Large being spot 1, motorcycle should get Small (spot 2)",
    "    # because we prefer smallest fitting spot",
    "    print(f\"   Motorcycle got: Floor {ticket.floor}, Spot {ticket.spot_number}\")",
    "    print(f\"   (Small spot is spot 2, which is preferred over Large spot 1)\")",
    "    print(\"   âœ“ PASSED\")",
    "",
    "",
    "if __name__ == '__main__':",
    "    print(\"\\n\" + \"#\" * 70)",
    "    print(\"#  PARKING LOT SYSTEM - DEMO AND TESTS\")",
    "    print(\"#\" * 70)",
    "    ",
    "    run_example_1()",
    "    run_example_2()",
    "    run_example_3()",
    "    run_edge_cases()",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"ALL EXAMPLES AND TESTS COMPLETED! âœ“\")",
    "    print(\"=\" * 70)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.time.LocalDateTime;",
    "import java.time.Duration;",
    "import java.math.BigDecimal;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "",
    "/**",
    " * Parking Lot System",
    " * ",
    " * A production-quality implementation of a multi-floor parking lot system",
    " * with O(log n) allocation using PriorityQueues (MinHeaps).",
    " * ",
    " * Time Complexity:",
    " *   - parkVehicle: O(log n)",
    " *   - unparkVehicle: O(log n)", 
    " *   - getAvailableSpots: O(1)",
    " * ",
    " * Space Complexity: O(n) where n = total spots",
    " */",
    "",
    "// ============================================================",
    "// ENUMS",
    "// ============================================================",
    "",
    "enum VehicleType {",
    "    MOTORCYCLE(1),",
    "    CAR(2),",
    "    TRUCK(3);",
    "    ",
    "    private final int value;",
    "    VehicleType(int value) { this.value = value; }",
    "}",
    "",
    "enum SpotType {",
    "    SMALL(1),",
    "    COMPACT(2),",
    "    LARGE(3);",
    "    ",
    "    private final int value;",
    "    SpotType(int value) { this.value = value; }",
    "}",
    "",
    "// ============================================================",
    "// VALUE OBJECTS",
    "// ============================================================",
    "",
    "class Vehicle {",
    "    private final VehicleType type;",
    "    private final String licensePlate;",
    "    ",
    "    public Vehicle(VehicleType type, String licensePlate) {",
    "        this.type = type;",
    "        this.licensePlate = licensePlate;",
    "    }",
    "    ",
    "    public VehicleType getType() { return type; }",
    "    public String getLicensePlate() { return licensePlate; }",
    "}",
    "",
    "class ParkingSpot implements Comparable<ParkingSpot> {",
    "    private final int floor;",
    "    private final int spotNumber;",
    "    private final SpotType type;",
    "    ",
    "    public ParkingSpot(int floor, int spotNumber, SpotType type) {",
    "        this.floor = floor;",
    "        this.spotNumber = spotNumber;",
    "        this.type = type;",
    "    }",
    "    ",
    "    public int getFloor() { return floor; }",
    "    public int getSpotNumber() { return spotNumber; }",
    "    public SpotType getType() { return type; }",
    "    ",
    "    @Override",
    "    public int compareTo(ParkingSpot other) {",
    "        // Order by floor first, then spot number",
    "        if (this.floor != other.floor) {",
    "            return Integer.compare(this.floor, other.floor);",
    "        }",
    "        return Integer.compare(this.spotNumber, other.spotNumber);",
    "    }",
    "}",
    "",
    "class Ticket {",
    "    private final String id;",
    "    private final int floor;",
    "    private final int spotNumber;",
    "    private final LocalDateTime entryTime;",
    "    private final VehicleType vehicleType;",
    "    ",
    "    public Ticket(String id, int floor, int spotNumber, ",
    "                  LocalDateTime entryTime, VehicleType vehicleType) {",
    "        this.id = id;",
    "        this.floor = floor;",
    "        this.spotNumber = spotNumber;",
    "        this.entryTime = entryTime;",
    "        this.vehicleType = vehicleType;",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public int getFloor() { return floor; }",
    "    public int getSpotNumber() { return spotNumber; }",
    "    public LocalDateTime getEntryTime() { return entryTime; }",
    "    public VehicleType getVehicleType() { return vehicleType; }",
    "}",
    "",
    "class Receipt {",
    "    private final String ticketId;",
    "    private final int durationHours;",
    "    private final BigDecimal fee;",
    "    ",
    "    public Receipt(String ticketId, int durationHours, BigDecimal fee) {",
    "        this.ticketId = ticketId;",
    "        this.durationHours = durationHours;",
    "        this.fee = fee;",
    "    }",
    "    ",
    "    public String getTicketId() { return ticketId; }",
    "    public int getDurationHours() { return durationHours; }",
    "    public BigDecimal getFee() { return fee; }",
    "}",
    "",
    "class ParkingSession {",
    "    private final Vehicle vehicle;",
    "    private final ParkingSpot spot;",
    "    private final LocalDateTime entryTime;",
    "    ",
    "    public ParkingSession(Vehicle vehicle, ParkingSpot spot, LocalDateTime entryTime) {",
    "        this.vehicle = vehicle;",
    "        this.spot = spot;",
    "        this.entryTime = entryTime;",
    "    }",
    "    ",
    "    public Vehicle getVehicle() { return vehicle; }",
    "    public ParkingSpot getSpot() { return spot; }",
    "    public LocalDateTime getEntryTime() { return entryTime; }",
    "}",
    "",
    "// ============================================================",
    "// MAIN PARKING LOT CLASS",
    "// ============================================================",
    "",
    "public class ParkingLot {",
    "    // Fee rates per hour",
    "    private static final Map<VehicleType, BigDecimal> HOURLY_RATES = Map.of(",
    "        VehicleType.MOTORCYCLE, new BigDecimal(\"1.00\"),",
    "        VehicleType.CAR, new BigDecimal(\"2.00\"),",
    "        VehicleType.TRUCK, new BigDecimal(\"3.00\")",
    "    );",
    "    ",
    "    // Vehicle-spot compatibility (in preference order)",
    "    private static final Map<VehicleType, List<SpotType>> COMPATIBILITY = Map.of(",
    "        VehicleType.MOTORCYCLE, List.of(SpotType.SMALL, SpotType.COMPACT, SpotType.LARGE),",
    "        VehicleType.CAR, List.of(SpotType.COMPACT, SpotType.LARGE),",
    "        VehicleType.TRUCK, List.of(SpotType.LARGE)",
    "    );",
    "    ",
    "    // MinHeap (PriorityQueue) per spot type",
    "    private final Map<SpotType, PriorityQueue<ParkingSpot>> availableSpots;",
    "    ",
    "    // Spot type lookup",
    "    private final Map<String, SpotType> spotTypes;",
    "    ",
    "    // Active tickets",
    "    private final Map<String, ParkingSession> activeTickets;",
    "    ",
    "    // Occupancy counters",
    "    private final Map<Integer, Integer> occupiedPerFloor;",
    "    private final Map<Integer, Integer> totalPerFloor;",
    "    ",
    "    // Ticket counter for ID generation",
    "    private int ticketCounter = 0;",
    "    ",
    "    public ParkingLot(List<List<SpotType>> spotsConfig) {",
    "        this.availableSpots = new EnumMap<>(SpotType.class);",
    "        for (SpotType type : SpotType.values()) {",
    "            availableSpots.put(type, new PriorityQueue<>());",
    "        }",
    "        ",
    "        this.spotTypes = new HashMap<>();",
    "        this.activeTickets = new ConcurrentHashMap<>();",
    "        this.occupiedPerFloor = new HashMap<>();",
    "        this.totalPerFloor = new HashMap<>();",
    "        ",
    "        // Initialize floors",
    "        for (int floor = 0; floor < spotsConfig.size(); floor++) {",
    "            int floorNum = floor + 1;",
    "            List<SpotType> floorSpots = spotsConfig.get(floor);",
    "            occupiedPerFloor.put(floorNum, 0);",
    "            totalPerFloor.put(floorNum, floorSpots.size());",
    "            ",
    "            for (int spot = 0; spot < floorSpots.size(); spot++) {",
    "                int spotNum = spot + 1;",
    "                SpotType type = floorSpots.get(spot);",
    "                ",
    "                ParkingSpot parkingSpot = new ParkingSpot(floorNum, spotNum, type);",
    "                availableSpots.get(type).offer(parkingSpot);",
    "                spotTypes.put(floorNum + \"-\" + spotNum, type);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Park a vehicle in the lot.",
    "     * @param vehicle Vehicle to park",
    "     * @return Ticket if successful, null if no spot available",
    "     */",
    "    public Ticket parkVehicle(Vehicle vehicle) {",
    "        List<SpotType> compatibleTypes = COMPATIBILITY.get(vehicle.getType());",
    "        ",
    "        for (SpotType spotType : compatibleTypes) {",
    "            PriorityQueue<ParkingSpot> heap = availableSpots.get(spotType);",
    "            if (!heap.isEmpty()) {",
    "                ParkingSpot spot = heap.poll();",
    "                ",
    "                String ticketId = \"T-\" + (++ticketCounter);",
    "                LocalDateTime entryTime = LocalDateTime.now();",
    "                ",
    "                Ticket ticket = new Ticket(",
    "                    ticketId, spot.getFloor(), spot.getSpotNumber(),",
    "                    entryTime, vehicle.getType()",
    "                );",
    "                ",
    "                ParkingSession session = new ParkingSession(vehicle, spot, entryTime);",
    "                activeTickets.put(ticketId, session);",
    "                ",
    "                occupiedPerFloor.merge(spot.getFloor(), 1, Integer::sum);",
    "                ",
    "                return ticket;",
    "            }",
    "        }",
    "        ",
    "        return null; // No spot available",
    "    }",
    "    ",
    "    /**",
    "     * Unpark a vehicle and return receipt.",
    "     * @param ticketId Ticket ID",
    "     * @return Receipt with fee",
    "     * @throws IllegalArgumentException if ticket not found",
    "     */",
    "    public Receipt unparkVehicle(String ticketId) {",
    "        ParkingSession session = activeTickets.remove(ticketId);",
    "        if (session == null) {",
    "            throw new IllegalArgumentException(\"Ticket not found: \" + ticketId);",
    "        }",
    "        ",
    "        LocalDateTime exitTime = LocalDateTime.now();",
    "        Duration duration = Duration.between(session.getEntryTime(), exitTime);",
    "        ",
    "        // Round UP to nearest hour",
    "        int durationHours = (int) Math.max(1, Math.ceil(duration.toMinutes() / 60.0));",
    "        ",
    "        BigDecimal hourlyRate = HOURLY_RATES.get(session.getVehicle().getType());",
    "        BigDecimal fee = hourlyRate.multiply(new BigDecimal(durationHours));",
    "        ",
    "        // Return spot to correct heap",
    "        ParkingSpot spot = session.getSpot();",
    "        availableSpots.get(spot.getType()).offer(spot);",
    "        ",
    "        occupiedPerFloor.merge(spot.getFloor(), -1, Integer::sum);",
    "        ",
    "        return new Receipt(ticketId, durationHours, fee);",
    "    }",
    "    ",
    "    /**",
    "     * Get count of available spots for vehicle type.",
    "     */",
    "    public int getAvailableSpots(VehicleType vehicleType) {",
    "        return COMPATIBILITY.get(vehicleType).stream()",
    "            .mapToInt(type -> availableSpots.get(type).size())",
    "            .sum();",
    "    }",
    "    ",
    "    /**",
    "     * Get occupied spots per floor.",
    "     */",
    "    public Map<Integer, Integer> getOccupiedSpots() {",
    "        return new HashMap<>(occupiedPerFloor);",
    "    }",
    "    ",
    "    // ============================================================",
    "    // MAIN - Demo",
    "    // ============================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"Parking Lot System Demo\");",
    "        System.out.println(\"=\".repeat(50));",
    "        ",
    "        // Create lot with 2 floors",
    "        List<List<SpotType>> config = List.of(",
    "            List.of(SpotType.SMALL, SpotType.SMALL, SpotType.COMPACT, SpotType.COMPACT, SpotType.LARGE),",
    "            List.of(SpotType.SMALL, SpotType.COMPACT, SpotType.LARGE, SpotType.LARGE, SpotType.LARGE)",
    "        );",
    "        ",
    "        ParkingLot lot = new ParkingLot(config);",
    "        ",
    "        // Park a car",
    "        Vehicle car = new Vehicle(VehicleType.CAR, \"ABC-123\");",
    "        Ticket ticket1 = lot.parkVehicle(car);",
    "        System.out.println(\"Parked car at Floor \" + ticket1.getFloor() + \", Spot \" + ticket1.getSpotNumber());",
    "        ",
    "        // Park a motorcycle",
    "        Vehicle moto = new Vehicle(VehicleType.MOTORCYCLE, \"XYZ-789\");",
    "        Ticket ticket2 = lot.parkVehicle(moto);",
    "        System.out.println(\"Parked motorcycle at Floor \" + ticket2.getFloor() + \", Spot \" + ticket2.getSpotNumber());",
    "        ",
    "        // Check availability",
    "        System.out.println(\"Available spots for TRUCK: \" + lot.getAvailableSpots(VehicleType.TRUCK));",
    "        ",
    "        // Unpark car",
    "        Receipt receipt = lot.unparkVehicle(ticket1.getId());",
    "        System.out.println(\"Unparked car. Fee: $\" + receipt.getFee());",
    "        ",
    "        System.out.println(\"\\nDemo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-17",
      "section": "Imports and Module Docstring",
      "explanation": "We import essential modules: `enum` for vehicle/spot types, `dataclass` for clean value objects, `heapq` for MinHeap operations, `math.ceil` for rounding up hours, and `uuid` for ticket generation."
    },
    {
      "lines": "23-35",
      "section": "Enums: VehicleType and SpotType",
      "explanation": "Enums provide type safety and self-documenting code. SpotType values are ordered (1,2,3) which helps with preference ordering - smaller spots have lower values."
    },
    {
      "lines": "41-77",
      "section": "Value Objects: Vehicle, ParkingSpot, Ticket, Receipt",
      "explanation": "Using `@dataclass` for immutable value objects. These are simple data containers with no business logic. Ticket contains all info needed for the customer; Receipt contains fee calculation results."
    },
    {
      "lines": "84-115",
      "section": "ParkingLot Class Docstring and Constants",
      "explanation": "HOURLY_RATES maps vehicle types to fees. VEHICLE_SPOT_COMPATIBILITY defines which spots each vehicle can use, IN PREFERENCE ORDER. Motorcycles try Small first, then Compact, then Large."
    },
    {
      "lines": "117-160",
      "section": "ParkingLot.__init__ - Initialization",
      "explanation": "Creates three MinHeaps (one per spot type), a HashMap for active tickets, and floor occupancy counters. Populates heaps from configuration. Key insight: (floor, spot) tuples ensure correct ordering in heap."
    },
    {
      "lines": "162-180",
      "section": "create_default Factory Method",
      "explanation": "Convenience method to create a lot with default distribution (20% Small, 40% Compact, 40% Large). Shows good OOP design - multiple ways to construct the object."
    },
    {
      "lines": "182-230",
      "section": "park_vehicle - THE CORE METHOD",
      "explanation": "This is the heart of the system. Gets compatible spot types in preference order. Tries each heap until finding one with available spots. Pops from heap (O(log n)), creates ticket, stores session, updates counters. Returns None if all heaps empty."
    },
    {
      "lines": "232-275",
      "section": "unpark_vehicle - Exit Flow",
      "explanation": "Looks up session by ticket ID (O(1)). Calculates duration with ceil() for round-up. Computes fee based on vehicle type. CRITICALLY: pushes spot back to heap based on SPOT type (not vehicle type). Updates counters."
    },
    {
      "lines": "277-295",
      "section": "Query Methods",
      "explanation": "get_available_spots sums heap sizes for compatible spot types - O(1). get_occupied_spots returns the cached counter - O(1). get_capacity_status provides a summary view."
    },
    {
      "lines": "320-400",
      "section": "Examples and Tests",
      "explanation": "Comprehensive examples showing: basic flow, floor overflow, vehicle compatibility, edge cases (invalid ticket, spot reuse, preference order). These demonstrate the system works correctly."
    }
  ],
  "complexity_analysis": {
    "time": {
      "park_vehicle": {
        "complexity": "O(log n)",
        "explanation": "heapq.heappop is O(log n). We try at most 3 heaps (for motorcycles), so it's O(3 log n) = O(log n)."
      },
      "unpark_vehicle": {
        "complexity": "O(log n)",
        "explanation": "HashMap lookup is O(1). heapq.heappush is O(log n). Total: O(1) + O(log n) = O(log n)."
      },
      "get_available_spots": {
        "complexity": "O(1)",
        "explanation": "len() on Python list is O(1). We sum at most 3 lengths = O(1)."
      },
      "get_occupied_spots": {
        "complexity": "O(floors)",
        "explanation": "Returns a copy of the floor counter dict. With max 10 floors, effectively O(1)."
      },
      "overall": "**All operations are O(log n) or O(1)**. This meets the performance requirement."
    },
    "space": {
      "complexity": "O(n) where n = total spots",
      "breakdown": "- **Heaps**: O(n) combined - all spots distributed across 3 heaps\n- **Active tickets**: O(k) where k = parked vehicles â‰¤ n\n- **Spot types lookup**: O(n) - one entry per spot\n- **Floor counters**: O(floors) â‰ˆ O(1)\n- **Total**: O(n)",
      "note": "Space is optimal - we must store all spots somewhere. The heap structure adds no overhead vs a simple list."
    },
    "can_we_do_better": "**Time: No - O(log n) is optimal** for ordered allocation with insertions.\n\n**Space: No - O(n) is required** to track all spots.\n\nThe only improvement would be using a Fibonacci heap for O(1) amortized insert, but this is rarely worth the complexity in practice."
  },
  "test_cases": [
    {
      "name": "Basic parking flow",
      "category": "Happy Path",
      "input": "parkVehicle(Car), parkVehicle(Motorcycle), unparkVehicle(carTicket)",
      "expected": "Car gets Compact spot, Moto gets Small spot, Receipt with $2/hr fee",
      "explanation": "Validates basic park/unpark cycle with fee calculation."
    },
    {
      "name": "Vehicle-spot preference",
      "category": "Logic",
      "input": "Lot with [Large, Small]. parkVehicle(Motorcycle)",
      "expected": "Motorcycle gets Small (spot 2), not Large (spot 1)",
      "explanation": "Motorcycles prefer smallest fitting spot to reduce fragmentation."
    },
    {
      "name": "Floor overflow",
      "category": "Logic",
      "input": "2 floors, 2 Compact each. Park 4 cars.",
      "expected": "Cars 1-2 on Floor 1, Cars 3-4 on Floor 2",
      "explanation": "When floor 1 full, overflow to floor 2."
    },
    {
      "name": "Car using Large spot",
      "category": "Compatibility",
      "input": "Lot with only Large spots. parkVehicle(Car)",
      "expected": "Car parks in Large spot",
      "explanation": "Cars can use Large spots when Compact unavailable."
    },
    {
      "name": "Truck cannot use Small/Compact",
      "category": "Compatibility",
      "input": "Lot with only Small and Compact. parkVehicle(Truck)",
      "expected": "Returns None (no spot available)",
      "explanation": "Trucks can ONLY use Large spots."
    },
    {
      "name": "Spot reuse after unpark",
      "category": "Resource Management",
      "input": "Park car, unpark, park another car",
      "expected": "Second car gets same spot",
      "explanation": "Freed spots return to heap and can be reused."
    },
    {
      "name": "Partial hour rounding",
      "category": "Fee Calculation",
      "input": "Park for 30 minutes, unpark",
      "expected": "Fee for 1 hour (not 0 or 0.5)",
      "explanation": "Partial hours round UP. 30 min = 1 hour."
    },
    {
      "name": "Invalid ticket",
      "category": "Error Handling",
      "input": "unparkVehicle('INVALID-123')",
      "expected": "ValueError raised",
      "explanation": "Must handle non-existent tickets gracefully."
    },
    {
      "name": "Full parking lot",
      "category": "Edge Case",
      "input": "Fill all spots, try to park one more",
      "expected": "Returns None",
      "explanation": "When lot is full, parkVehicle returns None."
    },
    {
      "name": "Available spots count",
      "category": "Query",
      "input": "Lot with 5 spots. Park 2 cars. getAvailableSpots(CAR)",
      "expected": "3 (5 - 2 = 3)",
      "explanation": "Count updates correctly on park/unpark."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Linear search for available spot",
      "why_wrong": "Iterating all spots to find an available one is O(n). With 10,000 spots, this is too slow.",
      "correct_approach": "Use MinHeap per spot type. Pop gives best spot in O(log n).",
      "code_wrong": "# âŒ O(n) search\nfor floor in floors:\n    for spot in floor.spots:\n        if spot.available:\n            return spot",
      "code_correct": "# âœ… O(log n) with heap\nspot = heapq.heappop(available_compact)\nreturn spot"
    },
    {
      "mistake": "Returning spot to wrong heap",
      "why_wrong": "If a motorcycle parks in a Large spot and you return it to Small heap, the spot type is corrupted.",
      "correct_approach": "Return spot to heap based on SPOT type (stored in session), not vehicle type.",
      "code_wrong": "# âŒ Wrong - uses vehicle type\nheap = available[session.vehicle.type]\nheap.push(spot)",
      "code_correct": "# âœ… Correct - uses spot type\nheap = available[session.spot.spot_type]\nheap.push(spot)"
    },
    {
      "mistake": "Not rounding up partial hours",
      "why_wrong": "30 minutes should cost 1 hour, not 0 hours. Truncating loses revenue.",
      "correct_approach": "Use math.ceil() to always round up.",
      "code_wrong": "# âŒ Truncates\nhours = int(duration_seconds / 3600)",
      "code_correct": "# âœ… Rounds up\nhours = math.ceil(duration_seconds / 3600)"
    },
    {
      "mistake": "Not checking if heap is empty",
      "why_wrong": "Popping from empty heap raises exception.",
      "correct_approach": "Check `if heap:` before popping.",
      "code_wrong": "# âŒ Crashes if empty\nspot = heapq.heappop(available_compact)",
      "code_correct": "# âœ… Safe\nif available_compact:\n    spot = heapq.heappop(available_compact)\nelse:\n    return None"
    },
    {
      "mistake": "Not preferring smallest spot for flexible vehicles",
      "why_wrong": "If motorcycles take Large spots, trucks can't park. Causes fragmentation.",
      "correct_approach": "Try heaps in order: Small â†’ Compact â†’ Large for motorcycles.",
      "code_wrong": "# âŒ Takes first available\nfor spot_type in SpotType:\n    if available[spot_type]:\n        return heappop(available[spot_type])",
      "code_correct": "# âœ… Preference order\nfor spot_type in [SMALL, COMPACT, LARGE]:\n    if available[spot_type]:\n        return heappop(available[spot_type])"
    }
  ],
  "interview_tips": {
    "opening": "This is a classic LLD problem. Before coding, I'd like to clarify a few things: What vehicle types and spot types do we support? Is there a preference for spot selection - like lowest floor first? Can vehicles use larger spots than needed?",
    "clarifying_questions_to_ask": [
      "**What vehicle and spot types?** - Confirms scope: Motorcycle/Car/Truck, Small/Compact/Large",
      "**Spot selection priority?** - Lowest floor, then smallest fitting spot, then lowest spot number",
      "**Can vehicles use larger spots?** - Yes: Motoâ†’any, Carâ†’Compact+, Truckâ†’Large only",
      "**Fee calculation?** - Hourly, round UP partial hours",
      "**Full lot behavior?** - Return None or throw exception",
      "**Concurrency?** - Single-threaded first, discuss multi-threading as follow-up"
    ],
    "what_to_mention_proactively": [
      "**I'll use MinHeaps** for O(log n) spot allocation. One heap per spot type, ordered by (floor, spot).",
      "**HashMap for tickets** for O(1) lookup on unpark.",
      "**Preference order** - motorcycles try Small first, then Compact, then Large to reduce fragmentation.",
      "**I'll round UP partial hours** - standard practice for parking fees."
    ],
    "communication_during_coding": [
      "I'm defining enums for VehicleType and SpotType for type safety...",
      "Here's the key: I'm using heapq.heappop which gives O(log n) allocation...",
      "Notice I'm checking heaps in preference order - smallest fitting spot first...",
      "Critically, I return the spot to the heap based on SPOT type, not vehicle type...",
      "Let me add error handling for invalid ticket IDs..."
    ],
    "if_stuck": [
      "**Step back**: What's the core requirement? Lowest floor, lowest spot. How to get 'minimum' efficiently?",
      "**Draw it**: Sketch the heaps with (floor, spot) tuples. See how pop gives minimum.",
      "**Simplify**: Forget spot types first. Just get one heap working for all vehicles.",
      "**Ask**: Can I assume single-threaded? That simplifies initial implementation."
    ],
    "time_management": "**0-5 min**: Clarify requirements, discuss approach\n**5-10 min**: Define classes, data structures\n**10-25 min**: Implement park/unpark\n**25-35 min**: Implement queries, test\n**35-45 min**: Edge cases, follow-ups\n\nğŸ’¡ Tip: Mention the heap optimization BEFORE the interviewer asks about efficiency!"
  },
  "pattern_recognition": {
    "pattern_name": "Resource Allocation with Ordered Selection",
    "indicators": [
      "Multiple resources of different types/sizes",
      "Need to allocate 'best' resource efficiently",
      "Preference order (smallest first, closest first, etc.)",
      "Resources can be returned after use"
    ],
    "similar_problems": [
      "**LC 1603 - Design Parking System**: Simpler version - just count spots per type",
      "**Meeting Room Booking**: Allocate rooms by size/features",
      "**Elevator System**: Allocate elevators by distance/direction",
      "**Load Balancer**: Allocate servers by capacity/latency",
      "**Cache Eviction (LRU)**: Select resource to evict by recency"
    ],
    "template": "```python\nclass ResourceAllocator:\n    def __init__(self):\n        # MinHeap per resource type for ordered allocation\n        self.available = {\n            ResourceType.A: MinHeap(),\n            ResourceType.B: MinHeap(),\n        }\n        # HashMap for active allocations\n        self.active = {}  # allocationId -> AllocationSession\n    \n    def allocate(self, request):\n        compatible_types = get_compatible(request.type)\n        for resource_type in compatible_types:  # Preference order\n            if self.available[resource_type]:\n                resource = heappop(self.available[resource_type])\n                session = create_session(request, resource)\n                self.active[session.id] = session\n                return session\n        return None\n    \n    def deallocate(self, session_id):\n        session = self.active.pop(session_id)\n        heappush(self.available[session.resource.type], session.resource)\n        return create_receipt(session)\n```",
    "when_to_use": "Use this pattern whenever:\n1. You have multiple resources to allocate\n2. There's a preference/priority order\n3. Resources are returned after use\n4. You need O(log n) or O(1) allocation"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Reserved Parking & VIP Support**\n\nKey additions:\n- Reservations: TreeMap<(floor, spot), List<TimeRange>> for O(log n) overlap checking\n- VIP threshold: If >90% full, reject regular customers but allow VIPs\n- Need to mark spots as 'reserved' during time windows",
    "part_3_hint": "**Part 3: EV Charging Spots**\n\nKey additions:\n- New SpotType: EV_CHARGING with chargerType attribute\n- Charging status tracking per spot\n- Dynamic pricing: base rate + charging rate during peak hours\n- Consider: What if EV is fully charged but still parked?",
    "part_4_hint": "**Part 4: System Design Discussion**\n\nTopics:\n- **Concurrency**: Lock per spot? Per floor? Global lock?\n- **Distribution**: Multiple entry gates, how to sync?\n- **Real-time signage**: Push vs poll for availability updates?\n- **Analytics**: Peak hours, revenue optimization",
    "data_structure_evolution": "```\nPart 1: MinHeaps + HashMap\n        â””â”€â”€ Basic allocation, O(log n)\n\nPart 2: + TreeMap for reservations\n        â””â”€â”€ O(log n) time range overlap checks\n\nPart 3: + Charging status tracker\n        â””â”€â”€ Real-time updates, dynamic pricing\n\nPart 4: + Distributed locks, event bus\n        â””â”€â”€ Multi-gate synchronization\n```"
  },
  "generated_at": "2026-01-15T10:30:00.000000",
  "_meta": {
    "problem_id": "parking_lot_system",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}
