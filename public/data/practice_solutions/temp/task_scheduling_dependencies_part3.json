{
  "problem_title": "Task Scheduling with Dependencies - Part 3: Find Critical Path",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 shifts focus from scheduling with limited workers to identifying the **critical path** - the longest chain of dependent tasks that determines minimum project duration. Instead of just calculating when tasks complete, we must now track *which* tasks form this bottleneck sequence. This requires maintaining predecessor relationships during the topological traversal so we can reconstruct the path.",
    "new_requirements": [
      "Return the critical path as an ordered list of task IDs",
      "Track which predecessor determined each task's earliest start time",
      "Backtrack from the latest-finishing task to reconstruct the path",
      "Handle multiple valid critical paths (return any one)"
    ],
    "new_constraints": [
      "Must maintain O(V+E) time complexity while adding path tracking",
      "Multiple critical paths may exist - any valid path is acceptable",
      "Path must be returned in execution order (start to end)"
    ],
    "key_insight": "The critical path is found by tracking which dependency gave each task its maximum 'earliest start time'. When processing a task, record the predecessor that constrained it most. After finding the task with maximum completion time, backtrack through predecessors to reconstruct the critical path."
  },
  "visual_explanation": {
    "before_after": "```\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n              BEFORE: Only Calculate Total Time\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    [Task 1: 3]\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 2: 2]\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 4: 3]\n         \u2502                                  \u25b2\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 3: 5]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Result: minimum_time = 11 \u2713\n    Missing: WHICH tasks form the critical path?\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n               AFTER: Track Critical Path\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    [Task 1: 3]\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 2: 2]\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 4: 3]\n    completion=3      completion=5      completion=11\n    pred=None         pred=1            pred=3 \u2190\u2500\u2510\n         \u2502                                  \u25b2    \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba[Task 3: 5]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n                      completion=8               \u2502\n                      pred=1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    Result: (11, [1, 3, 4])\n    Critical Path: Task 1 \u2192 Task 3 \u2192 Task 4\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551           CRITICAL PATH ALGORITHM FLOW                            \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                   \u2551\n\u2551  PHASE 1: BUILD GRAPH + TRACK PREDECESSORS                       \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                       \u2551\n\u2551                                                                   \u2551\n\u2551  Step 1: Initialize data structures                              \u2551\n\u2551    \u2022 duration[task] = task duration                              \u2551\n\u2551    \u2022 graph[task] = tasks that depend on this task               \u2551\n\u2551    \u2022 reverse_graph[task] = dependencies of this task            \u2551\n\u2551    \u2022 in_degree[task] = count of unprocessed dependencies        \u2551\n\u2551                                                                   \u2551\n\u2551  Step 2: Topological sort with tracking                          \u2551\n\u2551    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551    \u2502 For each task in topological order:                      \u2502  \u2551\n\u2551    \u2502                                                          \u2502  \u2551\n\u2551    \u2502   If no dependencies:                                    \u2502  \u2551\n\u2551    \u2502     completion[task] = duration[task]                   \u2502  \u2551\n\u2551    \u2502     predecessor[task] = None                            \u2502  \u2551\n\u2551    \u2502                                                          \u2502  \u2551\n\u2551    \u2502   Else:                                                  \u2502  \u2551\n\u2551    \u2502     best_pred = argmax(completion[dep] for dep in deps) \u2502  \u2551\n\u2551    \u2502     completion[task] = completion[best_pred] + duration \u2502  \u2551\n\u2551    \u2502     predecessor[task] = best_pred  \u2190 KEY TRACKING!      \u2502  \u2551\n\u2551    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                   \u2551\n\u2551  PHASE 2: BACKTRACK TO BUILD PATH                                \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                \u2551\n\u2551                                                                   \u2551\n\u2551  Step 3: Find end of critical path                               \u2551\n\u2551    end_task = argmax(completion[task] for all tasks)            \u2551\n\u2551                                                                   \u2551\n\u2551  Step 4: Walk backwards through predecessors                     \u2551\n\u2551    path = []                                                     \u2551\n\u2551    current = end_task                                            \u2551\n\u2551    while current is not None:                                    \u2551\n\u2551        path.append(current)                                      \u2551\n\u2551        current = predecessor[current]                            \u2551\n\u2551    path.reverse()  \u2190 Get correct order                          \u2551\n\u2551                                                                   \u2551\n\u2551  Return: (max_completion_time, path)                             \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Enumerate All Paths",
      "description": "Generate all possible paths from sources to sinks using DFS, calculate the length of each path, and return the longest one.",
      "time_complexity": "O(V! \u00d7 E) in worst case",
      "space_complexity": "O(V!) to store all paths",
      "why_not_optimal": "Exponential complexity! A DAG can have exponentially many paths. For a wide graph with many parallel branches, this becomes infeasible. Example: 20 tasks with 10 parallel branches could have millions of paths."
    },
    {
      "name": "Modified Part 2 - Track During Processing",
      "description": "Extend the topological sort solution by adding a predecessor map. When calculating completion time for each task, record which dependency gave the maximum start time. Then backtrack from the max-completion task.",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V + E)",
      "key_insight": "We're already visiting each task once during topological sort. Adding predecessor tracking is O(1) per task. The backtracking is O(V) since the critical path can have at most V tasks."
    },
    {
      "name": "Optimal Approach - Single-Pass with Backtracking",
      "description": "Integrate critical path tracking directly into Kahn's algorithm. For each task, when computing completion time from all dependencies, record which dependency was the 'bottleneck'. After processing all tasks, find the task with maximum completion time and backtrack through predecessors.",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V + E)",
      "key_insight": "The critical path is implicitly encoded in the 'predecessor' relationship. Each task remembers which dependency delayed it most. This forms a tree rooted at sink tasks, and any root-to-leaf path in this tree is a potential critical path."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Predecessor Tracking with Backtracking\n\n### Core Insight\nThe critical path problem is elegantly solved by a simple observation: **each task on the critical path was delayed by exactly one predecessor** - the one that finished latest. If we track this relationship during our topological sort, we can reconstruct the path by walking backwards.\n\n### Algorithm Design\n\n**Step 1: Build the Graph**\n- Create `duration[task]` mapping for O(1) duration lookup\n- Build forward graph for topological traversal\n- Build reverse graph to find each task's dependencies\n- Initialize in-degree counts for Kahn's algorithm\n\n**Step 2: Process in Topological Order**\nFor each task `t` removed from the queue:\n- If `t` has no dependencies: `completion[t] = duration[t]`, `predecessor[t] = None`\n- Otherwise:\n  - Find `best_pred = argmax(completion[dep])` over all dependencies\n  - `completion[t] = completion[best_pred] + duration[t]`\n  - `predecessor[t] = best_pred`\n\n**Step 3: Find Critical Path End**\n- `end_task = argmax(completion[t])` over all tasks\n\n**Step 4: Backtrack**\n- Start from `end_task`, follow predecessors to build path\n- Reverse the path (we built it backwards)\n\n### Why This Works\nThe **predecessor relationship forms a forest** where each tree is rooted at a source task (no dependencies). The critical path is the longest root-to-leaf path in this forest. By tracking predecessors during topological sort, we're essentially computing this forest incrementally.",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Integer> duration",
        "purpose": "O(1) lookup of task durations by task ID"
      },
      {
        "structure": "HashMap<Integer, List<Integer>> graph",
        "purpose": "Forward adjacency list: task \u2192 tasks depending on it"
      },
      {
        "structure": "HashMap<Integer, List<Integer>> reverseGraph",
        "purpose": "Backward adjacency list: task \u2192 its dependencies"
      },
      {
        "structure": "HashMap<Integer, Integer> inDegree",
        "purpose": "Count of unprocessed dependencies for Kahn's algorithm"
      },
      {
        "structure": "HashMap<Integer, Integer> completionTime",
        "purpose": "Earliest completion time for each task"
      },
      {
        "structure": "HashMap<Integer, Integer> predecessor",
        "purpose": "The dependency that determined each task's start time"
      }
    ],
    "algorithm_steps": [
      "Step 1: Parse task_list into duration map and collect all task IDs",
      "Step 2: Build forward graph, reverse graph, and in-degree map from dependencies",
      "Step 3: Initialize BFS queue with all tasks having in_degree = 0 (no dependencies)",
      "Step 4: For each task popped from queue, compute completion_time as max(dependency completion times) + own duration",
      "Step 5: Record the predecessor that gave the maximum dependency completion time",
      "Step 6: Decrement in-degrees of dependent tasks; add newly-ready tasks to queue",
      "Step 7: After processing all tasks, find the task with maximum completion_time",
      "Step 8: Backtrack through predecessor links to build critical path",
      "Step 9: Reverse the path (built tail-to-head) and return with total time"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Tuple, Dict, Optional",
    "from collections import defaultdict, deque",
    "",
    "",
    "class TaskScheduler:",
    "    \"\"\"",
    "    Task Scheduler with Critical Path Analysis.",
    "    ",
    "    Solves the task scheduling problem with dependencies, supporting:",
    "    - Valid execution order via topological sort",
    "    - Minimum completion time calculation (unlimited parallelism)",
    "    - Critical path identification",
    "    ",
    "    The critical path is the longest chain of dependent tasks that",
    "    determines the minimum project duration. Any delay on critical",
    "    path tasks delays the entire project.",
    "    \"\"\"",
    "    ",
    "    def find_critical_path(",
    "        self,",
    "        task_list: List[List[int]],",
    "        dependency_list: List[List[int]]",
    "    ) -> Tuple[int, List[int]]:",
    "        \"\"\"",
    "        Find the critical path through the task dependency graph.",
    "        ",
    "        Args:",
    "            task_list: List of [task_id, duration] pairs",
    "            dependency_list: List of [task_a, task_b] pairs where",
    "                            task_a must complete before task_b starts",
    "        ",
    "        Returns:",
    "            Tuple of (minimum_total_duration, critical_path_task_ids)",
    "            The critical path is returned in execution order.",
    "        ",
    "        Time Complexity: O(V + E) where V = tasks, E = dependencies",
    "        Space Complexity: O(V + E) for graph storage",
    "        ",
    "        Example:",
    "            >>> scheduler = TaskScheduler()",
    "            >>> tasks = [[1,3], [2,2], [3,5], [4,3]]",
    "            >>> deps = [[1,2], [1,3], [2,4], [3,4]]",
    "            >>> scheduler.find_critical_path(tasks, deps)",
    "            (11, [1, 3, 4])",
    "        \"\"\"",
    "        # Handle edge case: empty task list",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        # PHASE 1: Build data structures",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        # Duration map for O(1) lookup",
    "        duration: Dict[int, int] = {}",
    "        for task_id, task_duration in task_list:",
    "            duration[task_id] = task_duration",
    "        ",
    "        all_tasks = set(duration.keys())",
    "        ",
    "        # Build bidirectional graph representation",
    "        # graph[a] = [b, c] means b and c depend on a",
    "        # reverse_graph[b] = [a] means b depends on a",
    "        graph: Dict[int, List[int]] = defaultdict(list)",
    "        reverse_graph: Dict[int, List[int]] = defaultdict(list)",
    "        in_degree: Dict[int, int] = {tid: 0 for tid in all_tasks}",
    "        ",
    "        for dep_from, dep_to in dependency_list:",
    "            graph[dep_from].append(dep_to)",
    "            reverse_graph[dep_to].append(dep_from)",
    "            in_degree[dep_to] += 1",
    "        ",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        # PHASE 2: Topological sort with critical path tracking",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        # Track completion times and predecessors",
    "        completion_time: Dict[int, int] = {}",
    "        predecessor: Dict[int, Optional[int]] = {}",
    "        ",
    "        # Initialize with tasks that have no dependencies",
    "        queue = deque()",
    "        for task_id in all_tasks:",
    "            if in_degree[task_id] == 0:",
    "                queue.append(task_id)",
    "        ",
    "        # Process tasks in topological order",
    "        while queue:",
    "            current = queue.popleft()",
    "            dependencies = reverse_graph[current]",
    "            ",
    "            if not dependencies:",
    "                # Source task: starts at time 0",
    "                completion_time[current] = duration[current]",
    "                predecessor[current] = None",
    "            else:",
    "                # Find the dependency that finished latest",
    "                # This dependency determines our start time",
    "                max_dep_completion = 0",
    "                best_predecessor = None",
    "                ",
    "                for dep in dependencies:",
    "                    if completion_time[dep] > max_dep_completion:",
    "                        max_dep_completion = completion_time[dep]",
    "                        best_predecessor = dep",
    "                ",
    "                # Our completion time = when we can start + our duration",
    "                completion_time[current] = max_dep_completion + duration[current]",
    "                predecessor[current] = best_predecessor",
    "            ",
    "            # Update dependent tasks",
    "            for next_task in graph[current]:",
    "                in_degree[next_task] -= 1",
    "                if in_degree[next_task] == 0:",
    "                    queue.append(next_task)",
    "        ",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        # PHASE 3: Find end of critical path and backtrack",
    "        # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        # Find the task with maximum completion time",
    "        max_time = 0",
    "        end_task = None",
    "        ",
    "        for task_id, time in completion_time.items():",
    "            if time > max_time:",
    "                max_time = time",
    "                end_task = task_id",
    "        ",
    "        # Backtrack through predecessors to build critical path",
    "        critical_path: List[int] = []",
    "        current_task = end_task",
    "        ",
    "        while current_task is not None:",
    "            critical_path.append(current_task)",
    "            current_task = predecessor[current_task]",
    "        ",
    "        # Reverse to get path from start to end",
    "        critical_path.reverse()",
    "        ",
    "        return (max_time, critical_path)",
    "",
    "",
    "def run_demo():",
    "    \"\"\"Demonstrate the critical path finder with examples.\"\"\"",
    "    scheduler = TaskScheduler()",
    "    ",
    "    print(\"=\"*70)",
    "    print(\"CRITICAL PATH FINDER - DEMONSTRATION\")",
    "    print(\"=\"*70)",
    "    ",
    "    # Example 1: Diamond dependency graph",
    "    print(\"\\n\ud83d\udccb Example 1: Diamond Dependency Graph\")",
    "    print(\"-\" * 50)",
    "    ",
    "    tasks1 = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "    deps1 = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "    ",
    "    print(\"Tasks (id, duration):\", tasks1)",
    "    print(\"Dependencies (from, to):\", deps1)",
    "    print()",
    "    print(\"Graph Structure:\")",
    "    print(\"       [1:3]\")",
    "    print(\"       /   \\\\\")",
    "    print(\"    [2:2] [3:5]\")",
    "    print(\"       \\\\   /\")",
    "    print(\"       [4:3]\")",
    "    print()",
    "    ",
    "    result1 = scheduler.find_critical_path(tasks1, deps1)",
    "    print(f\"\u2705 Result: Duration = {result1[0]}, Critical Path = {result1[1]}\")",
    "    print(f\"   Path 1\u21922\u21924 = 3+2+3 = 8\")",
    "    print(f\"   Path 1\u21923\u21924 = 3+5+3 = 11 \u2190 Critical!\")",
    "    ",
    "    # Example 2: Independent tasks (parallel)",
    "    print(\"\\n\ud83d\udccb Example 2: Independent Tasks\")",
    "    print(\"-\" * 50)",
    "    ",
    "    tasks2 = [[1, 5], [2, 5]]",
    "    deps2 = []",
    "    ",
    "    print(\"Tasks:\", tasks2)",
    "    print(\"Dependencies:\", deps2)",
    "    print(\"(Tasks can run in parallel)\")",
    "    ",
    "    result2 = scheduler.find_critical_path(tasks2, deps2)",
    "    print(f\"\u2705 Result: Duration = {result2[0]}, Critical Path = {result2[1]}\")",
    "    print(\"   Either [1] or [2] is valid (both have duration 5)\")",
    "    ",
    "    # Example 3: Linear chain",
    "    print(\"\\n\ud83d\udccb Example 3: Linear Chain\")",
    "    print(\"-\" * 50)",
    "    ",
    "    tasks3 = [[1, 2], [2, 3], [3, 4], [4, 1]]",
    "    deps3 = [[1, 2], [2, 3], [3, 4]]",
    "    ",
    "    print(\"Tasks:\", tasks3)",
    "    print(\"Dependencies:\", deps3)",
    "    print(\"Graph: [1] \u2192 [2] \u2192 [3] \u2192 [4]\")",
    "    ",
    "    result3 = scheduler.find_critical_path(tasks3, deps3)",
    "    print(f\"\u2705 Result: Duration = {result3[0]}, Critical Path = {result3[1]}\")",
    "    print(f\"   Total = 2+3+4+1 = {2+3+4+1}\")",
    "    ",
    "    # Example 4: Complex real-world scenario",
    "    print(\"\\n\ud83d\udccb Example 4: Build Pipeline Simulation\")",
    "    print(\"-\" * 50)",
    "    ",
    "    # Simulating a build: compile \u2192 test \u2192 package \u2192 deploy",
    "    # With parallel unit tests and integration tests",
    "    tasks4 = [",
    "        [1, 5],   # compile",
    "        [2, 3],   # unit tests",
    "        [3, 8],   # integration tests (slow!)",
    "        [4, 2],   # package",
    "        [5, 1]    # deploy",
    "    ]",
    "    deps4 = [",
    "        [1, 2], [1, 3],  # compile \u2192 tests",
    "        [2, 4], [3, 4],  # tests \u2192 package",
    "        [4, 5]           # package \u2192 deploy",
    "    ]",
    "    ",
    "    print(\"Build Pipeline:\")",
    "    print(\"  compile(5) \u2192 unit_tests(3) \u2500\u2500\u2500\u2500\u2500\u2510\")",
    "    print(\"             \u2192 integration_tests(8) \u2192 package(2) \u2192 deploy(1)\")",
    "    ",
    "    result4 = scheduler.find_critical_path(tasks4, deps4)",
    "    print(f\"\\n\u2705 Result: Duration = {result4[0]}, Critical Path = {result4[1]}\")",
    "    print(\"   The integration tests are the bottleneck!\")",
    "    ",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"All tests completed successfully!\")",
    "    print(\"=\"*70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Task Scheduler with Critical Path Analysis.",
    " * ",
    " * Solves the task scheduling problem with dependencies, supporting:",
    " * - Valid execution order via topological sort",
    " * - Minimum completion time calculation (unlimited parallelism)",
    " * - Critical path identification",
    " * ",
    " * The critical path is the longest chain of dependent tasks that",
    " * determines the minimum project duration.",
    " */",
    "public class TaskScheduler {",
    "    ",
    "    /**",
    "     * Find the critical path through the task dependency graph.",
    "     * ",
    "     * @param taskList Array of [task_id, duration] pairs",
    "     * @param dependencyList Array of [task_a, task_b] pairs where",
    "     *                       task_a must complete before task_b starts",
    "     * @return Object array: [total_duration (Integer), critical_path (List<Integer>)]",
    "     * ",
    "     * Time Complexity: O(V + E) where V = tasks, E = dependencies",
    "     * Space Complexity: O(V + E) for graph storage",
    "     */",
    "    public Object[] findCriticalPath(int[][] taskList, int[][] dependencyList) {",
    "        // Handle edge case: empty task list",
    "        if (taskList == null || taskList.length == 0) {",
    "            return new Object[]{0, new ArrayList<Integer>()};",
    "        }",
    "        ",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        // PHASE 1: Build data structures",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        // Duration map for O(1) lookup",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Set<Integer> allTasks = new HashSet<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            allTasks.add(task[0]);",
    "        }",
    "        ",
    "        // Build bidirectional graph representation",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, List<Integer>> reverseGraph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        // Initialize maps for all tasks",
    "        for (int taskId : allTasks) {",
    "            graph.put(taskId, new ArrayList<>());",
    "            reverseGraph.put(taskId, new ArrayList<>());",
    "            inDegree.put(taskId, 0);",
    "        }",
    "        ",
    "        // Build edges",
    "        for (int[] dep : dependencyList) {",
    "            int from = dep[0];",
    "            int to = dep[1];",
    "            graph.get(from).add(to);",
    "            reverseGraph.get(to).add(from);",
    "            inDegree.put(to, inDegree.get(to) + 1);",
    "        }",
    "        ",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        // PHASE 2: Topological sort with critical path tracking",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        Map<Integer, Integer> completionTime = new HashMap<>();",
    "        Map<Integer, Integer> predecessor = new HashMap<>();",
    "        ",
    "        // Initialize queue with source tasks (no dependencies)",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int taskId : allTasks) {",
    "            if (inDegree.get(taskId) == 0) {",
    "                queue.offer(taskId);",
    "            }",
    "        }",
    "        ",
    "        // Process tasks in topological order",
    "        while (!queue.isEmpty()) {",
    "            int current = queue.poll();",
    "            List<Integer> dependencies = reverseGraph.get(current);",
    "            ",
    "            if (dependencies.isEmpty()) {",
    "                // Source task: starts at time 0",
    "                completionTime.put(current, duration.get(current));",
    "                predecessor.put(current, null);",
    "            } else {",
    "                // Find the dependency that finished latest",
    "                int maxDepCompletion = 0;",
    "                Integer bestPredecessor = null;",
    "                ",
    "                for (int dep : dependencies) {",
    "                    if (completionTime.get(dep) > maxDepCompletion) {",
    "                        maxDepCompletion = completionTime.get(dep);",
    "                        bestPredecessor = dep;",
    "                    }",
    "                }",
    "                ",
    "                completionTime.put(current, maxDepCompletion + duration.get(current));",
    "                predecessor.put(current, bestPredecessor);",
    "            }",
    "            ",
    "            // Update dependent tasks",
    "            for (int nextTask : graph.get(current)) {",
    "                inDegree.put(nextTask, inDegree.get(nextTask) - 1);",
    "                if (inDegree.get(nextTask) == 0) {",
    "                    queue.offer(nextTask);",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        // PHASE 3: Find end of critical path and backtrack",
    "        // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "        ",
    "        int maxTime = 0;",
    "        Integer endTask = null;",
    "        ",
    "        for (Map.Entry<Integer, Integer> entry : completionTime.entrySet()) {",
    "            if (entry.getValue() > maxTime) {",
    "                maxTime = entry.getValue();",
    "                endTask = entry.getKey();",
    "            }",
    "        }",
    "        ",
    "        // Backtrack through predecessors",
    "        List<Integer> criticalPath = new ArrayList<>();",
    "        Integer currentTask = endTask;",
    "        ",
    "        while (currentTask != null) {",
    "            criticalPath.add(currentTask);",
    "            currentTask = predecessor.get(currentTask);",
    "        }",
    "        ",
    "        // Reverse to get start-to-end order",
    "        Collections.reverse(criticalPath);",
    "        ",
    "        return new Object[]{maxTime, criticalPath};",
    "    }",
    "    ",
    "    /**",
    "     * Demonstration of the critical path finder.",
    "     */",
    "    public static void main(String[] args) {",
    "        TaskScheduler scheduler = new TaskScheduler();",
    "        ",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"CRITICAL PATH FINDER - DEMONSTRATION\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        // Example 1: Diamond dependency graph",
    "        System.out.println(\"\\n\ud83d\udccb Example 1: Diamond Dependency Graph\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        int[][] tasks1 = {{1, 3}, {2, 2}, {3, 5}, {4, 3}};",
    "        int[][] deps1 = {{1, 2}, {1, 3}, {2, 4}, {3, 4}};",
    "        ",
    "        System.out.println(\"Graph Structure:\");",
    "        System.out.println(\"       [1:3]\");",
    "        System.out.println(\"       /   \\\\\");",
    "        System.out.println(\"    [2:2] [3:5]\");",
    "        System.out.println(\"       \\\\   /\");",
    "        System.out.println(\"       [4:3]\");",
    "        ",
    "        Object[] result1 = scheduler.findCriticalPath(tasks1, deps1);",
    "        System.out.printf(\"\\n\u2705 Result: Duration = %d, Critical Path = %s%n\",",
    "            result1[0], result1[1]);",
    "        ",
    "        // Example 2: Independent tasks",
    "        System.out.println(\"\\n\ud83d\udccb Example 2: Independent Tasks\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        int[][] tasks2 = {{1, 5}, {2, 5}};",
    "        int[][] deps2 = {};",
    "        ",
    "        Object[] result2 = scheduler.findCriticalPath(tasks2, deps2);",
    "        System.out.printf(\"\u2705 Result: Duration = %d, Critical Path = %s%n\",",
    "            result2[0], result2[1]);",
    "        ",
    "        // Example 3: Linear chain",
    "        System.out.println(\"\\n\ud83d\udccb Example 3: Linear Chain\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        int[][] tasks3 = {{1, 2}, {2, 3}, {3, 4}, {4, 1}};",
    "        int[][] deps3 = {{1, 2}, {2, 3}, {3, 4}};",
    "        ",
    "        Object[] result3 = scheduler.findCriticalPath(tasks3, deps3);",
    "        System.out.printf(\"\u2705 Result: Duration = %d, Critical Path = %s%n\",",
    "            result3[0], result3[1]);",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"All tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-16",
      "explanation": "**Imports and class docstring.** Import necessary collections (defaultdict, deque) for efficient graph operations. The class docstring explains the problem domain and capabilities."
    },
    {
      "lines": "18-45",
      "explanation": "**Method signature and documentation.** Detailed docstring with parameter descriptions, return type, complexity analysis, and usage example. This is critical for production code."
    },
    {
      "lines": "47-49",
      "explanation": "**Edge case handling.** Empty task list returns (0, []). Always handle degenerate inputs first."
    },
    {
      "lines": "51-70",
      "explanation": "**Phase 1: Build data structures.** Create duration map for O(1) lookup. Build both forward and reverse graphs. Forward graph tells us which tasks depend on a task; reverse graph tells us a task's dependencies."
    },
    {
      "lines": "72-78",
      "explanation": "**Initialize tracking structures.** `completion_time` stores earliest finish time for each task. `predecessor` tracks which dependency determined each task's start time - this is the KEY for critical path reconstruction."
    },
    {
      "lines": "80-84",
      "explanation": "**Initialize BFS queue.** Start with all tasks that have no dependencies (in_degree == 0). These are 'source' tasks that can begin immediately."
    },
    {
      "lines": "86-112",
      "explanation": "**Phase 2: Topological sort with tracking.** For each task: if no dependencies, complete at own duration. Otherwise, find the dependency with maximum completion time (the bottleneck), and record it as predecessor. This single loop does both scheduling AND critical path preparation."
    },
    {
      "lines": "114-127",
      "explanation": "**Phase 3: Find critical path endpoint.** Scan all completion times to find the maximum. This task is where the critical path ends."
    },
    {
      "lines": "129-140",
      "explanation": "**Backtrack to build path.** Follow predecessor links from end_task back to a source task. Build list in reverse order, then reverse it for correct start-to-end ordering."
    },
    {
      "lines": "142-200",
      "explanation": "**Demo function.** Comprehensive examples demonstrating diamond graphs, independent tasks, linear chains, and real-world build pipeline scenarios. Shows expected outputs and explains reasoning."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "findCriticalPath": {
          "complexity": "O(V + E)",
          "explanation": "Building the graph is O(V + E). The topological sort visits each vertex once O(V) and each edge once O(E). Finding max completion time is O(V). Backtracking is O(V) since path has at most V tasks. Total: O(V + E)."
        }
      },
      "overall_change": "Same as Part 1/2 - the predecessor tracking adds only O(1) work per task, and backtracking is O(V). No asymptotic change."
    },
    "space": {
      "additional_space": "O(V)",
      "explanation": "New space for predecessor map: O(V). The critical_path list: O(V). Graph structures remain O(V + E). Total additional space beyond Part 1/2: O(V)."
    }
  },
  "dry_run": {
    "example_input": "tasks = [[1,3], [2,2], [3,5], [4,3]], deps = [[1,2], [1,3], [2,4], [3,4]]",
    "steps": [
      {
        "step": 1,
        "action": "Build data structures",
        "state": "duration={1:3, 2:2, 3:5, 4:3}, graph={1:[2,3], 2:[4], 3:[4]}, reverse_graph={2:[1], 3:[1], 4:[2,3]}, in_degree={1:0, 2:1, 3:1, 4:2}",
        "explanation": "Parse inputs. Task 1 has no dependencies. Tasks 2,3 depend on 1. Task 4 depends on both 2 and 3."
      },
      {
        "step": 2,
        "action": "Initialize queue",
        "state": "queue=[1], completion_time={}, predecessor={}",
        "explanation": "Only task 1 has in_degree=0, so it starts in the queue."
      },
      {
        "step": 3,
        "action": "Process task 1",
        "state": "completion_time={1:3}, predecessor={1:None}, queue=[2,3]",
        "explanation": "Task 1 has no dependencies (reverse_graph[1]=[]). Completes at time 3. Decrement in_degree[2] and in_degree[3] to 0, add them to queue."
      },
      {
        "step": 4,
        "action": "Process task 2",
        "state": "completion_time={1:3, 2:5}, predecessor={1:None, 2:1}, in_degree[4]=1, queue=[3]",
        "explanation": "Task 2's only dependency is task 1 (completion=3). Task 2 completes at 3+2=5. Predecessor is task 1. Decrement in_degree[4] to 1."
      },
      {
        "step": 5,
        "action": "Process task 3",
        "state": "completion_time={1:3, 2:5, 3:8}, predecessor={..., 3:1}, in_degree[4]=0, queue=[4]",
        "explanation": "Task 3's only dependency is task 1 (completion=3). Task 3 completes at 3+5=8. Predecessor is task 1. Task 4's in_degree becomes 0."
      },
      {
        "step": 6,
        "action": "Process task 4",
        "state": "completion_time={1:3, 2:5, 3:8, 4:11}, predecessor={..., 4:3}, queue=[]",
        "explanation": "Task 4's dependencies: task 2 (completion=5), task 3 (completion=8). Max is 8 from task 3. Task 4 completes at 8+3=11. Predecessor is task 3."
      },
      {
        "step": 7,
        "action": "Find maximum completion time",
        "state": "max_time=11, end_task=4",
        "explanation": "Scan completion times: {1:3, 2:5, 3:8, 4:11}. Maximum is 11 at task 4."
      },
      {
        "step": 8,
        "action": "Backtrack through predecessors",
        "state": "4 \u2192 predecessor[4]=3 \u2192 predecessor[3]=1 \u2192 predecessor[1]=None",
        "explanation": "Start at task 4, follow predecessors: 4\u21923\u21921\u2192None. Build list [4,3,1]."
      },
      {
        "step": 9,
        "action": "Reverse path",
        "state": "critical_path = [1, 3, 4]",
        "explanation": "Reverse [4,3,1] to get execution order [1,3,4]."
      }
    ],
    "final_output": "(11, [1, 3, 4])"
  },
  "edge_cases": [
    {
      "case": "Empty task list",
      "handling": "Return (0, []) immediately",
      "gotcha": "Don't attempt to process empty input - it will cause errors when finding max completion time."
    },
    {
      "case": "Single task, no dependencies",
      "handling": "Task completes at its own duration, path contains just that task",
      "gotcha": "Predecessor is None for source tasks - handle null when backtracking."
    },
    {
      "case": "All tasks independent (no dependencies)",
      "handling": "Each task completes at its own duration. Return any one as critical path (all are equally critical).",
      "gotcha": "Multiple valid answers exist. Don't assert a specific task ID in tests - check duration is correct and path length is 1."
    },
    {
      "case": "Linear chain (A\u2192B\u2192C\u2192D)",
      "handling": "All tasks are on the critical path. Total time is sum of all durations.",
      "gotcha": "The entire chain should be returned, not just first and last tasks."
    },
    {
      "case": "Multiple critical paths (same length)",
      "handling": "Return any one valid path. The algorithm naturally returns one based on processing order.",
      "gotcha": "Tests should accept any valid critical path, not just one specific answer."
    },
    {
      "case": "Disconnected components",
      "handling": "Each component has its own critical path. The global critical path is from the component with maximum completion time.",
      "gotcha": "In-degree initialization must include ALL tasks, not just those mentioned in dependencies."
    }
  ],
  "test_cases": [
    {
      "name": "Diamond graph - basic functionality",
      "input": "tasks=[[1,3],[2,2],[3,5],[4,3]], deps=[[1,2],[1,3],[2,4],[3,4]]",
      "expected": "(11, [1, 3, 4])",
      "explanation": "Path 1\u21923\u21924 (3+5+3=11) is longer than 1\u21922\u21924 (3+2+3=8)"
    },
    {
      "name": "Independent tasks",
      "input": "tasks=[[1,5],[2,5]], deps=[]",
      "expected": "(5, [1]) or (5, [2])",
      "explanation": "Both tasks run in parallel, both complete at time 5. Either path is valid."
    },
    {
      "name": "Linear chain",
      "input": "tasks=[[1,2],[2,3],[3,4],[4,1]], deps=[[1,2],[2,3],[3,4]]",
      "expected": "(10, [1,2,3,4])",
      "explanation": "All tasks sequential. Total = 2+3+4+1 = 10. All tasks on critical path."
    },
    {
      "name": "Single task",
      "input": "tasks=[[42,7]], deps=[]",
      "expected": "(7, [42])",
      "explanation": "One task with duration 7. Critical path is just that task."
    },
    {
      "name": "Wide parallel tasks with merge",
      "input": "tasks=[[1,1],[2,10],[3,2],[4,3],[5,1]], deps=[[1,2],[1,3],[1,4],[2,5],[3,5],[4,5]]",
      "expected": "(12, [1,2,5])",
      "explanation": "Task 2 (duration 10) is the bottleneck. Path 1\u21922\u21925 = 1+10+1 = 12."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not tracking predecessors, trying to reconstruct path from completion times",
      "why_wrong": "Completion times alone don't tell you which path led to each task. You might incorrectly include non-critical tasks.",
      "correct_approach": "Track predecessor during topological sort. Record which dependency gave the maximum completion time.",
      "code_example_wrong": "# Wrong: Try to find path after the fact\npath = [end_task]\nwhile has_dependencies(current):\n    # Which dependency? completion times are ambiguous!",
      "code_example_correct": "# Correct: Track predecessor during processing\npredecessor[current] = best_dep  # Record during topo sort\n# Then backtrack is simple:\nwhile current: path.append(current); current = predecessor[current]"
    },
    {
      "mistake": "Updating completion time before task is fully ready",
      "why_wrong": "In Kahn's algorithm, a task's in-degree reaches 0 only when ALL dependencies are processed. Updating completion time when processing edges (instead of when popping from queue) can give wrong results.",
      "correct_approach": "Calculate completion time only when task is popped from the queue (in_degree became 0), ensuring all dependencies have been processed.",
      "code_example_wrong": "# Wrong: Update during edge processing\nfor next_task in graph[current]:\n    new_time = completion[current] + duration[next_task]\n    completion[next_task] = max(completion[next_task], new_time)",
      "code_example_correct": "# Correct: Update when task is dequeued\ncurrent = queue.popleft()\nmax_dep = max(completion[dep] for dep in reverse_graph[current])\ncompletion[current] = max_dep + duration[current]"
    },
    {
      "mistake": "Forgetting to reverse the backtracked path",
      "why_wrong": "Backtracking builds the path from end to start. Returning it as-is gives wrong order.",
      "correct_approach": "Reverse the path after backtracking, or use a deque with appendleft.",
      "code_example_wrong": "# Wrong: Return path as built\npath = []\nwhile current: path.append(current); current = pred[current]\nreturn path  # Returns [4, 3, 1] instead of [1, 3, 4]",
      "code_example_correct": "# Correct: Reverse before returning\npath.reverse()\nreturn path  # Returns [1, 3, 4]"
    },
    {
      "mistake": "Not handling tasks with no dependencies (source tasks)",
      "why_wrong": "Source tasks have no predecessors. Trying to find max among empty list causes errors or wrong values.",
      "correct_approach": "Check if dependencies list is empty before computing max. Source tasks start at time 0.",
      "code_example_wrong": "# Wrong: No check for empty dependencies\nmax_dep = max(completion[d] for d in reverse_graph[current])  # Error if empty!",
      "code_example_correct": "# Correct: Handle source tasks separately\ndeps = reverse_graph[current]\nif not deps:\n    completion[current] = duration[current]\nelse:\n    completion[current] = max(completion[d] for d in deps) + duration[current]"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the intuition: 'The critical path is like finding the longest path in a DAG. The key insight is that we can track which dependency delayed each task during our topological sort, then backtrack to find the path.' Draw the example graph and trace through manually before coding.",
    "what_to_mention": [
      "This is a classic project management technique (CPM - Critical Path Method)",
      "Real applications: build systems (make, gradle), CI/CD pipelines, project scheduling",
      "The algorithm is online - we could extend it to handle task additions",
      "Multiple critical paths may exist - our algorithm returns one arbitrarily",
      "Non-critical tasks have 'slack' or 'float' - room for delay without affecting project completion"
    ],
    "time_allocation": "10-15 minutes: 2 min for understanding, 3 min for approach explanation, 8 min for coding, 2 min for testing/edge cases",
    "if_stuck": [
      "Hint 1: What information do you need to reconstruct the path? (Answer: which predecessor determined each task's start time)",
      "Hint 2: When do you know all of a task's dependencies are processed? (Answer: when its in_degree reaches 0)",
      "Hint 3: How do you find the end of the critical path? (Answer: task with maximum completion time)",
      "Hint 4: How do you find the start of the critical path? (Answer: backtrack through predecessors until reaching None)"
    ]
  },
  "connection_to_next_part": "Part 4 could extend this to: (1) Find ALL critical paths (not just one), (2) Calculate slack/float for each task, (3) Handle task crashes by recomputing critical path, (4) Support incremental updates when tasks are added/removed. The predecessor tracking structure we've built is the foundation for these extensions.",
  "generated_at": "2026-01-14T15:17:07.750061",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}