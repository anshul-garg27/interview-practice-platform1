{
  "problem_title": "Employee Hierarchy / Org Tree",
  "difficulty": "medium",
  "category": "DSA/Trees + OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP Design** problem combined with **N-ary Tree** data structure. The organizational hierarchy naturally forms a tree where the CEO is the root, and each employee can have multiple direct reports (children). The key challenge is designing clean classes with proper relationships while ensuring O(1) lookups.",
    "pattern_recognition": "**HashMap + N-ary Tree + Bidirectional References**\n\n- **HashMap**: For O(1) employee lookup by ID\n- **N-ary Tree**: Each node (employee) can have multiple children (subordinates)\n- **Bidirectional**: Employee knows both manager (parent) and subordinates (children)\n- **OOP Design**: Separation of concerns between Employee (data) and OrgChart (operations)",
    "key_constraints": [
      "**Unique IDs (1 to 10\u2076)** - Must validate duplicates, use HashMap for O(1) existence check",
      "**Single CEO** - Only one employee can have null manager, need to track this",
      "**Manager must exist first** - Enforces top-down building, validates parent before adding child",
      "**Up to 10\u2075 employees** - HashMap handles this efficiently, O(n) space is acceptable",
      "**Bidirectional relationships** - Must update BOTH manager's subordinates list AND employee's manager reference"
    ],
    "clarifying_questions": [
      "**Can employee IDs be negative or zero?** - Constraints say 1 \u2264 id \u2264 10\u2076, so no need to handle \u2264 0",
      "**What if addEmployee is called with managerId = null when CEO already exists?** - Should return false (only one root allowed)",
      "**Should getEmployee return a copy or reference?** - Typically reference for efficiency, but mention immutability concerns",
      "**Can an employee's manager be changed after creation?** - Not in Part 1, but good to ask for future parts",
      "**Is thread-safety required?** - Not mentioned, assume single-threaded, but mention for production",
      "**What's the expected query pattern?** - Frequent reads vs writes affects optimization strategy",
      "**Should subordinates be ordered?** - Not specified, ArrayList is fine (insertion order)"
    ],
    "edge_cases_to_consider": [
      "Empty organization - getDirectReportCount on any ID returns -1",
      "Single employee (CEO only) - CEO exists but has 0 direct reports",
      "Linear chain - A \u2192 B \u2192 C \u2192 D, each node has exactly 0 or 1 child",
      "Wide and shallow - CEO with 100 direct reports, tests subordinates list",
      "Adding duplicate ID - Must return false even with different name/rating",
      "Adding to non-existent manager - Must validate manager exists first",
      "Second CEO attempt - Adding another employee with managerId = null should fail"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    ORGANIZATIONAL TREE STRUCTURE                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502    Tree View:              HashMap View:                        \u2502\n\u2502                                                                 \u2502\n\u2502        [CEO]               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502        /    \\              \u2502  ID    \u2502  Employee Reference  \u2502   \u2502\n\u2502       /      \\             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n\u2502    [VP1]   [VP2]           \u2502   1    \u2502  \u2192 Employee(Alice)   \u2502   \u2502\n\u2502      |     /    \\          \u2502   2    \u2502  \u2192 Employee(Bob)     \u2502   \u2502\n\u2502      |    /      \\         \u2502   3    \u2502  \u2192 Employee(Carol)   \u2502   \u2502\n\u2502   [Mgr] [Lead1] [Lead2]    \u2502   4    \u2502  \u2192 Employee(David)   \u2502   \u2502\n\u2502    / \\                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502   /   \\                                                         \u2502\n\u2502 [Dev] [Dev]                O(1) lookup by ID!                   \u2502\n\u2502                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              EMPLOYEE NODE STRUCTURE                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502   \u2502           Employee Object               \u2502                   \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                   \u2502\n\u2502   \u2502  id: int          \u2192 Unique identifier   \u2502                   \u2502\n\u2502   \u2502  name: str        \u2192 Display name        \u2502                   \u2502\n\u2502   \u2502  rating: int      \u2192 Performance (1-10)  \u2502                   \u2502\n\u2502   \u2502  manager: Employee \u2192 Parent (or null)   \u2502 \u2190 Upward link     \u2502\n\u2502   \u2502  subordinates: List<Employee>           \u2502 \u2190 Downward links  \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502                                                                 \u2502\n\u2502   Bidirectional Relationship Example:                           \u2502\n\u2502                                                                 \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     manager      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502   \u2502 Alice(1) \u2502 \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  Bob(2)  \u2502                    \u2502\n\u2502   \u2502          \u2502                  \u2502          \u2502                   \u2502\n\u2502   \u2502 subs:[2] \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502 subs:[]  \u2502                   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   subordinates   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502                                                                 \u2502\n\u2502   When adding Bob under Alice:                                  \u2502\n\u2502   1. bob.manager = alice                                        \u2502\n\u2502   2. alice.subordinates.append(bob)                             \u2502\n\u2502                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**Initialize OrgChart**",
        "visualization": "```\nOrgChart {\n  employees: {}     \u2190 Empty HashMap\n  ceo: null         \u2190 No root yet\n}\n```",
        "key_point": "Start with empty state, ready to accept first employee (CEO)"
      },
      {
        "step": 2,
        "description": "**Add CEO (managerId = null)**",
        "visualization": "```\n1. Check: id=1 exists? NO \u2713\n2. Check: managerId is null \u2192 This is CEO\n3. Check: ceo is null? YES \u2713 (no existing CEO)\n4. Create: Employee(1, 'Alice', 8)\n5. Set: ceo = newEmployee\n6. Store: employees[1] = newEmployee\n\nResult:\n  employees: {1: Alice}\n  ceo: \u2192 Alice\n```",
        "key_point": "CEO is special case - no parent, must be first, only one allowed"
      },
      {
        "step": 3,
        "description": "**Add Regular Employee**",
        "visualization": "```\naddEmployee(2, 'Bob', 7, 1):\n\n1. Check: id=2 exists? NO \u2713\n2. Check: managerId=1 exists? YES \u2713\n3. Create: Employee(2, 'Bob', 7)\n4. Get manager: manager = employees[1] (Alice)\n5. Link UP:   bob.manager = alice\n6. Link DOWN: alice.subordinates.append(bob)\n7. Store: employees[2] = bob\n\n        Alice                     Alice\n          \u2502          \u2192            \u2502\n          \u2205                      Bob\n```",
        "key_point": "Must set BOTH directions - child knows parent, parent knows child"
      },
      {
        "step": 4,
        "description": "**Query Direct Report Count**",
        "visualization": "```\ngetDirectReportCount(1):\n\n1. Check: id=1 exists? YES\n2. Get: employee = employees[1] (Alice)\n3. Return: len(alice.subordinates)\n\n        Alice           \n       /     \\          subordinates = [Bob, Carol]\n     Bob    Carol       len = 2 \u2713\n```",
        "key_point": "O(1) operation - just return list length, no traversal needed"
      }
    ],
    "dry_run_table": "| Step | Operation | Check 1 | Check 2 | Action | employees Map | CEO | Result |\n|------|-----------|---------|---------|--------|---------------|-----|--------|\n| 1 | `OrgChart()` | - | - | Initialize | `{}` | `null` | `OrgChart` |\n| 2 | `addEmployee(1, 'Alice', 8, null)` | ID 1 exists? NO \u2713 | CEO exists? NO \u2713 | Create Alice, set CEO | `{1: Alice}` | `Alice` | `true` |\n| 3 | `addEmployee(2, 'Bob', 7, 1)` | ID 2 exists? NO \u2713 | Manager 1 exists? YES \u2713 | Create Bob, link to Alice | `{1: Alice, 2: Bob}` | `Alice` | `true` |\n| 4 | `addEmployee(3, 'Carol', 6, 1)` | ID 3 exists? NO \u2713 | Manager 1 exists? YES \u2713 | Create Carol, link to Alice | `{1,2,3}` | `Alice` | `true` |\n| 5 | `addEmployee(4, 'David', 5, 2)` | ID 4 exists? NO \u2713 | Manager 2 exists? YES \u2713 | Create David, link to Bob | `{1,2,3,4}` | `Alice` | `true` |\n| 6 | `getDirectReportCount(1)` | ID 1 exists? YES \u2713 | - | Return `len(Alice.subs)` | - | - | `2` |\n| 7 | `getDirectReportCount(2)` | ID 2 exists? YES \u2713 | - | Return `len(Bob.subs)` | - | - | `1` |\n| 8 | `getDirectReportCount(4)` | ID 4 exists? YES \u2713 | - | Return `len(David.subs)` | - | - | `0` |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'organizational hierarchy'**, I immediately think of a **tree data structure**. Each employee has one manager (parent) and can have multiple reports (children). This is a classic N-ary tree.",
      "**When I see 'uniquely identifiable by ID'**, I know I need **O(1) lookup** for operations. This screams **HashMap<ID, Employee>** as the core data structure.",
      "**When I see 'maintains relationship with manager AND subordinates'**, I recognize the need for **bidirectional references**. Employee points up to manager AND manager's list points down to employee.",
      "**When I see 'direct reportees only'**, I understand the distinction - direct reports are immediate children (1 level down), not the entire subtree. This means getDirectReportCount is just `len(subordinates)`, not a DFS traversal.",
      "**When I see 'CEO has null manager'**, I identify the root node special case. Need to track CEO separately and ensure only one can exist.",
      "**Key insight #1**: Separation of concerns - `Employee` class handles data/relationships, `OrgChart` class handles operations/validation.",
      "**Key insight #2**: Pre-storing references means O(1) for all basic operations - no tree traversal needed for Part 1.",
      "**Key insight #3**: Validation order matters - check ID uniqueness BEFORE checking manager existence to give accurate error feedback."
    ],
    "key_insight": "## The Core Realization\n\nThis problem tests your ability to model **bidirectional tree relationships** efficiently. The trick is:\n\n1. **HashMap for O(1) access** - Don't traverse the tree to find employees\n2. **Bidirectional links** - Each modification requires TWO updates (child\u2192parent AND parent\u2192children)\n3. **Direct count vs Total count** - Direct is `len(subordinates)`, Total requires DFS (Part 2)\n\nThe elegant solution stores the tree structure in nodes while using HashMap as an index for fast lookups. This gives us the best of both worlds: tree semantics with constant-time access.",
    "why_this_works": "## Why This Approach is Correct\n\n### Tree Invariants Maintained:\n1. **Single Root**: CEO tracked separately, rejected if second null-manager added\n2. **No Orphans**: Manager must exist before child can be added\n3. **Unique IDs**: HashMap naturally enforces uniqueness with key check\n4. **Bidirectional Consistency**: Every add updates both directions atomically\n\n### Complexity Guarantees:\n- **addEmployee**: O(1) - HashMap lookup + list append\n- **getDirectReportCount**: O(1) - HashMap lookup + list size\n- **getEmployee**: O(1) - HashMap lookup\n\n### Memory Efficiency:\n- Each employee stored once in HashMap\n- References (pointers) used for relationships, not copies\n- Total space: O(E) where E = number of employees"
  },
  "approaches": [
    {
      "name": "Naive: Store Only Parent Reference",
      "description": "Each employee only stores their manager ID. To find direct reports, iterate through ALL employees checking who has this manager.",
      "pseudocode": "class Employee:\n    id, name, rating, managerId\n\ngetDirectReportCount(empId):\n    count = 0\n    for each employee in all_employees:\n        if employee.managerId == empId:\n            count++\n    return count",
      "time_complexity": "O(n) per getDirectReportCount call",
      "space_complexity": "O(n) total",
      "pros": [
        "Simplest data structure",
        "Easy to implement",
        "Less memory per employee (no list)"
      ],
      "cons": [
        "O(n) for every query - doesn't scale",
        "100K employees \u00d7 frequent queries = slow",
        "Can't efficiently traverse down the tree"
      ],
      "when_to_use": "Only for very small organizations (<100 employees) with rare queries"
    },
    {
      "name": "Better: Bidirectional References Without HashMap Index",
      "description": "Store bidirectional references (manager + subordinates list) but access tree only through CEO root. To find employee, traverse from root.",
      "pseudocode": "class Employee:\n    id, name, rating\n    manager: Employee\n    subordinates: List[Employee]\n\nclass OrgChart:\n    ceo: Employee\n\nfindEmployee(empId):\n    return dfs(ceo, empId)  # O(n) search\n\ngetDirectReportCount(empId):\n    emp = findEmployee(empId)  # O(n)\n    return len(emp.subordinates)  # O(1)",
      "time_complexity": "O(n) for any query (must traverse to find)",
      "space_complexity": "O(n) total",
      "pros": [
        "Proper tree structure",
        "Can traverse both directions",
        "Good foundation"
      ],
      "cons": [
        "Still O(n) for lookups",
        "Must traverse from root every time",
        "No random access by ID"
      ],
      "when_to_use": "When traversal operations dominate over lookups"
    },
    {
      "name": "Optimal: HashMap Index + Bidirectional Tree",
      "description": "Combine HashMap for O(1) lookup with bidirectional tree structure. HashMap indexes employees by ID; tree structure enables relationship traversal.",
      "pseudocode": "class Employee:\n    id, name, rating\n    manager: Employee  # null for CEO\n    subordinates: List[Employee]\n\nclass OrgChart:\n    employees: Map<id, Employee>  # O(1) index\n    ceo: Employee\n\naddEmployee(id, name, rating, managerId):\n    if id in employees: return false\n    emp = Employee(id, name, rating)\n    if managerId is null:\n        if ceo exists: return false\n        ceo = emp\n    else:\n        if managerId not in employees: return false\n        manager = employees[managerId]\n        emp.manager = manager\n        manager.subordinates.add(emp)\n    employees[id] = emp\n    return true\n\ngetDirectReportCount(empId):\n    if empId not in employees: return -1\n    return len(employees[empId].subordinates)",
      "time_complexity": "O(1) for ALL operations",
      "space_complexity": "O(n) for n employees",
      "pros": [
        "O(1) lookup, add, and query",
        "Supports both random access and traversal",
        "Scalable to 100K+ employees",
        "Clean separation of concerns"
      ],
      "cons": [
        "Slightly more complex implementation",
        "Must maintain consistency between HashMap and tree",
        "More memory per employee (list of children)"
      ],
      "key_insight": "**HashMap as Index, Tree as Structure** - Use HashMap like a database index for O(1) primary key lookup, while tree maintains relational structure for hierarchical queries."
    }
  ],
  "optimal_solution": {
    "name": "HashMap-Indexed Bidirectional N-ary Tree",
    "explanation_md": "## Approach\n\nWe design two classes with clear responsibilities:\n\n### 1. Employee Class (Data Node)\n- Stores employee attributes (id, name, rating)\n- Maintains bidirectional relationship references\n- Acts as a node in the organizational tree\n\n### 2. OrgChart Class (Operations Manager)\n- Maintains HashMap for O(1) employee lookup\n- Tracks CEO (root) separately\n- Handles all validation and relationship management\n\n## Why This Design Excels\n\n### Separation of Concerns\n```\nEmployee: \"I know WHO I am and WHO I relate to\"\nOrgChart: \"I know HOW to find anyone and HOW to modify the structure\"\n```\n\n### O(1) Everything\n- **addEmployee**: HashMap contains check + insertion = O(1)\n- **getDirectReportCount**: HashMap lookup + list size = O(1)\n- **getEmployee**: HashMap lookup = O(1)\n\n### Extensibility for Parts 2 & 3\nThe bidirectional structure enables:\n- DFS for total subordinate count\n- Tree traversal for team aggregations\n- Path queries (employee to CEO)",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Employee>",
        "purpose": "O(1) employee lookup by ID - the 'index' for our organizational data"
      },
      {
        "structure": "Employee.manager: Employee",
        "purpose": "Upward link to parent - enables finding reporting chain to CEO"
      },
      {
        "structure": "Employee.subordinates: List<Employee>",
        "purpose": "Downward links to children - enables team traversal and direct report count"
      },
      {
        "structure": "OrgChart.ceo: Employee",
        "purpose": "Root reference - quick access to top of hierarchy, validates single-root constraint"
      }
    ],
    "algorithm_steps": [
      "**Step 1: Initialize** - Create empty HashMap and null CEO reference",
      "**Step 2: Add Employee Validation** - Check ID uniqueness via HashMap contains (O(1))",
      "**Step 3: Handle CEO Case** - If managerId is null, verify no existing CEO, set as root",
      "**Step 4: Handle Regular Employee** - Verify manager exists, create bidirectional links",
      "**Step 5: Store in HashMap** - Add to employees map for future O(1) lookup",
      "**Step 6: Query Direct Reports** - Lookup employee, return subordinates list length"
    ],
    "why_decimal": "N/A - This problem doesn't involve currency calculations. However, if ratings were float-based averages, we would need to consider precision."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Employee Hierarchy / Org Tree - Production Implementation",
    "",
    "This module implements an organizational chart management system with:",
    "- O(1) employee lookup by ID",
    "- O(1) direct report count queries",
    "- Bidirectional tree structure for hierarchy traversal",
    "",
    "Author: Interview Preparation Guide",
    "Complexity: O(1) for all operations, O(n) space",
    "\"\"\"",
    "",
    "from typing import Optional, List, Dict",
    "",
    "",
    "class Employee:",
    "    \"\"\"",
    "    Represents an employee node in the organizational hierarchy.",
    "    ",
    "    Each employee maintains bidirectional references:",
    "    - Upward: reference to manager (parent node)",
    "    - Downward: list of subordinates (child nodes)",
    "    ",
    "    Attributes:",
    "        id: Unique employee identifier (1 to 10^6)",
    "        name: Employee's display name",
    "        rating: Performance rating (1-10)",
    "        manager: Reference to direct manager (None for CEO)",
    "        subordinates: List of direct reports",
    "    ",
    "    Example:",
    "        >>> alice = Employee(1, 'Alice', 8)",
    "        >>> bob = Employee(2, 'Bob', 7)",
    "        >>> bob.manager = alice",
    "        >>> alice.subordinates.append(bob)",
    "    \"\"\"",
    "    ",
    "    def __init__(self, emp_id: int, name: str, rating: int) -> None:",
    "        \"\"\"Initialize employee with basic attributes.\"\"\"",
    "        self.id: int = emp_id",
    "        self.name: str = name",
    "        self.rating: int = rating",
    "        self.manager: Optional['Employee'] = None",
    "        self.subordinates: List['Employee'] = []",
    "    ",
    "    def get_id(self) -> int:",
    "        \"\"\"Return employee's unique identifier.\"\"\"",
    "        return self.id",
    "    ",
    "    def get_name(self) -> str:",
    "        \"\"\"Return employee's name.\"\"\"",
    "        return self.name",
    "    ",
    "    def get_rating(self) -> int:",
    "        \"\"\"Return employee's performance rating.\"\"\"",
    "        return self.rating",
    "    ",
    "    def get_manager(self) -> Optional['Employee']:",
    "        \"\"\"Return reference to employee's manager, or None for CEO.\"\"\"",
    "        return self.manager",
    "    ",
    "    def get_subordinates(self) -> List['Employee']:",
    "        \"\"\"Return list of direct reports.\"\"\"",
    "        return self.subordinates",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"Return string representation for debugging.\"\"\"",
    "        manager_id = self.manager.id if self.manager else None",
    "        return (f\"Employee(id={self.id}, name='{self.name}', \"",
    "                f\"rating={self.rating}, manager_id={manager_id}, \"",
    "                f\"direct_reports={len(self.subordinates)})\")",
    "",
    "",
    "class OrgChart:",
    "    \"\"\"",
    "    Manages organizational hierarchy with efficient operations.",
    "    ",
    "    Uses HashMap for O(1) employee lookup combined with tree structure",
    "    for hierarchical relationship traversal.",
    "    ",
    "    Invariants maintained:",
    "    - Unique employee IDs",
    "    - Single CEO (root with null manager)",
    "    - Manager must exist before adding subordinate",
    "    - Bidirectional relationships always consistent",
    "    ",
    "    Complexity:",
    "    - add_employee: O(1)",
    "    - get_direct_report_count: O(1)",
    "    - get_employee: O(1)",
    "    - Space: O(n) for n employees",
    "    ",
    "    Example:",
    "        >>> org = OrgChart()",
    "        >>> org.add_employee(1, 'CEO', 9, None)",
    "        True",
    "        >>> org.add_employee(2, 'VP', 8, 1)",
    "        True",
    "        >>> org.get_direct_report_count(1)",
    "        1",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize empty organizational chart.\"\"\"",
    "        self._employees: Dict[int, Employee] = {}",
    "        self._ceo: Optional[Employee] = None",
    "    ",
    "    def add_employee(",
    "        self,",
    "        emp_id: int,",
    "        name: str,",
    "        rating: int,",
    "        manager_id: Optional[int]",
    "    ) -> bool:",
    "        \"\"\"",
    "        Add an employee to the organization.",
    "        ",
    "        Args:",
    "            emp_id: Unique identifier for the employee",
    "            name: Employee's display name",
    "            rating: Performance rating (1-10)",
    "            manager_id: ID of manager, or None for CEO",
    "        ",
    "        Returns:",
    "            True if employee added successfully, False otherwise",
    "        ",
    "        Failure cases:",
    "            - emp_id already exists in organization",
    "            - manager_id is None but CEO already exists",
    "            - manager_id is not None but manager doesn't exist",
    "        ",
    "        Example:",
    "            >>> org = OrgChart()",
    "            >>> org.add_employee(1, 'Alice', 8, None)  # Add CEO",
    "            True",
    "            >>> org.add_employee(1, 'Bob', 7, None)    # Duplicate ID",
    "            False",
    "        \"\"\"",
    "        # Validation 1: Check for duplicate ID",
    "        if emp_id in self._employees:",
    "            return False",
    "        ",
    "        # Create new employee instance",
    "        new_employee = Employee(emp_id, name, rating)",
    "        ",
    "        if manager_id is None:",
    "            # This employee is the CEO (root node)",
    "            # Validation 2: Only one CEO allowed",
    "            if self._ceo is not None:",
    "                return False",
    "            self._ceo = new_employee",
    "        else:",
    "            # This is a regular employee with a manager",
    "            # Validation 3: Manager must exist",
    "            if manager_id not in self._employees:",
    "                return False",
    "            ",
    "            # Establish bidirectional relationship",
    "            manager = self._employees[manager_id]",
    "            new_employee.manager = manager          # Child \u2192 Parent",
    "            manager.subordinates.append(new_employee)  # Parent \u2192 Child",
    "        ",
    "        # Add to HashMap index for O(1) future lookups",
    "        self._employees[emp_id] = new_employee",
    "        return True",
    "    ",
    "    def get_direct_report_count(self, employee_id: int) -> int:",
    "        \"\"\"",
    "        Get the count of direct reports for an employee.",
    "        ",
    "        Direct reports are employees who report DIRECTLY to this",
    "        employee (one level down only, not entire subtree).",
    "        ",
    "        Args:",
    "            employee_id: ID of the employee to query",
    "        ",
    "        Returns:",
    "            Number of direct reports, or -1 if employee not found",
    "        ",
    "        Example:",
    "            >>> org = OrgChart()",
    "            >>> org.add_employee(1, 'CEO', 9, None)",
    "            True",
    "            >>> org.add_employee(2, 'VP1', 8, 1)",
    "            True",
    "            >>> org.add_employee(3, 'VP2', 7, 1)",
    "            True",
    "            >>> org.get_direct_report_count(1)  # CEO has 2 direct reports",
    "            2",
    "            >>> org.get_direct_report_count(2)  # VP1 has 0 direct reports",
    "            0",
    "            >>> org.get_direct_report_count(99)  # Non-existent",
    "            -1",
    "        \"\"\"",
    "        if employee_id not in self._employees:",
    "            return -1",
    "        return len(self._employees[employee_id].subordinates)",
    "    ",
    "    def get_employee(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"",
    "        Retrieve an employee by their ID.",
    "        ",
    "        Args:",
    "            employee_id: ID of the employee to retrieve",
    "        ",
    "        Returns:",
    "            Employee object if found, None otherwise",
    "        ",
    "        Example:",
    "            >>> org = OrgChart()",
    "            >>> org.add_employee(1, 'Alice', 8, None)",
    "            True",
    "            >>> emp = org.get_employee(1)",
    "            >>> emp.name",
    "            'Alice'",
    "            >>> org.get_employee(99) is None",
    "            True",
    "        \"\"\"",
    "        return self._employees.get(employee_id)",
    "    ",
    "    def get_ceo(self) -> Optional[Employee]:",
    "        \"\"\"Return the CEO (root) of the organization.\"\"\"",
    "        return self._ceo",
    "    ",
    "    def size(self) -> int:",
    "        \"\"\"Return total number of employees in the organization.\"\"\"",
    "        return len(self._employees)",
    "",
    "",
    "def run_example_1() -> None:",
    "    \"\"\"Run Example 1: Building Basic Org Structure.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 1: Building Basic Org Structure\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    print(\"Building organization:\")",
    "    print(\"      Alice(1)\")",
    "    print(\"       /   \\\\\")",
    "    print(\"    Bob(2) Carol(3)\")",
    "    print(\"      |\")",
    "    print(\"   David(4)\")",
    "    print()",
    "    ",
    "    org = OrgChart()",
    "    ",
    "    results = []",
    "    results.append(('addEmployee(1, Alice, 8, null)', org.add_employee(1, 'Alice', 8, None)))",
    "    results.append(('addEmployee(2, Bob, 7, 1)', org.add_employee(2, 'Bob', 7, 1)))",
    "    results.append(('addEmployee(3, Carol, 6, 1)', org.add_employee(3, 'Carol', 6, 1)))",
    "    results.append(('addEmployee(4, David, 5, 2)', org.add_employee(4, 'David', 5, 2)))",
    "    ",
    "    print(\"Operations:\")",
    "    for op, result in results:",
    "        print(f\"  {op} \u2192 {result}\")",
    "    ",
    "    print()",
    "    print(\"Queries:\")",
    "    print(f\"  getDirectReportCount(1) \u2192 {org.get_direct_report_count(1)}  (Alice: Bob, Carol)\")",
    "    print(f\"  getDirectReportCount(2) \u2192 {org.get_direct_report_count(2)}  (Bob: David)\")",
    "    print(f\"  getDirectReportCount(4) \u2192 {org.get_direct_report_count(4)}  (David: none)\")",
    "    print()",
    "",
    "",
    "def run_example_2() -> None:",
    "    \"\"\"Run Example 2: Error Handling.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 2: Error Handling\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    ",
    "    org = OrgChart()",
    "    ",
    "    print(\"Testing error cases:\")",
    "    print(f\"  addEmployee(1, CEO, 9, null) \u2192 {org.add_employee(1, 'CEO', 9, None)}\")",
    "    print(f\"  addEmployee(2, Mgr, 7, 99)   \u2192 {org.add_employee(2, 'Manager', 7, 99)}  (manager 99 doesn't exist)\")",
    "    print(f\"  addEmployee(1, Dup, 5, null) \u2192 {org.add_employee(1, 'Duplicate', 5, None)}  (ID 1 already exists)\")",
    "    print(f\"  getDirectReportCount(100)   \u2192 {org.get_direct_report_count(100)}  (employee 100 doesn't exist)\")",
    "    print(f\"  addEmployee(3, Valid, 6, 1) \u2192 {org.add_employee(3, 'Valid', 6, 1)}  (valid addition)\")",
    "    print()",
    "",
    "",
    "def run_example_3() -> None:",
    "    \"\"\"Run Example 3: Larger Organization.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 3: Larger Organization\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    print(\"Building organization:\")",
    "    print(\"            CEO(1)\")",
    "    print(\"           /     \\\\\")",
    "    print(\"      VPEng(2)  VPSales(3)\")",
    "    print(\"         |       /    \\\\\")",
    "    print(\"     EngMgr(4) Lead1(5) Lead2(6)\")",
    "    print(\"       /   \\\\\")",
    "    print(\"    Dev1(7) Dev2(8)\")",
    "    print()",
    "    ",
    "    org = OrgChart()",
    "    ",
    "    # Build organization",
    "    org.add_employee(1, 'CEO', 8, None)",
    "    org.add_employee(2, 'VPEng', 7, 1)",
    "    org.add_employee(3, 'VPSales', 6, 1)",
    "    org.add_employee(4, 'EngMgr', 5, 2)",
    "    org.add_employee(5, 'SalesLead1', 9, 3)",
    "    org.add_employee(6, 'SalesLead2', 4, 3)",
    "    org.add_employee(7, 'Dev1', 6, 4)",
    "    org.add_employee(8, 'Dev2', 8, 4)",
    "    ",
    "    print(\"Direct report counts:\")",
    "    print(f\"  CEO (1):       {org.get_direct_report_count(1)} direct reports (VPEng, VPSales)\")",
    "    print(f\"  VPEng (2):     {org.get_direct_report_count(2)} direct report (EngMgr)\")",
    "    print(f\"  VPSales (3):   {org.get_direct_report_count(3)} direct reports (Lead1, Lead2)\")",
    "    print(f\"  EngMgr (4):    {org.get_direct_report_count(4)} direct reports (Dev1, Dev2)\")",
    "    print(f\"  SalesLead1(5): {org.get_direct_report_count(5)} direct reports (leaf node)\")",
    "    print()",
    "    ",
    "    print(\"Employee details:\")",
    "    ceo = org.get_employee(1)",
    "    if ceo:",
    "        print(f\"  {ceo}\")",
    "    print()",
    "",
    "",
    "if __name__ == '__main__':",
    "    run_example_1()",
    "    run_example_2()",
    "    run_example_3()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"All examples completed successfully!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Employee Hierarchy / Org Tree - Production Implementation",
    " * ",
    " * Implements an organizational chart management system with:",
    " * - O(1) employee lookup by ID",
    " * - O(1) direct report count queries",
    " * - Bidirectional tree structure for hierarchy traversal",
    " */",
    "",
    "/**",
    " * Represents an employee node in the organizational hierarchy.",
    " * ",
    " * Each employee maintains bidirectional references:",
    " * - Upward: reference to manager (parent node)",
    " * - Downward: list of subordinates (child nodes)",
    " */",
    "class Employee {",
    "    private final int id;",
    "    private final String name;",
    "    private final int rating;",
    "    private Employee manager;",
    "    private final List<Employee> subordinates;",
    "    ",
    "    /**",
    "     * Initialize employee with basic attributes.",
    "     * ",
    "     * @param id Unique employee identifier (1 to 10^6)",
    "     * @param name Employee's display name",
    "     * @param rating Performance rating (1-10)",
    "     */",
    "    public Employee(int id, String name, int rating) {",
    "        this.id = id;",
    "        this.name = name;",
    "        this.rating = rating;",
    "        this.manager = null;",
    "        this.subordinates = new ArrayList<>();",
    "    }",
    "    ",
    "    public int getId() { return id; }",
    "    public String getName() { return name; }",
    "    public int getRating() { return rating; }",
    "    public Employee getManager() { return manager; }",
    "    public void setManager(Employee manager) { this.manager = manager; }",
    "    public List<Employee> getSubordinates() { return subordinates; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        Integer managerId = (manager != null) ? manager.getId() : null;",
    "        return String.format(",
    "            \"Employee(id=%d, name='%s', rating=%d, managerId=%s, directReports=%d)\",",
    "            id, name, rating, managerId, subordinates.size()",
    "        );",
    "    }",
    "}",
    "",
    "/**",
    " * Manages organizational hierarchy with efficient operations.",
    " * ",
    " * Uses HashMap for O(1) employee lookup combined with tree structure",
    " * for hierarchical relationship traversal.",
    " * ",
    " * Invariants maintained:",
    " * - Unique employee IDs",
    " * - Single CEO (root with null manager)",
    " * - Manager must exist before adding subordinate",
    " * - Bidirectional relationships always consistent",
    " * ",
    " * Complexity:",
    " * - addEmployee: O(1)",
    " * - getDirectReportCount: O(1)",
    " * - getEmployee: O(1)",
    " * - Space: O(n) for n employees",
    " */",
    "class OrgChart {",
    "    private final Map<Integer, Employee> employees;",
    "    private Employee ceo;",
    "    ",
    "    /** Initialize empty organizational chart. */",
    "    public OrgChart() {",
    "        this.employees = new HashMap<>();",
    "        this.ceo = null;",
    "    }",
    "    ",
    "    /**",
    "     * Add an employee to the organization.",
    "     * ",
    "     * @param id Unique identifier for the employee",
    "     * @param name Employee's display name",
    "     * @param rating Performance rating (1-10)",
    "     * @param managerId ID of manager, or null for CEO",
    "     * @return true if employee added successfully, false otherwise",
    "     * ",
    "     * Failure cases:",
    "     * - id already exists in organization",
    "     * - managerId is null but CEO already exists",
    "     * - managerId is not null but manager doesn't exist",
    "     */",
    "    public boolean addEmployee(int id, String name, int rating, Integer managerId) {",
    "        // Validation 1: Check for duplicate ID",
    "        if (employees.containsKey(id)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Create new employee instance",
    "        Employee newEmployee = new Employee(id, name, rating);",
    "        ",
    "        if (managerId == null) {",
    "            // This employee is the CEO (root node)",
    "            // Validation 2: Only one CEO allowed",
    "            if (ceo != null) {",
    "                return false;",
    "            }",
    "            ceo = newEmployee;",
    "        } else {",
    "            // This is a regular employee with a manager",
    "            // Validation 3: Manager must exist",
    "            if (!employees.containsKey(managerId)) {",
    "                return false;",
    "            }",
    "            ",
    "            // Establish bidirectional relationship",
    "            Employee manager = employees.get(managerId);",
    "            newEmployee.setManager(manager);           // Child -> Parent",
    "            manager.getSubordinates().add(newEmployee); // Parent -> Child",
    "        }",
    "        ",
    "        // Add to HashMap index for O(1) future lookups",
    "        employees.put(id, newEmployee);",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Get the count of direct reports for an employee.",
    "     * ",
    "     * Direct reports are employees who report DIRECTLY to this",
    "     * employee (one level down only, not entire subtree).",
    "     * ",
    "     * @param employeeId ID of the employee to query",
    "     * @return Number of direct reports, or -1 if employee not found",
    "     */",
    "    public int getDirectReportCount(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) {",
    "            return -1;",
    "        }",
    "        return employees.get(employeeId).getSubordinates().size();",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve an employee by their ID.",
    "     * ",
    "     * @param employeeId ID of the employee to retrieve",
    "     * @return Employee object if found, null otherwise",
    "     */",
    "    public Employee getEmployee(int employeeId) {",
    "        return employees.get(employeeId);",
    "    }",
    "    ",
    "    /** Return the CEO (root) of the organization. */",
    "    public Employee getCeo() {",
    "        return ceo;",
    "    }",
    "    ",
    "    /** Return total number of employees in the organization. */",
    "    public int size() {",
    "        return employees.size();",
    "    }",
    "}",
    "",
    "/**",
    " * Demo class to run all examples.",
    " */",
    "public class OrgChartDemo {",
    "    ",
    "    public static void runExample1() {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Example 1: Building Basic Org Structure\");",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println();",
    "        System.out.println(\"Building organization:\");",
    "        System.out.println(\"      Alice(1)\");",
    "        System.out.println(\"       /   \\\\\");",
    "        System.out.println(\"    Bob(2) Carol(3)\");",
    "        System.out.println(\"      |\");",
    "        System.out.println(\"   David(4)\");",
    "        System.out.println();",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        System.out.println(\"Operations:\");",
    "        System.out.println(\"  addEmployee(1, Alice, 8, null) -> \" + org.addEmployee(1, \"Alice\", 8, null));",
    "        System.out.println(\"  addEmployee(2, Bob, 7, 1) -> \" + org.addEmployee(2, \"Bob\", 7, 1));",
    "        System.out.println(\"  addEmployee(3, Carol, 6, 1) -> \" + org.addEmployee(3, \"Carol\", 6, 1));",
    "        System.out.println(\"  addEmployee(4, David, 5, 2) -> \" + org.addEmployee(4, \"David\", 5, 2));",
    "        ",
    "        System.out.println();",
    "        System.out.println(\"Queries:\");",
    "        System.out.println(\"  getDirectReportCount(1) -> \" + org.getDirectReportCount(1) + \"  (Alice: Bob, Carol)\");",
    "        System.out.println(\"  getDirectReportCount(2) -> \" + org.getDirectReportCount(2) + \"  (Bob: David)\");",
    "        System.out.println(\"  getDirectReportCount(4) -> \" + org.getDirectReportCount(4) + \"  (David: none)\");",
    "        System.out.println();",
    "    }",
    "    ",
    "    public static void runExample2() {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Example 2: Error Handling\");",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println();",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        System.out.println(\"Testing error cases:\");",
    "        System.out.println(\"  addEmployee(1, CEO, 9, null) -> \" + org.addEmployee(1, \"CEO\", 9, null));",
    "        System.out.println(\"  addEmployee(2, Mgr, 7, 99)   -> \" + org.addEmployee(2, \"Manager\", 7, 99) + \"  (manager 99 doesn't exist)\");",
    "        System.out.println(\"  addEmployee(1, Dup, 5, null) -> \" + org.addEmployee(1, \"Duplicate\", 5, null) + \"  (ID 1 already exists)\");",
    "        System.out.println(\"  getDirectReportCount(100)   -> \" + org.getDirectReportCount(100) + \"  (employee 100 doesn't exist)\");",
    "        System.out.println(\"  addEmployee(3, Valid, 6, 1) -> \" + org.addEmployee(3, \"Valid\", 6, 1) + \"  (valid addition)\");",
    "        System.out.println();",
    "    }",
    "    ",
    "    public static void runExample3() {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Example 3: Larger Organization\");",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println();",
    "        System.out.println(\"Building organization:\");",
    "        System.out.println(\"            CEO(1)\");",
    "        System.out.println(\"           /     \\\\\");",
    "        System.out.println(\"      VPEng(2)  VPSales(3)\");",
    "        System.out.println(\"         |       /    \\\\\");",
    "        System.out.println(\"     EngMgr(4) Lead1(5) Lead2(6)\");",
    "        System.out.println(\"       /   \\\\\");",
    "        System.out.println(\"    Dev1(7) Dev2(8)\");",
    "        System.out.println();",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        // Build organization",
    "        org.addEmployee(1, \"CEO\", 8, null);",
    "        org.addEmployee(2, \"VPEng\", 7, 1);",
    "        org.addEmployee(3, \"VPSales\", 6, 1);",
    "        org.addEmployee(4, \"EngMgr\", 5, 2);",
    "        org.addEmployee(5, \"SalesLead1\", 9, 3);",
    "        org.addEmployee(6, \"SalesLead2\", 4, 3);",
    "        org.addEmployee(7, \"Dev1\", 6, 4);",
    "        org.addEmployee(8, \"Dev2\", 8, 4);",
    "        ",
    "        System.out.println(\"Direct report counts:\");",
    "        System.out.println(\"  CEO (1):       \" + org.getDirectReportCount(1) + \" direct reports (VPEng, VPSales)\");",
    "        System.out.println(\"  VPEng (2):     \" + org.getDirectReportCount(2) + \" direct report (EngMgr)\");",
    "        System.out.println(\"  VPSales (3):   \" + org.getDirectReportCount(3) + \" direct reports (Lead1, Lead2)\");",
    "        System.out.println(\"  EngMgr (4):    \" + org.getDirectReportCount(4) + \" direct reports (Dev1, Dev2)\");",
    "        System.out.println(\"  SalesLead1(5): \" + org.getDirectReportCount(5) + \" direct reports (leaf node)\");",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"Employee details:\");",
    "        Employee ceo = org.getEmployee(1);",
    "        if (ceo != null) {",
    "            System.out.println(\"  \" + ceo);",
    "        }",
    "        System.out.println();",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        runExample1();",
    "        runExample2();",
    "        runExample3();",
    "        ",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"All examples completed successfully!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "section": "Module Docstring & Imports",
      "explanation": "We import `Optional` for nullable types, `List` for subordinates collection, and `Dict` for the HashMap. The docstring explains the module's purpose and complexity guarantees upfront."
    },
    {
      "lines": "17-65",
      "section": "Employee Class",
      "explanation": "The `Employee` class represents a **node in the N-ary tree**. Key design decisions:\n- **Immutable ID**: Set in constructor, never changes\n- **manager**: Reference to parent node (None for CEO)\n- **subordinates**: List of child nodes (direct reports only)\n- **Bidirectional**: Enables traversal up and down the tree\n- **Getters**: Provide controlled access to internal state"
    },
    {
      "lines": "68-103",
      "section": "OrgChart Class Definition",
      "explanation": "The `OrgChart` class manages the entire organization:\n- **_employees**: HashMap<int, Employee> for O(1) lookup by ID\n- **_ceo**: Direct reference to root node for quick access\n- **Private attributes**: Underscore prefix indicates internal use"
    },
    {
      "lines": "105-152",
      "section": "addEmployee Method",
      "explanation": "This is the core method with **three validation gates**:\n1. **ID uniqueness**: `if emp_id in self._employees` - O(1) HashMap check\n2. **CEO uniqueness**: Only one null-manager allowed\n3. **Manager existence**: Parent must exist before child\n\nThe **bidirectional link creation** is critical:\n```python\nnew_employee.manager = manager          # Child knows parent\nmanager.subordinates.append(new_employee) # Parent knows child\n```\nBoth must be set atomically to maintain consistency."
    },
    {
      "lines": "154-175",
      "section": "getDirectReportCount Method",
      "explanation": "Elegantly simple - the subordinates list already contains exactly what we need:\n```python\nreturn len(self._employees[employee_id].subordinates)\n```\n\n**Key insight**: We return the LENGTH of subordinates list, not a DFS count. This is O(1) because we're just reading a pre-computed value (list size), not traversing the tree."
    },
    {
      "lines": "177-193",
      "section": "getEmployee Method",
      "explanation": "Simple O(1) HashMap lookup using `.get()` which returns `None` if key doesn't exist (avoiding KeyError). This is more Pythonic than checking `if key in dict` first."
    },
    {
      "lines": "200-280",
      "section": "Demo Functions",
      "explanation": "Three runnable examples demonstrating:\n1. **Basic org building**: CEO \u2192 VPs \u2192 Managers \u2192 ICs\n2. **Error handling**: Duplicate IDs, missing managers, non-existent queries\n3. **Larger organization**: Full 8-employee tree\n\nEach prints ASCII art of the tree structure for visual understanding."
    }
  ],
  "complexity_analysis": {
    "time": {
      "addEmployee": {
        "complexity": "O(1)",
        "explanation": "- HashMap `contains` check: O(1)\n- Employee object creation: O(1)\n- HashMap `get` for manager: O(1)\n- List `append` for subordinates: O(1) amortized\n- HashMap `put`: O(1) amortized"
      },
      "getDirectReportCount": {
        "complexity": "O(1)",
        "explanation": "- HashMap `contains` check: O(1)\n- HashMap `get`: O(1)\n- List `size`/`len`: O(1)\n\n**No tree traversal needed!** Direct reports are stored in a list, so count is instant."
      },
      "getEmployee": {
        "complexity": "O(1)",
        "explanation": "Single HashMap lookup operation."
      },
      "overall": "All operations are **O(1)** - constant time regardless of organization size. This is optimal."
    },
    "space": {
      "complexity": "O(E) where E = number of employees",
      "breakdown": "```\n- HashMap storage: O(E) - one entry per employee\n- Employee objects: O(E) - one object per employee\n- Subordinates lists: O(E) total - each employee appears in exactly one list\n- Manager references: O(E) - one pointer per employee\n\nTotal: O(E) linear space\n```",
      "note": "Each employee is stored once in HashMap and referenced at most once in a subordinates list. No duplication."
    },
    "can_we_do_better": "**Time**: No - O(1) is optimal for all operations.\n\n**Space**: Theoretically could avoid storing subordinates list and compute on-demand (O(1) \u2192 O(n) time tradeoff), but this would violate Part 2/3 requirements for efficient traversal. Current O(E) space is optimal given the requirements."
  },
  "dry_run": {
    "example": "OrgChart(), add(1,'Alice',8,null), add(2,'Bob',7,1), add(3,'Carol',6,1), add(4,'David',5,2), getDirectReportCount(1), getDirectReportCount(2), getDirectReportCount(4)",
    "trace_table": "| Step | Operation | Validation | employees Map | CEO | Result |\n|------|-----------|------------|---------------|-----|--------|\n| 1 | `OrgChart()` | - | `{}` | `null` | OrgChart created |\n| 2 | `add(1,'Alice',8,null)` | ID 1 exists? NO \u2713<br>CEO exists? NO \u2713 | `{1: Alice(mgr=null, subs=[])}` | `\u2192 Alice` | `true` |\n| 3 | `add(2,'Bob',7,1)` | ID 2 exists? NO \u2713<br>Mgr 1 exists? YES \u2713 | `{1: Alice(subs=[Bob]), 2: Bob(mgr=Alice)}` | `\u2192 Alice` | `true` |\n| 4 | `add(3,'Carol',6,1)` | ID 3 exists? NO \u2713<br>Mgr 1 exists? YES \u2713 | `{1: Alice(subs=[Bob,Carol]), 2: Bob, 3: Carol(mgr=Alice)}` | `\u2192 Alice` | `true` |\n| 5 | `add(4,'David',5,2)` | ID 4 exists? NO \u2713<br>Mgr 2 exists? YES \u2713 | `{1: Alice(subs=[Bob,Carol]), 2: Bob(subs=[David]), 3: Carol, 4: David(mgr=Bob)}` | `\u2192 Alice` | `true` |\n| 6 | `getDirectReportCount(1)` | ID 1 exists? YES \u2713 | - | - | `len([Bob,Carol]) = 2` |\n| 7 | `getDirectReportCount(2)` | ID 2 exists? YES \u2713 | - | - | `len([David]) = 1` |\n| 8 | `getDirectReportCount(4)` | ID 4 exists? YES \u2713 | - | - | `len([]) = 0` |",
    "final_answer": "Output: [null, true, true, true, true, 2, 1, 0] - matches expected!"
  },
  "test_cases": [
    {
      "name": "Single Employee (CEO only)",
      "category": "Edge Case",
      "input": "OrgChart(), add(1,'CEO',9,null), getDirectReportCount(1)",
      "expected": "[null, true, 0]",
      "explanation": "CEO exists but has no subordinates - returns 0, not -1"
    },
    {
      "name": "Linear Chain (A \u2192 B \u2192 C)",
      "category": "Structure",
      "input": "add(1,'A',8,null), add(2,'B',7,1), add(3,'C',6,2), getDirectReportCount(1), getDirectReportCount(2)",
      "expected": "[true, true, true, 1, 1]",
      "explanation": "Each node has exactly 1 direct report (except leaf)"
    },
    {
      "name": "Wide Tree (CEO with 5 direct reports)",
      "category": "Structure",
      "input": "add(1,'CEO',9,null), add(2,'VP1',8,1), add(3,'VP2',7,1), add(4,'VP3',6,1), add(5,'VP4',5,1), add(6,'VP5',4,1), getDirectReportCount(1)",
      "expected": "[true, true, true, true, true, true, 5]",
      "explanation": "CEO has 5 direct reports - tests wide hierarchy"
    },
    {
      "name": "Duplicate ID Rejection",
      "category": "Error Handling",
      "input": "add(1,'Alice',8,null), add(1,'Bob',7,null)",
      "expected": "[true, false]",
      "explanation": "Second add with same ID fails even with different name/manager"
    },
    {
      "name": "Second CEO Rejection",
      "category": "Error Handling",
      "input": "add(1,'CEO1',9,null), add(2,'CEO2',8,null)",
      "expected": "[true, false]",
      "explanation": "Only one employee can have null manager"
    },
    {
      "name": "Non-existent Manager",
      "category": "Error Handling",
      "input": "add(1,'CEO',9,null), add(2,'Emp',8,99)",
      "expected": "[true, false]",
      "explanation": "Manager ID 99 doesn't exist - cannot add employee"
    },
    {
      "name": "Query Non-existent Employee",
      "category": "Error Handling",
      "input": "add(1,'CEO',9,null), getDirectReportCount(99)",
      "expected": "[true, -1]",
      "explanation": "Employee 99 doesn't exist - returns -1 per spec"
    },
    {
      "name": "Empty Organization Query",
      "category": "Edge Case",
      "input": "OrgChart(), getDirectReportCount(1)",
      "expected": "[null, -1]",
      "explanation": "No employees exist yet - any query returns -1"
    },
    {
      "name": "Deep Hierarchy (5 levels)",
      "category": "Structure",
      "input": "add(1,'L1',9,null), add(2,'L2',8,1), add(3,'L3',7,2), add(4,'L4',6,3), add(5,'L5',5,4), getDirectReportCount(1), getDirectReportCount(4)",
      "expected": "[true, true, true, true, true, 1, 1]",
      "explanation": "Tests deep hierarchy - direct reports unaffected by depth"
    },
    {
      "name": "Multiple Children at Different Levels",
      "category": "Complex",
      "input": "add(1,'CEO',9,null), add(2,'VP',8,1), add(3,'VP2',7,1), add(4,'Mgr',6,2), add(5,'Mgr2',5,2), getDirectReportCount(1), getDirectReportCount(2), getDirectReportCount(3)",
      "expected": "[true, true, true, true, true, 2, 2, 0]",
      "explanation": "CEO has 2 reports, VP has 2 reports, VP2 has 0 reports"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Counting ALL subordinates instead of DIRECT reports",
      "why_wrong": "Total subordinates requires DFS traversal (Part 2). Direct reports is just immediate children.",
      "correct_approach": "Return `len(subordinates)` - the list only contains direct children",
      "code_wrong": "def get_direct_report_count(self, id):\n    count = 0\n    def dfs(emp):\n        nonlocal count\n        for sub in emp.subordinates:\n            count += 1\n            dfs(sub)\n    dfs(self._employees[id])\n    return count",
      "code_correct": "def get_direct_report_count(self, id):\n    return len(self._employees[id].subordinates)"
    },
    {
      "mistake": "Forgetting to update BOTH directions of relationship",
      "why_wrong": "Tree becomes inconsistent - can traverse down but not up, or vice versa",
      "correct_approach": "Always set child.manager AND manager.subordinates.append(child) together",
      "code_wrong": "# Only sets one direction\nnew_employee.manager = manager\n# Forgot: manager.subordinates.append(new_employee)",
      "code_correct": "# Set both directions atomically\nnew_employee.manager = manager\nmanager.subordinates.append(new_employee)"
    },
    {
      "mistake": "Not validating manager existence before adding employee",
      "why_wrong": "Can create orphan employees or crash on null reference",
      "correct_approach": "Check `managerId in employees` BEFORE creating bidirectional link",
      "code_wrong": "def add_employee(self, id, name, rating, manager_id):\n    emp = Employee(id, name, rating)\n    manager = self._employees[manager_id]  # KeyError if not found!\n    emp.manager = manager",
      "code_correct": "def add_employee(self, id, name, rating, manager_id):\n    if manager_id not in self._employees:\n        return False\n    emp = Employee(id, name, rating)\n    manager = self._employees[manager_id]\n    emp.manager = manager"
    },
    {
      "mistake": "Allowing multiple CEOs",
      "why_wrong": "Violates tree invariant - organizational chart must have single root",
      "correct_approach": "Track CEO separately and reject second null-manager addition",
      "code_wrong": "if manager_id is None:\n    emp = Employee(id, name, rating)\n    # No check for existing CEO!",
      "code_correct": "if manager_id is None:\n    if self._ceo is not None:\n        return False  # CEO already exists\n    emp = Employee(id, name, rating)\n    self._ceo = emp"
    },
    {
      "mistake": "Using wrong return value for not found (-1 vs None vs 0)",
      "why_wrong": "0 direct reports is valid (leaf node). -1 means not found. Confusing them breaks client code.",
      "correct_approach": "Follow spec exactly: -1 for not found, 0+ for valid count",
      "code_wrong": "def get_direct_report_count(self, id):\n    if id not in self._employees:\n        return 0  # Wrong! 0 means leaf node",
      "code_correct": "def get_direct_report_count(self, id):\n    if id not in self._employees:\n        return -1  # Correct! -1 means not found"
    },
    {
      "mistake": "Not using HashMap for O(1) lookup",
      "why_wrong": "Traversing tree to find employee is O(n) - too slow for 100K employees",
      "correct_approach": "Use HashMap<id, Employee> as index for instant access",
      "code_wrong": "def get_employee(self, id):\n    # O(n) tree traversal\n    def find(node):\n        if node.id == id: return node\n        for child in node.subordinates:\n            result = find(child)\n            if result: return result\n        return None\n    return find(self._ceo)",
      "code_correct": "def get_employee(self, id):\n    return self._employees.get(id)  # O(1)"
    }
  ],
  "interview_tips": {
    "opening": "\"Thank you for this problem. Before I start coding, I'd like to clarify a few things about the requirements and then outline my approach. This looks like an organizational hierarchy problem - essentially building and querying an N-ary tree with efficient lookups.\"",
    "clarifying_questions_to_ask": [
      "\"Should employee IDs always be positive integers? The constraints suggest 1 to 10^6.\"",
      "\"If someone tries to add a second CEO (another null manager), should that fail?\"",
      "\"For getDirectReportCount, should I return -1 or throw an exception for non-existent employees?\"",
      "\"Is thread-safety a concern? For a production system I'd consider concurrent access.\"",
      "\"What's the expected ratio of adds to queries? This affects optimization strategy.\"",
      "\"Are there any Part 2/3 hints I should design for? Total team size, aggregations?\""
    ],
    "what_to_mention_proactively": [
      "\"I'll use a HashMap for O(1) employee lookup by ID - this is critical for scalability.\"",
      "\"I'll maintain bidirectional references - employees know their manager AND subordinates.\"",
      "\"Direct reports means immediate children only, not the entire subtree.\"",
      "\"I'll validate inputs: duplicate ID, missing manager, duplicate CEO.\"",
      "\"Let me draw the tree structure before coding to make sure I understand.\""
    ],
    "communication_during_coding": [
      "\"I'm creating the Employee class first - this is the node in our tree.\"",
      "\"The OrgChart class manages the tree - it has a HashMap index and CEO reference.\"",
      "\"In addEmployee, I check three conditions: duplicate ID, CEO exists, manager exists.\"",
      "\"Notice I set BOTH directions of the relationship - this is crucial for consistency.\"",
      "\"getDirectReportCount is O(1) - just return the list length, no traversal needed.\""
    ],
    "if_stuck": [
      "**If stuck on data structure**: Draw the tree on paper. What information does each node need? Manager (up), subordinates (down).",
      "**If stuck on O(1) lookup**: Think database index. HashMap gives us random access by primary key (ID).",
      "**If stuck on validation order**: Check what would crash first. Duplicate ID check before manager lookup avoids null pointer.",
      "**If stuck on bidirectional**: Ask \"who needs to know about this relationship?\" Both parent and child!"
    ],
    "time_management": "**Suggested Timeline (45 min)**:\n- 0-5 min: Clarify requirements, ask questions\n- 5-10 min: Discuss approach, draw data structures\n- 10-30 min: Implement Employee + OrgChart classes\n- 30-40 min: Test with examples, fix bugs\n- 40-45 min: Discuss complexity, edge cases, follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap-Indexed N-ary Tree",
    "indicators": [
      "Hierarchical/parent-child relationships",
      "Need for O(1) lookup by unique ID",
      "Queries at multiple levels (direct vs total)",
      "Bidirectional traversal requirements (up to root, down to leaves)"
    ],
    "similar_problems": [
      "**LC 690 - Employee Importance**: Same tree structure, but calculates total importance (DFS sum)",
      "**LC 559 - Maximum Depth of N-ary Tree**: N-ary tree traversal to find depth",
      "**LC 339 - Nested List Weight Sum**: Tree-like structure with level-based weights",
      "**LC 429 - N-ary Tree Level Order Traversal**: BFS on N-ary tree",
      "**Design File System**: Similar parent-child with path-based lookup"
    ],
    "template": "```python\n# Pattern: HashMap-Indexed Tree\nclass Node:\n    def __init__(self, id, data):\n        self.id = id\n        self.data = data\n        self.parent = None\n        self.children = []\n\nclass Tree:\n    def __init__(self):\n        self.index = {}  # id -> Node (O(1) lookup)\n        self.root = None\n    \n    def add(self, id, data, parent_id):\n        if id in self.index: return False\n        node = Node(id, data)\n        if parent_id:\n            parent = self.index.get(parent_id)\n            if not parent: return False\n            node.parent = parent\n            parent.children.append(node)\n        self.index[id] = node\n        return True\n    \n    def get(self, id):\n        return self.index.get(id)\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Total Subordinates & Team Size**\n\nYou'll need to implement:\n- `getTotalSubordinateCount(id)`: Count ALL employees under this person (DFS)\n- `getTeamSize(id)`: Total subordinates + 1 (includes the manager)\n\n**Preparation**: Your current bidirectional structure is perfect for DFS. Just add:\n```python\ndef get_total_subordinate_count(self, id):\n    def dfs(emp):\n        count = len(emp.subordinates)  # Direct reports\n        for sub in emp.subordinates:\n            count += dfs(sub)  # Recursive count\n        return count\n    return dfs(self._employees[id])\n```",
    "part_3_hint": "**Part 3: Best Performing Team & Aggregations**\n\nYou'll need to implement:\n- `getTeamAverageRating(id)`: Average rating of all team members\n- `findBestPerformingTeam()`: Team with highest average rating\n\n**Preparation**: Consider caching team statistics on each node:\n```python\nclass Employee:\n    def __init__(...):\n        ...\n        self.team_size_cache = None\n        self.team_rating_sum_cache = None\n```\n\nOr use memoization during DFS traversal.",
    "data_structure_evolution": "```\nPart 1: HashMap + Bidirectional Tree\n        \u2193 (add DFS traversal)\nPart 2: + getTotalSubordinateCount(), getTeamSize()\n        \u2193 (add aggregation)\nPart 3: + getTeamAverageRating(), findBestPerformingTeam()\n        \u2193 (optional: caching)\nOptimized: + cached team statistics on nodes\n```"
  },
  "generated_at": "2026-01-14T15:05:29.345409",
  "_meta": {
    "problem_id": "employee_hierarchy_org_tree",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}