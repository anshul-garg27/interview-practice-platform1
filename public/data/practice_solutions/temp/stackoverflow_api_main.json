{
  "problem_title": "Stack Overflow API Design",
  "difficulty": "hard",
  "category": "LLD/API Design",
  "estimated_time": "60-90 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Low-Level Design (LLD)** problem that tests ability to model entities, relationships, and efficient data access patterns. Stack Overflow is a well-known system with clear CRUD operations - perfect for demonstrating OOP design skills and understanding of indexing for efficient queries.",
    "pattern_recognition": "**HashMap-based Storage** + **Secondary Indexes** + **OOP Entity Modeling**. The key pattern here is maintaining multiple indexes (by user, by tag) to avoid O(n) scans. This is the same pattern used in databases with composite indexes.",
    "key_constraints": [
      "**Up to 10\u2075 operations** - Must be efficient; O(n) queries per call would be too slow",
      "**O(1) or O(log n) operations** - Explicitly stated requirement; suggests HashMap + pre-built indexes",
      "**Unique IDs** - Need reliable ID generation strategy (counter or UUID)",
      "**Sorted results** - getQuestionsByUser (by time), getQuestionsByTag (by score) - sorting adds complexity",
      "**Validation required** - Must check user/question exists before operations"
    ],
    "clarifying_questions": [
      "**Should createUser throw an exception or return null for duplicate IDs?** - Determines error handling strategy",
      "**Is username unique or just user ID?** - Affects validation logic",
      "**What timestamp precision is needed?** - Affects tiebreakers in sorting",
      "**Should getQuestion return a deep copy or the actual object?** - Immutability concerns",
      "**Are tags case-sensitive?** - 'Java' vs 'java' being same or different",
      "**What happens if user doesn't exist when posting question?** - Error handling strategy",
      "**Can a question have 0 tags?** - Edge case validation"
    ],
    "edge_cases_to_consider": [
      "Duplicate user ID on createUser",
      "Posting answer to non-existent question",
      "Getting non-existent question",
      "User with no questions",
      "Tag with no questions",
      "Question with no answers",
      "Multiple questions with same score (tiebreaker)",
      "Empty tags list on question"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 STACK OVERFLOW SYSTEM \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502  USERS   \u2502         \u2502  QUESTIONS   \u2502         \u2502  ANSWERS \u2502         \u2502\n\u2502  \u2502 HashMap  \u2502         \u2502   HashMap    \u2502         \u2502  HashMap \u2502         \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u2502\n\u2502  \u2502 u1\u2192User1 \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502 q_1\u2192Question \u2502<\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 a_1\u2192Ans1 \u2502         \u2502\n\u2502  \u2502 u2\u2192User2 \u2502         \u2502 q_2\u2192Question \u2502         \u2502 a_2\u2192Ans2 \u2502         \u2502\n\u2502  \u2502 u3\u2192User3 \u2502         \u2502 q_3\u2192Question \u2502         \u2502 a_3\u2192Ans3 \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502                              \u2502                       \u2502               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502  \u2502            SECONDARY INDEXES (for O(1) lookups)                   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  \u2502 user_questions \u2502  \u2502  tag_questions \u2502  \u2502 question_answers \u2502    \u2502\n\u2502  \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u2502\n\u2502  \u2502  \u2502 u1\u2192[q_1,q_3]   \u2502  \u2502 java\u2192[q_1,q_2] \u2502  \u2502 q_1\u2192[a_1,a_2]    \u2502    \u2502\n\u2502  \u2502  \u2502 u2\u2192[q_2]       \u2502  \u2502 python\u2192[q_1]   \u2502  \u2502 q_2\u2192[a_3]        \u2502    \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\nINITIAL STATE:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  users: {}                question_counter: 1                    \u2502\n\u2502  questions: {}            answer_counter: 1                      \u2502\n\u2502  answers: {}                                                     \u2502\n\u2502  user_questions: {}       tag_questions: {}                      \u2502\n\u2502  question_answers: {}                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER createUser('u1', 'alice'):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  users: {'u1': User(id='u1', username='alice', reputation=0)}   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER postQuestion('u1', 'Title', 'Body', ['python', 'strings']):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  questions: {'q_1': Question(...)}                               \u2502\n\u2502  user_questions: {'u1': ['q_1']}                                \u2502\n\u2502  tag_questions: {'python': ['q_1'], 'strings': ['q_1']}        \u2502\n\u2502  question_counter: 2  (incremented!)                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER postAnswer('u2', 'q_1', 'Use [::-1]'):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  answers: {'a_1': Answer(id='a_1', questionId='q_1', ...)}      \u2502\n\u2502  question_answers: {'q_1': ['a_1']}                             \u2502\n\u2502  answer_counter: 2  (incremented!)                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**createUser** - Store user in HashMap",
        "visualization": "users[user_id] = User(id, username)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 users  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502u1\u2192User1\u2502 \u2190 NEW\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
        "key_point": "Check for duplicate ID first, return null if exists"
      },
      {
        "step": 2,
        "description": "**postQuestion** - Create question + update ALL indexes",
        "visualization": "1. Generate ID: q_{counter}\n2. Create Question object\n3. Store: questions[q_id] = question\n4. Index: user_questions[user_id].append(q_id)\n5. Index: for tag in tags: tag_questions[tag].append(q_id)",
        "key_point": "Must update BOTH primary storage AND all secondary indexes"
      },
      {
        "step": 3,
        "description": "**postAnswer** - Validate question exists, then store",
        "visualization": "if question_id NOT in questions:\n    return None  \u2190 VALIDATION FIRST\nelse:\n    answers[a_id] = answer\n    question_answers[q_id].append(a_id)",
        "key_point": "Validation before mutation is critical"
      },
      {
        "step": 4,
        "description": "**getQuestionsByTag** - Use index + sort",
        "visualization": "1. Get IDs: tag_questions['java'] \u2192 ['q_1', 'q_2']\n2. Fetch: [questions[id] for id in ids]\n3. Sort: sorted(qs, key=score, reverse=True)",
        "key_point": "Index gives O(1) lookup, sorting is O(k log k) where k = matching questions"
      }
    ],
    "dry_run_table": "| Step | Operation | Primary Storage Change | Index Updates | Counter | Result |\n|------|-----------|----------------------|---------------|---------|--------|\n| 1 | `StackOverflow()` | All empty | All empty | q:1, a:1 | Init |\n| 2 | `createUser('u1','alice')` | users['u1']=User | - | - | User{u1} |\n| 3 | `createUser('u2','bob')` | users['u2']=User | - | - | User{u2} |\n| 4 | `postQuestion('u1','Q1','B1',['java'])` | questions['q_1']=Q | user_qs['u1']=['q_1'], tag_qs['java']=['q_1'] | q:2 | Question{q_1} |\n| 5 | `postAnswer('u2','q_1','Answer')` | answers['a_1']=A | question_ans['q_1']=['a_1'] | a:2 | Answer{a_1} |\n| 6 | `getQuestion('q_1')` | - | - | - | Question + [Answer] |\n| 7 | `getQuestion('invalid')` | - | - | - | **null** |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'get questions by user/tag efficiently'**, I think of **secondary indexes** - pre-built mappings that avoid scanning all questions",
      "**When I see 'sorted by creation time / score'**, I think of keeping lists and sorting on retrieval, or maintaining sorted order (TreeMap)",
      "**When I see 'unique IDs for questions/answers'**, I think of auto-increment counter (`q_1`, `q_2`) or UUID - counter is simpler and readable",
      "**When I see 'validate question exists before answer'**, I think of checking HashMap containsKey before proceeding",
      "**The key insight is**: Primary storage gives O(1) by-ID lookup, but we need **multiple access patterns** (by user, by tag), so we maintain **multiple indexes**",
      "**I should use HashMap** because all lookups are by unique key (id), giving O(1) access",
      "**I should use defaultdict(list)** for indexes to avoid checking if key exists before appending"
    ],
    "key_insight": "The crucial realization is that this is essentially implementing a **simple database with indexes**. The primary storage (HashMaps) provides entity storage, while secondary indexes (user\u2192questions, tag\u2192questions) provide efficient query access patterns. This is exactly how real databases work!",
    "why_this_works": "**HashMap** gives O(1) lookup by ID. **Secondary indexes** (pre-built lists of IDs grouped by user/tag) avoid O(n) table scans. When we insert a question, we pay O(tags) to update indexes, but we get O(1) lookup later. This is the classic **write amplification for read optimization** tradeoff."
  },
  "approaches": [
    {
      "name": "Brute Force - No Indexes",
      "description": "Store entities in HashMaps, but scan all questions for getQuestionsByUser/Tag",
      "pseudocode": "def get_questions_by_user(user_id):\n    result = []\n    for q in questions.values():  # O(n) scan!\n        if q.author_id == user_id:\n            result.append(q)\n    return sorted(result, key=created_at, reverse=True)",
      "time_complexity": "O(n) for getByUser/Tag where n = total questions",
      "space_complexity": "O(1) extra (no indexes)",
      "pros": [
        "Simple to implement",
        "Less memory",
        "No index maintenance"
      ],
      "cons": [
        "O(n) per query is too slow for 10\u2075 operations",
        "Doesn't meet O(1)/O(log n) requirement"
      ],
      "when_to_use": "Only for very small datasets or prototyping"
    },
    {
      "name": "Optimal: HashMap + Secondary Indexes",
      "description": "Maintain HashMaps for primary storage AND pre-built indexes for each query pattern",
      "pseudocode": "# On insert\ndef post_question(...):\n    questions[q_id] = question\n    user_questions[user_id].append(q_id)  # index!\n    for tag in tags:\n        tag_questions[tag].append(q_id)  # index!\n\n# On query - O(1) to get IDs, O(k log k) to sort\ndef get_questions_by_tag(tag):\n    q_ids = tag_questions[tag]  # O(1)!\n    qs = [questions[id] for id in q_ids]\n    return sorted(qs, key=score, reverse=True)",
      "time_complexity": "O(1) for simple lookups, O(k log k) for sorted queries (k = result size)",
      "space_complexity": "O(Q + A + T*Q) where Q=questions, A=answers, T=unique tags",
      "pros": [
        "Meets O(1) requirement for direct lookups",
        "Scales to 10\u2075 operations",
        "Production-ready pattern"
      ],
      "cons": [
        "More complex",
        "Index maintenance overhead on writes",
        "More memory"
      ],
      "key_insight": "Trade write-time complexity for read-time efficiency"
    }
  ],
  "optimal_solution": {
    "name": "HashMap + Secondary Indexes with OOP Entity Modeling",
    "explanation_md": "## Approach\n\nWe model the system with three core entities (**User**, **Question**, **Answer**) and one service class (**StackOverflow**) that manages all data and operations.\n\n### Data Storage Strategy\n\n1. **Primary Storage** - HashMaps keyed by unique ID:\n   - `users: Dict[str, User]`\n   - `questions: Dict[str, Question]`  \n   - `answers: Dict[str, Answer]`\n\n2. **Secondary Indexes** - Pre-built for efficient queries:\n   - `user_questions: Dict[str, List[str]]` - user_id \u2192 [question_ids]\n   - `tag_questions: Dict[str, List[str]]` - tag \u2192 [question_ids]\n   - `question_answers: Dict[str, List[str]]` - question_id \u2192 [answer_ids]\n\n### Why This Works\n\n- **O(1) Entity Lookup**: Any entity by ID is instant via HashMap\n- **O(k) Query + O(k log k) Sort**: Finding questions by user/tag uses pre-built index\n- **Index Maintenance**: We pay O(tags) on insert to keep indexes updated\n- **Separation of Concerns**: Entities are pure data, service handles logic",
    "data_structures": [
      {
        "structure": "HashMap<userId, User>",
        "purpose": "O(1) user lookup and existence check"
      },
      {
        "structure": "HashMap<questionId, Question>",
        "purpose": "O(1) question lookup"
      },
      {
        "structure": "HashMap<answerId, Answer>",
        "purpose": "O(1) answer lookup"
      },
      {
        "structure": "HashMap<userId, List<questionId>>",
        "purpose": "O(1) access to user's questions"
      },
      {
        "structure": "HashMap<tag, List<questionId>>",
        "purpose": "O(1) access to questions by tag"
      },
      {
        "structure": "HashMap<questionId, List<answerId>>",
        "purpose": "O(1) access to question's answers"
      },
      {
        "structure": "int questionCounter",
        "purpose": "Auto-increment ID generation for questions"
      },
      {
        "structure": "int answerCounter",
        "purpose": "Auto-increment ID generation for answers"
      }
    ],
    "algorithm_steps": [
      "1. **createUser**: Check if user_id exists \u2192 if yes, return None. Otherwise, create User, store in users HashMap, return User",
      "2. **postQuestion**: Validate user exists \u2192 generate unique q_id using counter \u2192 create Question \u2192 store in questions HashMap \u2192 update user_questions index \u2192 update tag_questions index for each tag \u2192 increment counter \u2192 return Question",
      "3. **postAnswer**: Validate user AND question exist \u2192 generate unique a_id \u2192 create Answer \u2192 store in answers HashMap \u2192 update question_answers index \u2192 increment counter \u2192 return Answer",
      "4. **getQuestion**: Direct HashMap lookup \u2192 return Question or None",
      "5. **getQuestionsByUser**: Get question IDs from user_questions index \u2192 fetch Question objects \u2192 sort by created_at descending \u2192 return list",
      "6. **getQuestionsByTag**: Get question IDs from tag_questions index \u2192 fetch Question objects \u2192 sort by score descending \u2192 return list"
    ],
    "why_decimal": "Not applicable for this problem (no currency), but timestamp precision matters for sorting - using time.time() gives float seconds which is sufficient for ordering."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 1: Core Operations",
    "",
    "A production-ready implementation of Stack Overflow's core functionality",
    "including user management, questions, answers, and efficient queries.",
    "",
    "Author: Interview Solution",
    "Time Complexity: O(1) for lookups, O(k log k) for sorted queries",
    "Space Complexity: O(U + Q + A + indexes)",
    "\"\"\"",
    "",
    "from typing import Dict, List, Optional",
    "from collections import defaultdict",
    "from dataclasses import dataclass, field",
    "import time",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.\"\"\"",
    "    id: str",
    "    username: str",
    "    reputation: int = 0",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"User(id='{self.id}', username='{self.username}', reputation={self.reputation})\"",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Represents a question posted on Stack Overflow.\"\"\"",
    "    id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    score: int = 0",
    "    created_at: float = field(default_factory=time.time)",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Question(id='{self.id}', title='{self.title[:30]}...', score={self.score})\"",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.\"\"\"",
    "    id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    score: int = 0",
    "    is_accepted: bool = False",
    "    created_at: float = field(default_factory=time.time)",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Answer(id='{self.id}', question_id='{self.question_id}', score={self.score})\"",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class for Stack Overflow functionality.",
    "    ",
    "    Provides CRUD operations for users, questions, and answers",
    "    with efficient indexing for common query patterns.",
    "    ",
    "    Example:",
    "        >>> so = StackOverflow()",
    "        >>> user = so.create_user('u1', 'alice')",
    "        >>> question = so.post_question('u1', 'How to...', 'Body', ['python'])",
    "        >>> questions = so.get_questions_by_tag('python')",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize empty Stack Overflow instance.\"\"\"",
    "        # Primary storage - O(1) lookup by ID",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        ",
    "        # Secondary indexes - O(1) access to related entities",
    "        self._user_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self._tag_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self._question_answers: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # ID generators",
    "        self._question_counter: int = 1",
    "        self._answer_counter: int = 1",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> Optional[User]:",
    "        \"\"\"",
    "        Create a new user with the given ID and username.",
    "        ",
    "        Args:",
    "            user_id: Unique identifier for the user",
    "            username: Display name of the user",
    "            ",
    "        Returns:",
    "            The created User object, or None if user_id already exists",
    "            ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        # Check for duplicate user ID",
    "        if user_id in self._users:",
    "            return None",
    "        ",
    "        # Create and store new user",
    "        user = User(id=user_id, username=username)",
    "        self._users[user_id] = user",
    "        return user",
    "    ",
    "    def post_question(",
    "        self,",
    "        user_id: str,",
    "        title: str,",
    "        body: str,",
    "        tags: List[str]",
    "    ) -> Optional[Question]:",
    "        \"\"\"",
    "        Post a new question by the specified user.",
    "        ",
    "        Args:",
    "            user_id: ID of the user posting the question",
    "            title: Title of the question",
    "            body: Body/content of the question",
    "            tags: List of tags associated with the question",
    "            ",
    "        Returns:",
    "            The created Question object, or None if user doesn't exist",
    "            ",
    "        Time Complexity: O(T) where T = number of tags",
    "        \"\"\"",
    "        # Validate user exists",
    "        if user_id not in self._users:",
    "            return None",
    "        ",
    "        # Generate unique question ID",
    "        question_id = f\"q_{self._question_counter}\"",
    "        self._question_counter += 1",
    "        ",
    "        # Create question object",
    "        question = Question(",
    "            id=question_id,",
    "            author_id=user_id,",
    "            title=title,",
    "            body=body,",
    "            tags=list(tags)  # Copy to prevent external modification",
    "        )",
    "        ",
    "        # Store in primary storage",
    "        self._questions[question_id] = question",
    "        ",
    "        # Update secondary indexes",
    "        self._user_questions[user_id].append(question_id)",
    "        for tag in tags:",
    "            self._tag_questions[tag].append(question_id)",
    "        ",
    "        return question",
    "    ",
    "    def post_answer(",
    "        self,",
    "        user_id: str,",
    "        question_id: str,",
    "        body: str",
    "    ) -> Optional[Answer]:",
    "        \"\"\"",
    "        Post an answer to an existing question.",
    "        ",
    "        Args:",
    "            user_id: ID of the user posting the answer",
    "            question_id: ID of the question being answered",
    "            body: Body/content of the answer",
    "            ",
    "        Returns:",
    "            The created Answer object, or None if user/question doesn't exist",
    "            ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        # Validate user and question exist",
    "        if user_id not in self._users:",
    "            return None",
    "        if question_id not in self._questions:",
    "            return None",
    "        ",
    "        # Generate unique answer ID",
    "        answer_id = f\"a_{self._answer_counter}\"",
    "        self._answer_counter += 1",
    "        ",
    "        # Create answer object",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            author_id=user_id,",
    "            body=body",
    "        )",
    "        ",
    "        # Store in primary storage",
    "        self._answers[answer_id] = answer",
    "        ",
    "        # Update index",
    "        self._question_answers[question_id].append(answer_id)",
    "        ",
    "        return answer",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"",
    "        Retrieve a question by its ID.",
    "        ",
    "        Args:",
    "            question_id: ID of the question to retrieve",
    "            ",
    "        Returns:",
    "            The Question object, or None if not found",
    "            ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        return self._questions.get(question_id)",
    "    ",
    "    def get_answers_for_question(self, question_id: str) -> List[Answer]:",
    "        \"\"\"",
    "        Get all answers for a specific question.",
    "        ",
    "        Args:",
    "            question_id: ID of the question",
    "            ",
    "        Returns:",
    "            List of Answer objects for the question",
    "            ",
    "        Time Complexity: O(A) where A = number of answers",
    "        \"\"\"",
    "        answer_ids = self._question_answers.get(question_id, [])",
    "        return [self._answers[aid] for aid in answer_ids if aid in self._answers]",
    "    ",
    "    def get_questions_by_user(self, user_id: str) -> List[Question]:",
    "        \"\"\"",
    "        Get all questions posted by a user, ordered by creation time (newest first).",
    "        ",
    "        Args:",
    "            user_id: ID of the user",
    "            ",
    "        Returns:",
    "            List of Questions sorted by created_at descending",
    "            ",
    "        Time Complexity: O(Q log Q) where Q = user's question count",
    "        \"\"\"",
    "        question_ids = self._user_questions.get(user_id, [])",
    "        questions = [",
    "            self._questions[qid]",
    "            for qid in question_ids",
    "            if qid in self._questions",
    "        ]",
    "        # Sort by creation time, newest first",
    "        return sorted(questions, key=lambda q: q.created_at, reverse=True)",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Question]:",
    "        \"\"\"",
    "        Get all questions with a specific tag, ordered by score (highest first).",
    "        ",
    "        Args:",
    "            tag: Tag to filter by",
    "            ",
    "        Returns:",
    "            List of Questions sorted by score descending",
    "            ",
    "        Time Complexity: O(Q log Q) where Q = questions with this tag",
    "        \"\"\"",
    "        question_ids = self._tag_questions.get(tag, [])",
    "        questions = [",
    "            self._questions[qid]",
    "            for qid in question_ids",
    "            if qid in self._questions",
    "        ]",
    "        # Sort by score, highest first",
    "        return sorted(questions, key=lambda q: q.score, reverse=True)",
    "",
    "",
    "def main() -> None:",
    "    \"\"\"Demo the Stack Overflow API with example operations.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"STACK OVERFLOW API - DEMO\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Initialize",
    "    so = StackOverflow()",
    "    print(\"\\n1. Creating users...\")",
    "    ",
    "    # Create users",
    "    alice = so.create_user('u1', 'alice')",
    "    bob = so.create_user('u2', 'bob')",
    "    print(f\"   Created: {alice}\")",
    "    print(f\"   Created: {bob}\")",
    "    ",
    "    # Test duplicate user",
    "    duplicate = so.create_user('u1', 'alice_duplicate')",
    "    print(f\"   Duplicate user 'u1': {duplicate}  # Should be None\")",
    "    ",
    "    print(\"\\n2. Posting questions...\")",
    "    ",
    "    # Post questions",
    "    q1 = so.post_question(",
    "        'u1',",
    "        'How to reverse a string in Python?',",
    "        'I need help with string reversal',",
    "        ['python', 'strings']",
    "    )",
    "    print(f\"   Posted: {q1}\")",
    "    ",
    "    # Add a small delay to ensure different timestamps",
    "    import time as t",
    "    t.sleep(0.01)",
    "    ",
    "    q2 = so.post_question(",
    "        'u1',",
    "        'What is a HashMap?',",
    "        'Explain HashMaps in Java',",
    "        ['java', 'data-structures']",
    "    )",
    "    print(f\"   Posted: {q2}\")",
    "    ",
    "    q3 = so.post_question(",
    "        'u2',",
    "        'Python vs Java performance',",
    "        'Which is faster?',",
    "        ['python', 'java', 'performance']",
    "    )",
    "    print(f\"   Posted: {q3}\")",
    "    ",
    "    print(\"\\n3. Posting answers...\")",
    "    ",
    "    # Post answers",
    "    a1 = so.post_answer('u2', 'q_1', 'Use [::-1] or reversed()')",
    "    print(f\"   Posted: {a1}\")",
    "    ",
    "    a2 = so.post_answer('u1', 'q_1', 'You can also use a loop')",
    "    print(f\"   Posted: {a2}\")",
    "    ",
    "    # Test answer to non-existent question",
    "    bad_answer = so.post_answer('u1', 'invalid_q', 'This should fail')",
    "    print(f\"   Answer to invalid question: {bad_answer}  # Should be None\")",
    "    ",
    "    print(\"\\n4. Retrieving question with answers...\")",
    "    ",
    "    question = so.get_question('q_1')",
    "    answers = so.get_answers_for_question('q_1')",
    "    print(f\"   Question: {question}\")",
    "    print(f\"   Answers: {answers}\")",
    "    ",
    "    # Test get non-existent question",
    "    missing = so.get_question('invalid')",
    "    print(f\"   Non-existent question: {missing}  # Should be None\")",
    "    ",
    "    print(\"\\n5. Querying by user...\")",
    "    ",
    "    alice_questions = so.get_questions_by_user('u1')",
    "    print(f\"   Alice's questions (newest first):\")",
    "    for q in alice_questions:",
    "        print(f\"      - {q.title}\")",
    "    ",
    "    print(\"\\n6. Querying by tag...\")",
    "    ",
    "    python_questions = so.get_questions_by_tag('python')",
    "    print(f\"   Questions tagged 'python' (by score):\")",
    "    for q in python_questions:",
    "        print(f\"      - {q.title} (score: {q.score})\")",
    "    ",
    "    java_questions = so.get_questions_by_tag('java')",
    "    print(f\"   Questions tagged 'java' (by score):\")",
    "    for q in java_questions:",
    "        print(f\"      - {q.title} (score: {q.score})\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"DEMO COMPLETE - All operations successful!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.time.Instant;",
    "",
    "/**",
    " * Stack Overflow API - Part 1: Core Operations",
    " * ",
    " * Production-ready implementation with efficient indexing.",
    " */",
    "public class StackOverflowAPI {",
    "",
    "    /**",
    "     * Represents a Stack Overflow user.",
    "     */",
    "    public static class User {",
    "        private final String id;",
    "        private final String username;",
    "        private int reputation;",
    "        ",
    "        public User(String id, String username) {",
    "            this.id = id;",
    "            this.username = username;",
    "            this.reputation = 0;",
    "        }",
    "        ",
    "        public String getId() { return id; }",
    "        public String getUsername() { return username; }",
    "        public int getReputation() { return reputation; }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"User{id='%s', username='%s', reputation=%d}\",",
    "                                 id, username, reputation);",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Represents a question posted on Stack Overflow.",
    "     */",
    "    public static class Question {",
    "        private final String id;",
    "        private final String authorId;",
    "        private final String title;",
    "        private final String body;",
    "        private final List<String> tags;",
    "        private int score;",
    "        private final long createdAt;",
    "        ",
    "        public Question(String id, String authorId, String title,",
    "                       String body, List<String> tags) {",
    "            this.id = id;",
    "            this.authorId = authorId;",
    "            this.title = title;",
    "            this.body = body;",
    "            this.tags = new ArrayList<>(tags);",
    "            this.score = 0;",
    "            this.createdAt = Instant.now().toEpochMilli();",
    "        }",
    "        ",
    "        public String getId() { return id; }",
    "        public String getAuthorId() { return authorId; }",
    "        public String getTitle() { return title; }",
    "        public String getBody() { return body; }",
    "        public List<String> getTags() { return Collections.unmodifiableList(tags); }",
    "        public int getScore() { return score; }",
    "        public long getCreatedAt() { return createdAt; }",
    "        public void setScore(int score) { this.score = score; }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Question{id='%s', title='%s', score=%d}\",",
    "                                 id, title, score);",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Represents an answer to a question.",
    "     */",
    "    public static class Answer {",
    "        private final String id;",
    "        private final String questionId;",
    "        private final String authorId;",
    "        private final String body;",
    "        private int score;",
    "        private boolean isAccepted;",
    "        private final long createdAt;",
    "        ",
    "        public Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id;",
    "            this.questionId = questionId;",
    "            this.authorId = authorId;",
    "            this.body = body;",
    "            this.score = 0;",
    "            this.isAccepted = false;",
    "            this.createdAt = Instant.now().toEpochMilli();",
    "        }",
    "        ",
    "        public String getId() { return id; }",
    "        public String getQuestionId() { return questionId; }",
    "        public String getAuthorId() { return authorId; }",
    "        public String getBody() { return body; }",
    "        public int getScore() { return score; }",
    "        public boolean isAccepted() { return isAccepted; }",
    "        public long getCreatedAt() { return createdAt; }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Answer{id='%s', questionId='%s', score=%d}\",",
    "                                 id, questionId, score);",
    "        }",
    "    }",
    "",
    "    /**",
    "     * Main API class for Stack Overflow functionality.",
    "     */",
    "    public static class StackOverflow {",
    "        // Primary storage",
    "        private final Map<String, User> users;",
    "        private final Map<String, Question> questions;",
    "        private final Map<String, Answer> answers;",
    "        ",
    "        // Secondary indexes",
    "        private final Map<String, List<String>> userQuestions;",
    "        private final Map<String, List<String>> tagQuestions;",
    "        private final Map<String, List<String>> questionAnswers;",
    "        ",
    "        // ID generators",
    "        private int questionCounter;",
    "        private int answerCounter;",
    "        ",
    "        public StackOverflow() {",
    "            this.users = new HashMap<>();",
    "            this.questions = new HashMap<>();",
    "            this.answers = new HashMap<>();",
    "            this.userQuestions = new HashMap<>();",
    "            this.tagQuestions = new HashMap<>();",
    "            this.questionAnswers = new HashMap<>();",
    "            this.questionCounter = 1;",
    "            this.answerCounter = 1;",
    "        }",
    "        ",
    "        /**",
    "         * Create a new user.",
    "         * @return User object, or null if user_id already exists",
    "         */",
    "        public User createUser(String userId, String username) {",
    "            if (users.containsKey(userId)) {",
    "                return null;",
    "            }",
    "            User user = new User(userId, username);",
    "            users.put(userId, user);",
    "            return user;",
    "        }",
    "        ",
    "        /**",
    "         * Post a new question.",
    "         * @return Question object, or null if user doesn't exist",
    "         */",
    "        public Question postQuestion(String userId, String title,",
    "                                     String body, List<String> tags) {",
    "            if (!users.containsKey(userId)) {",
    "                return null;",
    "            }",
    "            ",
    "            String questionId = \"q_\" + questionCounter++;",
    "            Question question = new Question(questionId, userId, title, body, tags);",
    "            ",
    "            questions.put(questionId, question);",
    "            ",
    "            // Update indexes",
    "            userQuestions.computeIfAbsent(userId, k -> new ArrayList<>())",
    "                         .add(questionId);",
    "            for (String tag : tags) {",
    "                tagQuestions.computeIfAbsent(tag, k -> new ArrayList<>())",
    "                            .add(questionId);",
    "            }",
    "            ",
    "            return question;",
    "        }",
    "        ",
    "        /**",
    "         * Post an answer to a question.",
    "         * @return Answer object, or null if user/question doesn't exist",
    "         */",
    "        public Answer postAnswer(String userId, String questionId, String body) {",
    "            if (!users.containsKey(userId) || !questions.containsKey(questionId)) {",
    "                return null;",
    "            }",
    "            ",
    "            String answerId = \"a_\" + answerCounter++;",
    "            Answer answer = new Answer(answerId, questionId, userId, body);",
    "            ",
    "            answers.put(answerId, answer);",
    "            questionAnswers.computeIfAbsent(questionId, k -> new ArrayList<>())",
    "                           .add(answerId);",
    "            ",
    "            return answer;",
    "        }",
    "        ",
    "        /**",
    "         * Get a question by ID.",
    "         */",
    "        public Question getQuestion(String questionId) {",
    "            return questions.get(questionId);",
    "        }",
    "        ",
    "        /**",
    "         * Get all answers for a question.",
    "         */",
    "        public List<Answer> getAnswersForQuestion(String questionId) {",
    "            List<String> answerIds = questionAnswers.getOrDefault(questionId,",
    "                                                                   Collections.emptyList());",
    "            List<Answer> result = new ArrayList<>();",
    "            for (String id : answerIds) {",
    "                if (answers.containsKey(id)) {",
    "                    result.add(answers.get(id));",
    "                }",
    "            }",
    "            return result;",
    "        }",
    "        ",
    "        /**",
    "         * Get all questions by a user, sorted by creation time (newest first).",
    "         */",
    "        public List<Question> getQuestionsByUser(String userId) {",
    "            List<String> questionIds = userQuestions.getOrDefault(userId,",
    "                                                                   Collections.emptyList());",
    "            List<Question> result = new ArrayList<>();",
    "            for (String id : questionIds) {",
    "                if (questions.containsKey(id)) {",
    "                    result.add(questions.get(id));",
    "                }",
    "            }",
    "            result.sort((a, b) -> Long.compare(b.getCreatedAt(), a.getCreatedAt()));",
    "            return result;",
    "        }",
    "        ",
    "        /**",
    "         * Get all questions with a tag, sorted by score (highest first).",
    "         */",
    "        public List<Question> getQuestionsByTag(String tag) {",
    "            List<String> questionIds = tagQuestions.getOrDefault(tag,",
    "                                                                  Collections.emptyList());",
    "            List<Question> result = new ArrayList<>();",
    "            for (String id : questionIds) {",
    "                if (questions.containsKey(id)) {",
    "                    result.add(questions.get(id));",
    "                }",
    "            }",
    "            result.sort((a, b) -> Integer.compare(b.getScore(), a.getScore()));",
    "            return result;",
    "        }",
    "    }",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"STACK OVERFLOW API - JAVA DEMO\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        ",
    "        // Create users",
    "        System.out.println(\"\\n1. Creating users...\");",
    "        User alice = so.createUser(\"u1\", \"alice\");",
    "        User bob = so.createUser(\"u2\", \"bob\");",
    "        System.out.println(\"   Created: \" + alice);",
    "        System.out.println(\"   Created: \" + bob);",
    "        ",
    "        // Post questions",
    "        System.out.println(\"\\n2. Posting questions...\");",
    "        Question q1 = so.postQuestion(\"u1\", \"How to reverse a string?\",",
    "                                       \"Help needed\", Arrays.asList(\"python\", \"strings\"));",
    "        Question q2 = so.postQuestion(\"u1\", \"What is HashMap?\",",
    "                                       \"Explain please\", Arrays.asList(\"java\"));",
    "        System.out.println(\"   Posted: \" + q1);",
    "        System.out.println(\"   Posted: \" + q2);",
    "        ",
    "        // Post answer",
    "        System.out.println(\"\\n3. Posting answers...\");",
    "        Answer a1 = so.postAnswer(\"u2\", \"q_1\", \"Use [::-1]\");",
    "        System.out.println(\"   Posted: \" + a1);",
    "        ",
    "        // Query by user",
    "        System.out.println(\"\\n4. Alice's questions (newest first):\");",
    "        for (Question q : so.getQuestionsByUser(\"u1\")) {",
    "            System.out.println(\"   - \" + q.getTitle());",
    "        }",
    "        ",
    "        // Query by tag",
    "        System.out.println(\"\\n5. Questions tagged 'python':\");",
    "        for (Question q : so.getQuestionsByTag(\"python\")) {",
    "            System.out.println(\"   - \" + q.getTitle());",
    "        }",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"DEMO COMPLETE\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "section": "Imports and Module Docstring",
      "explanation": "We import `Dict`, `List`, `Optional` for type hints, `defaultdict` for auto-initializing collections, `dataclass` for clean entity definitions, and `time` for timestamps."
    },
    {
      "lines": "17-25",
      "section": "User Entity (dataclass)",
      "explanation": "Using `@dataclass` reduces boilerplate. User has `id`, `username`, and `reputation` (defaults to 0). The `__repr__` provides readable debug output."
    },
    {
      "lines": "28-40",
      "section": "Question Entity (dataclass)",
      "explanation": "Question stores all required fields. `created_at` uses `field(default_factory=time.time)` to capture creation timestamp. Score defaults to 0."
    },
    {
      "lines": "43-57",
      "section": "Answer Entity (dataclass)",
      "explanation": "Answer includes `question_id` as foreign key reference, `is_accepted` boolean for accepted answers (future use), and timestamp like Question."
    },
    {
      "lines": "60-86",
      "section": "StackOverflow.__init__",
      "explanation": "Initialize three primary HashMaps for entities, three secondary index HashMaps using `defaultdict(list)` for auto-list creation, and two counters for ID generation."
    },
    {
      "lines": "88-107",
      "section": "create_user Method",
      "explanation": "O(1) operation: Check if user exists \u2192 if yes return None (handles duplicates), otherwise create User and store in HashMap. Simple but critical validation."
    },
    {
      "lines": "109-148",
      "section": "post_question Method",
      "explanation": "Most complex method: validates user exists, generates unique ID using counter, creates Question, stores in primary HashMap, then updates BOTH user_questions AND tag_questions indexes. O(T) for T tags."
    },
    {
      "lines": "150-183",
      "section": "post_answer Method",
      "explanation": "Validates BOTH user AND question exist (critical!), generates answer ID, creates Answer, stores in primary HashMap, updates question_answers index. Returns None if validation fails."
    },
    {
      "lines": "185-199",
      "section": "get_question Method",
      "explanation": "Simple O(1) HashMap lookup using `.get()` which returns None if key doesn't exist. Clean and production-safe."
    },
    {
      "lines": "201-215",
      "section": "get_answers_for_question Method",
      "explanation": "Uses question_answers index for O(1) ID retrieval, then fetches actual Answer objects. The `if aid in self._answers` guard handles potential data inconsistency."
    },
    {
      "lines": "217-239",
      "section": "get_questions_by_user Method",
      "explanation": "Uses user_questions index for O(1) ID lookup, fetches Questions, then sorts by created_at descending. O(k log k) where k = user's question count."
    },
    {
      "lines": "241-261",
      "section": "get_questions_by_tag Method",
      "explanation": "Similar pattern: use tag_questions index, fetch Questions, sort by score descending. This enables tag-based browsing like on real Stack Overflow."
    },
    {
      "lines": "264-340",
      "section": "main() Demo Function",
      "explanation": "Comprehensive demo covering: user creation, duplicate handling, question posting, answer posting, invalid answer handling, retrieval with answers, and both query methods. Tests all happy paths and edge cases."
    }
  ],
  "complexity_analysis": {
    "time": {
      "create_user": {
        "complexity": "O(1)",
        "explanation": "HashMap containsKey + put operations"
      },
      "post_question": {
        "complexity": "O(T)",
        "explanation": "T = number of tags; HashMap operations are O(1), but we iterate through tags to update index"
      },
      "post_answer": {
        "complexity": "O(1)",
        "explanation": "Two HashMap lookups + one insert + one list append"
      },
      "get_question": {
        "complexity": "O(1)",
        "explanation": "Direct HashMap lookup"
      },
      "get_answers_for_question": {
        "complexity": "O(A)",
        "explanation": "A = number of answers for this question; fetch all answer objects"
      },
      "get_questions_by_user": {
        "complexity": "O(Q log Q)",
        "explanation": "Q = user's question count; O(1) index lookup + O(Q) fetch + O(Q log Q) sort"
      },
      "get_questions_by_tag": {
        "complexity": "O(Q log Q)",
        "explanation": "Q = questions with this tag; O(1) index lookup + O(Q) fetch + O(Q log Q) sort"
      },
      "overall": "All operations meet O(1) or O(k log k) requirement where k = result size"
    },
    "space": {
      "complexity": "O(U + Q + A + Q*T + Q) where U=users, Q=questions, A=answers, T=avg tags per question",
      "breakdown": "- Users HashMap: O(U)\n- Questions HashMap: O(Q)\n- Answers HashMap: O(A)\n- user_questions index: O(Q) total entries across all users\n- tag_questions index: O(Q*T) where T = avg tags per question\n- question_answers index: O(A) total entries",
      "note": "Index storage is the main space cost, but enables efficient queries. This is a classic space-time tradeoff."
    },
    "can_we_do_better": "The current solution is optimal for the given requirements. To eliminate O(k log k) sorting, we could maintain sorted data structures (e.g., TreeSet/SortedList), but this would complicate insertions and updates. For most use cases, sorting small result sets is acceptable."
  },
  "dry_run": {
    "example": "createUser('u1','alice'), createUser('u2','bob'), postQuestion('u1','Q1','B1',['java']), postAnswer('u2','q_1','Ans'), getQuestion('q_1'), getQuestionsByTag('java')",
    "trace_table": "| Step | Operation | Action | Primary Storage | Indexes | Counters | Return |\n|------|-----------|--------|-----------------|---------|----------|--------|\n| 1 | `StackOverflow()` | Init | users={}, questions={}, answers={} | All empty | q:1, a:1 | instance |\n| 2 | `createUser('u1','alice')` | Add user | users={'u1':User} | - | - | User{u1,alice} |\n| 3 | `createUser('u2','bob')` | Add user | users={'u1':..,'u2':User} | - | - | User{u2,bob} |\n| 4 | `postQuestion('u1','Q1','B1',['java'])` | Validate u1 \u2713, create q_1 | questions={'q_1':Question} | user_qs['u1']=['q_1'], tag_qs['java']=['q_1'] | q:2 | Question{q_1} |\n| 5 | `postAnswer('u2','q_1','Ans')` | Validate u2 \u2713, q_1 \u2713, create a_1 | answers={'a_1':Answer} | question_ans['q_1']=['a_1'] | a:2 | Answer{a_1} |\n| 6 | `getQuestion('q_1')` | HashMap lookup | - | - | - | Question{q_1} |\n| 7 | `getQuestionsByTag('java')` | Index \u2192 fetch \u2192 sort | - | - | - | [Question{q_1}] |",
    "final_answer": "All operations complete successfully with O(1) or O(k log k) complexity"
  },
  "test_cases": [
    {
      "name": "Basic Q&A Flow",
      "category": "Happy Path",
      "input": "createUser('u1','alice'), createUser('u2','bob'), postQuestion('u1','Title','Body',['tag1']), postAnswer('u2','q_1','Answer text'), getQuestion('q_1')",
      "expected": "Question with 1 answer",
      "explanation": "Complete happy path: user creates question, another user answers, retrieve shows both"
    },
    {
      "name": "Duplicate User ID",
      "category": "Edge Case - Validation",
      "input": "createUser('u1','alice'), createUser('u1','alice2')",
      "expected": "First returns User, second returns None",
      "explanation": "Duplicate user IDs are rejected gracefully"
    },
    {
      "name": "Answer to Non-existent Question",
      "category": "Edge Case - Validation",
      "input": "createUser('u1','alice'), postAnswer('u1','invalid_q','Answer')",
      "expected": "None",
      "explanation": "Validation catches missing question before creating answer"
    },
    {
      "name": "Get Non-existent Question",
      "category": "Edge Case - Missing Data",
      "input": "getQuestion('no_such_question')",
      "expected": "None",
      "explanation": "HashMap returns None for missing keys"
    },
    {
      "name": "Questions By User - Ordering",
      "category": "Sorting",
      "input": "createUser('u1','alice'), postQuestion('u1','Q1',...), [delay], postQuestion('u1','Q2',...), getQuestionsByUser('u1')",
      "expected": "[Q2, Q1] (newest first)",
      "explanation": "Results sorted by created_at descending"
    },
    {
      "name": "Questions By Tag - Multiple Matches",
      "category": "Filtering",
      "input": "Post 3 questions: Q1['java'], Q2['java','python'], Q3['python'], getQuestionsByTag('java')",
      "expected": "[Q1, Q2] (sorted by score)",
      "explanation": "Only questions with 'java' tag returned"
    },
    {
      "name": "Empty Results",
      "category": "Edge Case",
      "input": "getQuestionsByTag('nonexistent_tag')",
      "expected": "[] (empty list)",
      "explanation": "Missing tag returns empty list, not error"
    },
    {
      "name": "Question with No Tags",
      "category": "Edge Case",
      "input": "createUser('u1','alice'), postQuestion('u1','Title','Body',[])",
      "expected": "Question created successfully with empty tags",
      "explanation": "0 tags is valid per constraints"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not validating user/question exists before operations",
      "why_wrong": "Leads to dangling references (answer pointing to non-existent question)",
      "correct_approach": "Always check existence before creating dependent entities",
      "code_wrong": "def post_answer(self, user_id, question_id, body):\n    answer = Answer(...)  # No validation!\n    self._answers[answer.id] = answer",
      "code_correct": "def post_answer(self, user_id, question_id, body):\n    if user_id not in self._users or question_id not in self._questions:\n        return None\n    answer = Answer(...)"
    },
    {
      "mistake": "O(n) scan for getQuestionsByUser/Tag",
      "why_wrong": "With 10\u2075 operations, O(n) per query is too slow",
      "correct_approach": "Maintain secondary indexes updated on insert",
      "code_wrong": "def get_questions_by_tag(self, tag):\n    return [q for q in self._questions.values() if tag in q.tags]  # O(n)!",
      "code_correct": "def get_questions_by_tag(self, tag):\n    ids = self._tag_questions.get(tag, [])\n    return [self._questions[id] for id in ids]  # O(k) where k = matches"
    },
    {
      "mistake": "Forgetting to update indexes when adding questions",
      "why_wrong": "Queries will miss newly added questions",
      "correct_approach": "Update ALL relevant indexes in postQuestion",
      "code_wrong": "def post_question(...):\n    self._questions[q_id] = question\n    # Forgot to update user_questions and tag_questions!",
      "code_correct": "def post_question(...):\n    self._questions[q_id] = question\n    self._user_questions[user_id].append(q_id)\n    for tag in tags:\n        self._tag_questions[tag].append(q_id)"
    },
    {
      "mistake": "Not handling duplicate user IDs",
      "why_wrong": "Could overwrite existing user data",
      "correct_approach": "Check existence and return None or raise exception",
      "code_wrong": "def create_user(self, user_id, username):\n    user = User(user_id, username)\n    self._users[user_id] = user  # Silently overwrites!",
      "code_correct": "def create_user(self, user_id, username):\n    if user_id in self._users:\n        return None  # Or raise ValueError\n    user = User(user_id, username)\n    self._users[user_id] = user"
    },
    {
      "mistake": "Wrong sort order",
      "why_wrong": "getQuestionsByUser should be newest first, getQuestionsByTag should be highest score first",
      "correct_approach": "Use reverse=True with correct key function",
      "code_wrong": "sorted(questions, key=lambda q: q.created_at)  # Oldest first - wrong!",
      "code_correct": "sorted(questions, key=lambda q: q.created_at, reverse=True)  # Newest first"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start designing, let me make sure I understand the requirements correctly. This is a Stack Overflow-like system with users, questions, answers, and we need efficient queries by user and tag...",
    "clarifying_questions_to_ask": [
      "Should createUser return null or throw exception for duplicate IDs?",
      "Are tags case-sensitive? Is 'Java' the same as 'java'?",
      "What should happen if a non-existent user tries to post?",
      "For getQuestion, should I return the question object with its answers embedded, or just the question?",
      "Is there a maximum number of answers per question I should consider?",
      "Should I handle concurrent access (thread safety)?"
    ],
    "what_to_mention_proactively": [
      "I'll use HashMaps for O(1) entity lookup by ID",
      "I'll maintain secondary indexes for efficient user and tag queries",
      "I'll use auto-increment counters for unique ID generation",
      "Let me trace through an example to verify correctness",
      "I'm thinking about the time/space tradeoffs here..."
    ],
    "communication_during_coding": [
      "Starting with entity classes - User, Question, Answer with clear attributes",
      "Now implementing the main StackOverflow class with primary storage",
      "Adding secondary indexes for user_questions, tag_questions, question_answers",
      "In postQuestion, I need to update both user and tag indexes",
      "For getQuestionsByUser, I use the index for O(1) lookup, then sort"
    ],
    "if_stuck": [
      "Step back: What are the query patterns I need to support?",
      "Draw the data model: What entities exist and how do they relate?",
      "Think about indexes: What would I need to avoid O(n) scans?",
      "Start simple: Implement without indexes first, then optimize"
    ],
    "time_management": "0-8min: Clarify & discuss approach | 8-15min: Design entities | 15-35min: Implement StackOverflow class | 35-45min: Test with examples | 45-60min: Discuss edge cases & follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "In-Memory Database with Secondary Indexes",
    "indicators": [
      "Multiple entity types with relationships",
      "Need for O(1) lookup by primary key",
      "Need for efficient queries by non-primary attributes",
      "CRUD operations mentioned"
    ],
    "similar_problems": [
      "**Design Twitter** - Users, Tweets, Follows with timeline queries",
      "**Design LRU Cache** - HashMap + LinkedList for O(1) access",
      "**Design File System** - Tree structure with path-based lookups",
      "**Design Parking Lot** - Entity management with status tracking",
      "**LC 355 - Design Twitter** - Similar feed/timeline problem"
    ],
    "template": "1. Define entity classes with clear attributes\n2. Create service class with HashMap storage\n3. Add secondary indexes for each query pattern\n4. Update ALL indexes on every insert/update\n5. Use indexes for O(1) query access, sort results if needed"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Voting and Reputation** - Add upvote()/downvote() methods. Track vote history to prevent duplicate votes. Update question/answer scores and user reputation. Consider using a Vote entity or HashMap<(userId, targetId) \u2192 voteType>.",
    "part_3_hint": "**Part 3: Search and Filtering** - Add search by title/body text. Options: simple substring search O(n), or build inverted index (word \u2192 [question_ids]). Consider TF-IDF for relevance ranking.",
    "data_structure_evolution": "Part 1: HashMaps + Lists \u2192 Part 2: Add Vote tracking (Set or Map for duplicate detection) \u2192 Part 3: Add Inverted Index for text search"
  },
  "generated_at": "2026-01-14T15:35:57.728519",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}