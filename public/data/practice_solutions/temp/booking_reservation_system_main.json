{
  "problem_title": "Design a Hotel Booking/Reservation System",
  "difficulty": "hard",
  "category": "HLD/System Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic system design problem** combining database design, concurrency control, and distributed systems. The core challenge is preventing double-bookings while maintaining high availability and low latency. It's similar to designing a ticket booking system (concerts, flights) where **inventory is finite and time-sensitive**.",
    "pattern_recognition": "**Patterns Identified:**\n- **Interval Scheduling** (date range overlaps - similar to Meeting Rooms II)\n- **Distributed Locking** (preventing race conditions)\n- **CQRS Pattern** (separate read/write paths for search vs booking)\n- **Saga Pattern** (for payment + booking coordination)\n- **Pre-computation** (availability indexing for fast search)",
    "key_constraints": [
      "**No double-bookings** - This is THE critical invariant. Two users cannot book the same room for overlapping dates. Must be enforced at database level.",
      "**Search < 200ms P95** - Read-heavy operation cannot hit main booking database. Requires caching/search engine.",
      "**Booking < 500ms P95** - Must include availability check, lock acquisition, payment processing, and confirmation.",
      "**10K bookings/sec peak** - Requires horizontal scaling but careful partitioning to avoid hot spots on popular rooms.",
      "**99.99% availability** - Only 52 minutes downtime/year allowed. Requires redundancy and graceful degradation."
    ],
    "clarifying_questions": [
      "**Q: How should check-in/check-out times work?** - Determines overlap logic. Standard: check-in 3PM, check-out 11AM. Same-day turnover allowed?",
      "**Q: Should we support overbooking (like airlines)?** - Most hotels do 5-10% overbooking. Dramatically changes design if yes.",
      "**Q: What's the payment model?** - Charge immediately, or authorize now and charge at check-in? Affects refund complexity.",
      "**Q: How long should inventory be held during booking flow?** - User starts checkout, how long before we release the hold? (5-15 min typical)",
      "**Q: What consistency model is acceptable for search?** - Can search results be 1-5 minutes stale? (Usually yes)",
      "**Q: Do we need to support room type booking vs specific room booking?** - 'Any King room' vs 'Room 101 specifically'",
      "**Q: Multi-room bookings?** - Can a user book 3 rooms in one transaction? Adds complexity for atomicity."
    ],
    "edge_cases_to_consider": [
      "**Same-day turnover**: User A checks out Mar 15, User B checks in Mar 15 - this should be ALLOWED",
      "**Partial overlap**: Booking for Mar 10-15, someone tries Mar 13-18 - must REJECT",
      "**Concurrent identical requests**: Two users, same room, same dates, same millisecond",
      "**Cancellation race**: User cancels while another user is mid-booking-flow for same room",
      "**Payment failure after availability lock**: Room locked, payment fails - must release cleanly",
      "**Timezone edge cases**: User in PST books room in EST - which timezone for dates?",
      "**Leap year**: Feb 29 booking edge cases",
      "**Year boundary**: Dec 30 - Jan 3 booking spanning years"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "searchRooms - Search available rooms by location, dates, criteria",
        "how_met": "Elasticsearch index with pre-computed availability. Query filters by location + date range + capacity + amenities. Paginated response.",
        "gotchas": [
          "Search results can become stale - someone books while user is browsing",
          "Must handle 'no results' gracefully with suggestions"
        ]
      },
      {
        "requirement": "getRoomDetails - Real-time availability and pricing",
        "how_met": "Direct database query for current availability status. Dynamic pricing based on demand, season, day of week.",
        "gotchas": [
          "Must show LIVE availability here, not cached",
          "Price can change between search and detail view"
        ]
      },
      {
        "requirement": "createBooking - Prevent double-bookings with payment processing",
        "how_met": "Database transaction with SELECT FOR UPDATE or unique constraint on (room_id, date). Payment authorization before booking confirmation.",
        "gotchas": [
          "Race condition is THE critical problem",
          "Payment timing - don't charge if room unavailable"
        ]
      },
      {
        "requirement": "getBooking - Retrieve booking details",
        "how_met": "Simple read from bookings table with user authorization check.",
        "gotchas": [
          "Must verify user owns the booking",
          "Include hotel contact info for upcoming bookings"
        ]
      },
      {
        "requirement": "cancelBooking - Handle refunds based on policy",
        "how_met": "Update booking status, release inventory (delete from room_availability), process refund via payment service.",
        "gotchas": [
          "Race condition with new bookings",
          "Different refund policies by hotel/timing",
          "Non-refundable bookings"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "searchRooms",
        "target": "< 200ms P95",
        "achieved": "~100ms via Elasticsearch",
        "why": "Pre-indexed availability, denormalized data, no joins at query time"
      },
      {
        "operation": "createBooking",
        "target": "< 500ms P95",
        "achieved": "~300ms with payment",
        "why": "Single DB transaction + async payment auth"
      },
      {
        "operation": "getBooking",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Primary key lookup"
      },
      {
        "operation": "cancelBooking",
        "target": "< 500ms",
        "achieved": "~200ms",
        "why": "Single transaction + async refund"
      }
    ],
    "non_goals": [
      "Real-time chat with hotel staff (separate system)",
      "Hotel management dashboard (B2B, different service)",
      "Review/rating system (can be eventual consistent, separate service)",
      "Loyalty points/rewards (separate bounded context)",
      "Multi-currency handling (assume single currency for Part 1)"
    ]
  },
  "assumptions": [
    "**Standard check-in/out times**: Check-in 3PM, check-out 11AM. Same-day turnover IS allowed.",
    "**No overbooking**: Each room can only have one booking per date (unlike airlines).",
    "**Booking = specific room**: Not room type. Assigning specific room simplifies conflict detection.",
    "**Single currency (USD)**: No forex complexity for Part 1.",
    "**Payment authorization model**: Authorize card immediately, capture at check-in time.",
    "**Hold duration**: 10 minutes to complete checkout flow before releasing hold.",
    "**Search staleness OK**: Search results can be up to 5 minutes stale; live check on detail/book.",
    "**Single timezone**: Store all dates in UTC, display in hotel's local timezone."
  ],
  "tradeoffs": [
    {
      "decision": "Database locking strategy for preventing double-bookings",
      "chosen": "Pessimistic locking (SELECT FOR UPDATE) + Unique constraint on (room_id, date)",
      "why": "Belt AND suspenders approach. Unique constraint is the ultimate safeguard even if application bug misses lock. Pessimistic lock prevents wasted payment auth attempts.",
      "alternative": "Optimistic locking with retry",
      "when_to_switch": "If lock contention becomes a bottleneck (very popular rooms). Then use optimistic with exponential backoff retry."
    },
    {
      "decision": "Search data model",
      "chosen": "Elasticsearch with pre-computed availability + change data capture sync",
      "why": "Meets <200ms requirement. Full-text search on amenities/descriptions. Geo queries for location.",
      "alternative": "Read replica of SQL database",
      "when_to_switch": "If system is smaller scale and staleness of search results is unacceptable."
    },
    {
      "decision": "Availability data model",
      "chosen": "One row per (room_id, date) in room_availability table",
      "why": "Simple overlap detection with unique constraint. Easy to query 'all available dates for room X'. Efficient for 1 year window.",
      "alternative": "Store bookings only, compute availability at query time",
      "when_to_switch": "If storage becomes concern (it won't - 10M rooms \u00d7 365 days = 3.65B rows, manageable with partitioning)"
    },
    {
      "decision": "Payment flow timing",
      "chosen": "Authorize \u2192 Lock inventory \u2192 Confirm booking \u2192 Capture at check-in",
      "why": "Don't charge customer until we confirm room is theirs. Don't lock inventory until we know payment will work.",
      "alternative": "Lock inventory first, then payment",
      "when_to_switch": "Never - this creates poor UX where user thinks they have room but payment fails."
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Single Responsibility**: BookingService only handles booking logic, not search or payment",
      "**Database-level invariants**: Double-booking prevention at DB level, not just application",
      "**Idempotency**: createBooking should be idempotent with same request ID",
      "**Event-driven**: Publish BookingCreated, BookingCancelled events for downstream systems"
    ],
    "why_this_design_scales": "The architecture separates read (search) and write (booking) paths completely. Search scales horizontally with Elasticsearch replicas. Booking scales by partitioning rooms across database shards (by hotel_id or region). Payment is async and doesn't block the booking commit.",
    "expected_followup_hooks": [
      "**Part 2 - Concurrent handling**: The AvailabilityService.lockDates() method is where we'd add distributed locking",
      "**Part 3 - High traffic**: The SearchService is designed for horizontal scaling via Elasticsearch",
      "**Waitlist feature**: Add WaitlistService that subscribes to BookingCancelled events",
      "**Dynamic pricing**: PricingService can be injected, currently just uses base_price"
    ],
    "invariants": [
      "**INVARIANT 1**: For any (room_id, date) pair, at most ONE confirmed booking exists",
      "**INVARIANT 2**: Booking total_price = SUM(daily_rate) for all dates in range",
      "**INVARIANT 3**: A booking's check_in < check_out always",
      "**INVARIANT 4**: Cancelled booking's dates are immediately available for rebooking"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    THE DOUBLE-BOOKING PROBLEM                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  Without Proper Locking:\n  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  \n  TIME \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\n  \n  User A:  \u250c\u2500CHECK\u2500\u2510                    \u250c\u2500BOOK\u2500\u2510\n           \u2502 Room  \u2502 \u2500\u25b6 \u2713 Available     \u2502 Room \u2502 \u2500\u25b6 \u2713 SUCCESS\n           \u2502  101  \u2502                    \u2502 101  \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n  User B:       \u250c\u2500CHECK\u2500\u2510\u2502              \u250c\u2500BOOK\u2500\u2510\n                \u2502 Room  \u2502\u2502\u2500\u25b6 \u2713 Available\u2502 Room \u2502 \u2500\u25b6 \u2713 SUCCESS  \u26a0\ufe0f DOUBLE BOOKED!\n                \u2502  101  \u2502               \u2502 101  \u2502\n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \n  \n  With Database Locking:\n  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  \n  User A:  \u250c\u2500LOCK & CHECK\u2500\u2510            \u250c\u2500BOOK\u2500\u2510          \u250c\u2500COMMIT\u2500\u2510\n           \u2502 SELECT FOR   \u2502            \u2502 Room \u2502          \u2502 Release\u2502\n           \u2502 UPDATE       \u2502\u2500\u25b6 \u2713 Avail  \u2502 101  \u2502\u2500\u25b6 \u2713 OK   \u2502 Lock   \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502                                          \u2502\n  User B:           \u2502 \u250c\u2500LOCK & CHECK\u2500\u2510                        \u2502\u250c\u2500RETRY\u2500\u2510\n                    \u2502 \u2502 BLOCKED...   \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u25b6\u2502\u2502 \u2717 NOT \u2502\n                    \u2514\u25b6\u2502 (waiting)    \u2502                         \u2502\u2502 AVAIL \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       DATABASE SCHEMA                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        hotels          \u2502      \u2502         rooms          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 id (PK)                \u2502\u2500\u2500\u2510   \u2502 id (PK)                \u2502\n\u2502 name                   \u2502  \u2502   \u2502 hotel_id (FK)      \u25c4\u2500\u2500\u2500\u253c\u2500\u2518\n\u2502 city                   \u2502  \u2514\u2500\u2500\u25b6\u2502 room_number            \u2502\n\u2502 country                \u2502      \u2502 room_type              \u2502\n\u2502 latitude               \u2502      \u2502 capacity               \u2502\n\u2502 longitude              \u2502      \u2502 base_price_cents       \u2502\n\u2502 rating                 \u2502      \u2502 amenities (JSONB)      \u2502\n\u2502 amenities (JSONB)      \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502 description            \u2502                  \u2502\n\u2502 images (JSONB)         \u2502                  \u2502 1:N\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n                                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        users           \u2502      \u2502           room_availability                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 id (PK)                \u2502      \u2502 room_id (FK, PK)                           \u2502\n\u2502 email                  \u2502      \u2502 date (PK)          \u25c4\u2500\u2500 UNIQUE(room_id,date)\u2502\n\u2502 name                   \u2502      \u2502 is_available (bool)                        \u2502\n\u2502 phone                  \u2502      \u2502 booking_id (FK, nullable)                  \u2502\n\u2502 created_at             \u2502      \u2502 price_cents (daily rate)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502                                      \u25b2\n            \u2502 1:N                                  \u2502\n            \u25bc                                      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502                  bookings                       \u2502\u2500\u2518\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 id (PK)                                        \u2502\n\u2502 user_id (FK)                                   \u2502\n\u2502 room_id (FK)                                   \u2502\n\u2502 check_in_date                                  \u2502\n\u2502 check_out_date                                 \u2502\n\u2502 status (PENDING/CONFIRMED/CANCELLED/COMPLETED) \u2502\n\u2502 total_price_cents                              \u2502\n\u2502 payment_intent_id                              \u2502\n\u2502 created_at                                     \u2502\n\u2502 updated_at                                     \u2502\n\u2502 cancelled_at                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  \u26a0\ufe0f  CRITICAL CONSTRAINT:\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 UNIQUE INDEX ON room_availability(room_id, date)             \u2502\n  \u2502 WHERE booking_id IS NOT NULL                                 \u2502\n  \u2502                                                              \u2502\n  \u2502 This PREVENTS double-booking at the DATABASE level!          \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "User initiates booking request",
        "visualization": "```\nClient \u2500\u2500\u25b6 API Gateway \u2500\u2500\u25b6 Booking Service\n           \u2502\n           \u2514\u2500 Rate limit check\n           \u2514\u2500 Auth token validation\n```",
        "key_point": "Validate user is authenticated and request is well-formed"
      },
      {
        "step": 2,
        "description": "Authorize payment (don't charge yet)",
        "visualization": "```\nBooking Service \u2500\u2500\u25b6 Payment Service \u2500\u2500\u25b6 Stripe/Payment Gateway\n                                       \u2502\n                                       \u2514\u2500 Returns: payment_intent_id\n                                       \u2514\u2500 Card is AUTHORIZED, not charged\n```",
        "key_point": "If payment auth fails, stop here. Don't lock inventory."
      },
      {
        "step": 3,
        "description": "Begin database transaction with lock",
        "visualization": "```\n\u250c\u2500 BEGIN TRANSACTION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                               \u2502\n\u2502  SELECT * FROM room_availability                             \u2502\n\u2502  WHERE room_id = 'ROOM_101'                                  \u2502\n\u2502    AND date BETWEEN '2024-06-15' AND '2024-06-17'            \u2502\n\u2502    AND is_available = TRUE                                   \u2502\n\u2502  FOR UPDATE;  \u25c4\u2500\u2500 LOCKS these rows!                          \u2502\n\u2502                                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "FOR UPDATE locks rows, blocking concurrent transactions"
      },
      {
        "step": 4,
        "description": "Verify all dates are available",
        "visualization": "```\nExpected: 3 rows (Jun 15, 16, 17)\nActual:   3 rows \u2713\n\nIf any date missing or is_available=FALSE:\n  \u2500\u2500\u25b6 ROLLBACK\n  \u2500\u2500\u25b6 Cancel payment authorization\n  \u2500\u2500\u25b6 Return error to user\n```",
        "key_point": "If not all dates available, abort cleanly"
      },
      {
        "step": 5,
        "description": "Create booking and update availability",
        "visualization": "```\n\u250c\u2500 STILL IN TRANSACTION \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                               \u2502\n\u2502  INSERT INTO bookings (...) VALUES (...)                     \u2502\n\u2502  RETURNING id;  \u2500\u2500\u25b6 'BK_789456'                              \u2502\n\u2502                                                               \u2502\n\u2502  UPDATE room_availability                                    \u2502\n\u2502  SET is_available = FALSE,                                   \u2502\n\u2502      booking_id = 'BK_789456'                                \u2502\n\u2502  WHERE room_id = 'ROOM_101'                                  \u2502\n\u2502    AND date BETWEEN '2024-06-15' AND '2024-06-17';           \u2502\n\u2502                                                               \u2502\n\u2502  COMMIT;  \u25c4\u2500\u2500 Releases locks, makes changes permanent        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "Atomic commit of booking + availability update"
      },
      {
        "step": 6,
        "description": "Return confirmation, trigger async tasks",
        "visualization": "```\nBooking Service \u2500\u2500\u25b6 Message Queue \u2500\u2500\u25b6 Email Service\n       \u2502                          \u2500\u2500\u25b6 Search Index Updater\n       \u2502                          \u2500\u2500\u25b6 Analytics\n       \u2502\n       \u2514\u2500\u2500\u25b6 Client: { status: 'CONFIRMED', bookingId: 'BK_789456' }\n```",
        "key_point": "Confirmation sent immediately; emails/updates are async"
      }
    ],
    "dry_run_table": "| Step | Action | Database State | Result |\n|------|--------|----------------|--------|\n| 0 | Initial state | room_availability: [(101, Jun15, \u2713), (101, Jun16, \u2713), (101, Jun17, \u2713)] | - |\n| 1 | User A: authorize payment | No DB change | payment_intent_A created |\n| 2 | User A: SELECT FOR UPDATE | Rows LOCKED | 3 available dates found |\n| 3 | User B: authorize payment | No DB change | payment_intent_B created |\n| 4 | User B: SELECT FOR UPDATE | **BLOCKED** (waiting for A's lock) | - |\n| 5 | User A: INSERT booking | bookings: [BK_001] | Booking created |\n| 6 | User A: UPDATE availability | availability: [(101, Jun15, \u2717, BK_001), ...] | Dates marked booked |\n| 7 | User A: COMMIT | Lock released | **User A: SUCCESS** |\n| 8 | User B: Lock acquired | Reads UPDATED data | 0 available dates! |\n| 9 | User B: ROLLBACK | No changes | Cancel payment_intent_B |\n| 10 | User B: Return error | - | **User B: ROOM_NOT_AVAILABLE** |"
  },
  "thinking_process": {
    "step_by_step": [
      "When I see **'prevent double-booking'**, I immediately think: this is a **concurrency control problem**. Application-level checks are NOT sufficient because of race conditions between check and write.",
      "The phrase **'concurrent bookings up to 10K/sec'** tells me we need database-level guarantees, likely with **row-level locking** or **unique constraints**.",
      "When I see **'search < 200ms'**, I know we can't query the booking table on every search. This screams **CQRS** - separate read model (Elasticsearch) from write model (PostgreSQL).",
      "The **'payment chicken-and-egg'** problem is classic: authorize payment FIRST (fast check that card works), THEN lock inventory. If payment auth fails, we never touched inventory.",
      "For the **data model**, I should store one row per (room_id, date) rather than computing availability from bookings. This makes conflict detection trivial with a UNIQUE constraint.",
      "The **cancellation race condition** (User B books while User A cancels) is handled automatically if we use transactions properly - B's lock will wait until A's cancel transaction commits."
    ],
    "key_insight": "**The crucial realization**: Double-booking prevention MUST be enforced at the database level with constraints/locks, not application logic. Application bugs happen; database constraints are mathematical guarantees. Use BOTH pessimistic locking (SELECT FOR UPDATE) for UX and unique constraints as the ultimate backstop.",
    "why_this_works": "The system works because:\n1. **SELECT FOR UPDATE** serializes concurrent booking attempts for the same room\n2. **UNIQUE constraint** on (room_id, date, booking_id NOT NULL) mathematically prevents duplicates\n3. **Transaction isolation** ensures atomic check-and-book operations\n4. **Payment authorization** before locking prevents charging customers for unavailable rooms"
  },
  "approaches": [
    {
      "name": "Brute Force: Application-Level Check",
      "description": "Check availability in application code, then insert booking if available",
      "pseudocode": "available = db.query('SELECT * FROM bookings WHERE room=X AND dates overlap')\nif not available:\n    return 'not available'\ndb.insert(booking)  # RACE CONDITION HERE!\nreturn 'success'",
      "time_complexity": "O(B) where B = number of bookings for room",
      "space_complexity": "O(1)",
      "pros": [
        "Simple to implement",
        "Easy to understand"
      ],
      "cons": [
        "**FATAL FLAW**: Race condition between check and insert",
        "Two users can both see 'available' and both book",
        "Violates critical requirement"
      ],
      "when_to_use": "NEVER for booking systems. Only acceptable for non-critical, low-volume systems."
    },
    {
      "name": "Optimistic Locking with Retry",
      "description": "Add version column, check version matches when updating, retry on conflict",
      "pseudocode": "version = db.query('SELECT version FROM room WHERE id=X')\n# ... user fills form ...\nresult = db.update('UPDATE room SET booked=TRUE WHERE id=X AND version=V')\nif result.rows_affected == 0:\n    return 'conflict, please retry'\nreturn 'success'",
      "time_complexity": "O(1) per attempt, but may require retries",
      "space_complexity": "O(1)",
      "pros": [
        "No blocking/waiting",
        "Good throughput for low contention",
        "Simple implementation"
      ],
      "cons": [
        "Requires retry logic",
        "Poor UX if many conflicts",
        "Not suitable for very popular rooms"
      ],
      "when_to_use": "When contention is expected to be low. Good for most rooms most of the time."
    },
    {
      "name": "Optimal: Pessimistic Locking + Unique Constraint (Belt and Suspenders)",
      "description": "SELECT FOR UPDATE locks rows during transaction. Unique constraint as backstop.",
      "pseudocode": "BEGIN TRANSACTION\n\n-- Lock the date rows\navailable = db.query('''\n    SELECT * FROM room_availability \n    WHERE room_id=X AND date BETWEEN check_in AND check_out\n    FOR UPDATE\n''')\n\n-- Check all dates available\nif len(available) != expected_nights:\n    ROLLBACK\n    return 'not available'\n\n-- Create booking atomically\ndb.insert(booking)\ndb.update(room_availability, set booking_id=new_booking)\n\nCOMMIT\nreturn 'success'",
      "time_complexity": "O(D) where D = number of dates in booking (typically 1-14)",
      "space_complexity": "O(D) for locked rows",
      "pros": [
        "**Guarantees no double-booking**",
        "Clear error messages",
        "No retry needed for conflicting users"
      ],
      "cons": [
        "Blocking can cause waits",
        "Need to handle lock timeouts",
        "Slightly more complex"
      ],
      "key_insight": "Lock FIRST, then check. Unique constraint catches any bugs in application logic."
    }
  ],
  "optimal_solution": {
    "name": "Pessimistic Locking with Pre-computed Availability Table",
    "explanation_md": "## Approach\n\nThe key insight is that **preventing double-bookings requires database-level guarantees**, not application-level checks. We use a **two-layer defense**:\n\n### Layer 1: Pessimistic Locking (SELECT FOR UPDATE)\n- Before booking, lock all relevant date rows\n- Other transactions trying to book overlapping dates will **block and wait**\n- First transaction commits \u2192 second sees updated (unavailable) data\n\n### Layer 2: Unique Constraint\n- `UNIQUE(room_id, date) WHERE booking_id IS NOT NULL`\n- Even if application has bugs, database **physically cannot** store two bookings for same room/date\n- This is our mathematical guarantee\n\n### Why Pre-computed Availability?\nInstead of computing availability by scanning bookings table:\n```sql\n-- SLOW: Scans all bookings\nSELECT * FROM rooms WHERE NOT EXISTS (\n    SELECT 1 FROM bookings WHERE room_id = rooms.id AND dates_overlap(...)\n)\n```\n\nWe maintain explicit availability:\n```sql\n-- FAST: Index lookup\nSELECT * FROM room_availability \nWHERE room_id = X AND date = '2024-06-15' AND is_available = TRUE\n```\n\n### Payment Flow\n```\n1. Authorize payment (verify card works)     \u2190 Fast, no inventory lock\n2. Lock inventory rows (SELECT FOR UPDATE)  \u2190 Blocks competitors  \n3. Verify all dates available               \u2190 Inside transaction\n4. Create booking + update availability     \u2190 Atomic commit\n5. Return confirmation                      \u2190 User is done\n6. [Async] Send email, update search index  \u2190 Background jobs\n7. [At check-in] Capture payment            \u2190 Actual charge\n```",
    "data_structures": [
      {
        "structure": "PostgreSQL room_availability table",
        "purpose": "Pre-computed availability with UNIQUE constraint prevents double-booking"
      },
      {
        "structure": "Redis distributed lock (optional)",
        "purpose": "For cross-shard locking if database is sharded"
      },
      {
        "structure": "Elasticsearch index",
        "purpose": "Fast search with denormalized hotel+room+availability data"
      },
      {
        "structure": "Message queue (Kafka/SQS)",
        "purpose": "Async processing of emails, search index updates, analytics"
      }
    ],
    "algorithm_steps": [
      "1. **Validate request**: Check dates are valid (check_in < check_out, not in past, within booking window)",
      "2. **Authorize payment**: Call payment service to authorize (not charge) the card",
      "3. **Begin transaction**: Start PostgreSQL transaction with appropriate isolation level",
      "4. **Lock availability rows**: SELECT FOR UPDATE on room_availability for requested dates",
      "5. **Verify availability**: Ensure all required dates exist and is_available = TRUE",
      "6. **Create booking**: INSERT into bookings table with PENDING status",
      "7. **Update availability**: UPDATE room_availability SET is_available = FALSE, booking_id = new_id",
      "8. **Commit transaction**: Atomic commit, releases locks",
      "9. **Update booking status**: Set status to CONFIRMED",
      "10. **Return response**: Send confirmation to user",
      "11. **Async tasks**: Queue email notification, search index update, analytics event"
    ],
    "why_decimal": "Using integer cents (not float dollars) prevents precision errors. $199.99 = 19999 cents. All price arithmetic is exact integer math."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Production-Quality Implementation",
    "",
    "This module provides a complete hotel booking system with:",
    "- Race condition prevention via database locking",
    "- Pre-computed availability for fast search",
    "- Payment integration with authorize-then-capture flow",
    "- Comprehensive error handling",
    "",
    "Author: System Design Interview Preparation",
    "\"\"\"",
    "",
    "from __future__ import annotations",
    "from dataclasses import dataclass, field",
    "from datetime import date, datetime, timedelta",
    "from decimal import Decimal",
    "from enum import Enum",
    "from typing import Dict, List, Optional, Set, Tuple",
    "from abc import ABC, abstractmethod",
    "import uuid",
    "import threading",
    "from contextlib import contextmanager",
    "",
    "",
    "# ============================================================================",
    "# DOMAIN MODELS",
    "# ============================================================================",
    "",
    "class BookingStatus(Enum):",
    "    \"\"\"Booking lifecycle states.\"\"\"",
    "    PENDING = 'PENDING'        # Payment authorized, not confirmed",
    "    CONFIRMED = 'CONFIRMED'    # Booking confirmed",
    "    CANCELLED = 'CANCELLED'    # User cancelled",
    "    COMPLETED = 'COMPLETED'    # Guest checked out",
    "    NO_SHOW = 'NO_SHOW'        # Guest didn't arrive",
    "",
    "",
    "@dataclass",
    "class Location:",
    "    \"\"\"Geographic location with coordinates.\"\"\"",
    "    city: str",
    "    country: str",
    "    latitude: float",
    "    longitude: float",
    "",
    "",
    "@dataclass",
    "class Hotel:",
    "    \"\"\"Hotel entity with metadata.\"\"\"",
    "    id: str",
    "    name: str",
    "    location: Location",
    "    rating: float",
    "    amenities: List[str]",
    "    description: str",
    "    image_urls: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Room:",
    "    \"\"\"Room within a hotel.\"\"\"",
    "    id: str",
    "    hotel_id: str",
    "    room_number: str",
    "    room_type: str  # e.g., 'Standard King', 'Deluxe Suite'",
    "    capacity: int",
    "    base_price_cents: int  # Store in cents to avoid float precision",
    "    amenities: List[str]",
    "    ",
    "    @property",
    "    def base_price(self) -> Decimal:",
    "        \"\"\"Get base price as Decimal dollars.\"\"\"",
    "        return Decimal(self.base_price_cents) / Decimal('100')",
    "",
    "",
    "@dataclass",
    "class RoomAvailability:",
    "    \"\"\"Single date availability for a room.\"\"\"",
    "    room_id: str",
    "    date: date",
    "    is_available: bool",
    "    booking_id: Optional[str]",
    "    price_cents: int  # Daily rate (can vary by date)",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Confirmed or pending booking.\"\"\"",
    "    id: str",
    "    user_id: str",
    "    room_id: str",
    "    hotel_id: str",
    "    check_in: date",
    "    check_out: date",
    "    status: BookingStatus",
    "    total_price_cents: int",
    "    payment_intent_id: Optional[str]",
    "    created_at: datetime",
    "    updated_at: datetime",
    "    cancelled_at: Optional[datetime] = None",
    "    ",
    "    @property",
    "    def total_price(self) -> Decimal:",
    "        return Decimal(self.total_price_cents) / Decimal('100')",
    "    ",
    "    @property",
    "    def num_nights(self) -> int:",
    "        return (self.check_out - self.check_in).days",
    "",
    "",
    "# ============================================================================",
    "# REQUEST/RESPONSE DTOs",
    "# ============================================================================",
    "",
    "@dataclass",
    "class SearchRequest:",
    "    \"\"\"Search criteria for finding rooms.\"\"\"",
    "    location: str",
    "    check_in: date",
    "    check_out: date",
    "    guests: int",
    "    price_min_cents: Optional[int] = None",
    "    price_max_cents: Optional[int] = None",
    "    amenities: Optional[List[str]] = None",
    "    min_rating: Optional[float] = None",
    "    page: int = 1",
    "    page_size: int = 20",
    "",
    "",
    "@dataclass",
    "class SearchResult:",
    "    \"\"\"Single room in search results.\"\"\"",
    "    room: Room",
    "    hotel: Hotel",
    "    total_price_cents: int",
    "    is_available: bool",
    "",
    "",
    "@dataclass",
    "class SearchResponse:",
    "    \"\"\"Paginated search results.\"\"\"",
    "    results: List[SearchResult]",
    "    total_count: int",
    "    page: int",
    "    page_size: int",
    "    has_more: bool",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Request to create a booking.\"\"\"",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    payment_token: str  # Tokenized card from frontend",
    "    idempotency_key: Optional[str] = None  # For retry safety",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    \"\"\"Response from booking attempt.\"\"\"",
    "    success: bool",
    "    booking: Optional[Booking]",
    "    error_code: Optional[str] = None",
    "    error_message: Optional[str] = None",
    "",
    "",
    "@dataclass",
    "class CancelResponse:",
    "    \"\"\"Response from cancellation.\"\"\"",
    "    success: bool",
    "    refund_amount_cents: int",
    "    refund_status: str",
    "    error_message: Optional[str] = None",
    "",
    "",
    "# ============================================================================",
    "# EXCEPTIONS",
    "# ============================================================================",
    "",
    "class BookingError(Exception):",
    "    \"\"\"Base exception for booking errors.\"\"\"",
    "    pass",
    "",
    "",
    "class RoomNotAvailableError(BookingError):",
    "    \"\"\"Room is not available for requested dates.\"\"\"",
    "    def __init__(self, room_id: str, conflicting_dates: List[date]):",
    "        self.room_id = room_id",
    "        self.conflicting_dates = conflicting_dates",
    "        super().__init__(",
    "            f\"Room {room_id} not available for dates: {conflicting_dates}\"",
    "        )",
    "",
    "",
    "class PaymentError(BookingError):",
    "    \"\"\"Payment processing failed.\"\"\"",
    "    pass",
    "",
    "",
    "class BookingNotFoundError(BookingError):",
    "    \"\"\"Booking does not exist.\"\"\"",
    "    pass",
    "",
    "",
    "class UnauthorizedError(BookingError):",
    "    \"\"\"User not authorized for this action.\"\"\"",
    "    pass",
    "",
    "",
    "# ============================================================================",
    "# INTERFACES (for dependency injection)",
    "# ============================================================================",
    "",
    "class PaymentService(ABC):",
    "    \"\"\"Interface for payment processing.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def authorize(self, token: str, amount_cents: int) -> str:",
    "        \"\"\"Authorize payment, return payment_intent_id.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def capture(self, payment_intent_id: str) -> bool:",
    "        \"\"\"Capture previously authorized payment.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def refund(self, payment_intent_id: str, amount_cents: int) -> str:",
    "        \"\"\"Refund payment, return refund_id.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def cancel_authorization(self, payment_intent_id: str) -> bool:",
    "        \"\"\"Cancel payment authorization.\"\"\"",
    "        pass",
    "",
    "",
    "# ============================================================================",
    "# IN-MEMORY IMPLEMENTATIONS (for demonstration)",
    "# ============================================================================",
    "",
    "class InMemoryDatabase:",
    "    \"\"\"",
    "    Simulates database with locking for demonstration.",
    "    In production, this would be PostgreSQL with SELECT FOR UPDATE.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._hotels: Dict[str, Hotel] = {}",
    "        self._rooms: Dict[str, Room] = {}",
    "        self._availability: Dict[Tuple[str, date], RoomAvailability] = {}",
    "        self._bookings: Dict[str, Booking] = {}",
    "        self._lock = threading.RLock()  # Simulates row-level locking",
    "        self._row_locks: Dict[Tuple[str, date], threading.Lock] = {}",
    "    ",
    "    def _get_row_lock(self, room_id: str, d: date) -> threading.Lock:",
    "        \"\"\"Get or create lock for specific room/date combination.\"\"\"",
    "        key = (room_id, d)",
    "        with self._lock:",
    "            if key not in self._row_locks:",
    "                self._row_locks[key] = threading.Lock()",
    "            return self._row_locks[key]",
    "    ",
    "    @contextmanager",
    "    def transaction(self, room_id: str, dates: List[date]):",
    "        \"\"\"",
    "        Simulate database transaction with row-level locking.",
    "        Locks all requested room/date combinations.",
    "        \"\"\"",
    "        # Sort to prevent deadlocks (always acquire locks in same order)",
    "        sorted_dates = sorted(dates)",
    "        locks = [self._get_row_lock(room_id, d) for d in sorted_dates]",
    "        ",
    "        # Acquire all locks",
    "        for lock in locks:",
    "            lock.acquire()",
    "        ",
    "        try:",
    "            yield",
    "        finally:",
    "            # Release all locks in reverse order",
    "            for lock in reversed(locks):",
    "                lock.release()",
    "    ",
    "    def add_hotel(self, hotel: Hotel) -> None:",
    "        self._hotels[hotel.id] = hotel",
    "    ",
    "    def add_room(self, room: Room) -> None:",
    "        self._rooms[room.id] = room",
    "    ",
    "    def get_room(self, room_id: str) -> Optional[Room]:",
    "        return self._rooms.get(room_id)",
    "    ",
    "    def get_hotel(self, hotel_id: str) -> Optional[Hotel]:",
    "        return self._hotels.get(hotel_id)",
    "    ",
    "    def initialize_availability(",
    "        self, ",
    "        room_id: str, ",
    "        start_date: date, ",
    "        end_date: date,",
    "        price_cents: int",
    "    ) -> None:",
    "        \"\"\"Initialize availability for a room over a date range.\"\"\"",
    "        current = start_date",
    "        while current < end_date:",
    "            key = (room_id, current)",
    "            self._availability[key] = RoomAvailability(",
    "                room_id=room_id,",
    "                date=current,",
    "                is_available=True,",
    "                booking_id=None,",
    "                price_cents=price_cents",
    "            )",
    "            current += timedelta(days=1)",
    "    ",
    "    def get_availability(",
    "        self, ",
    "        room_id: str, ",
    "        check_in: date, ",
    "        check_out: date",
    "    ) -> List[RoomAvailability]:",
    "        \"\"\"Get availability for date range (excluding check_out date).\"\"\"",
    "        result = []",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key in self._availability:",
    "                result.append(self._availability[key])",
    "            current += timedelta(days=1)",
    "        return result",
    "    ",
    "    def check_all_available(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date",
    "    ) -> Tuple[bool, List[date], int]:",
    "        \"\"\"",
    "        Check if all dates are available.",
    "        Returns: (all_available, unavailable_dates, total_price_cents)",
    "        \"\"\"",
    "        availability = self.get_availability(room_id, check_in, check_out)",
    "        expected_nights = (check_out - check_in).days",
    "        ",
    "        unavailable = [a.date for a in availability if not a.is_available]",
    "        missing_dates = []",
    "        ",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key not in self._availability:",
    "                missing_dates.append(current)",
    "            current += timedelta(days=1)",
    "        ",
    "        all_problems = unavailable + missing_dates",
    "        total_price = sum(a.price_cents for a in availability if a.is_available)",
    "        ",
    "        return len(all_problems) == 0 and len(availability) == expected_nights, all_problems, total_price",
    "    ",
    "    def mark_booked(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date,",
    "        booking_id: str",
    "    ) -> None:",
    "        \"\"\"Mark dates as booked.\"\"\"",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key in self._availability:",
    "                avail = self._availability[key]",
    "                self._availability[key] = RoomAvailability(",
    "                    room_id=avail.room_id,",
    "                    date=avail.date,",
    "                    is_available=False,",
    "                    booking_id=booking_id,",
    "                    price_cents=avail.price_cents",
    "                )",
    "            current += timedelta(days=1)",
    "    ",
    "    def mark_available(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date",
    "    ) -> None:",
    "        \"\"\"Mark dates as available (for cancellation).\"\"\"",
    "        current = check_in",
    "        while current < check_out:",
    "            key = (room_id, current)",
    "            if key in self._availability:",
    "                avail = self._availability[key]",
    "                self._availability[key] = RoomAvailability(",
    "                    room_id=avail.room_id,",
    "                    date=avail.date,",
    "                    is_available=True,",
    "                    booking_id=None,",
    "                    price_cents=avail.price_cents",
    "                )",
    "            current += timedelta(days=1)",
    "    ",
    "    def save_booking(self, booking: Booking) -> None:",
    "        self._bookings[booking.id] = booking",
    "    ",
    "    def get_booking(self, booking_id: str) -> Optional[Booking]:",
    "        return self._bookings.get(booking_id)",
    "    ",
    "    def search_rooms(",
    "        self,",
    "        request: SearchRequest",
    "    ) -> List[Tuple[Room, Hotel, int]]:",
    "        \"\"\"",
    "        Search for available rooms.",
    "        Returns list of (room, hotel, total_price_cents).",
    "        In production, this would query Elasticsearch.",
    "        \"\"\"",
    "        results = []",
    "        ",
    "        for room in self._rooms.values():",
    "            hotel = self._hotels.get(room.hotel_id)",
    "            if not hotel:",
    "                continue",
    "            ",
    "            # Location filter",
    "            if request.location.lower() not in hotel.location.city.lower():",
    "                continue",
    "            ",
    "            # Capacity filter",
    "            if room.capacity < request.guests:",
    "                continue",
    "            ",
    "            # Rating filter",
    "            if request.min_rating and hotel.rating < request.min_rating:",
    "                continue",
    "            ",
    "            # Check availability",
    "            is_avail, _, total_price = self.check_all_available(",
    "                room.id, request.check_in, request.check_out",
    "            )",
    "            ",
    "            if not is_avail:",
    "                continue",
    "            ",
    "            # Price filter",
    "            if request.price_max_cents and total_price > request.price_max_cents:",
    "                continue",
    "            if request.price_min_cents and total_price < request.price_min_cents:",
    "                continue",
    "            ",
    "            results.append((room, hotel, total_price))",
    "        ",
    "        return results",
    "",
    "",
    "class MockPaymentService(PaymentService):",
    "    \"\"\"Mock payment service for testing.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._authorizations: Dict[str, int] = {}",
    "    ",
    "    def authorize(self, token: str, amount_cents: int) -> str:",
    "        if 'fail' in token.lower():",
    "            raise PaymentError(f\"Payment authorization failed for token: {token}\")",
    "        intent_id = f\"pi_{uuid.uuid4().hex[:16]}\"",
    "        self._authorizations[intent_id] = amount_cents",
    "        return intent_id",
    "    ",
    "    def capture(self, payment_intent_id: str) -> bool:",
    "        return payment_intent_id in self._authorizations",
    "    ",
    "    def refund(self, payment_intent_id: str, amount_cents: int) -> str:",
    "        return f\"re_{uuid.uuid4().hex[:16]}\"",
    "    ",
    "    def cancel_authorization(self, payment_intent_id: str) -> bool:",
    "        self._authorizations.pop(payment_intent_id, None)",
    "        return True",
    "",
    "",
    "# ============================================================================",
    "# MAIN BOOKING SERVICE",
    "# ============================================================================",
    "",
    "class HotelBookingService:",
    "    \"\"\"",
    "    Main service for hotel booking operations.",
    "    ",
    "    Handles:",
    "    - Searching for available rooms",
    "    - Creating bookings with race condition prevention",
    "    - Cancelling bookings with refund processing",
    "    ",
    "    Example:",
    "        >>> service = HotelBookingService(db, payment_service)",
    "        >>> response = service.create_booking(request)",
    "        >>> if response.success:",
    "        ...     print(f'Booked! ID: {response.booking.id}')",
    "    \"\"\"",
    "    ",
    "    def __init__(self, db: InMemoryDatabase, payment_service: PaymentService):",
    "        self._db = db",
    "        self._payment = payment_service",
    "    ",
    "    def search_rooms(self, request: SearchRequest) -> SearchResponse:",
    "        \"\"\"",
    "        Search for available rooms matching criteria.",
    "        ",
    "        Args:",
    "            request: Search criteria including location, dates, guests",
    "        ",
    "        Returns:",
    "            SearchResponse with paginated results",
    "        ",
    "        Note:",
    "            In production, this queries Elasticsearch for speed.",
    "            Results may be slightly stale (few minutes).",
    "        \"\"\"",
    "        # Validate dates",
    "        if request.check_in >= request.check_out:",
    "            raise ValueError(\"Check-in must be before check-out\")",
    "        if request.check_in < date.today():",
    "            raise ValueError(\"Cannot book dates in the past\")",
    "        ",
    "        # Search (in production: Elasticsearch query)",
    "        raw_results = self._db.search_rooms(request)",
    "        ",
    "        # Pagination",
    "        start = (request.page - 1) * request.page_size",
    "        end = start + request.page_size",
    "        page_results = raw_results[start:end]",
    "        ",
    "        results = [",
    "            SearchResult(",
    "                room=room,",
    "                hotel=hotel,",
    "                total_price_cents=price,",
    "                is_available=True",
    "            )",
    "            for room, hotel, price in page_results",
    "        ]",
    "        ",
    "        return SearchResponse(",
    "            results=results,",
    "            total_count=len(raw_results),",
    "            page=request.page,",
    "            page_size=request.page_size,",
    "            has_more=end < len(raw_results)",
    "        )",
    "    ",
    "    def get_room_details(",
    "        self,",
    "        room_id: str,",
    "        check_in: date,",
    "        check_out: date",
    "    ) -> Optional[SearchResult]:",
    "        \"\"\"",
    "        Get detailed room information with live availability.",
    "        ",
    "        Unlike search results, this queries the database directly",
    "        for real-time availability status.",
    "        \"\"\"",
    "        room = self._db.get_room(room_id)",
    "        if not room:",
    "            return None",
    "        ",
    "        hotel = self._db.get_hotel(room.hotel_id)",
    "        if not hotel:",
    "            return None",
    "        ",
    "        is_avail, _, total_price = self._db.check_all_available(",
    "            room_id, check_in, check_out",
    "        )",
    "        ",
    "        return SearchResult(",
    "            room=room,",
    "            hotel=hotel,",
    "            total_price_cents=total_price,",
    "            is_available=is_avail",
    "        )",
    "    ",
    "    def create_booking(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Create a new booking with race condition prevention.",
    "        ",
    "        Flow:",
    "        1. Validate request",
    "        2. Authorize payment (don't charge yet)",
    "        3. Lock inventory rows (prevents concurrent booking)",
    "        4. Verify availability (inside lock)",
    "        5. Create booking and update availability",
    "        6. Return confirmation",
    "        ",
    "        Args:",
    "            request: Booking details including room, dates, payment",
    "        ",
    "        Returns:",
    "            BookingResponse with success/failure and booking details",
    "        ",
    "        Raises:",
    "            RoomNotAvailableError: If room is not available",
    "            PaymentError: If payment authorization fails",
    "        \"\"\"",
    "        # Step 1: Validate request",
    "        if request.check_in >= request.check_out:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking=None,",
    "                error_code='INVALID_DATES',",
    "                error_message='Check-in must be before check-out'",
    "            )",
    "        ",
    "        if request.check_in < date.today():",
    "            return BookingResponse(",
    "                success=False,",
    "                booking=None,",
    "                error_code='PAST_DATE',",
    "                error_message='Cannot book dates in the past'",
    "            )",
    "        ",
    "        room = self._db.get_room(request.room_id)",
    "        if not room:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking=None,",
    "                error_code='ROOM_NOT_FOUND',",
    "                error_message=f'Room {request.room_id} not found'",
    "            )",
    "        ",
    "        # Get dates for locking",
    "        dates = []",
    "        current = request.check_in",
    "        while current < request.check_out:",
    "            dates.append(current)",
    "            current += timedelta(days=1)",
    "        ",
    "        # Step 2: Pre-check availability (before payment auth)",
    "        is_avail, unavail_dates, total_price = self._db.check_all_available(",
    "            request.room_id, request.check_in, request.check_out",
    "        )",
    "        ",
    "        if not is_avail:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking=None,",
    "                error_code='ROOM_NOT_AVAILABLE',",
    "                error_message=f'Room not available for dates: {unavail_dates}'",
    "            )",
    "        ",
    "        # Step 3: Authorize payment (before locking inventory)",
    "        try:",
    "            payment_intent_id = self._payment.authorize(",
    "                request.payment_token,",
    "                total_price",
    "            )",
    "        except PaymentError as e:",
    "            return BookingResponse(",
    "                success=False,",
    "                booking=None,",
    "                error_code='PAYMENT_FAILED',",
    "                error_message=str(e)",
    "            )",
    "        ",
    "        # Step 4: Lock inventory and verify availability (CRITICAL SECTION)",
    "        # This is where we prevent race conditions!",
    "        try:",
    "            with self._db.transaction(request.room_id, dates):",
    "                # Re-check availability INSIDE the lock",
    "                is_avail, unavail_dates, _ = self._db.check_all_available(",
    "                    request.room_id, request.check_in, request.check_out",
    "                )",
    "                ",
    "                if not is_avail:",
    "                    # Room was booked by someone else!",
    "                    # Cancel payment authorization",
    "                    self._payment.cancel_authorization(payment_intent_id)",
    "                    return BookingResponse(",
    "                        success=False,",
    "                        booking=None,",
    "                        error_code='ROOM_NOT_AVAILABLE',",
    "                        error_message=f'Room was just booked for: {unavail_dates}'",
    "                    )",
    "                ",
    "                # Step 5: Create booking",
    "                now = datetime.utcnow()",
    "                booking = Booking(",
    "                    id=f\"BK_{uuid.uuid4().hex[:12].upper()}\",",
    "                    user_id=request.user_id,",
    "                    room_id=request.room_id,",
    "                    hotel_id=room.hotel_id,",
    "                    check_in=request.check_in,",
    "                    check_out=request.check_out,",
    "                    status=BookingStatus.CONFIRMED,",
    "                    total_price_cents=total_price,",
    "                    payment_intent_id=payment_intent_id,",
    "                    created_at=now,",
    "                    updated_at=now",
    "                )",
    "                ",
    "                # Mark dates as booked",
    "                self._db.mark_booked(",
    "                    request.room_id,",
    "                    request.check_in,",
    "                    request.check_out,",
    "                    booking.id",
    "                )",
    "                ",
    "                # Save booking",
    "                self._db.save_booking(booking)",
    "        ",
    "        except Exception as e:",
    "            # Something went wrong, cancel payment auth",
    "            self._payment.cancel_authorization(payment_intent_id)",
    "            raise",
    "        ",
    "        # Step 6: Return success",
    "        return BookingResponse(",
    "            success=True,",
    "            booking=booking",
    "        )",
    "    ",
    "    def get_booking(",
    "        self,",
    "        booking_id: str,",
    "        user_id: str",
    "    ) -> Optional[Booking]:",
    "        \"\"\"",
    "        Get booking details.",
    "        ",
    "        Args:",
    "            booking_id: The booking to retrieve",
    "            user_id: User making the request (for authorization)",
    "        ",
    "        Returns:",
    "            Booking if found and user is authorized, None otherwise",
    "        ",
    "        Raises:",
    "            UnauthorizedError: If user doesn't own this booking",
    "        \"\"\"",
    "        booking = self._db.get_booking(booking_id)",
    "        if not booking:",
    "            return None",
    "        ",
    "        if booking.user_id != user_id:",
    "            raise UnauthorizedError(",
    "                f\"User {user_id} not authorized to view booking {booking_id}\"",
    "            )",
    "        ",
    "        return booking",
    "    ",
    "    def cancel_booking(",
    "        self,",
    "        booking_id: str,",
    "        user_id: str",
    "    ) -> CancelResponse:",
    "        \"\"\"",
    "        Cancel a booking and process refund.",
    "        ",
    "        Args:",
    "            booking_id: Booking to cancel",
    "            user_id: User requesting cancellation",
    "        ",
    "        Returns:",
    "            CancelResponse with refund details",
    "        \"\"\"",
    "        booking = self._db.get_booking(booking_id)",
    "        ",
    "        if not booking:",
    "            return CancelResponse(",
    "                success=False,",
    "                refund_amount_cents=0,",
    "                refund_status='NONE',",
    "                error_message=f'Booking {booking_id} not found'",
    "            )",
    "        ",
    "        if booking.user_id != user_id:",
    "            return CancelResponse(",
    "                success=False,",
    "                refund_amount_cents=0,",
    "                refund_status='NONE',",
    "                error_message='Not authorized to cancel this booking'",
    "            )",
    "        ",
    "        if booking.status == BookingStatus.CANCELLED:",
    "            return CancelResponse(",
    "                success=False,",
    "                refund_amount_cents=0,",
    "                refund_status='ALREADY_CANCELLED',",
    "                error_message='Booking already cancelled'",
    "            )",
    "        ",
    "        # Get dates for locking",
    "        dates = []",
    "        current = booking.check_in",
    "        while current < booking.check_out:",
    "            dates.append(current)",
    "            current += timedelta(days=1)",
    "        ",
    "        # Calculate refund (simplified: full refund if > 24h before check-in)",
    "        days_until_checkin = (booking.check_in - date.today()).days",
    "        if days_until_checkin > 1:",
    "            refund_amount = booking.total_price_cents",
    "        elif days_until_checkin == 1:",
    "            refund_amount = booking.total_price_cents // 2  # 50% refund",
    "        else:",
    "            refund_amount = 0  # No refund",
    "        ",
    "        # Lock and cancel",
    "        with self._db.transaction(booking.room_id, dates):",
    "            # Update booking status",
    "            now = datetime.utcnow()",
    "            cancelled_booking = Booking(",
    "                id=booking.id,",
    "                user_id=booking.user_id,",
    "                room_id=booking.room_id,",
    "                hotel_id=booking.hotel_id,",
    "                check_in=booking.check_in,",
    "                check_out=booking.check_out,",
    "                status=BookingStatus.CANCELLED,",
    "                total_price_cents=booking.total_price_cents,",
    "                payment_intent_id=booking.payment_intent_id,",
    "                created_at=booking.created_at,",
    "                updated_at=now,",
    "                cancelled_at=now",
    "            )",
    "            self._db.save_booking(cancelled_booking)",
    "            ",
    "            # Release inventory",
    "            self._db.mark_available(",
    "                booking.room_id,",
    "                booking.check_in,",
    "                booking.check_out",
    "            )",
    "        ",
    "        # Process refund (async in production)",
    "        refund_status = 'PROCESSED'",
    "        if refund_amount > 0 and booking.payment_intent_id:",
    "            try:",
    "                self._payment.refund(booking.payment_intent_id, refund_amount)",
    "            except Exception:",
    "                refund_status = 'PENDING'  # Will retry async",
    "        ",
    "        return CancelResponse(",
    "            success=True,",
    "            refund_amount_cents=refund_amount,",
    "            refund_status=refund_status",
    "        )",
    "",
    "",
    "# ============================================================================",
    "# DEMONSTRATION",
    "# ============================================================================",
    "",
    "def run_demo():",
    "    \"\"\"Demonstrate the booking system with various scenarios.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"HOTEL BOOKING SYSTEM DEMONSTRATION\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Setup",
    "    db = InMemoryDatabase()",
    "    payment_service = MockPaymentService()",
    "    service = HotelBookingService(db, payment_service)",
    "    ",
    "    # Create test data",
    "    hotel = Hotel(",
    "        id=\"HOTEL_NYC_001\",",
    "        name=\"Grand Hotel New York\",",
    "        location=Location(\"New York\", \"USA\", 40.7128, -74.0060),",
    "        rating=4.5,",
    "        amenities=[\"WiFi\", \"Pool\", \"Gym\", \"Restaurant\"],",
    "        description=\"Luxury hotel in Manhattan\"",
    "    )",
    "    db.add_hotel(hotel)",
    "    ",
    "    room = Room(",
    "        id=\"ROOM_NYC_101\",",
    "        hotel_id=\"HOTEL_NYC_001\",",
    "        room_number=\"101\",",
    "        room_type=\"Deluxe King\",",
    "        capacity=2,",
    "        base_price_cents=25000,  # $250/night",
    "        amenities=[\"King Bed\", \"City View\", \"Mini Bar\"]",
    "    )",
    "    db.add_room(room)",
    "    ",
    "    # Initialize availability for next 30 days",
    "    today = date.today()",
    "    db.initialize_availability(",
    "        room.id,",
    "        today,",
    "        today + timedelta(days=30),",
    "        room.base_price_cents",
    "    )",
    "    ",
    "    print(\"\\n\ud83d\udccc Scenario 1: Search for available rooms\")",
    "    print(\"-\" * 50)",
    "    ",
    "    check_in = today + timedelta(days=7)",
    "    check_out = today + timedelta(days=10)",
    "    ",
    "    search_request = SearchRequest(",
    "        location=\"New York\",",
    "        check_in=check_in,",
    "        check_out=check_out,",
    "        guests=2",
    "    )",
    "    ",
    "    search_response = service.search_rooms(search_request)",
    "    print(f\"Found {search_response.total_count} room(s)\")",
    "    for result in search_response.results:",
    "        print(f\"  - {result.room.room_type} at {result.hotel.name}\")",
    "        print(f\"    ${result.total_price_cents / 100:.2f} total for {(check_out - check_in).days} nights\")",
    "    ",
    "    print(\"\\n\ud83d\udccc Scenario 2: Create a booking\")",
    "    print(\"-\" * 50)",
    "    ",
    "    booking_request = BookingRequest(",
    "        user_id=\"USER_ALICE\",",
    "        room_id=\"ROOM_NYC_101\",",
    "        check_in=check_in,",
    "        check_out=check_out,",
    "        payment_token=\"tok_visa_4242\"",
    "    )",
    "    ",
    "    response = service.create_booking(booking_request)",
    "    print(f\"Booking success: {response.success}\")",
    "    if response.success:",
    "        print(f\"  Booking ID: {response.booking.id}\")",
    "        print(f\"  Total: ${response.booking.total_price_cents / 100:.2f}\")",
    "        print(f\"  Status: {response.booking.status.value}\")",
    "    ",
    "    print(\"\\n\ud83d\udccc Scenario 3: Concurrent booking attempt (same room)\")",
    "    print(\"-\" * 50)",
    "    ",
    "    # User B tries to book same room, overlapping dates",
    "    booking_request_b = BookingRequest(",
    "        user_id=\"USER_BOB\",",
    "        room_id=\"ROOM_NYC_101\",",
    "        check_in=check_in + timedelta(days=1),  # Overlaps with Alice",
    "        check_out=check_out + timedelta(days=2),",
    "        payment_token=\"tok_visa_5555\"",
    "    )",
    "    ",
    "    response_b = service.create_booking(booking_request_b)",
    "    print(f\"Bob's booking success: {response_b.success}\")",
    "    if not response_b.success:",
    "        print(f\"  Error: {response_b.error_code}\")",
    "        print(f\"  Message: {response_b.error_message}\")",
    "    ",
    "    print(\"\\n\ud83d\udccc Scenario 4: Cancel booking\")",
    "    print(\"-\" * 50)",
    "    ",
    "    if response.success:",
    "        cancel_response = service.cancel_booking(",
    "            response.booking.id,",
    "            \"USER_ALICE\"",
    "        )",
    "        print(f\"Cancellation success: {cancel_response.success}\")",
    "        print(f\"Refund amount: ${cancel_response.refund_amount_cents / 100:.2f}\")",
    "        print(f\"Refund status: {cancel_response.refund_status}\")",
    "    ",
    "    print(\"\\n\ud83d\udccc Scenario 5: Book after cancellation\")",
    "    print(\"-\" * 50)",
    "    ",
    "    # Now Bob can book!",
    "    response_b2 = service.create_booking(booking_request_b)",
    "    print(f\"Bob's second attempt success: {response_b2.success}\")",
    "    if response_b2.success:",
    "        print(f\"  Booking ID: {response_b2.booking.id}\")",
    "        print(f\"  Total: ${response_b2.booking.total_price_cents / 100:.2f}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"DEMONSTRATION COMPLETE\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.LocalDate;",
    "import java.time.LocalDateTime;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Hotel Booking System - Production-Quality Implementation",
    " * ",
    " * Features:",
    " * - Race condition prevention via database-level locking",
    " * - Pre-computed availability for fast search",
    " * - Payment integration with authorize-then-capture flow",
    " */",
    "public class HotelBookingSystem {",
    "",
    "    // ========================================================================",
    "    // ENUMS",
    "    // ========================================================================",
    "    ",
    "    public enum BookingStatus {",
    "        PENDING, CONFIRMED, CANCELLED, COMPLETED, NO_SHOW",
    "    }",
    "",
    "    // ========================================================================",
    "    // DOMAIN MODELS",
    "    // ========================================================================",
    "    ",
    "    public static class Location {",
    "        public final String city;",
    "        public final String country;",
    "        public final double latitude;",
    "        public final double longitude;",
    "        ",
    "        public Location(String city, String country, double lat, double lon) {",
    "            this.city = city;",
    "            this.country = country;",
    "            this.latitude = lat;",
    "            this.longitude = lon;",
    "        }",
    "    }",
    "",
    "    public static class Hotel {",
    "        public final String id;",
    "        public final String name;",
    "        public final Location location;",
    "        public final double rating;",
    "        public final List<String> amenities;",
    "        ",
    "        public Hotel(String id, String name, Location location, ",
    "                     double rating, List<String> amenities) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.location = location;",
    "            this.rating = rating;",
    "            this.amenities = amenities;",
    "        }",
    "    }",
    "",
    "    public static class Room {",
    "        public final String id;",
    "        public final String hotelId;",
    "        public final String roomNumber;",
    "        public final String roomType;",
    "        public final int capacity;",
    "        public final long basePriceCents;",
    "        public final List<String> amenities;",
    "        ",
    "        public Room(String id, String hotelId, String roomNumber, ",
    "                    String roomType, int capacity, long basePriceCents,",
    "                    List<String> amenities) {",
    "            this.id = id;",
    "            this.hotelId = hotelId;",
    "            this.roomNumber = roomNumber;",
    "            this.roomType = roomType;",
    "            this.capacity = capacity;",
    "            this.basePriceCents = basePriceCents;",
    "            this.amenities = amenities;",
    "        }",
    "        ",
    "        public BigDecimal getBasePrice() {",
    "            return BigDecimal.valueOf(basePriceCents).divide(BigDecimal.valueOf(100));",
    "        }",
    "    }",
    "",
    "    public static class RoomAvailability {",
    "        public final String roomId;",
    "        public final LocalDate date;",
    "        public boolean isAvailable;",
    "        public String bookingId;",
    "        public final long priceCents;",
    "        ",
    "        public RoomAvailability(String roomId, LocalDate date, ",
    "                                 boolean isAvailable, String bookingId,",
    "                                 long priceCents) {",
    "            this.roomId = roomId;",
    "            this.date = date;",
    "            this.isAvailable = isAvailable;",
    "            this.bookingId = bookingId;",
    "            this.priceCents = priceCents;",
    "        }",
    "    }",
    "",
    "    public static class Booking {",
    "        public final String id;",
    "        public final String userId;",
    "        public final String roomId;",
    "        public final String hotelId;",
    "        public final LocalDate checkIn;",
    "        public final LocalDate checkOut;",
    "        public BookingStatus status;",
    "        public final long totalPriceCents;",
    "        public final String paymentIntentId;",
    "        public final LocalDateTime createdAt;",
    "        public LocalDateTime updatedAt;",
    "        public LocalDateTime cancelledAt;",
    "        ",
    "        public Booking(String id, String userId, String roomId, String hotelId,",
    "                       LocalDate checkIn, LocalDate checkOut, BookingStatus status,",
    "                       long totalPriceCents, String paymentIntentId,",
    "                       LocalDateTime createdAt) {",
    "            this.id = id;",
    "            this.userId = userId;",
    "            this.roomId = roomId;",
    "            this.hotelId = hotelId;",
    "            this.checkIn = checkIn;",
    "            this.checkOut = checkOut;",
    "            this.status = status;",
    "            this.totalPriceCents = totalPriceCents;",
    "            this.paymentIntentId = paymentIntentId;",
    "            this.createdAt = createdAt;",
    "            this.updatedAt = createdAt;",
    "        }",
    "        ",
    "        public long getNumNights() {",
    "            return ChronoUnit.DAYS.between(checkIn, checkOut);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // REQUEST/RESPONSE DTOs",
    "    // ========================================================================",
    "    ",
    "    public static class SearchRequest {",
    "        public String location;",
    "        public LocalDate checkIn;",
    "        public LocalDate checkOut;",
    "        public int guests;",
    "        public Long priceMaxCents;",
    "        public Double minRating;",
    "        public int page = 1;",
    "        public int pageSize = 20;",
    "    }",
    "",
    "    public static class SearchResult {",
    "        public final Room room;",
    "        public final Hotel hotel;",
    "        public final long totalPriceCents;",
    "        public final boolean isAvailable;",
    "        ",
    "        public SearchResult(Room room, Hotel hotel, long price, boolean avail) {",
    "            this.room = room;",
    "            this.hotel = hotel;",
    "            this.totalPriceCents = price;",
    "            this.isAvailable = avail;",
    "        }",
    "    }",
    "",
    "    public static class SearchResponse {",
    "        public final List<SearchResult> results;",
    "        public final int totalCount;",
    "        public final int page;",
    "        public final boolean hasMore;",
    "        ",
    "        public SearchResponse(List<SearchResult> results, int total, ",
    "                              int page, boolean hasMore) {",
    "            this.results = results;",
    "            this.totalCount = total;",
    "            this.page = page;",
    "            this.hasMore = hasMore;",
    "        }",
    "    }",
    "",
    "    public static class BookingRequest {",
    "        public String userId;",
    "        public String roomId;",
    "        public LocalDate checkIn;",
    "        public LocalDate checkOut;",
    "        public String paymentToken;",
    "    }",
    "",
    "    public static class BookingResponse {",
    "        public final boolean success;",
    "        public final Booking booking;",
    "        public final String errorCode;",
    "        public final String errorMessage;",
    "        ",
    "        public BookingResponse(boolean success, Booking booking, ",
    "                               String errorCode, String errorMessage) {",
    "            this.success = success;",
    "            this.booking = booking;",
    "            this.errorCode = errorCode;",
    "            this.errorMessage = errorMessage;",
    "        }",
    "        ",
    "        public static BookingResponse success(Booking booking) {",
    "            return new BookingResponse(true, booking, null, null);",
    "        }",
    "        ",
    "        public static BookingResponse failure(String code, String msg) {",
    "            return new BookingResponse(false, null, code, msg);",
    "        }",
    "    }",
    "",
    "    public static class CancelResponse {",
    "        public final boolean success;",
    "        public final long refundAmountCents;",
    "        public final String refundStatus;",
    "        public final String errorMessage;",
    "        ",
    "        public CancelResponse(boolean success, long refund, ",
    "                              String status, String error) {",
    "            this.success = success;",
    "            this.refundAmountCents = refund;",
    "            this.refundStatus = status;",
    "            this.errorMessage = error;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // IN-MEMORY DATABASE (simulates PostgreSQL with locking)",
    "    // ========================================================================",
    "    ",
    "    public static class InMemoryDatabase {",
    "        private final Map<String, Hotel> hotels = new ConcurrentHashMap<>();",
    "        private final Map<String, Room> rooms = new ConcurrentHashMap<>();",
    "        private final Map<String, RoomAvailability> availability = new ConcurrentHashMap<>();",
    "        private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "        private final Map<String, ReentrantLock> rowLocks = new ConcurrentHashMap<>();",
    "        ",
    "        private String availKey(String roomId, LocalDate date) {",
    "            return roomId + \"_\" + date.toString();",
    "        }",
    "        ",
    "        private ReentrantLock getRowLock(String roomId, LocalDate date) {",
    "            return rowLocks.computeIfAbsent(availKey(roomId, date), ",
    "                k -> new ReentrantLock());",
    "        }",
    "        ",
    "        public void lockDates(String roomId, List<LocalDate> dates) {",
    "            // Sort to prevent deadlocks",
    "            dates.stream().sorted().forEach(d -> getRowLock(roomId, d).lock());",
    "        }",
    "        ",
    "        public void unlockDates(String roomId, List<LocalDate> dates) {",
    "            // Unlock in reverse order",
    "            List<LocalDate> sorted = dates.stream()",
    "                .sorted(Comparator.reverseOrder()).collect(Collectors.toList());",
    "            sorted.forEach(d -> getRowLock(roomId, d).unlock());",
    "        }",
    "        ",
    "        public void addHotel(Hotel hotel) { hotels.put(hotel.id, hotel); }",
    "        public void addRoom(Room room) { rooms.put(room.id, room); }",
    "        public Room getRoom(String id) { return rooms.get(id); }",
    "        public Hotel getHotel(String id) { return hotels.get(id); }",
    "        ",
    "        public void initializeAvailability(String roomId, LocalDate start, ",
    "                                           LocalDate end, long priceCents) {",
    "            LocalDate current = start;",
    "            while (current.isBefore(end)) {",
    "                String key = availKey(roomId, current);",
    "                availability.put(key, new RoomAvailability(",
    "                    roomId, current, true, null, priceCents));",
    "                current = current.plusDays(1);",
    "            }",
    "        }",
    "        ",
    "        public record AvailabilityCheck(boolean allAvailable, ",
    "                                         List<LocalDate> unavailDates,",
    "                                         long totalPriceCents) {}",
    "        ",
    "        public AvailabilityCheck checkAvailability(String roomId, ",
    "                                                    LocalDate checkIn,",
    "                                                    LocalDate checkOut) {",
    "            List<LocalDate> unavailable = new ArrayList<>();",
    "            long totalPrice = 0;",
    "            int expectedNights = (int) ChronoUnit.DAYS.between(checkIn, checkOut);",
    "            int foundNights = 0;",
    "            ",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                String key = availKey(roomId, current);",
    "                RoomAvailability avail = availability.get(key);",
    "                if (avail == null || !avail.isAvailable) {",
    "                    unavailable.add(current);",
    "                } else {",
    "                    totalPrice += avail.priceCents;",
    "                    foundNights++;",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "            ",
    "            return new AvailabilityCheck(",
    "                unavailable.isEmpty() && foundNights == expectedNights,",
    "                unavailable, totalPrice);",
    "        }",
    "        ",
    "        public void markBooked(String roomId, LocalDate checkIn, ",
    "                               LocalDate checkOut, String bookingId) {",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                String key = availKey(roomId, current);",
    "                RoomAvailability avail = availability.get(key);",
    "                if (avail != null) {",
    "                    avail.isAvailable = false;",
    "                    avail.bookingId = bookingId;",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "        }",
    "        ",
    "        public void markAvailable(String roomId, LocalDate checkIn, ",
    "                                   LocalDate checkOut) {",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                String key = availKey(roomId, current);",
    "                RoomAvailability avail = availability.get(key);",
    "                if (avail != null) {",
    "                    avail.isAvailable = true;",
    "                    avail.bookingId = null;",
    "                }",
    "                current = current.plusDays(1);",
    "            }",
    "        }",
    "        ",
    "        public void saveBooking(Booking booking) { ",
    "            bookings.put(booking.id, booking); ",
    "        }",
    "        public Booking getBooking(String id) { return bookings.get(id); }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MOCK PAYMENT SERVICE",
    "    // ========================================================================",
    "    ",
    "    public static class PaymentService {",
    "        private final Map<String, Long> authorizations = new ConcurrentHashMap<>();",
    "        ",
    "        public String authorize(String token, long amountCents) {",
    "            if (token.toLowerCase().contains(\"fail\")) {",
    "                throw new RuntimeException(\"Payment failed for token: \" + token);",
    "            }",
    "            String intentId = \"pi_\" + UUID.randomUUID().toString().substring(0, 16);",
    "            authorizations.put(intentId, amountCents);",
    "            return intentId;",
    "        }",
    "        ",
    "        public void cancelAuthorization(String intentId) {",
    "            authorizations.remove(intentId);",
    "        }",
    "        ",
    "        public String refund(String intentId, long amountCents) {",
    "            return \"re_\" + UUID.randomUUID().toString().substring(0, 16);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN BOOKING SERVICE",
    "    // ========================================================================",
    "    ",
    "    public static class BookingService {",
    "        private final InMemoryDatabase db;",
    "        private final PaymentService payment;",
    "        ",
    "        public BookingService(InMemoryDatabase db, PaymentService payment) {",
    "            this.db = db;",
    "            this.payment = payment;",
    "        }",
    "        ",
    "        private List<LocalDate> getDateRange(LocalDate checkIn, LocalDate checkOut) {",
    "            List<LocalDate> dates = new ArrayList<>();",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                dates.add(current);",
    "                current = current.plusDays(1);",
    "            }",
    "            return dates;",
    "        }",
    "        ",
    "        public BookingResponse createBooking(BookingRequest request) {",
    "            // Validate dates",
    "            if (!request.checkIn.isBefore(request.checkOut)) {",
    "                return BookingResponse.failure(\"INVALID_DATES\", ",
    "                    \"Check-in must be before check-out\");",
    "            }",
    "            if (request.checkIn.isBefore(LocalDate.now())) {",
    "                return BookingResponse.failure(\"PAST_DATE\", ",
    "                    \"Cannot book dates in the past\");",
    "            }",
    "            ",
    "            Room room = db.getRoom(request.roomId);",
    "            if (room == null) {",
    "                return BookingResponse.failure(\"ROOM_NOT_FOUND\", ",
    "                    \"Room not found\");",
    "            }",
    "            ",
    "            List<LocalDate> dates = getDateRange(request.checkIn, request.checkOut);",
    "            ",
    "            // Pre-check availability",
    "            var preCheck = db.checkAvailability(",
    "                request.roomId, request.checkIn, request.checkOut);",
    "            if (!preCheck.allAvailable()) {",
    "                return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\",",
    "                    \"Room not available for: \" + preCheck.unavailDates());",
    "            }",
    "            ",
    "            // Authorize payment",
    "            String paymentIntentId;",
    "            try {",
    "                paymentIntentId = payment.authorize(",
    "                    request.paymentToken, preCheck.totalPriceCents());",
    "            } catch (Exception e) {",
    "                return BookingResponse.failure(\"PAYMENT_FAILED\", e.getMessage());",
    "            }",
    "            ",
    "            // CRITICAL: Lock and verify availability",
    "            try {",
    "                db.lockDates(request.roomId, dates);",
    "                try {",
    "                    // Re-check inside lock",
    "                    var check = db.checkAvailability(",
    "                        request.roomId, request.checkIn, request.checkOut);",
    "                    ",
    "                    if (!check.allAvailable()) {",
    "                        payment.cancelAuthorization(paymentIntentId);",
    "                        return BookingResponse.failure(\"ROOM_NOT_AVAILABLE\",",
    "                            \"Room was just booked for: \" + check.unavailDates());",
    "                    }",
    "                    ",
    "                    // Create booking",
    "                    String bookingId = \"BK_\" + UUID.randomUUID()",
    "                        .toString().substring(0, 12).toUpperCase();",
    "                    LocalDateTime now = LocalDateTime.now();",
    "                    ",
    "                    Booking booking = new Booking(",
    "                        bookingId, request.userId, request.roomId, room.hotelId,",
    "                        request.checkIn, request.checkOut, BookingStatus.CONFIRMED,",
    "                        check.totalPriceCents(), paymentIntentId, now);",
    "                    ",
    "                    // Mark dates as booked",
    "                    db.markBooked(request.roomId, request.checkIn, ",
    "                                  request.checkOut, bookingId);",
    "                    db.saveBooking(booking);",
    "                    ",
    "                    return BookingResponse.success(booking);",
    "                } finally {",
    "                    db.unlockDates(request.roomId, dates);",
    "                }",
    "            } catch (Exception e) {",
    "                payment.cancelAuthorization(paymentIntentId);",
    "                throw e;",
    "            }",
    "        }",
    "        ",
    "        public CancelResponse cancelBooking(String bookingId, String userId) {",
    "            Booking booking = db.getBooking(bookingId);",
    "            ",
    "            if (booking == null) {",
    "                return new CancelResponse(false, 0, \"NONE\", ",
    "                    \"Booking not found\");",
    "            }",
    "            if (!booking.userId.equals(userId)) {",
    "                return new CancelResponse(false, 0, \"NONE\", ",
    "                    \"Not authorized\");",
    "            }",
    "            if (booking.status == BookingStatus.CANCELLED) {",
    "                return new CancelResponse(false, 0, \"ALREADY_CANCELLED\", ",
    "                    \"Already cancelled\");",
    "            }",
    "            ",
    "            List<LocalDate> dates = getDateRange(booking.checkIn, booking.checkOut);",
    "            ",
    "            // Calculate refund",
    "            long daysUntil = ChronoUnit.DAYS.between(LocalDate.now(), booking.checkIn);",
    "            long refundAmount;",
    "            if (daysUntil > 1) {",
    "                refundAmount = booking.totalPriceCents;",
    "            } else if (daysUntil == 1) {",
    "                refundAmount = booking.totalPriceCents / 2;",
    "            } else {",
    "                refundAmount = 0;",
    "            }",
    "            ",
    "            // Lock and cancel",
    "            db.lockDates(booking.roomId, dates);",
    "            try {",
    "                booking.status = BookingStatus.CANCELLED;",
    "                booking.cancelledAt = LocalDateTime.now();",
    "                booking.updatedAt = LocalDateTime.now();",
    "                db.saveBooking(booking);",
    "                db.markAvailable(booking.roomId, booking.checkIn, booking.checkOut);",
    "            } finally {",
    "                db.unlockDates(booking.roomId, dates);",
    "            }",
    "            ",
    "            // Process refund",
    "            String refundStatus = \"PROCESSED\";",
    "            if (refundAmount > 0 && booking.paymentIntentId != null) {",
    "                try {",
    "                    payment.refund(booking.paymentIntentId, refundAmount);",
    "                } catch (Exception e) {",
    "                    refundStatus = \"PENDING\";",
    "                }",
    "            }",
    "            ",
    "            return new CancelResponse(true, refundAmount, refundStatus, null);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN DEMONSTRATION",
    "    // ========================================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"HOTEL BOOKING SYSTEM DEMONSTRATION (Java)\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        // Setup",
    "        InMemoryDatabase db = new InMemoryDatabase();",
    "        PaymentService paymentService = new PaymentService();",
    "        BookingService service = new BookingService(db, paymentService);",
    "        ",
    "        // Create test data",
    "        Hotel hotel = new Hotel(",
    "            \"HOTEL_NYC_001\", \"Grand Hotel New York\",",
    "            new Location(\"New York\", \"USA\", 40.7128, -74.0060),",
    "            4.5, List.of(\"WiFi\", \"Pool\", \"Gym\"));",
    "        db.addHotel(hotel);",
    "        ",
    "        Room room = new Room(",
    "            \"ROOM_NYC_101\", \"HOTEL_NYC_001\", \"101\",",
    "            \"Deluxe King\", 2, 25000,",
    "            List.of(\"King Bed\", \"City View\"));",
    "        db.addRoom(room);",
    "        ",
    "        LocalDate today = LocalDate.now();",
    "        db.initializeAvailability(room.id, today, today.plusDays(30), 25000);",
    "        ",
    "        System.out.println(\"\\n\ud83d\udccc Scenario: Create booking\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        BookingRequest request = new BookingRequest();",
    "        request.userId = \"USER_ALICE\";",
    "        request.roomId = \"ROOM_NYC_101\";",
    "        request.checkIn = today.plusDays(7);",
    "        request.checkOut = today.plusDays(10);",
    "        request.paymentToken = \"tok_visa_4242\";",
    "        ",
    "        BookingResponse response = service.createBooking(request);",
    "        System.out.println(\"Success: \" + response.success);",
    "        if (response.success) {",
    "            System.out.printf(\"  Booking ID: %s%n\", response.booking.id);",
    "            System.out.printf(\"  Total: $%.2f%n\", ",
    "                response.booking.totalPriceCents / 100.0);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\ud83d\udccc Scenario: Concurrent booking (should fail)\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        BookingRequest requestB = new BookingRequest();",
    "        requestB.userId = \"USER_BOB\";",
    "        requestB.roomId = \"ROOM_NYC_101\";",
    "        requestB.checkIn = today.plusDays(8);",
    "        requestB.checkOut = today.plusDays(12);",
    "        requestB.paymentToken = \"tok_visa_5555\";",
    "        ",
    "        BookingResponse responseB = service.createBooking(requestB);",
    "        System.out.println(\"Success: \" + responseB.success);",
    "        if (!responseB.success) {",
    "            System.out.println(\"  Error: \" + responseB.errorCode);",
    "            System.out.println(\"  Message: \" + responseB.errorMessage);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\ud83d\udccc Scenario: Cancel and rebook\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        if (response.success) {",
    "            CancelResponse cancel = service.cancelBooking(",
    "                response.booking.id, \"USER_ALICE\");",
    "            System.out.printf(\"Cancelled: %s, Refund: $%.2f%n\",",
    "                cancel.success, cancel.refundAmountCents / 100.0);",
    "            ",
    "            // Now Bob can book",
    "            BookingResponse responseB2 = service.createBooking(requestB);",
    "            System.out.println(\"Bob's rebooking success: \" + responseB2.success);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"DEMONSTRATION COMPLETE\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "section": "Imports & Module Docstring",
      "explanation": "We import dataclasses for clean domain models, datetime for date handling, Decimal for precise currency calculations, and threading for simulating database locking. The docstring explains the system's purpose."
    },
    {
      "lines": "25-35",
      "section": "BookingStatus Enum",
      "explanation": "Defines the booking lifecycle: PENDING (payment authorized), CONFIRMED (ready), CANCELLED (user cancelled), COMPLETED (guest checked out), NO_SHOW. These states enable proper state machine transitions."
    },
    {
      "lines": "50-95",
      "section": "Domain Models (Hotel, Room, Booking)",
      "explanation": "Core entities using dataclasses. Note: **prices stored in cents** (integers) to avoid floating-point precision issues. The `base_price` property converts to Decimal for display. Room has `capacity` for guest filtering."
    },
    {
      "lines": "100-125",
      "section": "RoomAvailability Model",
      "explanation": "**KEY DESIGN**: One row per (room_id, date). This denormalized structure enables: 1) Fast availability queries, 2) UNIQUE constraint for double-booking prevention, 3) Per-day pricing flexibility."
    },
    {
      "lines": "190-280",
      "section": "InMemoryDatabase Transaction/Locking",
      "explanation": "The `transaction` context manager simulates PostgreSQL's SELECT FOR UPDATE. It acquires locks on all date rows in sorted order (preventing deadlocks), then releases in reverse order. This is where race conditions are prevented."
    },
    {
      "lines": "380-500",
      "section": "create_booking Method - The Critical Path",
      "explanation": "The 6-step booking flow:\n1. Validate dates\n2. Pre-check availability (optimization)\n3. Authorize payment\n4. **Lock inventory rows**\n5. Re-verify availability INSIDE lock\n6. Create booking atomically\n\nStep 5 is crucial: we must re-check after locking because someone may have booked between our pre-check and lock acquisition."
    },
    {
      "lines": "440-465",
      "section": "Critical Section - Double-Booking Prevention",
      "explanation": "```python\nwith self._db.transaction(request.room_id, dates):\n    # Re-check availability INSIDE the lock\n    is_avail, unavail_dates, _ = self._db.check_all_available(...)\n    if not is_avail:\n        # Room was booked by someone else!\n        self._payment.cancel_authorization(payment_intent_id)\n        return ...\n```\n\nThis is the **core algorithm**: lock first, then check. Other transactions will block at the lock and see our updated data when they proceed."
    },
    {
      "lines": "520-580",
      "section": "cancel_booking Method",
      "explanation": "Cancellation flow:\n1. Verify user owns booking\n2. Calculate refund based on cancellation policy (days until check-in)\n3. Lock the date rows\n4. Update booking status to CANCELLED\n5. Release inventory (mark_available)\n6. Process refund asynchronously\n\nLocking prevents race condition where someone tries to book while we're cancelling."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test date validation first (past dates, invalid ranges)\n2. Test single booking flow without payment\n3. Add payment mock, test auth + cancel flow\n4. Test availability check logic\n5. Test concurrent booking (two threads)\n6. Test cancel \u2192 rebook flow",
    "what_to_print_or_assert": [
      "print(f'Dates to book: {dates}') - Verify date range calculation",
      "print(f'Lock acquired for {room_id}, {dates}') - Confirm locking",
      "assert len(availability) == expected_nights - Verify all dates exist",
      "print(f'Available: {is_avail}, Unavailable: {unavail_dates}') - Debug availability"
    ],
    "common_failure_modes": [
      "**Off-by-one in date range**: Check-out date should NOT be included in booked dates",
      "**Lock ordering**: If not sorted, two concurrent requests can deadlock",
      "**Payment not cancelled on failure**: Must cancel auth if booking fails after payment",
      "**Race condition**: If checking availability outside lock, two threads can both see 'available'"
    ],
    "how_to_fix_fast": "1. **If double-booking occurs**: Add print statements around lock acquisition. Ensure re-check happens INSIDE lock.\n2. **If deadlock**: Verify dates are sorted before locking.\n3. **If payment issues**: Wrap entire booking in try/finally that cancels payment on any exception."
  },
  "complexity_analysis": {
    "time": {
      "searchRooms": {
        "complexity": "O(H \u00d7 R \u00d7 D)",
        "explanation": "H=hotels, R=rooms per hotel, D=days in range. In production, Elasticsearch makes this O(log N) with indices."
      },
      "getRoomDetails": {
        "complexity": "O(D)",
        "explanation": "D = days in booking range. One availability lookup per day."
      },
      "createBooking": {
        "complexity": "O(D)",
        "explanation": "Lock D rows, check D rows, update D rows. All within single transaction."
      },
      "cancelBooking": {
        "complexity": "O(D)",
        "explanation": "Lock D rows, update D rows to available."
      },
      "overall": "Booking operations are O(D) where D is typically 1-14 nights. Very efficient."
    },
    "space": {
      "complexity": "O(H + R + R\u00d7365 + B) where B = bookings",
      "breakdown": "- Hotels table: O(H) = 500K\n- Rooms table: O(R) = 10M\n- Availability: O(R \u00d7 365) = 3.65B rows (partitioned by month)\n- Bookings: O(B) = grows over time, archived after checkout",
      "note": "Availability table is largest but partitionable. Old partitions can be dropped."
    },
    "can_we_do_better": "The availability model trades space for time. Alternative: compute availability from bookings table (saves space, but O(B) per query). Our approach is optimal for read-heavy workload."
  },
  "dry_run": {
    "example": "Concurrent booking: User A and B both try to book ROOM_101 for Jun 15-17",
    "trace_table": "| Time | User A | User B | DB Locks | availability(101, Jun15-16) |\n|------|--------|--------|----------|------------------------------|\n| T1 | Pre-check: Available \u2713 | - | None | [\u2713, \u2713] |\n| T2 | Authorize payment: pi_A | Pre-check: Available \u2713 | None | [\u2713, \u2713] |\n| T3 | **LOCK(101, Jun15-16)** | Authorize payment: pi_B | **A holds lock** | [\u2713, \u2713] |\n| T4 | Re-check: Available \u2713 | **BLOCKED** (waiting) | A holds lock | [\u2713, \u2713] |\n| T5 | Create BK_001 | (waiting...) | A holds lock | [\u2717 BK_001, \u2717 BK_001] |\n| T6 | **COMMIT & RELEASE LOCK** | (waiting...) | **Released** | [\u2717 BK_001, \u2717 BK_001] |\n| T7 | Return SUCCESS | **LOCK ACQUIRED** | **B holds lock** | [\u2717 BK_001, \u2717 BK_001] |\n| T8 | - | Re-check: **NOT Available!** | B holds lock | [\u2717 BK_001, \u2717 BK_001] |\n| T9 | - | Cancel pi_B, ROLLBACK | Released | [\u2717 BK_001, \u2717 BK_001] |\n| T10 | - | Return **ROOM_NOT_AVAILABLE** | None | [\u2717 BK_001, \u2717 BK_001] |",
    "final_answer": "User A: SUCCESS (booking BK_001). User B: ROOM_NOT_AVAILABLE. No double-booking!"
  },
  "test_cases": [
    {
      "name": "Basic booking flow",
      "category": "Happy Path",
      "input": "Book ROOM_101 for Jun 15-17, 2 nights, $250/night",
      "expected": "SUCCESS, booking_id generated, total $500",
      "explanation": "Simple case: room available, payment succeeds, booking created."
    },
    {
      "name": "Concurrent booking - same dates",
      "category": "Concurrency",
      "input": "User A and B both book ROOM_101 for Jun 15-17 simultaneously",
      "expected": "First to acquire lock succeeds, second gets ROOM_NOT_AVAILABLE",
      "explanation": "Race condition test. Only one can win."
    },
    {
      "name": "Overlapping dates conflict",
      "category": "Concurrency",
      "input": "Existing: Jun 15-17. New request: Jun 16-19",
      "expected": "ROOM_NOT_AVAILABLE (Jun 16 conflicts)",
      "explanation": "Partial overlap must be detected."
    },
    {
      "name": "Same-day turnover allowed",
      "category": "Edge Case",
      "input": "Existing: Jun 15-17 (checkout Jun 17). New: Jun 17-19 (checkin Jun 17)",
      "expected": "SUCCESS - checkout date is not blocked",
      "explanation": "Jun 17 checkout at 11AM, checkin at 3PM - this should work!"
    },
    {
      "name": "Payment failure before lock",
      "category": "Error Handling",
      "input": "Book with payment_token='tok_fail_card'",
      "expected": "PAYMENT_FAILED, no inventory locked",
      "explanation": "Payment auth fails first, we never touch inventory."
    },
    {
      "name": "Cancel and rebook",
      "category": "Workflow",
      "input": "Book Jun 15-17, cancel, new user books Jun 15-17",
      "expected": "Cancel SUCCESS with refund, new booking SUCCESS",
      "explanation": "Cancellation must free inventory immediately."
    },
    {
      "name": "Unauthorized cancellation",
      "category": "Security",
      "input": "User B tries to cancel User A's booking",
      "expected": "UNAUTHORIZED error",
      "explanation": "Users can only cancel their own bookings."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking availability outside of lock",
      "why_wrong": "Race condition: Thread A checks available, Thread B checks available, both proceed to book",
      "correct_approach": "Lock first, THEN check availability inside the lock",
      "code_wrong": "if db.is_available(room, dates):  # No lock!\n    db.create_booking(room, dates)  # Race condition!",
      "code_correct": "with db.transaction(room, dates):  # Lock acquired\n    if db.is_available(room, dates):  # Check INSIDE lock\n        db.create_booking(room, dates)"
    },
    {
      "mistake": "Not handling check-out date boundary correctly",
      "why_wrong": "If you include check-out date in blocked dates, same-day turnover fails",
      "correct_approach": "Block dates from check_in to check_out - 1 (exclusive end)",
      "code_wrong": "for d in range(check_in, check_out + 1):  # WRONG: includes checkout",
      "code_correct": "while current < check_out:  # CORRECT: excludes checkout date"
    },
    {
      "mistake": "Charging payment before confirming availability",
      "why_wrong": "User gets charged, then finds out room is unavailable - terrible UX, refund hassle",
      "correct_approach": "Authorize (hold) first, capture only at check-in or after confirmation",
      "code_wrong": "payment.charge(amount)  # Charge immediately\nif not available:\n    payment.refund()  # Awkward",
      "code_correct": "intent_id = payment.authorize(amount)  # Just hold\nif available:\n    # Later: payment.capture(intent_id)\nelse:\n    payment.cancel_authorization(intent_id)  # Clean release"
    },
    {
      "mistake": "Not sorting dates before locking",
      "why_wrong": "Thread A locks Jun 15 then Jun 16. Thread B locks Jun 16 then Jun 15. DEADLOCK!",
      "correct_approach": "Always acquire locks in consistent order (sorted dates)",
      "code_wrong": "for date in dates:  # Random order\n    lock(date)",
      "code_correct": "for date in sorted(dates):  # Consistent order prevents deadlock\n    lock(date)"
    },
    {
      "mistake": "Using floats for currency",
      "why_wrong": "0.1 + 0.1 + 0.1 = 0.30000000000000004. Prices will be wrong.",
      "correct_approach": "Store prices in cents (integers), use Decimal for display",
      "code_wrong": "price = 199.99  # float\ntotal = price * nights  # precision errors",
      "code_correct": "price_cents = 19999  # integer cents\ntotal_cents = price_cents * nights  # exact math"
    }
  ],
  "interview_tips": {
    "opening": "Thank you! This is a classic booking system design problem. Before I dive in, I'd like to clarify a few requirements to make sure I'm solving the right problem...",
    "clarifying_questions_to_ask": [
      "What's the acceptable consistency model? I assume strong consistency for bookings (no double-booking ever), but can search results be slightly stale?",
      "What's the payment model - charge immediately or authorize now, capture at check-in?",
      "Should I support overbooking like airlines do? (Usually no for hotels)",
      "What's the typical booking window? Can users book 1 year in advance?",
      "Do we need to support booking room types ('any King room') or specific rooms?"
    ],
    "what_to_mention_proactively": [
      "The critical challenge here is **preventing double-bookings**, which requires database-level guarantees, not just application logic",
      "I'll separate the read path (search) from write path (booking) for scalability - this is CQRS pattern",
      "For currency, I'll use integer cents to avoid floating-point precision issues",
      "I'll use pessimistic locking with SELECT FOR UPDATE as the primary defense, plus a unique constraint as a backstop"
    ],
    "communication_during_coding": [
      "I'm starting with the domain models - Hotel, Room, Booking...",
      "Now the critical part - the booking transaction with locking...",
      "I'm re-checking availability INSIDE the lock - this is crucial for race condition prevention",
      "Let me trace through a concurrent booking scenario to verify this works..."
    ],
    "if_stuck": [
      "Take a step back: What's the core invariant? 'No double-booking'. How do I guarantee that?",
      "Think: What if two requests hit at the exact same millisecond? Application checks won't help.",
      "Database constraints are the answer - either locking or unique constraint or both.",
      "Draw the race condition timeline - it helps clarify the problem."
    ],
    "time_management": "0-8min: Clarify requirements, discuss high-level approach | 8-15min: Draw architecture diagram | 15-25min: Data model & API design | 25-40min: Deep dive on booking/concurrency | 40-45min: Discuss scaling, follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Distributed Locking / Pessimistic Concurrency Control",
    "indicators": [
      "Finite inventory that can't be oversold",
      "'Two users can't book the same thing'",
      "Race condition explicitly mentioned",
      "Financial transactions involved"
    ],
    "similar_problems": [
      "**LC 253 - Meeting Rooms II**: Same interval overlap detection logic",
      "**LC 731 - My Calendar II**: Double-booking detection",
      "**Flight/Concert Ticket Booking**: Same pattern - finite seats, prevent overselling",
      "**Flash Sale System**: Limited inventory, high concurrency"
    ],
    "template": "1. Identify the resource to lock (room+date)\n2. Choose locking strategy (pessimistic vs optimistic)\n3. Lock \u2192 Verify \u2192 Mutate \u2192 Commit\n4. Handle lock timeout/failure gracefully\n5. Add database constraint as ultimate backstop"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 will focus on **concurrent booking handling at scale**. You'll need to discuss: distributed locks (Redis/ZooKeeper), optimistic locking with retry, database sharding by hotel_id/region, and handling hot spots (popular hotels).",
    "part_3_hint": "Part 3 is about **scaling for high traffic**. Key topics: Elasticsearch for search, CDN for static content, message queues for async processing, read replicas, caching strategies, and handling 10x traffic during holidays.",
    "data_structure_evolution": "Part 1: Single DB with locking \u2192 Part 2: Add Redis distributed locks \u2192 Part 3: Sharded DB + Elasticsearch + Message Queue"
  },
  "generated_at": "2026-01-17T03:20:16.575508",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}