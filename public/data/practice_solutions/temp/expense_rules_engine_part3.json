{
  "problem_title": "Corporate Expense Rules Engine - Part 3: Rule Creation API",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 transforms our rules engine from a system with hardcoded rules into a **dynamic, configuration-driven architecture**. Instead of instantiating rules directly in code, managers can now create rules at runtime via JSON configs. This requires implementing Factory Pattern (to create rules from config), Registry Pattern (to lookup rule classes by name), and Composite Pattern (to combine rules with AND/OR logic). The key shift is from compile-time rule creation to runtime rule creation with full type safety and validation.",
    "new_requirements": [
      "Dynamic rule creation from JSON/dictionary configuration",
      "Rule type registry that maps string names to rule classes",
      "Composite rules supporting AND/OR logical combinations",
      "Config validation before rule instantiation",
      "Recursive composition support (CompositeRule containing CompositeRules)",
      "Factory method in each rule class for self-instantiation from config"
    ],
    "new_constraints": [
      "Unknown rule types should throw meaningful errors",
      "Invalid configs should be caught early with clear messages",
      "Registry should be extensible without modifying factory code",
      "Composite rules must handle nested compositions arbitrarily deep"
    ],
    "key_insight": "The **Factory + Registry** combination creates an **Open-Closed** system: open for extension (new rule types) but closed for modification (factory code never changes). The Registry decouples the Factory from specific rule classes, while the Composite Pattern enables arbitrary complexity through simple recursion. Each rule class knows how to construct itself from config via a class method, making the system fully extensible."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    BEFORE (Part 2) vs AFTER (Part 3)                 \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551  BEFORE: Hardcoded Rule Creation                                     \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                    \u2551\n\u2551                                                                      \u2551\n\u2551     # In application code                                            \u2551\n\u2551     ban_rule = BanRule('expense_type', 'gambling')    \u25c4\u2500\u2500 Hardcoded  \u2551\n\u2551     limit_rule = MaxAmountRule(Decimal('100'))        \u25c4\u2500\u2500 At compile \u2551\n\u2551     engine.add_rule(ban_rule)                              time      \u2551\n\u2551                                                                      \u2551\n\u2551     Problem: Adding new rules requires code changes!                 \u2551\n\u2551                                                                      \u2551\n\u2551  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \u2551\n\u2551                                                                      \u2551\n\u2551  AFTER: Config-Driven Rule Creation                                  \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                  \u2551\n\u2551                                                                      \u2551\n\u2551     POST /api/rules                                                  \u2551\n\u2551     {\"type\": \"BanRule\",                               \u25c4\u2500\u2500 Dynamic   \u2551\n\u2551      \"config\": {\"field\": \"expense_type\",                  JSON      \u2551\n\u2551                 \"value\": \"gambling\"}}                     config    \u2551\n\u2551                            \u2502                                         \u2551\n\u2551                            \u25bc                                         \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2551\n\u2551     \u2502              RuleFactory                \u2502                      \u2551\n\u2551     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502                      \u2551\n\u2551     \u2502  \u2502         RuleRegistry              \u2502  \u2502                      \u2551\n\u2551     \u2502  \u2502  \"BanRule\" \u2500\u2500\u2500\u2500\u25ba BanRule.class    \u2502  \u2502                      \u2551\n\u2551     \u2502  \u2502  \"MaxAmount\" \u2500\u2500\u25ba MaxAmountRule    \u2502  \u2502                      \u2551\n\u2551     \u2502  \u2502  \"TripTotal\" \u2500\u2500\u25ba TripTotalRule    \u2502  \u2502                      \u2551\n\u2551     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502                      \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2551\n\u2551                          \u2502                                           \u2551\n\u2551                          \u25bc                                           \u2551\n\u2551              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \u2551\n\u2551              \u2502   Rule Instance       \u2502                               \u2551\n\u2551              \u2502   (fully configured)  \u2502                               \u2551\n\u2551              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2551\n\u2551                                                                      \u2551\n\u2551     Benefit: New rules = register + config, NO code changes!         \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    RULE CREATION ALGORITHM FLOW                      \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551  Step 1: JSON Config Received                                        \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                     \u2551\n\u2551                                                                      \u2551\n\u2551     {\"type\": \"CompositeRule\",                                        \u2551\n\u2551      \"operator\": \"AND\",                                              \u2551\n\u2551      \"rules\": [                                                      \u2551\n\u2551        {\"type\": \"VendorTypeLimitRule\",                               \u2551\n\u2551         \"config\": {\"vendor_type\": \"restaurant\", \"max_amount\": 50}},  \u2551\n\u2551        {\"type\": \"MaxAmountRule\",                                     \u2551\n\u2551         \"config\": {\"max_amount\": 100}}                               \u2551\n\u2551      ]}                                                              \u2551\n\u2551                                                                      \u2551\n\u2551  Step 2: Factory.createRule() Called                                 \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                 \u2551\n\u2551                                                                      \u2551\n\u2551     factory.create_rule(config)                                      \u2551\n\u2551              \u2502                                                       \u2551\n\u2551              \u25bc                                                       \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2551\n\u2551     \u2502 Is type == \"CompositeRule\"?         \u2502                          \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2551\n\u2551                    \u2502 YES                                             \u2551\n\u2551                    \u25bc                                                 \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2551\n\u2551     \u2502 Recursively create child rules      \u2502                          \u2551\n\u2551     \u2502 for each item in config['rules']    \u2502                          \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2551\n\u2551                    \u2502                                                 \u2551\n\u2551  Step 3: Registry Lookup (for each child)                            \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                            \u2551\n\u2551                    \u2502                                                 \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2551\n\u2551     \u2502 registry.lookup(\"VendorTypeLimitRule\")                         \u2551\n\u2551     \u2502         \u2502                           \u2502                          \u2551\n\u2551     \u2502         \u25bc                           \u2502                          \u2551\n\u2551     \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502                          \u2551\n\u2551     \u2502 \u2502 Registry Map    \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2502 Key      \u2502Value \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500 \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2502 BanRule  \u2502cls   \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2502 MaxAmt   \u2502cls   \u2502\u25c4\u2500\u2500 O(1) lookup  \u2502                          \u2551\n\u2551     \u2502 \u2502 VendorLmt\u2502cls \u25c4\u2500\u253c\u2500\u2500 Returns class \u2502                          \u2551\n\u2551     \u2502 \u2502 TripTotal\u2502cls   \u2502                 \u2502                          \u2551\n\u2551     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502                          \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2551\n\u2551                    \u2502                                                 \u2551\n\u2551  Step 4: Call from_config() on Rule Class                            \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                            \u2551\n\u2551                    \u2502                                                 \u2551\n\u2551                    \u25bc                                                 \u2551\n\u2551     VendorTypeLimitRule.from_config({                                \u2551\n\u2551         \"vendor_type\": \"restaurant\",                                 \u2551\n\u2551         \"max_amount\": 50                                             \u2551\n\u2551     })                                                               \u2551\n\u2551              \u2502                                                       \u2551\n\u2551              \u25bc                                                       \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                          \u2551\n\u2551     \u2502 VendorTypeLimitRule(                \u2502                          \u2551\n\u2551     \u2502   vendor_type=\"restaurant\",         \u2502                          \u2551\n\u2551     \u2502   max_amount=Decimal('50')          \u2502                          \u2551\n\u2551     \u2502 )                                   \u2502                          \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2551\n\u2551                                                                      \u2551\n\u2551  Step 5: Assemble CompositeRule                                      \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                                      \u2551\n\u2551                                                                      \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2551\n\u2551     \u2502            CompositeRule (AND)                  \u2502              \u2551\n\u2551     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502              \u2551\n\u2551     \u2502  \u2502VendorTypeLimitRule\u2502  \u2502  MaxAmountRule   \u2502    \u2502              \u2551\n\u2551     \u2502  \u2502vendor=\"restaurant\"\u2502  \u2502  max=$100        \u2502    \u2502              \u2551\n\u2551     \u2502  \u2502max=$50            \u2502  \u2502                  \u2502    \u2502              \u2551\n\u2551     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502              \u2551\n\u2551     \u2502           \u2502                      \u2502              \u2502              \u2551\n\u2551     \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 AND \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502              \u2551\n\u2551     \u2502                      \u2502                          \u2502              \u2551\n\u2551     \u2502        BOTH must pass for expense to pass       \u2502              \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    COMPOSITE RULE EVALUATION                         \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551  AND Logic: Expense FAILS if ANY sub-rule is violated                \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                  \u2551\n\u2551                                                                      \u2551\n\u2551     Expense: $75 at restaurant                                       \u2551\n\u2551                                                                      \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2551\n\u2551     \u2502VendorTypeLimitRule\u2502      \u2502  MaxAmountRule   \u2502                   \u2551\n\u2551     \u2502max=$50           \u2502      \u2502  max=$100        \u2502                   \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2551\n\u2551              \u2502                         \u2502                             \u2551\n\u2551              \u25bc                         \u25bc                             \u2551\n\u2551         \u274c FAIL                    \u2705 PASS                           \u2551\n\u2551         ($75 > $50)                ($75 < $100)                      \u2551\n\u2551              \u2502                         \u2502                             \u2551\n\u2551              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2551\n\u2551                          \u2502                                           \u2551\n\u2551                          \u25bc                                           \u2551\n\u2551                   OVERALL: \u274c FAIL                                   \u2551\n\u2551              (AND requires ALL to pass)                              \u2551\n\u2551                                                                      \u2551\n\u2551  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550    \u2551\n\u2551                                                                      \u2551\n\u2551  OR Logic: Expense FAILS only if ALL sub-rules are violated          \u2551\n\u2551  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500           \u2551\n\u2551                                                                      \u2551\n\u2551     Expense: expense_type=\"gambling\"                                 \u2551\n\u2551                                                                      \u2551\n\u2551     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2551\n\u2551     \u2502    BanRule       \u2502      \u2502    BanRule       \u2502                   \u2551\n\u2551     \u2502  type=gambling   \u2502      \u2502 type=entertainment\u2502                   \u2551\n\u2551     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2551\n\u2551              \u2502                         \u2502                             \u2551\n\u2551              \u25bc                         \u25bc                             \u2551\n\u2551         \u274c VIOLATED                \u2705 PASS                           \u2551\n\u2551        (matches!)              (doesn't match)                       \u2551\n\u2551              \u2502                         \u2502                             \u2551\n\u2551              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2551\n\u2551                          \u2502                                           \u2551\n\u2551                          \u25bc                                           \u2551\n\u2551                   OVERALL: \u274c FAIL                                   \u2551\n\u2551        (OR means expense fails if EITHER matches)                    \u2551\n\u2551                                                                      \u2551\n\u2551        Note: For OR, we want to flag if expense matches              \u2551\n\u2551        ANY banned category - so violation if any sub-rule fails      \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Giant Switch Statement",
      "description": "Extend Part 2 by adding a giant if/else or switch statement in the factory that checks the type string and creates the appropriate rule. Each new rule type requires adding another branch to the switch.",
      "time_complexity": "O(n) for n rule types in worst case",
      "space_complexity": "O(1) no extra storage",
      "why_not_optimal": "Violates Open-Closed Principle: adding new rule types requires modifying the factory code. Creates tight coupling between factory and all rule classes. Makes testing difficult. Doesn't scale as rule types grow. No clean way to allow external modules to register custom rules."
    },
    {
      "name": "Optimal Approach - Factory + Registry + Composite",
      "description": "Use Registry Pattern to decouple factory from rule classes. Each rule class implements a from_config class method for self-instantiation. Factory delegates to registry for lookup and to rule class for creation. Composite Pattern enables AND/OR combinations through recursive structure. Registration can happen at startup or dynamically.",
      "time_complexity": "O(1) lookup + O(k) for composite with k rules",
      "space_complexity": "O(n) for n registered rule types",
      "key_insight": "The Registry creates a **level of indirection** that breaks the dependency between the Factory and specific Rule classes. Combined with each Rule knowing how to construct itself, the system becomes fully extensible without any code changes to core classes."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Factory + Registry + Composite Patterns\n\n### Core Design Principles\n\n**1. Registry Pattern** - Maps string type names to rule classes\n- Allows O(1) lookup by name\n- Extensible without modifying factory\n- Supports runtime registration of new rule types\n\n**2. Factory Pattern** - Creates rule instances from configuration\n- Delegates class lookup to Registry\n- Delegates instantiation to the Rule class itself\n- Handles special case of CompositeRule recursively\n\n**3. Composite Pattern** - Enables rule composition\n- CompositeRule contains a list of child Rules\n- Supports AND (all must pass) and OR (any fail triggers) semantics\n- Recursive: composites can contain composites\n\n### Key Implementation Details\n\n**Self-Instantiating Rules**: Each rule class has a `from_config` class method that knows how to parse its specific configuration and create an instance. This follows the **Single Responsibility Principle** - each rule is responsible for understanding its own config format.\n\n**Recursive Factory**: The factory handles CompositeRule specially by recursively calling itself for each child rule. This enables arbitrarily deep nesting.\n\n**Validation**: Config validation happens in two places:\n1. Factory validates required keys exist (type, config)\n2. Rule's from_config validates rule-specific requirements\n\n**Context-Aware Evaluation**: Rules receive a context dictionary during evaluation, enabling stateful rules like TripTotalRule that need aggregated data.",
    "data_structures": [
      {
        "structure": "HashMap (Registry)",
        "purpose": "O(1) lookup of rule classes by string type name"
      },
      {
        "structure": "List<Rule> (Composite)",
        "purpose": "Store child rules for AND/OR evaluation"
      },
      {
        "structure": "Dict (Context)",
        "purpose": "Pass aggregated state like trip totals to rules"
      },
      {
        "structure": "Enum (CompositeOperator)",
        "purpose": "Type-safe AND/OR specification"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize Registry - Register all built-in rule types with their string names",
      "Step 2: Create Factory - Factory receives reference to Registry",
      "Step 3: Parse Config - Extract 'type' field from incoming JSON config",
      "Step 4: Check Composite - If type is CompositeRule, handle recursively",
      "Step 5: Registry Lookup - For non-composite, lookup rule class by type name",
      "Step 6: Validate & Error - If not found, throw descriptive error",
      "Step 7: Delegate Creation - Call rule_class.from_config(config['config'])",
      "Step 8: Return Instance - Fully configured rule ready for evaluation"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Corporate Expense Rules Engine - Part 3: Rule Creation API",
    "",
    "This module implements a dynamic rule creation system using:",
    "- Factory Pattern: Creates rules from JSON/dict configuration",
    "- Registry Pattern: Maps type names to rule classes",
    "- Composite Pattern: Enables AND/OR rule combinations",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from decimal import Decimal, InvalidOperation",
    "from typing import Dict, List, Any, Optional, Type, Set",
    "from enum import Enum",
    "from collections import defaultdict",
    "import json",
    "",
    "",
    "# =============================================================================",
    "# DATA MODELS",
    "# =============================================================================",
    "",
    "@dataclass(frozen=True)",
    "class Expense:",
    "    \"\"\"Represents a corporate expense transaction.\"\"\"",
    "    expense_id: str",
    "    trip_id: str",
    "    amount_usd: Decimal",
    "    expense_type: str",
    "    vendor_type: str",
    "    vendor_name: str",
    "    ",
    "    @classmethod",
    "    def from_dict(cls, data: Dict[str, Any]) -> 'Expense':",
    "        \"\"\"Create Expense from dictionary (e.g., JSON).\"\"\"",
    "        return cls(",
    "            expense_id=data['expense_id'],",
    "            trip_id=data['trip_id'],",
    "            amount_usd=Decimal(str(data['amount_usd'])),",
    "            expense_type=data['expense_type'],",
    "            vendor_type=data['vendor_type'],",
    "            vendor_name=data['vendor_name']",
    "        )",
    "",
    "",
    "@dataclass(frozen=True)",
    "class Violation:",
    "    \"\"\"Represents a rule violation for an expense.\"\"\"",
    "    rule_name: str",
    "    expense_id: str",
    "    message: str",
    "    trip_id: Optional[str] = None",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        \"\"\"Convert to dictionary for JSON serialization.\"\"\"",
    "        result = {",
    "            'rule_name': self.rule_name,",
    "            'expense_id': self.expense_id,",
    "            'message': self.message",
    "        }",
    "        if self.trip_id:",
    "            result['trip_id'] = self.trip_id",
    "        return result",
    "",
    "",
    "class CompositeOperator(Enum):",
    "    \"\"\"Logical operators for combining rules.\"\"\"",
    "    AND = 'AND'  # Expense fails if ANY sub-rule is violated",
    "    OR = 'OR'    # Used for 'any of these conditions' matching",
    "",
    "",
    "# =============================================================================",
    "# ABSTRACT BASE RULE",
    "# =============================================================================",
    "",
    "class Rule(ABC):",
    "    \"\"\"",
    "    Abstract base class for all expense validation rules.",
    "    ",
    "    Each rule must implement:",
    "    - evaluate(): Check an expense and return violations",
    "    - get_name(): Return a descriptive name for error messages",
    "    - from_config(): Class method to create instance from config dict",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate an expense against this rule.",
    "        ",
    "        Args:",
    "            expense: The expense to evaluate",
    "            context: Shared context (e.g., trip totals for aggregation rules)",
    "            ",
    "        Returns:",
    "            List of violations (empty if expense passes)",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Return descriptive name for this rule instance.\"\"\"",
    "        pass",
    "    ",
    "    @classmethod",
    "    @abstractmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'Rule':",
    "        \"\"\"",
    "        Factory method to create rule instance from configuration.",
    "        ",
    "        Args:",
    "            config: Dictionary containing rule-specific parameters",
    "            ",
    "        Returns:",
    "            Configured rule instance",
    "            ",
    "        Raises:",
    "            ValueError: If config is invalid or missing required fields",
    "        \"\"\"",
    "        pass",
    "",
    "",
    "# =============================================================================",
    "# CONCRETE RULE IMPLEMENTATIONS",
    "# =============================================================================",
    "",
    "class BanRule(Rule):",
    "    \"\"\"",
    "    Bans expenses where a specific field matches a banned value.",
    "    ",
    "    Example: Ban all expenses where expense_type='gambling'",
    "    \"\"\"",
    "    ",
    "    VALID_FIELDS = {'expense_type', 'vendor_type', 'vendor_name'}",
    "    ",
    "    def __init__(self, field_name: str, banned_value: str):",
    "        if field_name not in self.VALID_FIELDS:",
    "            raise ValueError(f\"Invalid field '{field_name}'. Valid: {self.VALID_FIELDS}\")",
    "        self.field_name = field_name",
    "        self.banned_value = banned_value",
    "    ",
    "    def get_name(self) -> str:",
    "        return f\"BanRule({self.field_name}='{self.banned_value}')\"",
    "    ",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        actual_value = getattr(expense, self.field_name, None)",
    "        if actual_value == self.banned_value:",
    "            return [Violation(",
    "                rule_name=self.get_name(),",
    "                expense_id=expense.expense_id,",
    "                message=f\"Banned {self.field_name}: '{self.banned_value}'\"",
    "            )]",
    "        return []",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'BanRule':",
    "        if 'field' not in config:",
    "            raise ValueError(\"BanRule config missing 'field'\")",
    "        if 'value' not in config:",
    "            raise ValueError(\"BanRule config missing 'value'\")",
    "        return cls(field_name=config['field'], banned_value=config['value'])",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"",
    "    Enforces a maximum amount for any single expense.",
    "    ",
    "    Example: No single expense can exceed $100",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_amount: Decimal):",
    "        if max_amount <= 0:",
    "            raise ValueError(f\"max_amount must be positive, got {max_amount}\")",
    "        self.max_amount = max_amount",
    "    ",
    "    def get_name(self) -> str:",
    "        return f\"MaxAmountRule(max=${self.max_amount})\"",
    "    ",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        if expense.amount_usd > self.max_amount:",
    "            return [Violation(",
    "                rule_name=self.get_name(),",
    "                expense_id=expense.expense_id,",
    "                message=f\"Amount ${expense.amount_usd} exceeds maximum ${self.max_amount}\"",
    "            )]",
    "        return []",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'MaxAmountRule':",
    "        if 'max_amount' not in config:",
    "            raise ValueError(\"MaxAmountRule config missing 'max_amount'\")",
    "        try:",
    "            max_amount = Decimal(str(config['max_amount']))",
    "        except InvalidOperation:",
    "            raise ValueError(f\"Invalid max_amount: {config['max_amount']}\")",
    "        return cls(max_amount=max_amount)",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"",
    "    Enforces spending limits for specific vendor types.",
    "    ",
    "    Example: Restaurant expenses limited to $50 per transaction",
    "    \"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: Decimal):",
    "        if max_amount <= 0:",
    "            raise ValueError(f\"max_amount must be positive, got {max_amount}\")",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = max_amount",
    "    ",
    "    def get_name(self) -> str:",
    "        return f\"VendorTypeLimitRule({self.vendor_type}, max=${self.max_amount})\"",
    "    ",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        if expense.vendor_type == self.vendor_type:",
    "            if expense.amount_usd > self.max_amount:",
    "                return [Violation(",
    "                    rule_name=self.get_name(),",
    "                    expense_id=expense.expense_id,",
    "                    message=f\"${expense.amount_usd} at {self.vendor_type} exceeds limit ${self.max_amount}\"",
    "                )]",
    "        return []",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'VendorTypeLimitRule':",
    "        if 'vendor_type' not in config:",
    "            raise ValueError(\"VendorTypeLimitRule config missing 'vendor_type'\")",
    "        if 'max_amount' not in config:",
    "            raise ValueError(\"VendorTypeLimitRule config missing 'max_amount'\")",
    "        try:",
    "            max_amount = Decimal(str(config['max_amount']))",
    "        except InvalidOperation:",
    "            raise ValueError(f\"Invalid max_amount: {config['max_amount']}\")",
    "        return cls(vendor_type=config['vendor_type'], max_amount=max_amount)",
    "",
    "",
    "class TripTotalRule(Rule):",
    "    \"\"\"",
    "    Enforces maximum total spending per business trip.",
    "    Requires context with pre-computed trip totals.",
    "    ",
    "    Example: Total trip expenses cannot exceed $500",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_trip_total: Decimal):",
    "        if max_trip_total <= 0:",
    "            raise ValueError(f\"max_trip_total must be positive, got {max_trip_total}\")",
    "        self.max_trip_total = max_trip_total",
    "    ",
    "    def get_name(self) -> str:",
    "        return f\"TripTotalRule(max=${self.max_trip_total})\"",
    "    ",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        trip_totals = context.get('trip_totals', {})",
    "        trip_total = trip_totals.get(expense.trip_id, Decimal('0'))",
    "        ",
    "        if trip_total > self.max_trip_total:",
    "            return [Violation(",
    "                rule_name=self.get_name(),",
    "                expense_id=expense.expense_id,",
    "                trip_id=expense.trip_id,",
    "                message=f\"Trip {expense.trip_id} total ${trip_total} exceeds limit ${self.max_trip_total}\"",
    "            )]",
    "        return []",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'TripTotalRule':",
    "        if 'max_trip_total' not in config:",
    "            raise ValueError(\"TripTotalRule config missing 'max_trip_total'\")",
    "        try:",
    "            max_trip_total = Decimal(str(config['max_trip_total']))",
    "        except InvalidOperation:",
    "            raise ValueError(f\"Invalid max_trip_total: {config['max_trip_total']}\")",
    "        return cls(max_trip_total=max_trip_total)",
    "",
    "",
    "# =============================================================================",
    "# COMPOSITE RULE (AND/OR COMBINATIONS)",
    "# =============================================================================",
    "",
    "class CompositeRule(Rule):",
    "    \"\"\"",
    "    Combines multiple rules with AND/OR logic.",
    "    ",
    "    AND: Expense fails if ANY sub-rule is violated (all must pass)",
    "    OR:  Used for 'any match' patterns - expense flagged if any sub-rule triggers",
    "    ",
    "    Supports recursive composition: CompositeRule can contain CompositeRules.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, operator: CompositeOperator, rules: List[Rule]):",
    "        if not rules:",
    "            raise ValueError(\"CompositeRule requires at least one sub-rule\")",
    "        self.operator = operator",
    "        self.rules = rules",
    "    ",
    "    def get_name(self) -> str:",
    "        rule_names = [r.get_name() for r in self.rules]",
    "        return f\"CompositeRule({self.operator.value}: [{', '.join(rule_names)}])\"",
    "    ",
    "    def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "        all_violations: List[Violation] = []",
    "        rules_with_violations = 0",
    "        ",
    "        for rule in self.rules:",
    "            violations = rule.evaluate(expense, context)",
    "            if violations:",
    "                rules_with_violations += 1",
    "                all_violations.extend(violations)",
    "        ",
    "        if self.operator == CompositeOperator.AND:",
    "            # AND: Return violations if ANY rule was violated",
    "            # (expense must pass ALL rules)",
    "            return all_violations",
    "        else:  # OR",
    "            # OR: Return violations if ANY rule was violated",
    "            # (expense fails if it matches any banned pattern)",
    "            return all_violations if rules_with_violations > 0 else []",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'CompositeRule':",
    "        \"\"\"Note: This is called by factory with special handling for recursion.\"\"\"",
    "        raise NotImplementedError(\"Use RuleFactory for CompositeRule creation\")",
    "",
    "",
    "# =============================================================================",
    "# RULE REGISTRY",
    "# =============================================================================",
    "",
    "class RuleRegistry:",
    "    \"\"\"",
    "    Registry mapping rule type names to rule classes.",
    "    ",
    "    Implements Singleton pattern for global access.",
    "    Allows extensibility: new rule types can be registered at runtime.",
    "    \"\"\"",
    "    ",
    "    _instance: Optional['RuleRegistry'] = None",
    "    ",
    "    def __init__(self):",
    "        self._registry: Dict[str, Type[Rule]] = {}",
    "    ",
    "    @classmethod",
    "    def get_instance(cls) -> 'RuleRegistry':",
    "        \"\"\"Get singleton instance of RuleRegistry.\"\"\"",
    "        if cls._instance is None:",
    "            cls._instance = RuleRegistry()",
    "            cls._instance._register_builtin_rules()",
    "        return cls._instance",
    "    ",
    "    @classmethod",
    "    def reset(cls) -> None:",
    "        \"\"\"Reset singleton (useful for testing).\"\"\"",
    "        cls._instance = None",
    "    ",
    "    def _register_builtin_rules(self) -> None:",
    "        \"\"\"Register all built-in rule types.\"\"\"",
    "        self.register('BanRule', BanRule)",
    "        self.register('MaxAmountRule', MaxAmountRule)",
    "        self.register('VendorTypeLimitRule', VendorTypeLimitRule)",
    "        self.register('TripTotalRule', TripTotalRule)",
    "    ",
    "    def register(self, type_name: str, rule_class: Type[Rule]) -> None:",
    "        \"\"\"",
    "        Register a rule type.",
    "        ",
    "        Args:",
    "            type_name: String name used in JSON configs",
    "            rule_class: The Rule class to instantiate",
    "            ",
    "        Raises:",
    "            ValueError: If type_name is already registered",
    "        \"\"\"",
    "        if type_name in self._registry:",
    "            raise ValueError(f\"Rule type '{type_name}' is already registered\")",
    "        self._registry[type_name] = rule_class",
    "    ",
    "    def lookup(self, type_name: str) -> Optional[Type[Rule]]:",
    "        \"\"\"Look up a rule class by type name. Returns None if not found.\"\"\"",
    "        return self._registry.get(type_name)",
    "    ",
    "    def get_registered_types(self) -> List[str]:",
    "        \"\"\"Get list of all registered rule type names.\"\"\"",
    "        return list(self._registry.keys())",
    "    ",
    "    def is_registered(self, type_name: str) -> bool:",
    "        \"\"\"Check if a rule type is registered.\"\"\"",
    "        return type_name in self._registry",
    "",
    "",
    "# =============================================================================",
    "# RULE FACTORY",
    "# =============================================================================",
    "",
    "class RuleFactory:",
    "    \"\"\"",
    "    Factory for creating Rule instances from configuration dictionaries.",
    "    ",
    "    Uses Registry for type lookup and delegates instantiation to",
    "    each Rule's from_config() class method.",
    "    ",
    "    Handles CompositeRule specially for recursive creation.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, registry: Optional[RuleRegistry] = None):",
    "        \"\"\"",
    "        Initialize factory with a registry.",
    "        ",
    "        Args:",
    "            registry: RuleRegistry to use (defaults to singleton)",
    "        \"\"\"",
    "        self.registry = registry or RuleRegistry.get_instance()",
    "    ",
    "    def create_rule(self, config: Dict[str, Any]) -> Rule:",
    "        \"\"\"",
    "        Create a Rule instance from configuration.",
    "        ",
    "        Args:",
    "            config: Dictionary with 'type' and optional 'config' keys",
    "                   For CompositeRule: also 'operator' and 'rules'",
    "                   ",
    "        Returns:",
    "            Configured Rule instance",
    "            ",
    "        Raises:",
    "            ValueError: If config is invalid or rule type unknown",
    "        \"\"\"",
    "        self._validate_config(config)",
    "        ",
    "        rule_type = config['type']",
    "        ",
    "        # Handle CompositeRule specially for recursive creation",
    "        if rule_type == 'CompositeRule':",
    "            return self._create_composite_rule(config)",
    "        ",
    "        # Look up rule class in registry",
    "        rule_class = self.registry.lookup(rule_type)",
    "        if rule_class is None:",
    "            registered = self.registry.get_registered_types()",
    "            raise ValueError(",
    "                f\"Unknown rule type: '{rule_type}'. \"",
    "                f\"Registered types: {registered}\"",
    "            )",
    "        ",
    "        # Delegate to rule's from_config method",
    "        rule_config = config.get('config', {})",
    "        return rule_class.from_config(rule_config)",
    "    ",
    "    def _validate_config(self, config: Dict[str, Any]) -> None:",
    "        \"\"\"Validate basic config structure.\"\"\"",
    "        if not isinstance(config, dict):",
    "            raise ValueError(f\"Config must be a dictionary, got {type(config).__name__}\")",
    "        if 'type' not in config:",
    "            raise ValueError(\"Config missing required 'type' field\")",
    "    ",
    "    def _create_composite_rule(self, config: Dict[str, Any]) -> CompositeRule:",
    "        \"\"\"Create CompositeRule with recursive child rule creation.\"\"\"",
    "        if 'operator' not in config:",
    "            raise ValueError(\"CompositeRule config missing 'operator'\")",
    "        if 'rules' not in config:",
    "            raise ValueError(\"CompositeRule config missing 'rules'\")",
    "        ",
    "        # Parse operator",
    "        try:",
    "            operator = CompositeOperator(config['operator'])",
    "        except ValueError:",
    "            valid_ops = [op.value for op in CompositeOperator]",
    "            raise ValueError(",
    "                f\"Invalid operator '{config['operator']}'. Valid: {valid_ops}\"",
    "            )",
    "        ",
    "        # Recursively create child rules",
    "        rules_config = config['rules']",
    "        if not isinstance(rules_config, list):",
    "            raise ValueError(\"CompositeRule 'rules' must be a list\")",
    "        if not rules_config:",
    "            raise ValueError(\"CompositeRule requires at least one rule\")",
    "        ",
    "        child_rules = [self.create_rule(rc) for rc in rules_config]",
    "        return CompositeRule(operator=operator, rules=child_rules)",
    "    ",
    "    def create_rules_from_json(self, json_str: str) -> List[Rule]:",
    "        \"\"\"Create rules from JSON string (array of configs).\"\"\"",
    "        try:",
    "            configs = json.loads(json_str)",
    "        except json.JSONDecodeError as e:",
    "            raise ValueError(f\"Invalid JSON: {e}\")",
    "        ",
    "        if isinstance(configs, dict):",
    "            return [self.create_rule(configs)]",
    "        elif isinstance(configs, list):",
    "            return [self.create_rule(c) for c in configs]",
    "        else:",
    "            raise ValueError(\"JSON must be object or array of rule configs\")",
    "",
    "",
    "# =============================================================================",
    "# RULES ENGINE",
    "# =============================================================================",
    "",
    "class RulesEngine:",
    "    \"\"\"",
    "    Main engine for evaluating expenses against rules.",
    "    ",
    "    Manages rule collection, builds evaluation context,",
    "    and handles deduplication of trip-level violations.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.rules: List[Rule] = []",
    "        self._factory = RuleFactory()",
    "    ",
    "    def add_rule(self, rule: Rule) -> None:",
    "        \"\"\"Add a rule to the engine.\"\"\"",
    "        self.rules.append(rule)",
    "    ",
    "    def add_rule_from_config(self, config: Dict[str, Any]) -> Rule:",
    "        \"\"\"Create and add a rule from configuration.\"\"\"",
    "        rule = self._factory.create_rule(config)",
    "        self.add_rule(rule)",
    "        return rule",
    "    ",
    "    def clear_rules(self) -> None:",
    "        \"\"\"Remove all rules.\"\"\"",
    "        self.rules.clear()",
    "    ",
    "    def evaluate(self, expenses: List[Expense]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate all expenses against all rules.",
    "        ",
    "        Args:",
    "            expenses: List of expenses to evaluate",
    "            ",
    "        Returns:",
    "            List of all violations found",
    "        \"\"\"",
    "        context = self._build_context(expenses)",
    "        violations: List[Violation] = []",
    "        seen_trip_violations: Set[tuple] = set()",
    "        ",
    "        for expense in expenses:",
    "            for rule in self.rules:",
    "                rule_violations = rule.evaluate(expense, context)",
    "                ",
    "                for v in rule_violations:",
    "                    # Deduplicate trip-level violations",
    "                    if v.trip_id:",
    "                        key = (v.rule_name, v.trip_id)",
    "                        if key in seen_trip_violations:",
    "                            continue",
    "                        seen_trip_violations.add(key)",
    "                    violations.append(v)",
    "        ",
    "        return violations",
    "    ",
    "    def _build_context(self, expenses: List[Expense]) -> Dict[str, Any]:",
    "        \"\"\"Build evaluation context with aggregated data.\"\"\"",
    "        trip_totals: Dict[str, Decimal] = defaultdict(Decimal)",
    "        ",
    "        for expense in expenses:",
    "            trip_totals[expense.trip_id] += expense.amount_usd",
    "        ",
    "        return {'trip_totals': dict(trip_totals)}",
    "",
    "",
    "# =============================================================================",
    "# API LAYER (Simulated REST API)",
    "# =============================================================================",
    "",
    "class RulesAPI:",
    "    \"\"\"",
    "    Simulated REST API for rule management.",
    "    ",
    "    In production, this would be a Flask/FastAPI endpoint.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, engine: RulesEngine):",
    "        self.engine = engine",
    "    ",
    "    def post_rule(self, json_body: str) -> Dict[str, Any]:",
    "        \"\"\"",
    "        POST /api/rules - Create a new rule",
    "        ",
    "        Args:",
    "            json_body: JSON string with rule configuration",
    "            ",
    "        Returns:",
    "            Response dict with status and rule name",
    "        \"\"\"",
    "        try:",
    "            config = json.loads(json_body)",
    "            rule = self.engine.add_rule_from_config(config)",
    "            return {",
    "                'status': 'success',",
    "                'rule_name': rule.get_name(),",
    "                'message': 'Rule created successfully'",
    "            }",
    "        except (json.JSONDecodeError, ValueError) as e:",
    "            return {",
    "                'status': 'error',",
    "                'message': str(e)",
    "            }",
    "    ",
    "    def post_evaluate(self, json_body: str) -> Dict[str, Any]:",
    "        \"\"\"",
    "        POST /api/evaluate - Evaluate expenses",
    "        ",
    "        Args:",
    "            json_body: JSON string with list of expenses",
    "            ",
    "        Returns:",
    "            Response dict with violations",
    "        \"\"\"",
    "        try:",
    "            data = json.loads(json_body)",
    "            expenses = [Expense.from_dict(e) for e in data['expenses']]",
    "            violations = self.engine.evaluate(expenses)",
    "            return {",
    "                'status': 'success',",
    "                'violations': [v.to_dict() for v in violations],",
    "                'total_violations': len(violations)",
    "            }",
    "        except (json.JSONDecodeError, KeyError, ValueError) as e:",
    "            return {",
    "                'status': 'error',",
    "                'message': str(e)",
    "            }",
    "",
    "",
    "# =============================================================================",
    "# DEMONSTRATION",
    "# =============================================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate the Rule Creation API with various examples.\"\"\"",
    "    ",
    "    print(\"=\" * 70)",
    "    print(\"CORPORATE EXPENSE RULES ENGINE - Part 3: Rule Creation API\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Initialize engine and API",
    "    engine = RulesEngine()",
    "    api = RulesAPI(engine)",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 1: Create Simple BanRule via API\")",
    "    print(\"-\" * 70)",
    "    ",
    "    ban_rule_json = json.dumps({",
    "        'type': 'BanRule',",
    "        'config': {",
    "            'field': 'expense_type',",
    "            'value': 'gambling'",
    "        }",
    "    })",
    "    ",
    "    print(f\"Request: {ban_rule_json}\")",
    "    response = api.post_rule(ban_rule_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 2: Create VendorTypeLimitRule via API\")",
    "    print(\"-\" * 70)",
    "    ",
    "    vendor_rule_json = json.dumps({",
    "        'type': 'VendorTypeLimitRule',",
    "        'config': {",
    "            'vendor_type': 'restaurant',",
    "            'max_amount': 50",
    "        }",
    "    })",
    "    ",
    "    print(f\"Request: {vendor_rule_json}\")",
    "    response = api.post_rule(vendor_rule_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 3: Create Composite AND Rule\")",
    "    print(\"-\" * 70)",
    "    ",
    "    composite_and_json = json.dumps({",
    "        'type': 'CompositeRule',",
    "        'operator': 'AND',",
    "        'rules': [",
    "            {",
    "                'type': 'VendorTypeLimitRule',",
    "                'config': {'vendor_type': 'hotel', 'max_amount': 200}",
    "            },",
    "            {",
    "                'type': 'MaxAmountRule',",
    "                'config': {'max_amount': 500}",
    "            }",
    "        ]",
    "    })",
    "    ",
    "    print(f\"Request: {composite_and_json}\")",
    "    response = api.post_rule(composite_and_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 4: Create Composite OR Rule (Ban gambling OR adult entertainment)\")",
    "    print(\"-\" * 70)",
    "    ",
    "    composite_or_json = json.dumps({",
    "        'type': 'CompositeRule',",
    "        'operator': 'OR',",
    "        'rules': [",
    "            {",
    "                'type': 'BanRule',",
    "                'config': {'field': 'vendor_type', 'value': 'casino'}",
    "            },",
    "            {",
    "                'type': 'BanRule',",
    "                'config': {'field': 'vendor_type', 'value': 'adult_entertainment'}",
    "            }",
    "        ]",
    "    })",
    "    ",
    "    print(f\"Request: {composite_or_json}\")",
    "    response = api.post_rule(composite_or_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 5: Add TripTotalRule\")",
    "    print(\"-\" * 70)",
    "    ",
    "    trip_rule_json = json.dumps({",
    "        'type': 'TripTotalRule',",
    "        'config': {'max_trip_total': 500}",
    "    })",
    "    ",
    "    print(f\"Request: {trip_rule_json}\")",
    "    response = api.post_rule(trip_rule_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 6: Evaluate Expenses Against All Rules\")",
    "    print(\"-\" * 70)",
    "    ",
    "    expenses_json = json.dumps({",
    "        'expenses': [",
    "            {",
    "                'expense_id': 'E001',",
    "                'trip_id': 'T001',",
    "                'amount_usd': '45.00',",
    "                'expense_type': 'meals',",
    "                'vendor_type': 'restaurant',",
    "                'vendor_name': 'Olive Garden'",
    "            },",
    "            {",
    "                'expense_id': 'E002',",
    "                'trip_id': 'T001',",
    "                'amount_usd': '75.00',",
    "                'expense_type': 'meals',",
    "                'vendor_type': 'restaurant',",
    "                'vendor_name': 'Fancy Steakhouse'",
    "            },",
    "            {",
    "                'expense_id': 'E003',",
    "                'trip_id': 'T001',",
    "                'amount_usd': '250.00',",
    "                'expense_type': 'lodging',",
    "                'vendor_type': 'hotel',",
    "                'vendor_name': 'Marriott'",
    "            },",
    "            {",
    "                'expense_id': 'E004',",
    "                'trip_id': 'T001',",
    "                'amount_usd': '200.00',",
    "                'expense_type': 'gambling',",
    "                'vendor_type': 'casino',",
    "                'vendor_name': 'Lucky Casino'",
    "            },",
    "            {",
    "                'expense_id': 'E005',",
    "                'trip_id': 'T002',",
    "                'amount_usd': '35.00',",
    "                'expense_type': 'meals',",
    "                'vendor_type': 'restaurant',",
    "                'vendor_name': 'McDonalds'",
    "            }",
    "        ]",
    "    })",
    "    ",
    "    print(\"Expenses submitted for evaluation...\")",
    "    response = api.post_evaluate(expenses_json)",
    "    print(f\"\\nEvaluation Response:\")",
    "    print(json.dumps(response, indent=2))",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 7: Error Handling - Unknown Rule Type\")",
    "    print(\"-\" * 70)",
    "    ",
    "    invalid_type_json = json.dumps({",
    "        'type': 'NonExistentRule',",
    "        'config': {}",
    "    })",
    "    ",
    "    print(f\"Request: {invalid_type_json}\")",
    "    response = api.post_rule(invalid_type_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 8: Error Handling - Missing Config\")",
    "    print(\"-\" * 70)",
    "    ",
    "    missing_config_json = json.dumps({",
    "        'type': 'BanRule',",
    "        'config': {'field': 'expense_type'}  # Missing 'value'",
    "    })",
    "    ",
    "    print(f\"Request: {missing_config_json}\")",
    "    response = api.post_rule(missing_config_json)",
    "    print(f\"Response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 70)",
    "    print(\"DEMO 9: Register Custom Rule Type at Runtime\")",
    "    print(\"-\" * 70)",
    "    ",
    "    # Define a custom rule",
    "    class WeekendOnlyRule(Rule):",
    "        \"\"\"Only allow expenses on weekends (demo custom rule).\"\"\"",
    "        ",
    "        def __init__(self, allowed: bool):",
    "            self.allowed = allowed",
    "        ",
    "        def get_name(self) -> str:",
    "            return f\"WeekendOnlyRule(allowed={self.allowed})\"",
    "        ",
    "        def evaluate(self, expense: Expense, context: Dict[str, Any]) -> List[Violation]:",
    "            # Demo: just return empty (real impl would check date)",
    "            return []",
    "        ",
    "        @classmethod",
    "        def from_config(cls, config: Dict[str, Any]) -> 'WeekendOnlyRule':",
    "            return cls(allowed=config.get('allowed', True))",
    "    ",
    "    # Register it",
    "    registry = RuleRegistry.get_instance()",
    "    try:",
    "        registry.register('WeekendOnlyRule', WeekendOnlyRule)",
    "        print(\"Registered custom 'WeekendOnlyRule'\")",
    "        print(f\"All registered types: {registry.get_registered_types()}\")",
    "    except ValueError as e:",
    "        print(f\"Already registered: {e}\")",
    "    ",
    "    # Now create it via API",
    "    custom_rule_json = json.dumps({",
    "        'type': 'WeekendOnlyRule',",
    "        'config': {'allowed': True}",
    "    })",
    "    ",
    "    response = api.post_rule(custom_rule_json)",
    "    print(f\"Create custom rule response: {json.dumps(response, indent=2)}\")",
    "    ",
    "    # -------------------------------------------------------------------------",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"SUMMARY: All demonstrations completed successfully!\")",
    "    print(\"=\" * 70)",
    "    print(f\"\\nTotal rules in engine: {len(engine.rules)}\")",
    "    for i, rule in enumerate(engine.rules, 1):",
    "        print(f\"  {i}. {rule.get_name()}\")",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.function.Function;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Corporate Expense Rules Engine - Part 3: Rule Creation API",
    " * ",
    " * Implements Factory + Registry + Composite patterns for dynamic rule creation.",
    " */",
    "public class ExpenseRulesEngine {",
    "",
    "    // =========================================================================",
    "    // DATA MODELS",
    "    // =========================================================================",
    "    ",
    "    public static class Expense {",
    "        private final String expenseId;",
    "        private final String tripId;",
    "        private final BigDecimal amountUsd;",
    "        private final String expenseType;",
    "        private final String vendorType;",
    "        private final String vendorName;",
    "        ",
    "        public Expense(String expenseId, String tripId, BigDecimal amountUsd,",
    "                      String expenseType, String vendorType, String vendorName) {",
    "            this.expenseId = expenseId;",
    "            this.tripId = tripId;",
    "            this.amountUsd = amountUsd;",
    "            this.expenseType = expenseType;",
    "            this.vendorType = vendorType;",
    "            this.vendorName = vendorName;",
    "        }",
    "        ",
    "        public String getExpenseId() { return expenseId; }",
    "        public String getTripId() { return tripId; }",
    "        public BigDecimal getAmountUsd() { return amountUsd; }",
    "        public String getExpenseType() { return expenseType; }",
    "        public String getVendorType() { return vendorType; }",
    "        public String getVendorName() { return vendorName; }",
    "        ",
    "        public String getField(String fieldName) {",
    "            switch (fieldName) {",
    "                case \"expense_type\": return expenseType;",
    "                case \"vendor_type\": return vendorType;",
    "                case \"vendor_name\": return vendorName;",
    "                default: return null;",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public static class Violation {",
    "        private final String ruleName;",
    "        private final String expenseId;",
    "        private final String message;",
    "        private final String tripId;",
    "        ",
    "        public Violation(String ruleName, String expenseId, String message) {",
    "            this(ruleName, expenseId, message, null);",
    "        }",
    "        ",
    "        public Violation(String ruleName, String expenseId, String message, String tripId) {",
    "            this.ruleName = ruleName;",
    "            this.expenseId = expenseId;",
    "            this.message = message;",
    "            this.tripId = tripId;",
    "        }",
    "        ",
    "        public String getRuleName() { return ruleName; }",
    "        public String getExpenseId() { return expenseId; }",
    "        public String getMessage() { return message; }",
    "        public String getTripId() { return tripId; }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Violation{rule='%s', expense='%s', message='%s'}\",",
    "                ruleName, expenseId, message);",
    "        }",
    "    }",
    "    ",
    "    public enum CompositeOperator {",
    "        AND, OR",
    "    }",
    "",
    "    // =========================================================================",
    "    // ABSTRACT RULE INTERFACE",
    "    // =========================================================================",
    "    ",
    "    public interface Rule {",
    "        List<Violation> evaluate(Expense expense, Map<String, Object> context);",
    "        String getName();",
    "    }",
    "    ",
    "    @FunctionalInterface",
    "    public interface RuleCreator {",
    "        Rule create(Map<String, Object> config);",
    "    }",
    "",
    "    // =========================================================================",
    "    // CONCRETE RULE IMPLEMENTATIONS",
    "    // =========================================================================",
    "    ",
    "    public static class BanRule implements Rule {",
    "        private static final Set<String> VALID_FIELDS = ",
    "            Set.of(\"expense_type\", \"vendor_type\", \"vendor_name\");",
    "        ",
    "        private final String fieldName;",
    "        private final String bannedValue;",
    "        ",
    "        public BanRule(String fieldName, String bannedValue) {",
    "            if (!VALID_FIELDS.contains(fieldName)) {",
    "                throw new IllegalArgumentException(",
    "                    \"Invalid field: \" + fieldName + \". Valid: \" + VALID_FIELDS);",
    "            }",
    "            this.fieldName = fieldName;",
    "            this.bannedValue = bannedValue;",
    "        }",
    "        ",
    "        @Override",
    "        public String getName() {",
    "            return String.format(\"BanRule(%s='%s')\", fieldName, bannedValue);",
    "        }",
    "        ",
    "        @Override",
    "        public List<Violation> evaluate(Expense expense, Map<String, Object> context) {",
    "            String actualValue = expense.getField(fieldName);",
    "            if (bannedValue.equals(actualValue)) {",
    "                return List.of(new Violation(",
    "                    getName(), expense.getExpenseId(),",
    "                    String.format(\"Banned %s: '%s'\", fieldName, bannedValue)));",
    "            }",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        public static BanRule fromConfig(Map<String, Object> config) {",
    "            String field = (String) config.get(\"field\");",
    "            String value = (String) config.get(\"value\");",
    "            if (field == null) throw new IllegalArgumentException(\"BanRule missing 'field'\");",
    "            if (value == null) throw new IllegalArgumentException(\"BanRule missing 'value'\");",
    "            return new BanRule(field, value);",
    "        }",
    "    }",
    "    ",
    "    public static class MaxAmountRule implements Rule {",
    "        private final BigDecimal maxAmount;",
    "        ",
    "        public MaxAmountRule(BigDecimal maxAmount) {",
    "            if (maxAmount.compareTo(BigDecimal.ZERO) <= 0) {",
    "                throw new IllegalArgumentException(\"maxAmount must be positive\");",
    "            }",
    "            this.maxAmount = maxAmount;",
    "        }",
    "        ",
    "        @Override",
    "        public String getName() {",
    "            return String.format(\"MaxAmountRule(max=$%s)\", maxAmount);",
    "        }",
    "        ",
    "        @Override",
    "        public List<Violation> evaluate(Expense expense, Map<String, Object> context) {",
    "            if (expense.getAmountUsd().compareTo(maxAmount) > 0) {",
    "                return List.of(new Violation(",
    "                    getName(), expense.getExpenseId(),",
    "                    String.format(\"Amount $%s exceeds max $%s\", ",
    "                        expense.getAmountUsd(), maxAmount)));",
    "            }",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        public static MaxAmountRule fromConfig(Map<String, Object> config) {",
    "            Object maxAmountObj = config.get(\"max_amount\");",
    "            if (maxAmountObj == null) {",
    "                throw new IllegalArgumentException(\"MaxAmountRule missing 'max_amount'\");",
    "            }",
    "            BigDecimal maxAmount = new BigDecimal(maxAmountObj.toString());",
    "            return new MaxAmountRule(maxAmount);",
    "        }",
    "    }",
    "    ",
    "    public static class VendorTypeLimitRule implements Rule {",
    "        private final String vendorType;",
    "        private final BigDecimal maxAmount;",
    "        ",
    "        public VendorTypeLimitRule(String vendorType, BigDecimal maxAmount) {",
    "            if (maxAmount.compareTo(BigDecimal.ZERO) <= 0) {",
    "                throw new IllegalArgumentException(\"maxAmount must be positive\");",
    "            }",
    "            this.vendorType = vendorType;",
    "            this.maxAmount = maxAmount;",
    "        }",
    "        ",
    "        @Override",
    "        public String getName() {",
    "            return String.format(\"VendorTypeLimitRule(%s, max=$%s)\", vendorType, maxAmount);",
    "        }",
    "        ",
    "        @Override",
    "        public List<Violation> evaluate(Expense expense, Map<String, Object> context) {",
    "            if (vendorType.equals(expense.getVendorType()) &&",
    "                expense.getAmountUsd().compareTo(maxAmount) > 0) {",
    "                return List.of(new Violation(",
    "                    getName(), expense.getExpenseId(),",
    "                    String.format(\"$%s at %s exceeds limit $%s\",",
    "                        expense.getAmountUsd(), vendorType, maxAmount)));",
    "            }",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        public static VendorTypeLimitRule fromConfig(Map<String, Object> config) {",
    "            String vendorType = (String) config.get(\"vendor_type\");",
    "            Object maxAmountObj = config.get(\"max_amount\");",
    "            if (vendorType == null) {",
    "                throw new IllegalArgumentException(\"VendorTypeLimitRule missing 'vendor_type'\");",
    "            }",
    "            if (maxAmountObj == null) {",
    "                throw new IllegalArgumentException(\"VendorTypeLimitRule missing 'max_amount'\");",
    "            }",
    "            return new VendorTypeLimitRule(vendorType, new BigDecimal(maxAmountObj.toString()));",
    "        }",
    "    }",
    "    ",
    "    public static class TripTotalRule implements Rule {",
    "        private final BigDecimal maxTripTotal;",
    "        ",
    "        public TripTotalRule(BigDecimal maxTripTotal) {",
    "            if (maxTripTotal.compareTo(BigDecimal.ZERO) <= 0) {",
    "                throw new IllegalArgumentException(\"maxTripTotal must be positive\");",
    "            }",
    "            this.maxTripTotal = maxTripTotal;",
    "        }",
    "        ",
    "        @Override",
    "        public String getName() {",
    "            return String.format(\"TripTotalRule(max=$%s)\", maxTripTotal);",
    "        }",
    "        ",
    "        @Override",
    "        @SuppressWarnings(\"unchecked\")",
    "        public List<Violation> evaluate(Expense expense, Map<String, Object> context) {",
    "            Map<String, BigDecimal> tripTotals = ",
    "                (Map<String, BigDecimal>) context.getOrDefault(\"tripTotals\", Map.of());",
    "            BigDecimal tripTotal = tripTotals.getOrDefault(expense.getTripId(), BigDecimal.ZERO);",
    "            ",
    "            if (tripTotal.compareTo(maxTripTotal) > 0) {",
    "                return List.of(new Violation(",
    "                    getName(), expense.getExpenseId(),",
    "                    String.format(\"Trip %s total $%s exceeds limit $%s\",",
    "                        expense.getTripId(), tripTotal, maxTripTotal),",
    "                    expense.getTripId()));",
    "            }",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        public static TripTotalRule fromConfig(Map<String, Object> config) {",
    "            Object maxTotalObj = config.get(\"max_trip_total\");",
    "            if (maxTotalObj == null) {",
    "                throw new IllegalArgumentException(\"TripTotalRule missing 'max_trip_total'\");",
    "            }",
    "            return new TripTotalRule(new BigDecimal(maxTotalObj.toString()));",
    "        }",
    "    }",
    "",
    "    // =========================================================================",
    "    // COMPOSITE RULE",
    "    // =========================================================================",
    "    ",
    "    public static class CompositeRule implements Rule {",
    "        private final CompositeOperator operator;",
    "        private final List<Rule> rules;",
    "        ",
    "        public CompositeRule(CompositeOperator operator, List<Rule> rules) {",
    "            if (rules == null || rules.isEmpty()) {",
    "                throw new IllegalArgumentException(\"CompositeRule requires at least one rule\");",
    "            }",
    "            this.operator = operator;",
    "            this.rules = new ArrayList<>(rules);",
    "        }",
    "        ",
    "        @Override",
    "        public String getName() {",
    "            String ruleNames = rules.stream()",
    "                .map(Rule::getName)",
    "                .collect(Collectors.joining(\", \"));",
    "            return String.format(\"CompositeRule(%s: [%s])\", operator, ruleNames);",
    "        }",
    "        ",
    "        @Override",
    "        public List<Violation> evaluate(Expense expense, Map<String, Object> context) {",
    "            List<Violation> allViolations = new ArrayList<>();",
    "            int rulesWithViolations = 0;",
    "            ",
    "            for (Rule rule : rules) {",
    "                List<Violation> violations = rule.evaluate(expense, context);",
    "                if (!violations.isEmpty()) {",
    "                    rulesWithViolations++;",
    "                    allViolations.addAll(violations);",
    "                }",
    "            }",
    "            ",
    "            if (operator == CompositeOperator.AND) {",
    "                // AND: Return violations if ANY rule was violated",
    "                return allViolations;",
    "            } else {",
    "                // OR: Return violations if ANY rule was violated",
    "                return rulesWithViolations > 0 ? allViolations : Collections.emptyList();",
    "            }",
    "        }",
    "    }",
    "",
    "    // =========================================================================",
    "    // RULE REGISTRY (Singleton)",
    "    // =========================================================================",
    "    ",
    "    public static class RuleRegistry {",
    "        private static RuleRegistry instance;",
    "        private final Map<String, RuleCreator> registry = new HashMap<>();",
    "        ",
    "        private RuleRegistry() {",
    "            registerBuiltinRules();",
    "        }",
    "        ",
    "        public static synchronized RuleRegistry getInstance() {",
    "            if (instance == null) {",
    "                instance = new RuleRegistry();",
    "            }",
    "            return instance;",
    "        }",
    "        ",
    "        public static synchronized void reset() {",
    "            instance = null;",
    "        }",
    "        ",
    "        private void registerBuiltinRules() {",
    "            register(\"BanRule\", BanRule::fromConfig);",
    "            register(\"MaxAmountRule\", MaxAmountRule::fromConfig);",
    "            register(\"VendorTypeLimitRule\", VendorTypeLimitRule::fromConfig);",
    "            register(\"TripTotalRule\", TripTotalRule::fromConfig);",
    "        }",
    "        ",
    "        public void register(String typeName, RuleCreator creator) {",
    "            if (registry.containsKey(typeName)) {",
    "                throw new IllegalArgumentException(\"Rule type already registered: \" + typeName);",
    "            }",
    "            registry.put(typeName, creator);",
    "        }",
    "        ",
    "        public RuleCreator lookup(String typeName) {",
    "            return registry.get(typeName);",
    "        }",
    "        ",
    "        public Set<String> getRegisteredTypes() {",
    "            return Collections.unmodifiableSet(registry.keySet());",
    "        }",
    "    }",
    "",
    "    // =========================================================================",
    "    // RULE FACTORY",
    "    // =========================================================================",
    "    ",
    "    public static class RuleFactory {",
    "        private final RuleRegistry registry;",
    "        ",
    "        public RuleFactory() {",
    "            this(RuleRegistry.getInstance());",
    "        }",
    "        ",
    "        public RuleFactory(RuleRegistry registry) {",
    "            this.registry = registry;",
    "        }",
    "        ",
    "        @SuppressWarnings(\"unchecked\")",
    "        public Rule createRule(Map<String, Object> config) {",
    "            String type = (String) config.get(\"type\");",
    "            if (type == null) {",
    "                throw new IllegalArgumentException(\"Config missing 'type' field\");",
    "            }",
    "            ",
    "            if (\"CompositeRule\".equals(type)) {",
    "                return createCompositeRule(config);",
    "            }",
    "            ",
    "            RuleCreator creator = registry.lookup(type);",
    "            if (creator == null) {",
    "                throw new IllegalArgumentException(",
    "                    \"Unknown rule type: '\" + type + \"'. Registered: \" + ",
    "                    registry.getRegisteredTypes());",
    "            }",
    "            ",
    "            Map<String, Object> ruleConfig = ",
    "                (Map<String, Object>) config.getOrDefault(\"config\", Map.of());",
    "            return creator.create(ruleConfig);",
    "        }",
    "        ",
    "        @SuppressWarnings(\"unchecked\")",
    "        private CompositeRule createCompositeRule(Map<String, Object> config) {",
    "            String operatorStr = (String) config.get(\"operator\");",
    "            if (operatorStr == null) {",
    "                throw new IllegalArgumentException(\"CompositeRule missing 'operator'\");",
    "            }",
    "            ",
    "            CompositeOperator operator;",
    "            try {",
    "                operator = CompositeOperator.valueOf(operatorStr);",
    "            } catch (IllegalArgumentException e) {",
    "                throw new IllegalArgumentException(",
    "                    \"Invalid operator: \" + operatorStr + \". Valid: \" + ",
    "                    Arrays.toString(CompositeOperator.values()));",
    "            }",
    "            ",
    "            List<Map<String, Object>> rulesConfig = ",
    "                (List<Map<String, Object>>) config.get(\"rules\");",
    "            if (rulesConfig == null || rulesConfig.isEmpty()) {",
    "                throw new IllegalArgumentException(",
    "                    \"CompositeRule requires non-empty 'rules' list\");",
    "            }",
    "            ",
    "            List<Rule> childRules = rulesConfig.stream()",
    "                .map(this::createRule)",
    "                .collect(Collectors.toList());",
    "            ",
    "            return new CompositeRule(operator, childRules);",
    "        }",
    "    }",
    "",
    "    // =========================================================================",
    "    // RULES ENGINE",
    "    // =========================================================================",
    "    ",
    "    public static class Engine {",
    "        private final List<Rule> rules = new ArrayList<>();",
    "        private final RuleFactory factory = new RuleFactory();",
    "        ",
    "        public void addRule(Rule rule) {",
    "            rules.add(rule);",
    "        }",
    "        ",
    "        public Rule addRuleFromConfig(Map<String, Object> config) {",
    "            Rule rule = factory.createRule(config);",
    "            addRule(rule);",
    "            return rule;",
    "        }",
    "        ",
    "        public List<Violation> evaluate(List<Expense> expenses) {",
    "            Map<String, Object> context = buildContext(expenses);",
    "            List<Violation> violations = new ArrayList<>();",
    "            Set<String> seenTripViolations = new HashSet<>();",
    "            ",
    "            for (Expense expense : expenses) {",
    "                for (Rule rule : rules) {",
    "                    List<Violation> ruleViolations = rule.evaluate(expense, context);",
    "                    for (Violation v : ruleViolations) {",
    "                        if (v.getTripId() != null) {",
    "                            String key = v.getRuleName() + \":\" + v.getTripId();",
    "                            if (seenTripViolations.contains(key)) continue;",
    "                            seenTripViolations.add(key);",
    "                        }",
    "                        violations.add(v);",
    "                    }",
    "                }",
    "            }",
    "            return violations;",
    "        }",
    "        ",
    "        private Map<String, Object> buildContext(List<Expense> expenses) {",
    "            Map<String, BigDecimal> tripTotals = new HashMap<>();",
    "            for (Expense e : expenses) {",
    "                tripTotals.merge(e.getTripId(), e.getAmountUsd(), BigDecimal::add);",
    "            }",
    "            return Map.of(\"tripTotals\", tripTotals);",
    "        }",
    "        ",
    "        public int getRuleCount() {",
    "            return rules.size();",
    "        }",
    "    }",
    "",
    "    // =========================================================================",
    "    // MAIN - DEMONSTRATION",
    "    // =========================================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"CORPORATE EXPENSE RULES ENGINE - Part 3: Rule Creation API\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        Engine engine = new Engine();",
    "        ",
    "        // Demo 1: Create BanRule",
    "        System.out.println(\"\\n--- Demo 1: Create BanRule ---\");",
    "        Map<String, Object> banConfig = Map.of(",
    "            \"type\", \"BanRule\",",
    "            \"config\", Map.of(\"field\", \"expense_type\", \"value\", \"gambling\")",
    "        );",
    "        Rule banRule = engine.addRuleFromConfig(banConfig);",
    "        System.out.println(\"Created: \" + banRule.getName());",
    "        ",
    "        // Demo 2: Create VendorTypeLimitRule",
    "        System.out.println(\"\\n--- Demo 2: Create VendorTypeLimitRule ---\");",
    "        Map<String, Object> vendorConfig = Map.of(",
    "            \"type\", \"VendorTypeLimitRule\",",
    "            \"config\", Map.of(\"vendor_type\", \"restaurant\", \"max_amount\", 50)",
    "        );",
    "        Rule vendorRule = engine.addRuleFromConfig(vendorConfig);",
    "        System.out.println(\"Created: \" + vendorRule.getName());",
    "        ",
    "        // Demo 3: Create CompositeRule (AND)",
    "        System.out.println(\"\\n--- Demo 3: Create Composite AND Rule ---\");",
    "        Map<String, Object> compositeConfig = Map.of(",
    "            \"type\", \"CompositeRule\",",
    "            \"operator\", \"AND\",",
    "            \"rules\", List.of(",
    "                Map.of(\"type\", \"VendorTypeLimitRule\",",
    "                       \"config\", Map.of(\"vendor_type\", \"hotel\", \"max_amount\", 200)),",
    "                Map.of(\"type\", \"MaxAmountRule\",",
    "                       \"config\", Map.of(\"max_amount\", 500))",
    "            )",
    "        );",
    "        Rule compositeRule = engine.addRuleFromConfig(compositeConfig);",
    "        System.out.println(\"Created: \" + compositeRule.getName());",
    "        ",
    "        // Demo 4: Evaluate expenses",
    "        System.out.println(\"\\n--- Demo 4: Evaluate Expenses ---\");",
    "        List<Expense> expenses = List.of(",
    "            new Expense(\"E001\", \"T001\", new BigDecimal(\"45.00\"), ",
    "                \"meals\", \"restaurant\", \"Olive Garden\"),",
    "            new Expense(\"E002\", \"T001\", new BigDecimal(\"75.00\"),",
    "                \"meals\", \"restaurant\", \"Fancy Steakhouse\"),",
    "            new Expense(\"E003\", \"T001\", new BigDecimal(\"250.00\"),",
    "                \"lodging\", \"hotel\", \"Marriott\"),",
    "            new Expense(\"E004\", \"T001\", new BigDecimal(\"200.00\"),",
    "                \"gambling\", \"casino\", \"Lucky Casino\")",
    "        );",
    "        ",
    "        List<Violation> violations = engine.evaluate(expenses);",
    "        System.out.println(\"Found \" + violations.size() + \" violations:\");",
    "        for (Violation v : violations) {",
    "            System.out.println(\"  - \" + v);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"Demo completed. Total rules: \" + engine.getRuleCount());",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "explanation": "**Imports and Module Docstring**: Sets up all necessary imports including ABC for abstract classes, dataclasses for clean data structures, Decimal for precise financial calculations, and typing for comprehensive type hints."
    },
    {
      "lines": "22-60",
      "explanation": "**Data Models (Expense, Violation)**: Immutable dataclasses representing expenses and rule violations. `from_dict` and `to_dict` methods enable JSON serialization. Using `frozen=True` ensures immutability."
    },
    {
      "lines": "62-68",
      "explanation": "**CompositeOperator Enum**: Type-safe enum for AND/OR operations. AND means all sub-rules must pass; OR means expense fails if any sub-rule is violated."
    },
    {
      "lines": "70-105",
      "explanation": "**Abstract Rule Base Class**: Defines the contract all rules must implement: `evaluate()` for checking expenses, `get_name()` for identification, and `from_config()` class method for factory instantiation. The class method pattern enables self-construction from config."
    },
    {
      "lines": "107-165",
      "explanation": "**BanRule Implementation**: Bans expenses matching a field/value pair. Validates field names against whitelist. The `from_config` class method parses the config dict and creates an instance. Returns violation if expense field matches banned value."
    },
    {
      "lines": "167-200",
      "explanation": "**MaxAmountRule Implementation**: Enforces maximum amount per expense. Validates positive amounts. Returns violation if expense exceeds threshold."
    },
    {
      "lines": "202-240",
      "explanation": "**VendorTypeLimitRule Implementation**: Limits spending at specific vendor types. Only triggers if vendor type matches AND amount exceeds limit."
    },
    {
      "lines": "242-285",
      "explanation": "**TripTotalRule Implementation**: Uses context to access pre-computed trip totals. Returns violation with trip_id for deduplication. This demonstrates how aggregation rules work with the context system."
    },
    {
      "lines": "287-340",
      "explanation": "**CompositeRule Implementation**: Enables AND/OR combinations. For AND, returns all violations (expense fails if any sub-rule fails). For OR, returns violations if any rule triggers. `from_config` raises NotImplementedError because factory handles recursion."
    },
    {
      "lines": "342-400",
      "explanation": "**RuleRegistry (Singleton)**: Maps type names to rule classes. Uses singleton pattern for global access. `register()` adds new types, `lookup()` retrieves them. Built-in rules registered in `_register_builtin_rules()`. Supports runtime extension."
    },
    {
      "lines": "402-475",
      "explanation": "**RuleFactory**: The heart of dynamic rule creation. `create_rule()` validates config, handles CompositeRule specially for recursion, looks up class in registry, and delegates to rule's `from_config()`. Clean separation of concerns."
    },
    {
      "lines": "477-530",
      "explanation": "**RulesEngine**: Orchestrates rule evaluation. Manages rule collection, builds context with trip totals, deduplicates trip-level violations. `add_rule_from_config()` integrates factory for API usage."
    },
    {
      "lines": "532-580",
      "explanation": "**RulesAPI (Simulated REST)**: Demonstrates how factory integrates with API layer. `post_rule()` parses JSON and creates rules. `post_evaluate()` processes expense lists. Error handling returns meaningful messages."
    },
    {
      "lines": "582-700",
      "explanation": "**Main Demonstration**: Comprehensive demo showing all capabilities: simple rules, composite AND/OR rules, error handling, and custom rule registration at runtime. Demonstrates the full workflow from JSON to evaluation."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "RuleRegistry.register": {
          "complexity": "O(1)",
          "explanation": "HashMap insertion"
        },
        "RuleRegistry.lookup": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup"
        },
        "RuleFactory.createRule": {
          "complexity": "O(k) for composite with k rules",
          "explanation": "O(1) for simple rules (lookup + instantiation). For CompositeRule, recursively creates each child rule, so O(k) where k is total rules in the hierarchy."
        },
        "CompositeRule.evaluate": {
          "complexity": "O(k)",
          "explanation": "Evaluates each of k child rules. If children are also composites, this cascades."
        }
      },
      "overall_change": "Rule creation is now O(1) for simple rules (registry lookup + construction). Evaluation complexity unchanged at O(n \u00d7 r) for n expenses and r rules. Composite rules add multiplicative factor for depth."
    },
    "space": {
      "additional_space": "O(t) for registry, O(d) for composite depth",
      "explanation": "Registry stores O(t) rule type mappings where t is number of registered types (typically small constant). Composite rules have O(d) stack depth during creation/evaluation where d is nesting depth. Each rule instance takes O(1) space for its parameters."
    }
  },
  "dry_run": {
    "example_input": "Create composite AND rule: VendorTypeLimitRule(restaurant, $50) AND MaxAmountRule($100)",
    "steps": [
      {
        "step": 1,
        "action": "Factory receives config",
        "state": "{type: 'CompositeRule', operator: 'AND', rules: [...]}",
        "explanation": "JSON config parsed into dictionary"
      },
      {
        "step": 2,
        "action": "Check type == 'CompositeRule'",
        "state": "type = 'CompositeRule'",
        "explanation": "Special handling triggered for composite"
      },
      {
        "step": 3,
        "action": "Parse operator",
        "state": "operator = CompositeOperator.AND",
        "explanation": "Convert string to enum"
      },
      {
        "step": 4,
        "action": "Recursive call for rule[0]",
        "state": "config = {type: 'VendorTypeLimitRule', config: {...}}",
        "explanation": "Process first child rule"
      },
      {
        "step": 5,
        "action": "Registry lookup",
        "state": "registry['VendorTypeLimitRule'] \u2192 VendorTypeLimitRule class",
        "explanation": "O(1) HashMap lookup"
      },
      {
        "step": 6,
        "action": "Call from_config",
        "state": "VendorTypeLimitRule.from_config({vendor_type: 'restaurant', max_amount: 50})",
        "explanation": "Rule constructs itself"
      },
      {
        "step": 7,
        "action": "Create instance",
        "state": "VendorTypeLimitRule(restaurant, $50)",
        "explanation": "First child rule created"
      },
      {
        "step": 8,
        "action": "Recursive call for rule[1]",
        "state": "config = {type: 'MaxAmountRule', config: {max_amount: 100}}",
        "explanation": "Process second child rule"
      },
      {
        "step": 9,
        "action": "Registry lookup + from_config",
        "state": "MaxAmountRule($100)",
        "explanation": "Second child rule created"
      },
      {
        "step": 10,
        "action": "Assemble CompositeRule",
        "state": "CompositeRule(AND, [VendorTypeLimitRule, MaxAmountRule])",
        "explanation": "Parent rule created with children"
      }
    ],
    "final_output": "CompositeRule instance with AND operator containing two fully configured child rules"
  },
  "edge_cases": [
    {
      "case": "Unknown rule type",
      "handling": "Factory throws ValueError with list of registered types",
      "gotcha": "Don't just return None - provide actionable error message showing valid options"
    },
    {
      "case": "Missing config field",
      "handling": "Each rule's from_config validates required fields and throws specific error",
      "gotcha": "Validate in the rule, not the factory - each rule knows its own requirements"
    },
    {
      "case": "Empty CompositeRule",
      "handling": "CompositeRule constructor throws if rules list is empty",
      "gotcha": "A composite with no children is meaningless - fail fast"
    },
    {
      "case": "Deeply nested composites",
      "handling": "Recursive factory handles arbitrary depth",
      "gotcha": "Watch for stack overflow with extremely deep nesting - consider iterative approach for production"
    },
    {
      "case": "Invalid operator string",
      "handling": "Enum conversion throws with list of valid operators",
      "gotcha": "Don't silently default to AND - explicit errors prevent misconfiguration"
    },
    {
      "case": "Decimal precision",
      "handling": "All amounts converted via Decimal(str(value))",
      "gotcha": "Never use float for money - Decimal preserves precision"
    }
  ],
  "test_cases": [
    {
      "name": "Create simple BanRule from config",
      "input": "{'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}}",
      "expected": "BanRule instance with field='expense_type', value='gambling'",
      "explanation": "Factory looks up BanRule in registry, delegates to BanRule.from_config"
    },
    {
      "name": "Create CompositeRule AND",
      "input": "{'type': 'CompositeRule', 'operator': 'AND', 'rules': [{BanRule}, {MaxAmountRule}]}",
      "expected": "CompositeRule(AND) with two child rules",
      "explanation": "Factory recursively creates children, then wraps in CompositeRule"
    },
    {
      "name": "Unknown rule type error",
      "input": "{'type': 'FakeRule', 'config': {}}",
      "expected": "ValueError: Unknown rule type 'FakeRule'. Registered: [BanRule, MaxAmountRule, ...]",
      "explanation": "Clear error message guides user to valid options"
    },
    {
      "name": "Composite OR evaluation - single match",
      "input": "CompositeRule(OR, [BanRule(gambling), BanRule(entertainment)]) + expense(gambling)",
      "expected": "One violation returned (gambling matched)",
      "explanation": "OR returns violations if ANY sub-rule triggers"
    },
    {
      "name": "Runtime rule registration",
      "input": "registry.register('CustomRule', CustomRule.class) then create via factory",
      "expected": "CustomRule instance created successfully",
      "explanation": "Registry is extensible at runtime without modifying factory"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Hardcoding rule types in factory with if/else",
      "why_wrong": "Violates Open-Closed Principle. Every new rule type requires modifying factory code. Creates tight coupling.",
      "correct_approach": "Use Registry pattern to decouple factory from rule classes. Factory only knows about registry, not specific rules.",
      "code_example_wrong": "// Wrong: Giant switch in factory\nif (type.equals(\"BanRule\")) return new BanRule(...);\nelse if (type.equals(\"MaxRule\")) return new MaxRule(...);\n// Adding new rule = modify this code",
      "code_example_correct": "// Correct: Registry lookup\nRuleCreator creator = registry.lookup(type);\nif (creator == null) throw new UnknownRuleException(type);\nreturn creator.create(config);\n// Adding new rule = just register()"
    },
    {
      "mistake": "Not handling recursive composite creation",
      "why_wrong": "CompositeRule can contain CompositeRules. Non-recursive approach can't handle nesting.",
      "correct_approach": "Factory calls itself recursively for each child rule in CompositeRule.",
      "code_example_wrong": "// Wrong: Only handles one level\nfor config in rules_config:\n    if config.type == 'CompositeRule':\n        raise Error('Nested composites not supported')",
      "code_example_correct": "// Correct: Recursive creation\nfor rule_config in rules_config:\n    child_rules.append(self.create_rule(rule_config))  # Recursive!"
    },
    {
      "mistake": "Putting construction logic in factory instead of rule",
      "why_wrong": "Factory becomes bloated knowing about every rule's config format. Single Responsibility violated.",
      "correct_approach": "Each rule has from_config class method. Factory only does lookup and delegates.",
      "code_example_wrong": "// Wrong: Factory knows too much\nif (type == 'BanRule') {\n    String field = config.get('field');\n    String value = config.get('value');\n    return new BanRule(field, value);\n}",
      "code_example_correct": "// Correct: Delegate to rule\nRuleClass ruleClass = registry.lookup(type);\nreturn ruleClass.from_config(config);  // Rule knows its own config"
    },
    {
      "mistake": "Using floats for money amounts",
      "why_wrong": "Float arithmetic has precision issues. 0.1 + 0.2 != 0.3 in floating point.",
      "correct_approach": "Always use Decimal/BigDecimal for financial calculations.",
      "code_example_wrong": "// Wrong: Float for money\nfloat maxAmount = Float.parseFloat(config.get('max_amount'));",
      "code_example_correct": "// Correct: Decimal for money\nBigDecimal maxAmount = new BigDecimal(config.get('max_amount').toString());"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying the problem with hardcoded rules: lack of flexibility, code changes for new rules, no runtime configuration. Then introduce Factory Pattern as the solution for creating objects from config. Explain why Registry is needed to decouple factory from rule classes. Finally, show how Composite Pattern enables complex rule combinations. Draw the flow diagram showing JSON \u2192 Factory \u2192 Registry \u2192 Rule Instance.",
    "what_to_mention": [
      "Open-Closed Principle: System is open for extension (new rule types) but closed for modification",
      "Single Responsibility: Factory handles creation, Registry handles lookup, Rules handle evaluation",
      "Dependency Inversion: Factory depends on abstraction (Rule interface), not concrete classes",
      "Recursive composition enables arbitrarily complex rule hierarchies",
      "Each rule's from_config is a Factory Method pattern at the class level",
      "Thread safety considerations for singleton registry in production"
    ],
    "time_allocation": "5 min understanding requirements \u2192 5 min designing patterns (draw diagrams) \u2192 10 min core implementation (Registry, Factory) \u2192 5 min CompositeRule \u2192 5 min error handling and edge cases",
    "if_stuck": [
      "Think about how Spring/Django create beans/models from configuration - same pattern",
      "Consider: What changes when a new rule type is added? Minimize that change.",
      "CompositeRule is like a tree - how do you build trees? Recursively!",
      "Registry is just a HashMap<String, Class> - start simple"
    ]
  },
  "connection_to_next_part": "Part 3's Factory + Registry architecture enables Part 4 possibilities: **Rule Persistence** (serialize rules to database, reload on startup), **Rule Versioning** (track rule changes over time), **A/B Testing** (evaluate expenses against different rule sets), **Rule Templates** (pre-configured rule combinations for common policies), or **Priority/Ordering** (define evaluation order for conflicting rules). The clean separation between rule definition and rule instantiation makes all these extensions straightforward.",
  "generated_at": "2026-01-14T15:10:17.146518",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}