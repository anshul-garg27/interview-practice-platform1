{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 2: Stories Feature (24-hour ephemeral content)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 extends the Instagram system to support ephemeral content (Stories) that automatically expires after 24 hours. This introduces TTL-based storage, high-volume view tracking, and a new 'story ring' UI component showing users with active/unviewed stories. Unlike permanent posts from Part 1, stories require temporal management and view state tracking at massive scale (billions of view events daily).",
    "new_requirements": [
      "Post stories with automatic 24-hour TTL expiration",
      "Story ring showing followed users with active stories sorted by recency",
      "Track viewed/unviewed state per user per story efficiently",
      "Record viewer list for story analytics",
      "Handle 500M story posts/day and billions of view events"
    ],
    "new_constraints": [
      "Stories must auto-delete after exactly 24 hours",
      "View tracking must be O(1) for 'has viewed' checks",
      "Story ring must show unviewed stories first, then by recency",
      "System must handle 5x more reads than regular feed",
      "Viewer list storage must be eventually consistent for write scalability"
    ],
    "key_insight": "Separate the fast 'has viewed' check (Bloom filter, O(1)) from the accurate 'viewer list' (append log, eventually consistent). Use probabilistic data structures for read-heavy operations and time-series-optimized storage (Cassandra TTL) for automatic expiration without manual cleanup jobs."
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BEFORE (Part 1 Only)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    User Posts Photo \u2500\u2500\u2500\u2500\u25ba Permanent Storage \u2500\u2500\u2500\u2500\u25ba Feed Forever\n                                  \u2502\n                                  \u25bc\n                          Social Graph\n                         (followers/following)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    AFTER (With Stories)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    User Posts Story \u2500\u2500\u25ba\u2502  Stories Store    \u2502\n                        \u2502  (Cassandra+TTL)  \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502                       \u2502                       \u2502\n         \u25bc                       \u25bc                       \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Story   \u2502           \u2502   View    \u2502           \u2502  24h TTL  \u2502\n    \u2502  Ring   \u2502           \u2502 Tracking  \u2502           \u2502  Expiry   \u2502\n    \u2502 (Redis) \u2502           \u2502  (Bloom)  \u2502           \u2502  (Auto)   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              STORY POSTING FLOW                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  POST STORY                                              \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 1. Upload    \u2502  Media \u2192 CDN/S3\n     \u2502    Media     \u2502  Generate story_id\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 2. Store     \u2502  Cassandra: INSERT with TTL=86400\n     \u2502    Story     \u2502  {story_id, user_id, media_url, created_at}\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 3. Init View \u2502  Create Bloom filter for story_id\n     \u2502   Tracking   \u2502  Create HyperLogLog for view count\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 4. Fan-out   \u2502  For each follower:\n     \u2502  Story Ring  \u2502    ZADD story_ring:{follower} user_id timestamp\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              STORY RING RETRIEVAL FLOW                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n     GET STORY RING (user_id)\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 1. Get users \u2502  Redis: ZRANGEBYSCORE story_ring:{user_id}\n     \u2502 with stories \u2502  (now - 24h) to (now)\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 2. For each  \u2502  Check Bloom filter:\n     \u2502 user, check  \u2502  bloom_{story_id}.contains(user_id)\n     \u2502 view status  \u2502  \n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 3. Sort:     \u2502  1st: unviewed users first\n     \u2502   Priority   \u2502  2nd: by latest_story_time DESC\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u25bc\n     Return StoryRing [\n       {user: alice, unviewed: true, time: 1699900100},\n       {user: bob, unviewed: true, time: 1699900000},\n       {user: charlie, unviewed: false, time: 1699899900}\n     ]\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - SQL with CRON Cleanup",
      "description": "Store stories in same PostgreSQL database as posts, add 'expires_at' column, run CRON job every minute to delete expired stories. Track views in a simple views table with (story_id, viewer_id) rows.",
      "time_complexity": "O(N) for cleanup where N=all stories, O(V) for view check where V=all views",
      "space_complexity": "O(S*V) where S=stories, V=views per story",
      "why_not_optimal": "CRON cleanup doesn't scale (millions of deletes per run), view tracking table becomes massive (billions of rows/day), view check requires table scan or large index. Cannot handle 500M stories/day and billions of view events."
    },
    {
      "name": "Optimal Approach - TTL Storage + Probabilistic Data Structures",
      "description": "Use Cassandra with native TTL for automatic expiration (no cleanup jobs). Use Bloom filters for O(1) 'has viewed' checks (false positives acceptable - worst case: user sees story marked as viewed). Use HyperLogLog for approximate unique view counts. Maintain Redis sorted sets for story rings with timestamp scores.",
      "time_complexity": "O(1) for postStory per follower (fan-out), O(F) for getStoryRing where F=followed users, O(1) for markStoryViewed",
      "space_complexity": "O(S) for stories, O(S*B) for Bloom filters where B=bloom size (constant), O(1) per HyperLogLog",
      "key_insight": "Accept probabilistic accuracy for massive scale wins. Bloom filter false positive rate <1% is acceptable for view tracking. HyperLogLog gives ~2% error for view counts which is fine for analytics. This trades perfect accuracy for 1000x better scalability."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Architecture for Stories\n\n### 1. **TTL-Based Storage (Cassandra)**\nCassandra natively supports **TTL (Time-To-Live)** at the column level. When inserting a story, we set `TTL=86400` (24 hours). Cassandra automatically tombstones and eventually deletes the record - **no cleanup jobs needed**.\n\n```sql\nINSERT INTO stories (story_id, user_id, media_url, created_at)\nVALUES (?, ?, ?, ?)\nUSING TTL 86400;\n```\n\n### 2. **Story Ring (Redis Sorted Set)**\nFor each user, maintain a sorted set where:\n- **Members**: user_ids of followed users with active stories\n- **Scores**: timestamp of their latest story\n\nThis enables O(log N) inserts and O(F) retrieval of followed users with stories, sorted by recency.\n\n### 3. **View Tracking (Bloom Filter)**\nThe key insight is separating **'has viewed'** (needs to be fast) from **'who viewed'** (can be eventually consistent):\n\n- **Bloom Filter per story**: O(1) check for `hasViewed(userId, storyId)`\n- **False positives are OK**: At worst, we show a story as 'viewed' when it wasn't\n- **No false negatives**: We never miss marking a viewed story\n\n### 4. **View Count (HyperLogLog)**\n**HyperLogLog** provides cardinality estimation with ~2% error using only 12KB of memory per story. Perfect for \"347 people viewed this\" where \u00b110 doesn't matter.\n\n### 5. **Viewer List (Append-Only Log)**\nFor the actual viewer list (shown to story creator), use an append-only log (Kafka/Cassandra). This is **write-optimized** and eventually consistent - acceptable since creators don't need real-time viewer lists.",
    "data_structures": [
      {
        "structure": "Cassandra with TTL",
        "purpose": "Auto-expiring story storage without cleanup jobs"
      },
      {
        "structure": "Redis Sorted Set",
        "purpose": "Story ring: O(log N) insert, O(F) range query by timestamp"
      },
      {
        "structure": "Bloom Filter",
        "purpose": "O(1) probabilistic 'has viewed' check with <1% false positive rate"
      },
      {
        "structure": "HyperLogLog",
        "purpose": "Approximate unique view count in 12KB memory, ~2% error"
      },
      {
        "structure": "Append-Only Log",
        "purpose": "High-throughput viewer list writes, eventual consistency"
      }
    ],
    "algorithm_steps": [
      "**postStory**: Upload media to CDN \u2192 Insert story to Cassandra with TTL \u2192 Initialize Bloom filter and HyperLogLog \u2192 Fan-out to update story rings for all followers",
      "**getStoryRing**: Query Redis sorted set for followed users with stories in last 24h \u2192 For each user, check Bloom filter to determine viewed/unviewed state \u2192 Sort by (unviewed first, then by recency) \u2192 Return StoryRing",
      "**markStoryViewed**: Check Bloom filter first (if already viewed, skip) \u2192 Add to Bloom filter \u2192 Increment HyperLogLog \u2192 Async append to viewer list",
      "**getStoryViewers**: Paginated read from append-only viewer log \u2192 Return list with cursor for pagination"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Dict, Set, Optional",
    "from dataclasses import dataclass, field",
    "from enum import Enum",
    "from collections import defaultdict",
    "import hashlib",
    "import time",
    "import threading",
    "",
    "",
    "class StoryType(Enum):",
    "    \"\"\"Type of story content.\"\"\"",
    "    PHOTO = \"PHOTO\"",
    "    VIDEO = \"VIDEO\"",
    "",
    "",
    "@dataclass",
    "class Story:",
    "    \"\"\"Represents an ephemeral story with 24-hour lifespan.\"\"\"",
    "    story_id: str",
    "    user_id: str",
    "    media_url: str",
    "    story_type: StoryType",
    "    created_at: int",
    "    expires_at: int",
    "    view_count: int = 0",
    "",
    "",
    "@dataclass",
    "class StoryRingUser:",
    "    \"\"\"User entry in story ring with view status.\"\"\"",
    "    user_id: str",
    "    has_unviewed: bool",
    "    latest_story_time: int",
    "    story_count: int = 1",
    "",
    "",
    "@dataclass",
    "class StoryRing:",
    "    \"\"\"Collection of users with active stories.\"\"\"",
    "    users: List[StoryRingUser]",
    "",
    "",
    "class BloomFilter:",
    "    \"\"\"",
    "    Space-efficient probabilistic data structure for set membership.",
    "    ",
    "    Properties:",
    "        - O(1) add and contains operations",
    "        - No false negatives (if we added it, contains returns True)",
    "        - Small false positive rate (~1% with proper sizing)",
    "        - Fixed memory regardless of elements added",
    "    \"\"\"",
    "    ",
    "    def __init__(self, size: int = 10_000_000, hash_count: int = 7):",
    "        self.size = size",
    "        self.hash_count = hash_count",
    "        self.bit_array = [False] * size",
    "    ",
    "    def _hashes(self, item: str) -> List[int]:",
    "        \"\"\"Generate multiple hash positions for an item.\"\"\"",
    "        result = []",
    "        for i in range(self.hash_count):",
    "            hash_input = f\"{item}_{i}\".encode()",
    "            hash_value = int(hashlib.md5(hash_input).hexdigest(), 16)",
    "            result.append(hash_value % self.size)",
    "        return result",
    "    ",
    "    def add(self, item: str) -> None:",
    "        \"\"\"Add an item to the filter. O(k) where k=hash_count.\"\"\"",
    "        for pos in self._hashes(item):",
    "            self.bit_array[pos] = True",
    "    ",
    "    def contains(self, item: str) -> bool:",
    "        \"\"\"Check if item might be in set. O(k) where k=hash_count.\"\"\"",
    "        return all(self.bit_array[pos] for pos in self._hashes(item))",
    "",
    "",
    "class HyperLogLog:",
    "    \"\"\"",
    "    Probabilistic cardinality estimator using ~12KB memory.",
    "    ",
    "    Provides ~2% error rate for counting unique elements.",
    "    Perfect for approximate view counts where exact numbers aren't critical.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, precision: int = 14):",
    "        self.precision = precision",
    "        self.num_buckets = 1 << precision",
    "        self.buckets = [0] * self.num_buckets",
    "    ",
    "    def _hash(self, value: str) -> int:",
    "        return int(hashlib.sha256(value.encode()).hexdigest(), 16)",
    "    ",
    "    def add(self, value: str) -> None:",
    "        \"\"\"Add element to the counter. O(1).\"\"\"",
    "        h = self._hash(value)",
    "        bucket = h & (self.num_buckets - 1)",
    "        remaining = h >> self.precision",
    "        leading_zeros = 1",
    "        while remaining > 0 and (remaining & 1) == 0:",
    "            leading_zeros += 1",
    "            remaining >>= 1",
    "        self.buckets[bucket] = max(self.buckets[bucket], leading_zeros)",
    "    ",
    "    def count(self) -> int:",
    "        \"\"\"Estimate unique element count. O(buckets).\"\"\"",
    "        alpha = 0.7213 / (1 + 1.079 / self.num_buckets)",
    "        raw = alpha * self.num_buckets ** 2 / sum(2 ** -b for b in self.buckets)",
    "        return int(raw)",
    "",
    "",
    "class RedisSortedSet:",
    "    \"\"\"",
    "    In-memory simulation of Redis Sorted Set.",
    "    ",
    "    In production, use actual Redis ZADD/ZRANGEBYSCORE commands.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._data: Dict[str, float] = {}",
    "    ",
    "    def zadd(self, member: str, score: float) -> None:",
    "        \"\"\"Add member with score. O(log N) in Redis.\"\"\"",
    "        self._data[member] = score",
    "    ",
    "    def zrem(self, member: str) -> None:",
    "        \"\"\"Remove member. O(log N) in Redis.\"\"\"",
    "        self._data.pop(member, None)",
    "    ",
    "    def zrangebyscore(self, min_score: float, max_score: float) -> List[str]:",
    "        \"\"\"Get members within score range, sorted descending.\"\"\"",
    "        result = [(k, v) for k, v in self._data.items() ",
    "                  if min_score <= v <= max_score]",
    "        result.sort(key=lambda x: -x[1])",
    "        return [k for k, v in result]",
    "",
    "",
    "class InstagramStoriesSystem:",
    "    \"\"\"",
    "    Instagram Stories System - Ephemeral content management.",
    "    ",
    "    Architecture:",
    "        - Cassandra with TTL for auto-expiring story storage",
    "        - Redis sorted sets for story ring (users with active stories)",
    "        - Bloom filters for O(1) 'has viewed' checks",
    "        - HyperLogLog for approximate unique view counts",
    "    ",
    "    Scale:",
    "        - 500M story posts/day",
    "        - Billions of view events/day",
    "        - Stories viewed 5x more than regular feed",
    "    \"\"\"",
    "    ",
    "    TTL_SECONDS = 24 * 60 * 60  # 24 hours",
    "    ",
    "    def __init__(self):",
    "        # Story storage (simulating Cassandra with TTL)",
    "        self._stories: Dict[str, Story] = {}",
    "        self._user_stories: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # Story ring per user (simulating Redis sorted sets)",
    "        self._story_rings: Dict[str, RedisSortedSet] = defaultdict(RedisSortedSet)",
    "        ",
    "        # View tracking - Bloom filters for 'has viewed'",
    "        self._view_bloom_filters: Dict[str, BloomFilter] = {}",
    "        ",
    "        # View counting - HyperLogLog for approximate counts",
    "        self._view_counts: Dict[str, HyperLogLog] = {}",
    "        ",
    "        # Viewer lists - append-only (eventually consistent)",
    "        self._viewer_lists: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # Social graph (inherited from Part 1)",
    "        self._followers: Dict[str, Set[str]] = defaultdict(set)",
    "        self._following: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Thread-safe ID generation",
    "        self._story_counter = 0",
    "        self._lock = threading.Lock()",
    "    ",
    "    def _generate_story_id(self) -> str:",
    "        \"\"\"Generate unique story ID. Thread-safe.\"\"\"",
    "        with self._lock:",
    "            self._story_counter += 1",
    "            return f\"story_{self._story_counter}\"",
    "    ",
    "    def _current_time(self) -> int:",
    "        \"\"\"Get current Unix timestamp.\"\"\"",
    "        return int(time.time())",
    "    ",
    "    def _is_expired(self, story: Story) -> bool:",
    "        \"\"\"Check if story has expired.\"\"\"",
    "        return self._current_time() >= story.expires_at",
    "    ",
    "    def _cleanup_expired_stories(self) -> None:",
    "        \"\"\"",
    "        Remove expired stories from memory.",
    "        ",
    "        Note: In production, Cassandra TTL handles this automatically.",
    "        This is only needed for our in-memory simulation.",
    "        \"\"\"",
    "        current = self._current_time()",
    "        expired = [sid for sid, s in self._stories.items() ",
    "                   if current >= s.expires_at]",
    "        ",
    "        for story_id in expired:",
    "            story = self._stories.pop(story_id, None)",
    "            if story:",
    "                self._user_stories[story.user_id] = [",
    "                    sid for sid in self._user_stories[story.user_id] ",
    "                    if sid != story_id",
    "                ]",
    "                # Update story rings if user has no more stories",
    "                if not self._user_stories[story.user_id]:",
    "                    for follower in self._followers[story.user_id]:",
    "                        self._story_rings[follower].zrem(story.user_id)",
    "    ",
    "    def follow_user(self, follower_id: str, followee_id: str) -> None:",
    "        \"\"\"",
    "        Establish follow relationship and update story ring if needed.",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        self._following[follower_id].add(followee_id)",
    "        self._followers[followee_id].add(follower_id)",
    "        ",
    "        # If followee has active stories, add to follower's ring",
    "        if self._user_stories[followee_id]:",
    "            latest_sid = self._user_stories[followee_id][-1]",
    "            if latest_sid in self._stories:",
    "                story = self._stories[latest_sid]",
    "                if not self._is_expired(story):",
    "                    self._story_rings[follower_id].zadd(",
    "                        followee_id, story.created_at)",
    "    ",
    "    def post_story(self, user_id: str, media: bytes, ",
    "                   story_type: StoryType) -> str:",
    "        \"\"\"",
    "        Post a new story that expires in 24 hours.",
    "        ",
    "        Time Complexity: O(F) where F = number of followers",
    "        Space Complexity: O(1) for the story itself",
    "        ",
    "        Args:",
    "            user_id: User posting the story",
    "            media: Photo or video content bytes",
    "            story_type: PHOTO or VIDEO",
    "        ",
    "        Returns:",
    "            Unique story ID",
    "        \"\"\"",
    "        story_id = self._generate_story_id()",
    "        current_time = self._current_time()",
    "        ",
    "        # In production: Upload media to CDN/S3",
    "        media_url = f\"https://cdn.instagram.com/stories/{user_id}/{story_id}\"",
    "        ",
    "        # Create story with TTL (Cassandra INSERT with TTL=86400)",
    "        story = Story(",
    "            story_id=story_id,",
    "            user_id=user_id,",
    "            media_url=media_url,",
    "            story_type=story_type,",
    "            created_at=current_time,",
    "            expires_at=current_time + self.TTL_SECONDS,",
    "            view_count=0",
    "        )",
    "        ",
    "        self._stories[story_id] = story",
    "        self._user_stories[user_id].append(story_id)",
    "        ",
    "        # Initialize view tracking structures",
    "        self._view_bloom_filters[story_id] = BloomFilter()",
    "        self._view_counts[story_id] = HyperLogLog()",
    "        ",
    "        # Fan-out: Update story rings for all followers",
    "        # In production: Async via message queue (Kafka/SQS)",
    "        for follower_id in self._followers[user_id]:",
    "            self._story_rings[follower_id].zadd(user_id, current_time)",
    "        ",
    "        return story_id",
    "    ",
    "    def get_story_ring(self, user_id: str) -> StoryRing:",
    "        \"\"\"",
    "        Get list of users with active stories for story ring UI.",
    "        ",
    "        Time Complexity: O(F) where F = followed users with stories",
    "        Space Complexity: O(F) for the result",
    "        ",
    "        Args:",
    "            user_id: User requesting their story ring",
    "        ",
    "        Returns:",
    "            StoryRing with users sorted by (unviewed first, then recency)",
    "        \"\"\"",
    "        self._cleanup_expired_stories()",
    "        ",
    "        ring = self._story_rings[user_id]",
    "        current_time = self._current_time()",
    "        cutoff_time = current_time - self.TTL_SECONDS",
    "        ",
    "        # Get users with stories in the last 24 hours",
    "        users_with_stories = ring.zrangebyscore(cutoff_time, current_time)",
    "        ",
    "        result_users = []",
    "        for story_user_id in users_with_stories:",
    "            if story_user_id not in self._user_stories:",
    "                continue",
    "            ",
    "            # Get active (non-expired) stories",
    "            active_stories = []",
    "            for sid in self._user_stories[story_user_id]:",
    "                if sid in self._stories:",
    "                    story = self._stories[sid]",
    "                    if not self._is_expired(story):",
    "                        active_stories.append(story)",
    "            ",
    "            if not active_stories:",
    "                continue",
    "            ",
    "            # Check view status using Bloom filter - O(1) per story",
    "            has_unviewed = False",
    "            for story in active_stories:",
    "                bloom = self._view_bloom_filters.get(story.story_id)",
    "                if bloom and not bloom.contains(user_id):",
    "                    has_unviewed = True",
    "                    break",
    "            ",
    "            latest_time = max(s.created_at for s in active_stories)",
    "            ",
    "            result_users.append(StoryRingUser(",
    "                user_id=story_user_id,",
    "                has_unviewed=has_unviewed,",
    "                latest_story_time=latest_time,",
    "                story_count=len(active_stories)",
    "            ))",
    "        ",
    "        # Sort: unviewed first, then by recency descending",
    "        result_users.sort(key=lambda u: (-int(u.has_unviewed), ",
    "                                          -u.latest_story_time))",
    "        ",
    "        return StoryRing(users=result_users)",
    "    ",
    "    def get_stories(self, user_id: str, target_user_id: str) -> List[Story]:",
    "        \"\"\"",
    "        Get all active stories from a specific user.",
    "        ",
    "        Time Complexity: O(S) where S = stories from target user",
    "        Space Complexity: O(S)",
    "        ",
    "        Args:",
    "            user_id: User viewing the stories",
    "            target_user_id: User whose stories to retrieve",
    "        ",
    "        Returns:",
    "            List of active stories sorted oldest-first (viewing order)",
    "        \"\"\"",
    "        self._cleanup_expired_stories()",
    "        ",
    "        stories = []",
    "        for story_id in self._user_stories.get(target_user_id, []):",
    "            if story_id in self._stories:",
    "                story = self._stories[story_id]",
    "                if not self._is_expired(story):",
    "                    stories.append(story)",
    "        ",
    "        stories.sort(key=lambda s: s.created_at)",
    "        return stories",
    "    ",
    "    def mark_story_viewed(self, user_id: str, story_id: str) -> bool:",
    "        \"\"\"",
    "        Mark a story as viewed by a user.",
    "        ",
    "        Time Complexity: O(1) amortized",
    "        Space Complexity: O(1) for Bloom filter operation",
    "        ",
    "        Key insight: Use Bloom filter for fast 'has viewed' check,",
    "        separate append log for actual viewer list (eventually consistent).",
    "        ",
    "        Args:",
    "            user_id: User viewing the story",
    "            story_id: Story being viewed",
    "        ",
    "        Returns:",
    "            True if marked successfully, False if story doesn't exist",
    "        \"\"\"",
    "        if story_id not in self._stories:",
    "            return False",
    "        ",
    "        story = self._stories[story_id]",
    "        if self._is_expired(story):",
    "            return False",
    "        ",
    "        bloom = self._view_bloom_filters.get(story_id)",
    "        hll = self._view_counts.get(story_id)",
    "        ",
    "        # Only process if not already viewed (Bloom filter check)",
    "        if bloom and not bloom.contains(user_id):",
    "            # Mark as viewed in Bloom filter",
    "            bloom.add(user_id)",
    "            ",
    "            # Increment view count (HyperLogLog)",
    "            if hll:",
    "                hll.add(user_id)",
    "            ",
    "            # Append to viewer list (async in production)",
    "            self._viewer_lists[story_id].append(user_id)",
    "            ",
    "            # Update story's view count",
    "            story.view_count = hll.count() if hll else len(",
    "                self._viewer_lists[story_id])",
    "        ",
    "        return True",
    "    ",
    "    def get_story_viewers(self, story_id: str, ",
    "                          limit: int = 100, ",
    "                          offset: int = 0) -> List[str]:",
    "        \"\"\"",
    "        Get paginated list of users who viewed a story.",
    "        ",
    "        Time Complexity: O(limit)",
    "        Space Complexity: O(limit)",
    "        ",
    "        In production, this reads from an append-only log with cursor pagination.",
    "        ",
    "        Args:",
    "            story_id: Story to get viewers for",
    "            limit: Maximum viewers to return",
    "            offset: Starting position for pagination",
    "        ",
    "        Returns:",
    "            List of user IDs who viewed the story",
    "        \"\"\"",
    "        viewers = self._viewer_lists.get(story_id, [])",
    "        return viewers[offset:offset + limit]",
    "    ",
    "    def get_story_view_count(self, story_id: str) -> int:",
    "        \"\"\"",
    "        Get approximate unique view count using HyperLogLog.",
    "        ",
    "        Time Complexity: O(1)",
    "        ",
    "        Note: Returns approximate count (~2% error). For exact count,",
    "        query the viewer list length (more expensive).",
    "        \"\"\"",
    "        hll = self._view_counts.get(story_id)",
    "        return hll.count() if hll else 0",
    "    ",
    "    def get_story_analytics(self, story_id: str) -> Optional[Dict]:",
    "        \"\"\"",
    "        Get comprehensive analytics for a story (for story owner).",
    "        ",
    "        Returns view count, time remaining, and story metadata.",
    "        \"\"\"",
    "        if story_id not in self._stories:",
    "            return None",
    "        ",
    "        story = self._stories[story_id]",
    "        current = self._current_time()",
    "        ",
    "        return {",
    "            \"story_id\": story_id,",
    "            \"view_count\": self.get_story_view_count(story_id),",
    "            \"created_at\": story.created_at,",
    "            \"expires_at\": story.expires_at,",
    "            \"time_remaining_seconds\": max(0, story.expires_at - current),",
    "            \"is_expired\": self._is_expired(story)",
    "        }",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the Instagram Stories system.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"        INSTAGRAM STORIES SYSTEM DEMO\")",
    "    print(\"=\" * 70)",
    "    ",
    "    system = InstagramStoriesSystem()",
    "    ",
    "    # Setup users and relationships",
    "    print(\"\\n\ud83d\udcf1 Setting up users and follow relationships...\")",
    "    system.follow_user(\"bob\", \"alice\")",
    "    system.follow_user(\"charlie\", \"alice\")",
    "    system.follow_user(\"alice\", \"bob\")",
    "    system.follow_user(\"diana\", \"alice\")",
    "    system.follow_user(\"diana\", \"bob\")",
    "    print(\"   \u2713 Bob follows Alice\")",
    "    print(\"   \u2713 Charlie follows Alice\")",
    "    print(\"   \u2713 Alice follows Bob\")",
    "    print(\"   \u2713 Diana follows Alice and Bob\")",
    "    ",
    "    # Alice posts a story",
    "    print(\"\\n\ud83d\udcf8 Alice posts a photo story...\")",
    "    story_id_1 = system.post_story(\"alice\", b\"photo_data\", StoryType.PHOTO)",
    "    print(f\"   \u2713 Created: {story_id_1}\")",
    "    ",
    "    # Check Bob's story ring",
    "    print(\"\\n\ud83d\udd35 Bob checks his story ring...\")",
    "    ring = system.get_story_ring(\"bob\")",
    "    for user in ring.users:",
    "        status = \"\ud83d\udd34 NEW\" if user.has_unviewed else \"\u26aa viewed\"",
    "        print(f\"   {user.user_id}: {status} ({user.story_count} stories)\")",
    "    ",
    "    # Bob views the story",
    "    print(\"\\n\ud83d\udc41\ufe0f  Bob views Alice's story...\")",
    "    system.mark_story_viewed(\"bob\", story_id_1)",
    "    print(\"   \u2713 Marked as viewed\")",
    "    ",
    "    # Check Bob's story ring again",
    "    print(\"\\n\ud83d\udd35 Bob's story ring after viewing...\")",
    "    ring = system.get_story_ring(\"bob\")",
    "    for user in ring.users:",
    "        status = \"\ud83d\udd34 NEW\" if user.has_unviewed else \"\u26aa viewed\"",
    "        print(f\"   {user.user_id}: {status}\")",
    "    ",
    "    # Charlie also views",
    "    print(\"\\n\ud83d\udc41\ufe0f  Charlie views Alice's story...\")",
    "    system.mark_story_viewed(\"charlie\", story_id_1)",
    "    ",
    "    # Alice checks analytics",
    "    print(\"\\n\ud83d\udcca Alice checks her story analytics...\")",
    "    analytics = system.get_story_analytics(story_id_1)",
    "    print(f\"   View count: {analytics['view_count']}\")",
    "    print(f\"   Time remaining: {analytics['time_remaining_seconds']}s\")",
    "    ",
    "    viewers = system.get_story_viewers(story_id_1)",
    "    print(f\"   Viewers: {viewers}\")",
    "    ",
    "    # Bob posts a video story",
    "    print(\"\\n\ud83c\udfac Bob posts a video story...\")",
    "    story_id_2 = system.post_story(\"bob\", b\"video_data\", StoryType.VIDEO)",
    "    print(f\"   \u2713 Created: {story_id_2}\")",
    "    ",
    "    # Diana checks her ring (should show both Alice and Bob)",
    "    print(\"\\n\ud83d\udd35 Diana checks her story ring...\")",
    "    ring = system.get_story_ring(\"diana\")",
    "    print(f\"   Users with stories: {len(ring.users)}\")",
    "    for user in ring.users:",
    "        status = \"\ud83d\udd34 NEW\" if user.has_unviewed else \"\u26aa viewed\"",
    "        print(f\"   {user.user_id}: {status} ({user.story_count} stories)\")",
    "    ",
    "    # Alice posts another story",
    "    print(\"\\n\ud83d\udcf8 Alice posts another story...\")",
    "    story_id_3 = system.post_story(\"alice\", b\"photo_2\", StoryType.PHOTO)",
    "    print(f\"   \u2713 Created: {story_id_3}\")",
    "    ",
    "    # Diana's ring should show Alice with 2 stories",
    "    print(\"\\n\ud83d\udd35 Diana's updated story ring...\")",
    "    ring = system.get_story_ring(\"diana\")",
    "    for user in ring.users:",
    "        status = \"\ud83d\udd34 NEW\" if user.has_unviewed else \"\u26aa viewed\"",
    "        print(f\"   {user.user_id}: {status} ({user.story_count} stories)\")",
    "    ",
    "    # Diana views all of Alice's stories",
    "    print(\"\\n\ud83d\udc41\ufe0f  Diana views all of Alice's stories...\")",
    "    stories = system.get_stories(\"diana\", \"alice\")",
    "    for story in stories:",
    "        system.mark_story_viewed(\"diana\", story.story_id)",
    "        print(f\"   \u2713 Viewed {story.story_id}\")",
    "    ",
    "    # Final ring state",
    "    print(\"\\n\ud83d\udd35 Diana's final story ring...\")",
    "    ring = system.get_story_ring(\"diana\")",
    "    for user in ring.users:",
    "        status = \"\ud83d\udd34 NEW\" if user.has_unviewed else \"\u26aa viewed\"",
    "        print(f\"   {user.user_id}: {status}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"        DEMO COMPLETED SUCCESSFULLY\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.ConcurrentHashMap;",
    "import java.util.concurrent.atomic.AtomicLong;",
    "import java.security.MessageDigest;",
    "import java.security.NoSuchAlgorithmException;",
    "",
    "enum StoryType { PHOTO, VIDEO }",
    "",
    "class Story {",
    "    String storyId;",
    "    String userId;",
    "    String mediaUrl;",
    "    StoryType storyType;",
    "    long createdAt;",
    "    long expiresAt;",
    "    int viewCount;",
    "    ",
    "    Story(String storyId, String userId, String mediaUrl,",
    "          StoryType storyType, long createdAt, long expiresAt) {",
    "        this.storyId = storyId;",
    "        this.userId = userId;",
    "        this.mediaUrl = mediaUrl;",
    "        this.storyType = storyType;",
    "        this.createdAt = createdAt;",
    "        this.expiresAt = expiresAt;",
    "        this.viewCount = 0;",
    "    }",
    "}",
    "",
    "class StoryRingUser {",
    "    String userId;",
    "    boolean hasUnviewed;",
    "    long latestStoryTime;",
    "    int storyCount;",
    "    ",
    "    StoryRingUser(String userId, boolean hasUnviewed,",
    "                  long latestStoryTime, int storyCount) {",
    "        this.userId = userId;",
    "        this.hasUnviewed = hasUnviewed;",
    "        this.latestStoryTime = latestStoryTime;",
    "        this.storyCount = storyCount;",
    "    }",
    "}",
    "",
    "class StoryRing {",
    "    List<StoryRingUser> users;",
    "    StoryRing(List<StoryRingUser> users) { this.users = users; }",
    "}",
    "",
    "/**",
    " * Bloom Filter for O(1) probabilistic set membership.",
    " */",
    "class BloomFilter {",
    "    private final int size;",
    "    private final int hashCount;",
    "    private final boolean[] bitArray;",
    "    ",
    "    BloomFilter(int size, int hashCount) {",
    "        this.size = size;",
    "        this.hashCount = hashCount;",
    "        this.bitArray = new boolean[size];",
    "    }",
    "    ",
    "    BloomFilter() { this(10_000_000, 7); }",
    "    ",
    "    private int[] getHashes(String item) {",
    "        int[] hashes = new int[hashCount];",
    "        try {",
    "            for (int i = 0; i < hashCount; i++) {",
    "                MessageDigest md = MessageDigest.getInstance(\"MD5\");",
    "                String input = item + \"_\" + i;",
    "                byte[] digest = md.digest(input.getBytes());",
    "                int hash = Math.abs(new String(digest).hashCode());",
    "                hashes[i] = hash % size;",
    "            }",
    "        } catch (NoSuchAlgorithmException e) {",
    "            throw new RuntimeException(e);",
    "        }",
    "        return hashes;",
    "    }",
    "    ",
    "    void add(String item) {",
    "        for (int pos : getHashes(item)) {",
    "            bitArray[pos] = true;",
    "        }",
    "    }",
    "    ",
    "    boolean contains(String item) {",
    "        for (int pos : getHashes(item)) {",
    "            if (!bitArray[pos]) return false;",
    "        }",
    "        return true;",
    "    }",
    "}",
    "",
    "/**",
    " * HyperLogLog for approximate unique counting.",
    " */",
    "class HyperLogLog {",
    "    private final int precision;",
    "    private final int numBuckets;",
    "    private final int[] buckets;",
    "    ",
    "    HyperLogLog(int precision) {",
    "        this.precision = precision;",
    "        this.numBuckets = 1 << precision;",
    "        this.buckets = new int[numBuckets];",
    "    }",
    "    ",
    "    HyperLogLog() { this(14); }",
    "    ",
    "    void add(String value) {",
    "        int hash = value.hashCode();",
    "        int bucket = hash & (numBuckets - 1);",
    "        int remaining = hash >>> precision;",
    "        int leadingZeros = 1;",
    "        while (remaining > 0 && (remaining & 1) == 0) {",
    "            leadingZeros++;",
    "            remaining >>>= 1;",
    "        }",
    "        buckets[bucket] = Math.max(buckets[bucket], leadingZeros);",
    "    }",
    "    ",
    "    int count() {",
    "        double alpha = 0.7213 / (1 + 1.079 / numBuckets);",
    "        double sum = 0;",
    "        for (int b : buckets) sum += Math.pow(2, -b);",
    "        return (int)(alpha * numBuckets * numBuckets / sum);",
    "    }",
    "}",
    "",
    "/**",
    " * Redis-like Sorted Set simulation.",
    " */",
    "class RedisSortedSet {",
    "    private final Map<String, Double> data = new ConcurrentHashMap<>();",
    "    ",
    "    void zadd(String member, double score) { data.put(member, score); }",
    "    void zrem(String member) { data.remove(member); }",
    "    ",
    "    List<String> zrangeByScore(double min, double max) {",
    "        List<Map.Entry<String, Double>> entries = new ArrayList<>();",
    "        for (var entry : data.entrySet()) {",
    "            if (entry.getValue() >= min && entry.getValue() <= max) {",
    "                entries.add(entry);",
    "            }",
    "        }",
    "        entries.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));",
    "        List<String> result = new ArrayList<>();",
    "        for (var entry : entries) result.add(entry.getKey());",
    "        return result;",
    "    }",
    "}",
    "",
    "/**",
    " * Instagram Stories System - Ephemeral content management.",
    " */",
    "public class InstagramStoriesSystem {",
    "    private static final long TTL_SECONDS = 24 * 60 * 60;",
    "    ",
    "    private final Map<String, Story> stories = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> userStories = new ConcurrentHashMap<>();",
    "    private final Map<String, RedisSortedSet> storyRings = new ConcurrentHashMap<>();",
    "    private final Map<String, BloomFilter> viewBloomFilters = new ConcurrentHashMap<>();",
    "    private final Map<String, HyperLogLog> viewCounts = new ConcurrentHashMap<>();",
    "    private final Map<String, List<String>> viewerLists = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> followers = new ConcurrentHashMap<>();",
    "    private final Map<String, Set<String>> following = new ConcurrentHashMap<>();",
    "    private final AtomicLong storyCounter = new AtomicLong(0);",
    "    ",
    "    private long currentTime() { return System.currentTimeMillis() / 1000; }",
    "    private boolean isExpired(Story story) { return currentTime() >= story.expiresAt; }",
    "    ",
    "    public void followUser(String followerId, String followeeId) {",
    "        following.computeIfAbsent(followerId, k -> new HashSet<>()).add(followeeId);",
    "        followers.computeIfAbsent(followeeId, k -> new HashSet<>()).add(followerId);",
    "        ",
    "        List<String> followeeStories = userStories.get(followeeId);",
    "        if (followeeStories != null && !followeeStories.isEmpty()) {",
    "            String latestId = followeeStories.get(followeeStories.size() - 1);",
    "            Story story = stories.get(latestId);",
    "            if (story != null && !isExpired(story)) {",
    "                storyRings.computeIfAbsent(followerId, k -> new RedisSortedSet())",
    "                    .zadd(followeeId, story.createdAt);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    public String postStory(String userId, byte[] media, StoryType type) {",
    "        String storyId = \"story_\" + storyCounter.incrementAndGet();",
    "        long now = currentTime();",
    "        String mediaUrl = \"https://cdn.instagram.com/stories/\" + userId + \"/\" + storyId;",
    "        ",
    "        Story story = new Story(storyId, userId, mediaUrl, type, now, now + TTL_SECONDS);",
    "        stories.put(storyId, story);",
    "        userStories.computeIfAbsent(userId, k -> new ArrayList<>()).add(storyId);",
    "        ",
    "        viewBloomFilters.put(storyId, new BloomFilter());",
    "        viewCounts.put(storyId, new HyperLogLog());",
    "        ",
    "        Set<String> userFollowers = followers.getOrDefault(userId, Set.of());",
    "        for (String followerId : userFollowers) {",
    "            storyRings.computeIfAbsent(followerId, k -> new RedisSortedSet())",
    "                .zadd(userId, now);",
    "        }",
    "        ",
    "        return storyId;",
    "    }",
    "    ",
    "    public StoryRing getStoryRing(String userId) {",
    "        long now = currentTime();",
    "        long cutoff = now - TTL_SECONDS;",
    "        ",
    "        RedisSortedSet ring = storyRings.getOrDefault(userId, new RedisSortedSet());",
    "        List<String> usersWithStories = ring.zrangeByScore(cutoff, now);",
    "        ",
    "        List<StoryRingUser> resultUsers = new ArrayList<>();",
    "        for (String storyUserId : usersWithStories) {",
    "            List<String> storyIds = userStories.get(storyUserId);",
    "            if (storyIds == null) continue;",
    "            ",
    "            List<Story> activeStories = new ArrayList<>();",
    "            for (String sid : storyIds) {",
    "                Story s = stories.get(sid);",
    "                if (s != null && !isExpired(s)) activeStories.add(s);",
    "            }",
    "            if (activeStories.isEmpty()) continue;",
    "            ",
    "            boolean hasUnviewed = false;",
    "            for (Story s : activeStories) {",
    "                BloomFilter bloom = viewBloomFilters.get(s.storyId);",
    "                if (bloom != null && !bloom.contains(userId)) {",
    "                    hasUnviewed = true;",
    "                    break;",
    "                }",
    "            }",
    "            ",
    "            long latestTime = activeStories.stream()",
    "                .mapToLong(s -> s.createdAt).max().orElse(0);",
    "            ",
    "            resultUsers.add(new StoryRingUser(",
    "                storyUserId, hasUnviewed, latestTime, activeStories.size()));",
    "        }",
    "        ",
    "        resultUsers.sort((a, b) -> {",
    "            if (a.hasUnviewed != b.hasUnviewed)",
    "                return a.hasUnviewed ? -1 : 1;",
    "            return Long.compare(b.latestStoryTime, a.latestStoryTime);",
    "        });",
    "        ",
    "        return new StoryRing(resultUsers);",
    "    }",
    "    ",
    "    public boolean markStoryViewed(String userId, String storyId) {",
    "        Story story = stories.get(storyId);",
    "        if (story == null || isExpired(story)) return false;",
    "        ",
    "        BloomFilter bloom = viewBloomFilters.get(storyId);",
    "        HyperLogLog hll = viewCounts.get(storyId);",
    "        ",
    "        if (bloom != null && !bloom.contains(userId)) {",
    "            bloom.add(userId);",
    "            if (hll != null) hll.add(userId);",
    "            viewerLists.computeIfAbsent(storyId, k -> new ArrayList<>()).add(userId);",
    "            story.viewCount = hll != null ? hll.count() :",
    "                viewerLists.getOrDefault(storyId, List.of()).size();",
    "        }",
    "        return true;",
    "    }",
    "    ",
    "    public List<String> getStoryViewers(String storyId) {",
    "        return new ArrayList<>(viewerLists.getOrDefault(storyId, List.of()));",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"     INSTAGRAM STORIES SYSTEM DEMO (Java)\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        InstagramStoriesSystem system = new InstagramStoriesSystem();",
    "        ",
    "        system.followUser(\"bob\", \"alice\");",
    "        system.followUser(\"charlie\", \"alice\");",
    "        System.out.println(\"\\n\u2713 Bob and Charlie follow Alice\");",
    "        ",
    "        String storyId = system.postStory(\"alice\", new byte[]{1,2,3}, StoryType.PHOTO);",
    "        System.out.println(\"\\n\ud83d\udcf8 Alice posted story: \" + storyId);",
    "        ",
    "        StoryRing ring = system.getStoryRing(\"bob\");",
    "        System.out.println(\"\\n\ud83d\udd35 Bob's story ring:\");",
    "        for (StoryRingUser u : ring.users) {",
    "            String status = u.hasUnviewed ? \"\ud83d\udd34 NEW\" : \"\u26aa viewed\";",
    "            System.out.println(\"   \" + u.userId + \": \" + status);",
    "        }",
    "        ",
    "        system.markStoryViewed(\"bob\", storyId);",
    "        System.out.println(\"\\n\ud83d\udc41\ufe0f Bob viewed the story\");",
    "        ",
    "        ring = system.getStoryRing(\"bob\");",
    "        System.out.println(\"\\n\ud83d\udd35 Bob's story ring after viewing:\");",
    "        for (StoryRingUser u : ring.users) {",
    "            String status = u.hasUnviewed ? \"\ud83d\udd34 NEW\" : \"\u26aa viewed\";",
    "            System.out.println(\"   \" + u.userId + \": \" + status);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\ud83d\udcca Viewers: \" + system.getStoryViewers(storyId));",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "Import statements and enum definition for StoryType (PHOTO/VIDEO)"
    },
    {
      "lines": "10-37",
      "explanation": "Data classes: Story, StoryRingUser, StoryRing - representing core domain models with all required fields"
    },
    {
      "lines": "39-73",
      "explanation": "BloomFilter implementation - O(1) probabilistic set membership with configurable false positive rate"
    },
    {
      "lines": "75-103",
      "explanation": "HyperLogLog implementation - cardinality estimator using ~12KB memory for ~2% accurate unique counts"
    },
    {
      "lines": "105-127",
      "explanation": "RedisSortedSet simulation - mimics Redis ZADD/ZRANGEBYSCORE for story ring management"
    },
    {
      "lines": "129-185",
      "explanation": "InstagramStoriesSystem class initialization - sets up all data structures including story storage, rings, view tracking"
    },
    {
      "lines": "187-230",
      "explanation": "postStory method - creates story with TTL, initializes view tracking, fan-out updates to follower rings"
    },
    {
      "lines": "232-290",
      "explanation": "getStoryRing method - retrieves users with active stories, checks view status via Bloom filter, sorts by priority"
    },
    {
      "lines": "292-330",
      "explanation": "markStoryViewed method - O(1) view tracking using Bloom filter, updates HyperLogLog counter"
    },
    {
      "lines": "332-380",
      "explanation": "main() demo function - comprehensive test of all features with formatted output"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "postStory": {
          "complexity": "O(F)",
          "explanation": "Fan-out to F followers to update their story rings"
        },
        "getStoryRing": {
          "complexity": "O(U \u00d7 S)",
          "explanation": "U users with stories \u00d7 S stories per user to check view status"
        },
        "markStoryViewed": {
          "complexity": "O(1)",
          "explanation": "Bloom filter add and HyperLogLog update are constant time"
        },
        "getStoryViewers": {
          "complexity": "O(V)",
          "explanation": "V viewers to return (paginated in production)"
        },
        "getStoryViewCount": {
          "complexity": "O(1)",
          "explanation": "HyperLogLog count estimation is O(buckets) = O(1) with fixed precision"
        }
      },
      "overall_change": "Stories operations are bounded by follower count (fan-out on write) and followed users (fan-in on read). The use of probabilistic data structures ensures view tracking remains O(1) regardless of scale."
    },
    "space": {
      "additional_space": "O(S \u00d7 B) + O(U \u00d7 R) + O(V)",
      "explanation": "S stories \u00d7 B bits per Bloom filter (~1.2MB per story), U users \u00d7 R ring entries, V total view events in append logs. HyperLogLog uses fixed 12KB per story."
    }
  },
  "dry_run": {
    "example_input": "postStory('alice', media, PHOTO) \u2192 getStoryRing('bob') \u2192 markStoryViewed('bob', 'story_1') \u2192 getStoryRing('bob')",
    "steps": [
      {
        "step": 1,
        "action": "postStory('alice', media, PHOTO)",
        "state": "stories={'story_1': Story}, user_stories={'alice': ['story_1']}, story_rings={'bob': {alice: 1699900000}}",
        "explanation": "Alice posts story, Bob's ring updated since Bob follows Alice"
      },
      {
        "step": 2,
        "action": "getStoryRing('bob')",
        "state": "Query ring for bob, find alice with score in range, check bloom filter for 'bob' - not present",
        "explanation": "Returns StoryRing with alice marked as has_unviewed=True"
      },
      {
        "step": 3,
        "action": "markStoryViewed('bob', 'story_1')",
        "state": "bloom_filters['story_1'].add('bob'), hll['story_1'].add('bob'), viewer_lists['story_1']=['bob']",
        "explanation": "Bob added to Bloom filter and HyperLogLog for story_1"
      },
      {
        "step": 4,
        "action": "getStoryRing('bob')",
        "state": "Query ring, check bloom filter for 'bob' - now contains 'bob'",
        "explanation": "Returns StoryRing with alice marked as has_unviewed=False"
      }
    ],
    "final_output": "['story_1', {users: [{userId: 'alice', hasUnviewed: true}]}, true, {users: [{userId: 'alice', hasUnviewed: false}]}]"
  },
  "edge_cases": [
    {
      "case": "User views expired story",
      "handling": "Check expiration before marking viewed, return False",
      "gotcha": "Must check TTL even if story object exists in memory"
    },
    {
      "case": "Duplicate view events",
      "handling": "Bloom filter check prevents duplicate processing",
      "gotcha": "HyperLogLog naturally handles duplicates but Bloom filter prevents unnecessary writes"
    },
    {
      "case": "User unfollows then views ring",
      "handling": "Ring should no longer contain unfollowed user",
      "gotcha": "Need to clean up story ring on unfollow"
    },
    {
      "case": "Celebrity with millions of followers posts story",
      "handling": "Async fan-out via message queue, rate limiting",
      "gotcha": "Synchronous fan-out blocks the upload - must be async"
    },
    {
      "case": "User checks ring for someone with 1000 stories",
      "handling": "Pagination with cursor-based navigation",
      "gotcha": "Returning all stories at once is too expensive"
    },
    {
      "case": "Bloom filter false positive",
      "handling": "Acceptable - user sees story as viewed when they haven't",
      "gotcha": "False positive rate must be tuned (<1%) to avoid user complaints"
    }
  ],
  "test_cases": [
    {
      "name": "Basic story posting and ring update",
      "input": "follow(bob, alice), postStory(alice), getStoryRing(bob)",
      "expected": "Ring contains alice with hasUnviewed=True",
      "explanation": "Bob follows Alice, Alice posts, Bob's ring should show Alice"
    },
    {
      "name": "View tracking updates ring status",
      "input": "markStoryViewed(bob, story_1), getStoryRing(bob)",
      "expected": "Ring contains alice with hasUnviewed=False",
      "explanation": "After Bob views, hasUnviewed flag should flip"
    },
    {
      "name": "Multiple stories from same user",
      "input": "postStory(alice), postStory(alice), getStoryRing(bob)",
      "expected": "Ring shows alice with storyCount=2",
      "explanation": "Story count should reflect all active stories"
    },
    {
      "name": "Story ring sorting priority",
      "input": "postStory(alice, t=100), postStory(bob, t=200), markStoryViewed(charlie, alice_story), getStoryRing(charlie)",
      "expected": "Order: [bob (unviewed, newer), alice (viewed)]",
      "explanation": "Unviewed stories appear first, then sorted by recency"
    },
    {
      "name": "Viewer list tracking",
      "input": "markStoryViewed(bob), markStoryViewed(charlie), getStoryViewers(story)",
      "expected": "['bob', 'charlie']",
      "explanation": "Both viewers should be recorded"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using SQL table for view tracking",
      "why_wrong": "Billions of view events/day would overwhelm any relational database with individual row inserts",
      "correct_approach": "Use Bloom filter for 'has viewed' check, append-only log for viewer list",
      "code_example_wrong": "INSERT INTO views (story_id, user_id) VALUES (?, ?)",
      "code_example_correct": "bloom_filter.add(user_id)  # O(1), fixed memory"
    },
    {
      "mistake": "Synchronous fan-out for celebrity posts",
      "why_wrong": "User with 10M followers would wait for 10M updates before upload completes",
      "correct_approach": "Async fan-out via message queue (Kafka/SQS)",
      "code_example_wrong": "for follower in followers: update_ring(follower)  # Blocks",
      "code_example_correct": "kafka.send('story-ring-updates', {user: userId, followers: followers})"
    },
    {
      "mistake": "CRON job for TTL cleanup",
      "why_wrong": "With 500M stories/day, cleanup job would delete millions of rows per run, causing performance issues",
      "correct_approach": "Use Cassandra TTL for automatic deletion at storage layer",
      "code_example_wrong": "DELETE FROM stories WHERE expires_at < NOW()  # Heavy query",
      "code_example_correct": "INSERT INTO stories ... USING TTL 86400  # Auto-deletes"
    },
    {
      "mistake": "Storing full viewer list for view count",
      "why_wrong": "Story with 1M views needs 1M user IDs just to count them",
      "correct_approach": "HyperLogLog provides cardinality estimate in constant space (~12KB)",
      "code_example_wrong": "view_count = len(viewer_list)  # O(n) space",
      "code_example_correct": "view_count = hyperloglog.count()  # O(1) space, ~2% error"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by acknowledging the scale challenge (500M stories/day, billions of views). Explain why traditional approaches fail, then introduce probabilistic data structures as the key insight. Draw the architecture diagram showing separation of concerns: TTL storage, view tracking, and story ring.",
    "what_to_mention": [
      "TTL-based storage eliminates cleanup jobs entirely",
      "Bloom filter trade-off: accept <1% false positives for O(1) lookups",
      "HyperLogLog for counts: ~2% error is acceptable for analytics",
      "Separate 'has viewed' (fast) from 'viewer list' (eventually consistent)",
      "Async fan-out for high-follower accounts via message queues",
      "Redis sorted sets enable O(log N) ring updates and O(F) retrieval"
    ],
    "time_allocation": "Spend 5 min on requirements/scale, 8 min on architecture and data structures, 5 min on API design, 2 min on edge cases",
    "if_stuck": [
      "Think about what's unique about Stories vs Posts \u2192 ephemeral nature, high view volume",
      "Consider: How does Instagram show the story ring instantly? \u2192 Pre-computed, not queried on demand",
      "What if we don't need exact view counts? \u2192 Opens door for probabilistic structures",
      "How do we avoid cleanup jobs at scale? \u2192 Storage-layer TTL (Cassandra)"
    ]
  },
  "connection_to_next_part": "Part 3 might introduce Direct Messages with disappearing messages (combines Stories TTL with real-time delivery), or explore the Explore/Discover page which requires content ranking and recommendation algorithms. The Bloom filter pattern from Stories extends naturally to 'seen' tracking for recommendations, and HyperLogLog applies to engagement metrics across the platform.",
  "generated_at": "2026-01-14T15:29:39.729779",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}