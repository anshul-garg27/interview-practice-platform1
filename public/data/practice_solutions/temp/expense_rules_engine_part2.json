{
  "problem_title": "Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 handled **individual expense validation** where each expense is evaluated in isolation. Part 2 introduces **trip-level aggregation rules** that must examine multiple expenses together to compute totals and enforce limits across an entire business trip. This fundamentally changes the evaluation model from 'one expense \u2192 one rule check' to 'all trip expenses \u2192 aggregated rule check'.",
    "new_requirements": [
      "Group expenses by trip_id before evaluation",
      "Sum expenses across a trip for TripTotalLimitRule",
      "Sum expenses by type within a trip for ExpenseTypeAggregationRule",
      "Report all contributing expense IDs in violations for transparency",
      "Support a new AggregationRule interface distinct from individual ExpenseRule"
    ],
    "new_constraints": [
      "Aggregation rules operate on List<Expense> not single Expense",
      "Violations must include trip_id and contributing_expenses list",
      "Must handle multiple trips in a single evaluation batch",
      "Empty trips or trips with no matching expense types should not generate violations"
    ],
    "key_insight": "The crucial insight is that aggregation rules require a **pre-processing step** to group expenses by trip_id using a HashMap. This transforms O(e \u00d7 r) individual checks into O(e) grouping + O(t \u00d7 r) trip checks, where t is the number of trips. The different evaluation model necessitates a separate interface (AggregationRule vs ExpenseRule) to maintain clean separation of concerns."
  },
  "visual_explanation": {
    "before_after": "```\n PART 1: Individual Evaluation          PART 2: Aggregation Evaluation\n \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n                                        \n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Expense \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502 E001    \u2502 \u2502 E002    \u2502 \u2502 E003    \u2502\n \u2502   E001  \u2502       \u2502                    \u2502 T001    \u2502 \u2502 T001    \u2502 \u2502 T002    \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u25bc                    \u2502 $150    \u2502 \u2502 $200    \u2502 \u2502 $100    \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n              \u2502 Rule 1  \u2502                    \u2502          \u2502          \u2502\n              \u2502 Check   \u2502                    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502                \u2502\n                                                  \u25bc                \u25bc\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2502 Expense \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502   Trip T001     \u2502 \u2502  Trip T002  \u2502\n \u2502   E002  \u2502       \u2502                    \u2502 [E001, E002]    \u2502 \u2502   [E003]    \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u25bc                    \u2502 Total: $350     \u2502 \u2502 Total: $100 \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502 Rule 1  \u2502                        \u2502                 \u2502\n              \u2502 Check   \u2502                        \u25bc                 \u25bc\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                        \u2502 TripTotalLimit  \u2502 \u2502 TripTotal   \u2502\n Each expense checked                   \u2502 $300 limit      \u2502 \u2502 $300 limit  \u2502\n INDEPENDENTLY                          \u2502 \u274c VIOLATION    \u2502 \u2502 \u2713 PASS      \u2502\n                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502     Input: List<Expense>            \u2502\n                    \u2502  [E001, E002, E003, E004, E005]     \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                                       \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          Step 1:   \u2502      GROUP BY trip_id               \u2502\n                    \u2502  HashMap<TripId, List<Expense>>     \u2502\n                    \u2502                                     \u2502\n                    \u2502  T001 \u2192 [E001, E002]                \u2502\n                    \u2502  T002 \u2192 [E003, E004, E005]          \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                                     \u2502\n                    \u25bc                                     \u25bc\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n Step 2:  \u2502   Process Trip T001 \u2502           \u2502   Process Trip T002 \u2502\n          \u2502   expenses: 2       \u2502           \u2502   expenses: 3       \u2502\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502                                 \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u25bc                     \u25bc           \u25bc                     \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502TripTotalLimit \u2502    \u2502ExpenseType    \u2502    \u2502TripTotalLimit \u2502    \u2502ExpenseType    \u2502\n  \u2502Rule: $300     \u2502    \u2502Aggregation    \u2502    \u2502Rule: $300     \u2502    \u2502Aggregation    \u2502\n  \u2502               \u2502    \u2502meals: $200    \u2502    \u2502               \u2502    \u2502meals: $200    \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502                    \u2502                    \u2502                    \u2502\n          \u25bc                    \u25bc                    \u25bc                    \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 Sum all       \u2502    \u2502 Filter meals  \u2502    \u2502 Sum all       \u2502    \u2502 Filter meals  \u2502\n  \u2502 expenses      \u2502    \u2502 Sum amounts   \u2502    \u2502 expenses      \u2502    \u2502 Sum amounts   \u2502\n  \u2502 Compare limit \u2502    \u2502 Compare limit \u2502    \u2502 Compare limit \u2502    \u2502 Compare limit \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                       \u2502\n                                       \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          Step 3:   \u2502     Collect All Violations          \u2502\n                    \u2502  Each violation includes:           \u2502\n                    \u2502  - trip_id                          \u2502\n                    \u2502  - rule name                        \u2502\n                    \u2502  - reason with amounts              \u2502\n                    \u2502  - contributing_expenses list       \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Evaluate Per Expense",
      "description": "Extend Part 1 by having aggregation rules maintain internal state. Each expense updates running totals, and violations are checked after processing all expenses. This mixes stateful and stateless evaluation, leading to complexity.",
      "time_complexity": "O(e \u00d7 r)",
      "space_complexity": "O(t \u00d7 r) for tracking state per trip per rule",
      "why_not_optimal": "This approach conflates two different concerns: individual expense validation and trip-level aggregation. Maintaining mutable state in rules breaks the clean functional design of Part 1, makes rules harder to test in isolation, and creates potential concurrency issues. It also requires awkward 'finalize' calls to check accumulated totals."
    },
    {
      "name": "Optimal Approach - Pre-Group Then Evaluate",
      "description": "Create a separate AggregationRule interface that receives a complete list of expenses for a trip. Pre-process expenses into HashMap<String, List<Expense>> grouped by trip_id, then iterate through trips applying aggregation rules. This maintains clean separation between individual and aggregation rules.",
      "time_complexity": "O(e + t \u00d7 r \u00d7 avg_expenses_per_trip)",
      "space_complexity": "O(e) for the grouping HashMap",
      "key_insight": "Treat aggregation as a fundamentally different operation with its own interface. The single-pass grouping step (O(e)) enables efficient trip-level evaluation without redundant iteration. Rules remain stateless and testable."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution introduces a **clean architectural separation** between individual expense rules and aggregation rules:\n\n1. **New `AggregationRule` Interface**: Unlike `ExpenseRule.evaluate(expense)`, the new interface is `AggregationRule.evaluate(trip_id, List<Expense>)`. This clearly communicates that these rules operate on collections.\n\n2. **Pre-Processing with HashMap**: Before evaluating aggregation rules, we group all expenses by `trip_id` in a single O(n) pass using `defaultdict(list)`. This creates a lookup table where each trip maps to its complete expense list.\n\n3. **Trip-Scoped Violations**: When an aggregation rule finds a violation, it reports:\n   - The `trip_id` (not individual `expense_id`)\n   - All `contributing_expenses` that caused the violation\n   - A descriptive reason with actual vs. limit amounts\n\n4. **Two Concrete Rules**:\n   - **`TripTotalLimitRule`**: Sums `amount_usd` across ALL expenses for a trip\n   - **`ExpenseTypeAggregationRule`**: Filters expenses by type, THEN sums amounts\n\n5. **Unified Engine**: The `ExpenseRulesEngine` manages both rule types and provides `evaluate_all()` for comprehensive checking.",
    "data_structures": [
      {
        "structure": "HashMap<String, List<Expense>>",
        "purpose": "Groups expenses by trip_id for efficient aggregation. O(1) lookup per trip."
      },
      {
        "structure": "List<AggregationRule>",
        "purpose": "Stores configured aggregation rules for iteration during evaluation."
      },
      {
        "structure": "Violation dataclass",
        "purpose": "Extended to include optional trip_id and contributing_expenses for aggregation violations."
      }
    ],
    "algorithm_steps": [
      "Step 1: Receive list of all expenses to evaluate",
      "Step 2: Build trip_expenses HashMap by iterating expenses once, appending each to its trip_id's list",
      "Step 3: For each (trip_id, expense_list) pair in the HashMap:",
      "Step 4:   For each AggregationRule configured in the engine:",
      "Step 5:     Call rule.evaluate(trip_id, expense_list)",
      "Step 6:     If violation returned, add to violations list",
      "Step 7: Return complete list of aggregation violations"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
    "",
    "This module extends Part 1 with aggregation rules that evaluate expenses",
    "at the trip level, enabling total spending limits and category-based limits.",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from decimal import Decimal",
    "from dataclasses import dataclass, field",
    "from typing import List, Dict, Optional, Set",
    "from collections import defaultdict",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DATA CLASSES",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Represents a single corporate expense.\"\"\"",
    "    expense_id: str",
    "    trip_id: str",
    "    amount_usd: Decimal",
    "    expense_type: str",
    "    vendor_type: str",
    "    vendor_name: str",
    "    ",
    "    @classmethod",
    "    def from_dict(cls, data: dict) -> 'Expense':",
    "        \"\"\"Factory method to create Expense from dictionary.\"\"\"",
    "        return cls(",
    "            expense_id=data['expense_id'],",
    "            trip_id=data['trip_id'],",
    "            amount_usd=Decimal(data['amount_usd']),",
    "            expense_type=data['expense_type'],",
    "            vendor_type=data['vendor_type'],",
    "            vendor_name=data['vendor_name']",
    "        )",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"",
    "    Represents a rule violation.",
    "    ",
    "    For individual rules: expense_id is set, trip_id is context",
    "    For aggregation rules: trip_id is primary, contributing_expenses lists all involved",
    "    \"\"\"",
    "    expense_id: Optional[str]",
    "    trip_id: Optional[str]",
    "    rule: str",
    "    reason: str",
    "    contributing_expenses: List[str] = field(default_factory=list)",
    "    ",
    "    def to_dict(self) -> dict:",
    "        \"\"\"Convert violation to dictionary for output.\"\"\"",
    "        result = {",
    "            'rule': self.rule,",
    "            'reason': self.reason",
    "        }",
    "        if self.expense_id:",
    "            result['expense_id'] = self.expense_id",
    "        if self.trip_id:",
    "            result['trip_id'] = self.trip_id",
    "        if self.contributing_expenses:",
    "            result['contributing_expenses'] = self.contributing_expenses",
    "        return result",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# PART 1: INDIVIDUAL EXPENSE RULES",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class ExpenseRule(ABC):",
    "    \"\"\"Abstract base class for individual expense rules.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"Evaluate a single expense against this rule.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the rule name for violation reporting.\"\"\"",
    "        pass",
    "",
    "",
    "class MaxAmountRule(ExpenseRule):",
    "    \"\"\"Rejects any single expense exceeding the maximum amount.\"\"\"",
    "    ",
    "    def __init__(self, max_amount: float):",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        if expense.amount_usd > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                trip_id=expense.trip_id,",
    "                rule=self.get_name(),",
    "                reason=f\"amount ${expense.amount_usd:.2f} exceeds limit ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"MaxAmountRule\"",
    "",
    "",
    "class BlockedVendorTypeRule(ExpenseRule):",
    "    \"\"\"Rejects expenses from blocked vendor types.\"\"\"",
    "    ",
    "    def __init__(self, blocked_types: Set[str]):",
    "        self.blocked_types = blocked_types",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        if expense.vendor_type in self.blocked_types:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                trip_id=expense.trip_id,",
    "                rule=self.get_name(),",
    "                reason=f\"vendor type '{expense.vendor_type}' is blocked\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"BlockedVendorTypeRule\"",
    "",
    "",
    "class VendorTypeLimitRule(ExpenseRule):",
    "    \"\"\"Sets a maximum amount for a specific vendor type.\"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: float):",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        if expense.vendor_type == self.vendor_type and expense.amount_usd > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                trip_id=expense.trip_id,",
    "                rule=self.get_name(),",
    "                reason=f\"amount ${expense.amount_usd:.2f} for '{self.vendor_type}' exceeds limit ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"VendorTypeLimitRule\"",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# PART 2: AGGREGATION RULES (NEW)",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class AggregationRule(ABC):",
    "    \"\"\"",
    "    Abstract base class for trip-level aggregation rules.",
    "    ",
    "    Unlike ExpenseRule which evaluates one expense at a time,",
    "    AggregationRule receives ALL expenses for a trip and can",
    "    compute totals, averages, or other aggregate metrics.",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[Violation]:",
    "        \"\"\"",
    "        Evaluate all expenses for a trip against this rule.",
    "        ",
    "        Args:",
    "            trip_id: The trip identifier",
    "            expenses: All expenses belonging to this trip",
    "            ",
    "        Returns:",
    "            Violation if rule is violated, None otherwise",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the rule name for violation reporting.\"\"\"",
    "        pass",
    "",
    "",
    "class TripTotalLimitRule(AggregationRule):",
    "    \"\"\"",
    "    Enforces a maximum total spending limit per trip.",
    "    ",
    "    Sums all expense amounts for a trip and compares against",
    "    the configured maximum. All expenses contribute to the total.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_trip_total: float):",
    "        \"\"\"",
    "        Initialize with maximum allowed trip total.",
    "        ",
    "        Args:",
    "            max_trip_total: Maximum sum of all expenses per trip",
    "        \"\"\"",
    "        self.max_trip_total = Decimal(str(max_trip_total))",
    "    ",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[Violation]:",
    "        if not expenses:",
    "            return None",
    "        ",
    "        total = sum(e.amount_usd for e in expenses)",
    "        ",
    "        if total > self.max_trip_total:",
    "            return Violation(",
    "                expense_id=None,",
    "                trip_id=trip_id,",
    "                rule=self.get_name(),",
    "                reason=f\"trip total ${total:.2f} exceeds limit ${self.max_trip_total:.2f}\",",
    "                contributing_expenses=[e.expense_id for e in expenses]",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"TripTotalLimitRule\"",
    "",
    "",
    "class ExpenseTypeAggregationRule(AggregationRule):",
    "    \"\"\"",
    "    Enforces a spending limit for a specific expense type per trip.",
    "    ",
    "    Filters expenses by type (e.g., 'meals'), sums their amounts,",
    "    and compares against the configured maximum.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, expense_type: str, max_amount: float):",
    "        \"\"\"",
    "        Initialize with expense type and its limit.",
    "        ",
    "        Args:",
    "            expense_type: Type to track (e.g., 'meals', 'lodging')",
    "            max_amount: Maximum sum for this type per trip",
    "        \"\"\"",
    "        self.expense_type = expense_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[Violation]:",
    "        # Filter to only matching expense types",
    "        matching_expenses = [",
    "            e for e in expenses if e.expense_type == self.expense_type",
    "        ]",
    "        ",
    "        if not matching_expenses:",
    "            return None",
    "        ",
    "        total = sum(e.amount_usd for e in matching_expenses)",
    "        ",
    "        if total > self.max_amount:",
    "            return Violation(",
    "                expense_id=None,",
    "                trip_id=trip_id,",
    "                rule=self.get_name(),",
    "                reason=f\"{self.expense_type} total ${total:.2f} exceeds limit ${self.max_amount:.2f}\",",
    "                contributing_expenses=[e.expense_id for e in matching_expenses]",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"ExpenseTypeAggregationRule\"",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# RULES ENGINE",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"",
    "    Central engine for evaluating expenses against configured rules.",
    "    ",
    "    Supports two categories of rules:",
    "    1. Individual rules: Evaluate each expense independently",
    "    2. Aggregation rules: Evaluate expenses grouped by trip",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.individual_rules: List[ExpenseRule] = []",
    "        self.aggregation_rules: List[AggregationRule] = []",
    "    ",
    "    def add_individual_rule(self, rule: ExpenseRule) -> None:",
    "        \"\"\"Add an individual expense rule to the engine.\"\"\"",
    "        self.individual_rules.append(rule)",
    "    ",
    "    def add_aggregation_rule(self, rule: AggregationRule) -> None:",
    "        \"\"\"Add a trip-level aggregation rule to the engine.\"\"\"",
    "        self.aggregation_rules.append(rule)",
    "    ",
    "    def evaluate_individual_rules(self, expenses: List[Expense]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate each expense against all individual rules.",
    "        ",
    "        Args:",
    "            expenses: List of expenses to evaluate",
    "            ",
    "        Returns:",
    "            List of violations from individual rule checks",
    "        \"\"\"",
    "        violations = []",
    "        for expense in expenses:",
    "            for rule in self.individual_rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "    ",
    "    def _group_expenses_by_trip(self, expenses: List[Expense]) -> Dict[str, List[Expense]]:",
    "        \"\"\"",
    "        Group expenses by trip_id for aggregation processing.",
    "        ",
    "        Time Complexity: O(n) where n is number of expenses",
    "        Space Complexity: O(n) for the resulting dictionary",
    "        \"\"\"",
    "        trip_expenses: Dict[str, List[Expense]] = defaultdict(list)",
    "        for expense in expenses:",
    "            trip_expenses[expense.trip_id].append(expense)",
    "        return dict(trip_expenses)",
    "    ",
    "    def evaluate_aggregation_rules(self, expenses: List[Expense]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate expenses grouped by trip against aggregation rules.",
    "        ",
    "        This method:",
    "        1. Groups expenses by trip_id (single pass)",
    "        2. For each trip, applies all aggregation rules",
    "        3. Collects and returns all violations",
    "        ",
    "        Args:",
    "            expenses: List of all expenses to evaluate",
    "            ",
    "        Returns:",
    "            List of violations from aggregation rule checks",
    "        \"\"\"",
    "        violations = []",
    "        trip_expenses = self._group_expenses_by_trip(expenses)",
    "        ",
    "        for trip_id, trip_exp_list in trip_expenses.items():",
    "            for rule in self.aggregation_rules:",
    "                violation = rule.evaluate(trip_id, trip_exp_list)",
    "                if violation:",
    "                    violations.append(violation)",
    "        ",
    "        return violations",
    "    ",
    "    def evaluate_all(self, expenses: List[Expense]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate expenses against all configured rules.",
    "        ",
    "        Combines individual and aggregation rule evaluation.",
    "        ",
    "        Args:",
    "            expenses: List of all expenses to evaluate",
    "            ",
    "        Returns:",
    "            Combined list of all violations",
    "        \"\"\"",
    "        individual_violations = self.evaluate_individual_rules(expenses)",
    "        aggregation_violations = self.evaluate_aggregation_rules(expenses)",
    "        return individual_violations + aggregation_violations",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DEMO AND TESTING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "def main():",
    "    \"\"\"Demonstrate the expense rules engine with Part 2 aggregation rules.\"\"\"",
    "    ",
    "    print(\"=\"*70)",
    "    print(\"CORPORATE EXPENSE RULES ENGINE - PART 2 DEMO\")",
    "    print(\"=\"*70)",
    "    ",
    "    # Create engine and configure rules",
    "    engine = ExpenseRulesEngine()",
    "    ",
    "    # Part 1 rules",
    "    engine.add_individual_rule(MaxAmountRule(500))",
    "    engine.add_individual_rule(BlockedVendorTypeRule({'casino', 'liquor_store'}))",
    "    ",
    "    # Part 2 aggregation rules",
    "    engine.add_aggregation_rule(TripTotalLimitRule(300))",
    "    engine.add_aggregation_rule(ExpenseTypeAggregationRule('meals', 200))",
    "    ",
    "    # Example 1: Trip total limit violation",
    "    print(\"\\n\" + \"-\"*70)",
    "    print(\"TEST 1: Trip Total Limit Rule\")",
    "    print(\"-\"*70)",
    "    ",
    "    expenses1 = [",
    "        Expense.from_dict({",
    "            'expense_id': 'E001', 'trip_id': 'T001',",
    "            'amount_usd': '150.00', 'expense_type': 'meals',",
    "            'vendor_type': 'restaurant', 'vendor_name': 'Steakhouse'",
    "        }),",
    "        Expense.from_dict({",
    "            'expense_id': 'E002', 'trip_id': 'T001',",
    "            'amount_usd': '200.00', 'expense_type': 'lodging',",
    "            'vendor_type': 'hotel', 'vendor_name': 'Marriott'",
    "        }),",
    "        Expense.from_dict({",
    "            'expense_id': 'E003', 'trip_id': 'T002',",
    "            'amount_usd': '100.00', 'expense_type': 'meals',",
    "            'vendor_type': 'restaurant', 'vendor_name': 'Cafe'",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for e in expenses1:",
    "        print(f\"  {e.expense_id} | Trip: {e.trip_id} | ${e.amount_usd} | {e.expense_type}\")",
    "    ",
    "    violations1 = engine.evaluate_aggregation_rules(expenses1)",
    "    print(f\"\\nAggregation Violations Found: {len(violations1)}\")",
    "    for v in violations1:",
    "        print(f\"  Trip: {v.trip_id}\")",
    "        print(f\"  Rule: {v.rule}\")",
    "        print(f\"  Reason: {v.reason}\")",
    "        print(f\"  Contributing Expenses: {v.contributing_expenses}\")",
    "        print()",
    "    ",
    "    # Example 2: Expense type aggregation violation",
    "    print(\"-\"*70)",
    "    print(\"TEST 2: Expense Type Aggregation Rule (meals limit)\")",
    "    print(\"-\"*70)",
    "    ",
    "    expenses2 = [",
    "        Expense.from_dict({",
    "            'expense_id': 'E001', 'trip_id': 'T001',",
    "            'amount_usd': '80.00', 'expense_type': 'meals',",
    "            'vendor_type': 'restaurant', 'vendor_name': 'Restaurant A'",
    "        }),",
    "        Expense.from_dict({",
    "            'expense_id': 'E002', 'trip_id': 'T001',",
    "            'amount_usd': '150.00', 'expense_type': 'meals',",
    "            'vendor_type': 'restaurant', 'vendor_name': 'Restaurant B'",
    "        }),",
    "        Expense.from_dict({",
    "            'expense_id': 'E003', 'trip_id': 'T001',",
    "            'amount_usd': '500.00', 'expense_type': 'lodging',",
    "            'vendor_type': 'hotel', 'vendor_name': 'Hotel C'",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for e in expenses2:",
    "        print(f\"  {e.expense_id} | Trip: {e.trip_id} | ${e.amount_usd} | {e.expense_type}\")",
    "    ",
    "    # Create new engine with only expense type rule for clarity",
    "    engine2 = ExpenseRulesEngine()",
    "    engine2.add_aggregation_rule(ExpenseTypeAggregationRule('meals', 200))",
    "    ",
    "    violations2 = engine2.evaluate_aggregation_rules(expenses2)",
    "    print(f\"\\nMeals Aggregation Violations: {len(violations2)}\")",
    "    for v in violations2:",
    "        print(f\"  Trip: {v.trip_id}\")",
    "        print(f\"  Rule: {v.rule}\")",
    "        print(f\"  Reason: {v.reason}\")",
    "        print(f\"  Contributing Expenses: {v.contributing_expenses}\")",
    "        print()",
    "    ",
    "    # Example 3: Combined evaluation (individual + aggregation)",
    "    print(\"-\"*70)",
    "    print(\"TEST 3: Combined Individual + Aggregation Rules\")",
    "    print(\"-\"*70)",
    "    ",
    "    expenses3 = [",
    "        Expense.from_dict({",
    "            'expense_id': 'E001', 'trip_id': 'T001',",
    "            'amount_usd': '600.00', 'expense_type': 'equipment',",
    "            'vendor_type': 'electronics', 'vendor_name': 'BestBuy'",
    "        }),",
    "        Expense.from_dict({",
    "            'expense_id': 'E002', 'trip_id': 'T001',",
    "            'amount_usd': '100.00', 'expense_type': 'meals',",
    "            'vendor_type': 'restaurant', 'vendor_name': 'Diner'",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for e in expenses3:",
    "        print(f\"  {e.expense_id} | Trip: {e.trip_id} | ${e.amount_usd} | {e.expense_type}\")",
    "    ",
    "    all_violations = engine.evaluate_all(expenses3)",
    "    print(f\"\\nAll Violations Found: {len(all_violations)}\")",
    "    for v in all_violations:",
    "        if v.expense_id:",
    "            print(f\"  [Individual] Expense: {v.expense_id} - {v.rule}: {v.reason}\")",
    "        else:",
    "            print(f\"  [Aggregation] Trip: {v.trip_id} - {v.rule}: {v.reason}\")",
    "    ",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"DEMO COMPLETE\")",
    "    print(\"=\"*70)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
    " * ",
    " * Extends Part 1 with aggregation rules that evaluate expenses grouped by trip.",
    " */",
    "public class ExpenseRulesEngine {",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DATA CLASSES",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public static class Expense {",
    "        private final String expenseId;",
    "        private final String tripId;",
    "        private final BigDecimal amountUsd;",
    "        private final String expenseType;",
    "        private final String vendorType;",
    "        private final String vendorName;",
    "",
    "        public Expense(String expenseId, String tripId, String amountUsd,",
    "                      String expenseType, String vendorType, String vendorName) {",
    "            this.expenseId = expenseId;",
    "            this.tripId = tripId;",
    "            this.amountUsd = new BigDecimal(amountUsd);",
    "            this.expenseType = expenseType;",
    "            this.vendorType = vendorType;",
    "            this.vendorName = vendorName;",
    "        }",
    "",
    "        public String getExpenseId() { return expenseId; }",
    "        public String getTripId() { return tripId; }",
    "        public BigDecimal getAmountUsd() { return amountUsd; }",
    "        public String getExpenseType() { return expenseType; }",
    "        public String getVendorType() { return vendorType; }",
    "        public String getVendorName() { return vendorName; }",
    "    }",
    "",
    "    public static class Violation {",
    "        private final String expenseId;  // For individual rules",
    "        private final String tripId;     // For aggregation rules",
    "        private final String rule;",
    "        private final String reason;",
    "        private final List<String> contributingExpenses;",
    "",
    "        // Constructor for individual rule violations",
    "        public Violation(String expenseId, String tripId, String rule, String reason) {",
    "            this(expenseId, tripId, rule, reason, new ArrayList<>());",
    "        }",
    "",
    "        // Constructor for aggregation rule violations",
    "        public Violation(String expenseId, String tripId, String rule,",
    "                        String reason, List<String> contributingExpenses) {",
    "            this.expenseId = expenseId;",
    "            this.tripId = tripId;",
    "            this.rule = rule;",
    "            this.reason = reason;",
    "            this.contributingExpenses = contributingExpenses;",
    "        }",
    "",
    "        public String getExpenseId() { return expenseId; }",
    "        public String getTripId() { return tripId; }",
    "        public String getRule() { return rule; }",
    "        public String getReason() { return reason; }",
    "        public List<String> getContributingExpenses() { return contributingExpenses; }",
    "",
    "        @Override",
    "        public String toString() {",
    "            if (expenseId != null) {",
    "                return String.format(\"[Individual] %s - %s: %s\", expenseId, rule, reason);",
    "            }",
    "            return String.format(\"[Aggregation] Trip %s - %s: %s (expenses: %s)\",",
    "                    tripId, rule, reason, contributingExpenses);",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 1: INDIVIDUAL EXPENSE RULES",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public interface ExpenseRule {",
    "        Optional<Violation> evaluate(Expense expense);",
    "        String getName();",
    "    }",
    "",
    "    public static class MaxAmountRule implements ExpenseRule {",
    "        private final BigDecimal maxAmount;",
    "",
    "        public MaxAmountRule(double maxAmount) {",
    "            this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "        }",
    "",
    "        @Override",
    "        public Optional<Violation> evaluate(Expense expense) {",
    "            if (expense.getAmountUsd().compareTo(maxAmount) > 0) {",
    "                String reason = String.format(\"amount $%.2f exceeds limit $%.2f\",",
    "                        expense.getAmountUsd(), maxAmount);",
    "                return Optional.of(new Violation(",
    "                        expense.getExpenseId(), expense.getTripId(), getName(), reason));",
    "            }",
    "            return Optional.empty();",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return \"MaxAmountRule\"; }",
    "    }",
    "",
    "    public static class BlockedVendorTypeRule implements ExpenseRule {",
    "        private final Set<String> blockedTypes;",
    "",
    "        public BlockedVendorTypeRule(Set<String> blockedTypes) {",
    "            this.blockedTypes = blockedTypes;",
    "        }",
    "",
    "        @Override",
    "        public Optional<Violation> evaluate(Expense expense) {",
    "            if (blockedTypes.contains(expense.getVendorType())) {",
    "                String reason = String.format(\"vendor type '%s' is blocked\",",
    "                        expense.getVendorType());",
    "                return Optional.of(new Violation(",
    "                        expense.getExpenseId(), expense.getTripId(), getName(), reason));",
    "            }",
    "            return Optional.empty();",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return \"BlockedVendorTypeRule\"; }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 2: AGGREGATION RULES (NEW)",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    /**",
    "     * Interface for trip-level aggregation rules.",
    "     * Unlike ExpenseRule, these receive ALL expenses for a trip.",
    "     */",
    "    public interface AggregationRule {",
    "        Optional<Violation> evaluate(String tripId, List<Expense> expenses);",
    "        String getName();",
    "    }",
    "",
    "    /**",
    "     * Enforces a maximum total spending limit per trip.",
    "     */",
    "    public static class TripTotalLimitRule implements AggregationRule {",
    "        private final BigDecimal maxTripTotal;",
    "",
    "        public TripTotalLimitRule(double maxTripTotal) {",
    "            this.maxTripTotal = BigDecimal.valueOf(maxTripTotal);",
    "        }",
    "",
    "        @Override",
    "        public Optional<Violation> evaluate(String tripId, List<Expense> expenses) {",
    "            if (expenses.isEmpty()) {",
    "                return Optional.empty();",
    "            }",
    "",
    "            BigDecimal total = expenses.stream()",
    "                    .map(Expense::getAmountUsd)",
    "                    .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "",
    "            if (total.compareTo(maxTripTotal) > 0) {",
    "                List<String> contributingIds = expenses.stream()",
    "                        .map(Expense::getExpenseId)",
    "                        .collect(Collectors.toList());",
    "",
    "                String reason = String.format(\"trip total $%.2f exceeds limit $%.2f\",",
    "                        total, maxTripTotal);",
    "",
    "                return Optional.of(new Violation(",
    "                        null, tripId, getName(), reason, contributingIds));",
    "            }",
    "            return Optional.empty();",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return \"TripTotalLimitRule\"; }",
    "    }",
    "",
    "    /**",
    "     * Enforces a spending limit for a specific expense type per trip.",
    "     */",
    "    public static class ExpenseTypeAggregationRule implements AggregationRule {",
    "        private final String expenseType;",
    "        private final BigDecimal maxAmount;",
    "",
    "        public ExpenseTypeAggregationRule(String expenseType, double maxAmount) {",
    "            this.expenseType = expenseType;",
    "            this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "        }",
    "",
    "        @Override",
    "        public Optional<Violation> evaluate(String tripId, List<Expense> expenses) {",
    "            List<Expense> matchingExpenses = expenses.stream()",
    "                    .filter(e -> e.getExpenseType().equals(expenseType))",
    "                    .collect(Collectors.toList());",
    "",
    "            if (matchingExpenses.isEmpty()) {",
    "                return Optional.empty();",
    "            }",
    "",
    "            BigDecimal total = matchingExpenses.stream()",
    "                    .map(Expense::getAmountUsd)",
    "                    .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "",
    "            if (total.compareTo(maxAmount) > 0) {",
    "                List<String> contributingIds = matchingExpenses.stream()",
    "                        .map(Expense::getExpenseId)",
    "                        .collect(Collectors.toList());",
    "",
    "                String reason = String.format(\"%s total $%.2f exceeds limit $%.2f\",",
    "                        expenseType, total, maxAmount);",
    "",
    "                return Optional.of(new Violation(",
    "                        null, tripId, getName(), reason, contributingIds));",
    "            }",
    "            return Optional.empty();",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return \"ExpenseTypeAggregationRule\"; }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // ENGINE IMPLEMENTATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    private final List<ExpenseRule> individualRules = new ArrayList<>();",
    "    private final List<AggregationRule> aggregationRules = new ArrayList<>();",
    "",
    "    public void addIndividualRule(ExpenseRule rule) {",
    "        individualRules.add(rule);",
    "    }",
    "",
    "    public void addAggregationRule(AggregationRule rule) {",
    "        aggregationRules.add(rule);",
    "    }",
    "",
    "    public List<Violation> evaluateIndividualRules(List<Expense> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Expense expense : expenses) {",
    "            for (ExpenseRule rule : individualRules) {",
    "                rule.evaluate(expense).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "",
    "    /**",
    "     * Groups expenses by trip_id for aggregation processing.",
    "     * Time: O(n), Space: O(n)",
    "     */",
    "    private Map<String, List<Expense>> groupExpensesByTrip(List<Expense> expenses) {",
    "        Map<String, List<Expense>> tripExpenses = new HashMap<>();",
    "        for (Expense expense : expenses) {",
    "            tripExpenses.computeIfAbsent(expense.getTripId(), k -> new ArrayList<>())",
    "                    .add(expense);",
    "        }",
    "        return tripExpenses;",
    "    }",
    "",
    "    /**",
    "     * Evaluates expenses grouped by trip against aggregation rules.",
    "     */",
    "    public List<Violation> evaluateAggregationRules(List<Expense> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        Map<String, List<Expense>> tripExpenses = groupExpensesByTrip(expenses);",
    "",
    "        for (Map.Entry<String, List<Expense>> entry : tripExpenses.entrySet()) {",
    "            String tripId = entry.getKey();",
    "            List<Expense> tripExpenseList = entry.getValue();",
    "",
    "            for (AggregationRule rule : aggregationRules) {",
    "                rule.evaluate(tripId, tripExpenseList).ifPresent(violations::add);",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "",
    "    /**",
    "     * Evaluates all rules (individual + aggregation).",
    "     */",
    "    public List<Violation> evaluateAll(List<Expense> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        violations.addAll(evaluateIndividualRules(expenses));",
    "        violations.addAll(evaluateAggregationRules(expenses));",
    "        return violations;",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // MAIN - DEMONSTRATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"CORPORATE EXPENSE RULES ENGINE - PART 2 DEMO\");",
    "        System.out.println(\"=\".repeat(70));",
    "",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "",
    "        // Configure rules",
    "        engine.addIndividualRule(new MaxAmountRule(500));",
    "        engine.addAggregationRule(new TripTotalLimitRule(300));",
    "        engine.addAggregationRule(new ExpenseTypeAggregationRule(\"meals\", 200));",
    "",
    "        // Test 1: Trip total limit violation",
    "        System.out.println(\"\\nTEST 1: Trip Total Limit Rule\");",
    "        System.out.println(\"-\".repeat(50));",
    "",
    "        List<Expense> expenses1 = Arrays.asList(",
    "            new Expense(\"E001\", \"T001\", \"150.00\", \"meals\", \"restaurant\", \"A\"),",
    "            new Expense(\"E002\", \"T001\", \"200.00\", \"lodging\", \"hotel\", \"B\"),",
    "            new Expense(\"E003\", \"T002\", \"100.00\", \"meals\", \"restaurant\", \"C\")",
    "        );",
    "",
    "        List<Violation> violations1 = engine.evaluateAggregationRules(expenses1);",
    "        System.out.println(\"Aggregation Violations: \" + violations1.size());",
    "        violations1.forEach(System.out::println);",
    "",
    "        // Test 2: Expense type aggregation",
    "        System.out.println(\"\\nTEST 2: Expense Type Aggregation\");",
    "        System.out.println(\"-\".repeat(50));",
    "",
    "        List<Expense> expenses2 = Arrays.asList(",
    "            new Expense(\"E001\", \"T001\", \"80.00\", \"meals\", \"restaurant\", \"A\"),",
    "            new Expense(\"E002\", \"T001\", \"150.00\", \"meals\", \"restaurant\", \"B\"),",
    "            new Expense(\"E003\", \"T001\", \"500.00\", \"lodging\", \"hotel\", \"C\")",
    "        );",
    "",
    "        ExpenseRulesEngine engine2 = new ExpenseRulesEngine();",
    "        engine2.addAggregationRule(new ExpenseTypeAggregationRule(\"meals\", 200));",
    "",
    "        List<Violation> violations2 = engine2.evaluateAggregationRules(expenses2);",
    "        System.out.println(\"Meals Violations: \" + violations2.size());",
    "        violations2.forEach(System.out::println);",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"DEMO COMPLETE\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Module docstring and imports. We add `defaultdict` for efficient grouping of expenses by trip_id."
    },
    {
      "lines": "18-45",
      "explanation": "Expense and Violation dataclasses. Violation is extended with optional `trip_id` and `contributing_expenses` list to support aggregation rule violations."
    },
    {
      "lines": "72-140",
      "explanation": "Part 1 individual expense rules (MaxAmountRule, BlockedVendorTypeRule, VendorTypeLimitRule) carried over unchanged."
    },
    {
      "lines": "148-165",
      "explanation": "**NEW: AggregationRule ABC** - The key architectural addition. Unlike ExpenseRule.evaluate(expense), this has evaluate(trip_id, List[Expense]) signature."
    },
    {
      "lines": "168-200",
      "explanation": "**NEW: TripTotalLimitRule** - Sums ALL expense amounts for a trip using generator expression. Returns violation with all expense IDs if over limit."
    },
    {
      "lines": "203-240",
      "explanation": "**NEW: ExpenseTypeAggregationRule** - Filters expenses by type FIRST, then sums. Only contributing expenses (matching type) are included in violation."
    },
    {
      "lines": "248-260",
      "explanation": "Engine initialization with separate lists for individual and aggregation rules. Clean separation of concerns."
    },
    {
      "lines": "271-282",
      "explanation": "**CRITICAL: _group_expenses_by_trip()** - Single O(n) pass using defaultdict to build HashMap<trip_id, List<Expense>>. This is the key pre-processing step."
    },
    {
      "lines": "284-305",
      "explanation": "**evaluateAggregationRules()** - Groups expenses, then iterates (trip_id, expenses) pairs applying each aggregation rule."
    },
    {
      "lines": "307-315",
      "explanation": "**evaluateAll()** - Unified method combining individual and aggregation evaluation for complete rule checking."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "_group_expenses_by_trip": {
          "complexity": "O(e)",
          "explanation": "Single pass through all expenses, HashMap insertion is O(1) amortized"
        },
        "TripTotalLimitRule.evaluate": {
          "complexity": "O(k)",
          "explanation": "Where k is number of expenses in the trip, sums all amounts"
        },
        "ExpenseTypeAggregationRule.evaluate": {
          "complexity": "O(k)",
          "explanation": "Filters then sums, both O(k) operations"
        },
        "evaluateAggregationRules": {
          "complexity": "O(e + t\u00d7r\u00d7avg_k)",
          "explanation": "O(e) for grouping + O(t\u00d7r) rule evaluations, each O(avg_k) for trip size"
        }
      },
      "overall_change": "Part 1 was O(e \u00d7 r_individual). Part 2 adds O(e + t \u00d7 r_aggregation \u00d7 avg_expenses_per_trip). Total: O(e \u00d7 r_individual + e + t \u00d7 r_aggregation \u00d7 k_avg)"
    },
    "space": {
      "additional_space": "O(e)",
      "explanation": "The grouping HashMap stores references to all e expenses reorganized by trip. No duplication of expense data, just reference reorganization. Each expense appears in exactly one trip's list."
    }
  },
  "dry_run": {
    "example_input": "TripTotalLimitRule($300) with expenses: E001(T001,$150), E002(T001,$200), E003(T002,$100)",
    "steps": [
      {
        "step": 1,
        "action": "Call evaluateAggregationRules(expenses)",
        "state": "expenses = [E001, E002, E003]",
        "explanation": "Starting aggregation evaluation"
      },
      {
        "step": 2,
        "action": "_group_expenses_by_trip()",
        "state": "trip_expenses = {}",
        "explanation": "Initialize empty HashMap"
      },
      {
        "step": 3,
        "action": "Process E001 (trip_id=T001)",
        "state": "trip_expenses = {'T001': [E001]}",
        "explanation": "First expense, create new list for T001"
      },
      {
        "step": 4,
        "action": "Process E002 (trip_id=T001)",
        "state": "trip_expenses = {'T001': [E001, E002]}",
        "explanation": "Append to existing T001 list"
      },
      {
        "step": 5,
        "action": "Process E003 (trip_id=T002)",
        "state": "trip_expenses = {'T001': [E001, E002], 'T002': [E003]}",
        "explanation": "Create new list for T002"
      },
      {
        "step": 6,
        "action": "Iterate trip T001",
        "state": "Processing [E001, E002]",
        "explanation": "Start evaluating T001 against rules"
      },
      {
        "step": 7,
        "action": "TripTotalLimitRule.evaluate('T001', [E001, E002])",
        "state": "total = $150 + $200 = $350",
        "explanation": "Sum all expenses for T001"
      },
      {
        "step": 8,
        "action": "Compare $350 > $300",
        "state": "VIOLATION",
        "explanation": "Total exceeds limit"
      },
      {
        "step": 9,
        "action": "Create Violation",
        "state": "Violation(trip_id='T001', rule='TripTotalLimitRule', contributing=['E001','E002'])",
        "explanation": "Build violation with all expense IDs"
      },
      {
        "step": 10,
        "action": "Iterate trip T002",
        "state": "Processing [E003]",
        "explanation": "Move to next trip"
      },
      {
        "step": 11,
        "action": "TripTotalLimitRule.evaluate('T002', [E003])",
        "state": "total = $100",
        "explanation": "Sum expenses for T002"
      },
      {
        "step": 12,
        "action": "Compare $100 <= $300",
        "state": "PASS",
        "explanation": "Under limit, no violation"
      }
    ],
    "final_output": "[Violation(trip_id='T001', rule='TripTotalLimitRule', reason='trip total $350.00 exceeds limit $300.00', contributing_expenses=['E001', 'E002'])]"
  },
  "edge_cases": [
    {
      "case": "Empty expense list",
      "handling": "grouping returns empty dict, no iterations occur, returns empty violations list",
      "gotcha": "Don't fail on empty input"
    },
    {
      "case": "Trip with single expense",
      "handling": "Works normally - list has one element, sum is just that amount",
      "gotcha": "Ensure code handles single-element lists"
    },
    {
      "case": "No expenses match type filter",
      "handling": "ExpenseTypeAggregationRule returns None when matching_expenses is empty",
      "gotcha": "Check for empty list BEFORE summing to avoid false positives"
    },
    {
      "case": "Expense exactly at limit",
      "handling": "Uses strict inequality (>), so exactly at limit is OK",
      "gotcha": "Be clear about boundary: > vs >="
    },
    {
      "case": "Multiple trips, some violating",
      "handling": "Each trip evaluated independently, violations collected separately",
      "gotcha": "Don't short-circuit on first violation"
    },
    {
      "case": "Same expense type, different trips",
      "handling": "Grouping isolates trips, each trip's type limit is independent",
      "gotcha": "The $200 meals limit is PER TRIP, not global"
    }
  ],
  "test_cases": [
    {
      "name": "Basic trip total violation",
      "input": "TripTotalLimitRule($300), expenses: T001[$150, $200], T002[$100]",
      "expected": "1 violation for T001 (total $350)",
      "explanation": "Only T001 exceeds the $300 limit"
    },
    {
      "name": "Expense type aggregation",
      "input": "ExpenseTypeAggregationRule(meals, $200), T001: meals[$80, $150], lodging[$500]",
      "expected": "1 violation for T001 meals (total $230)",
      "explanation": "Only meals counted, lodging ignored"
    },
    {
      "name": "Multiple aggregation rules same trip",
      "input": "TripTotal($500) + MealsLimit($100), T001: meals[$80, $50], transport[$400]",
      "expected": "2 violations: trip total $530 > $500, meals $130 > $100",
      "explanation": "Same trip can violate multiple aggregation rules"
    },
    {
      "name": "No violations scenario",
      "input": "TripTotalLimitRule($1000), T001[$200, $300]",
      "expected": "Empty violations list",
      "explanation": "$500 total is well under $1000"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using same interface for individual and aggregation rules",
      "why_wrong": "Forces awkward state management or multiple passes. Individual rules take one expense; aggregation rules need the full trip context.",
      "correct_approach": "Create separate interfaces: ExpenseRule.evaluate(expense) vs AggregationRule.evaluate(trip_id, List<Expense>)",
      "code_example_wrong": "// Forcing aggregation into individual interface\nclass TripTotalRule implements ExpenseRule {\n    Map<String, BigDecimal> tripTotals; // stateful!\n    void evaluate(expense) { tripTotals.merge(...) }\n}",
      "code_example_correct": "// Clean aggregation interface\nclass TripTotalRule implements AggregationRule {\n    Optional<Violation> evaluate(String tripId, List<Expense> expenses) {\n        BigDecimal total = expenses.stream()...sum();\n        // stateless!\n    }\n}"
    },
    {
      "mistake": "Including all expenses in violation for type-specific rules",
      "why_wrong": "ExpenseTypeAggregationRule for 'meals' should only list meal expenses as contributing, not lodging or transport.",
      "correct_approach": "Filter expenses FIRST, then extract IDs only from matching expenses",
      "code_example_wrong": "// Wrong: includes all expenses\ncontributing_expenses=[e.expense_id for e in expenses]",
      "code_example_correct": "// Correct: only matching type\nmatching = [e for e in expenses if e.expense_type == self.expense_type]\ncontributing_expenses=[e.expense_id for e in matching]"
    },
    {
      "mistake": "Not handling empty trip or empty matching expenses",
      "why_wrong": "Could cause division by zero, false violations, or null pointer exceptions",
      "correct_approach": "Check for empty list before processing and return None/empty early",
      "code_example_wrong": "def evaluate(trip_id, expenses):\n    total = sum(e.amount for e in expenses)  # fails if empty",
      "code_example_correct": "def evaluate(trip_id, expenses):\n    if not expenses:\n        return None\n    total = sum(e.amount for e in expenses)"
    },
    {
      "mistake": "Grouping expenses on every rule evaluation",
      "why_wrong": "Redundant O(e) work for each rule. With r rules, becomes O(e \u00d7 r) instead of O(e + r)",
      "correct_approach": "Group once, then iterate rules over pre-grouped data",
      "code_example_wrong": "for rule in rules:\n    grouped = group_by_trip(expenses)  # redundant!\n    for trip_id, exps in grouped: ...",
      "code_example_correct": "grouped = group_by_trip(expenses)  # once\nfor trip_id, exps in grouped:\n    for rule in rules: ..."
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clearly articulating WHY aggregation rules are fundamentally different: 'Individual rules are functions from Expense \u2192 Violation, but aggregation rules need List<Expense> \u2192 Violation. This suggests a separate interface.' Then sketch the HashMap grouping step before diving into code.",
    "what_to_mention": [
      "Explain the O(e) pre-processing step and why it enables efficient evaluation",
      "Discuss the Interface Segregation Principle - different interfaces for different evaluation models",
      "Mention that violations include contributing_expenses for auditability",
      "Note that rules remain stateless and easily testable",
      "Consider thread safety - stateless rules are inherently thread-safe"
    ],
    "time_allocation": "~12 minutes: 2 min explaining approach, 3 min for grouping + interface design, 5 min implementing rules, 2 min testing/edge cases",
    "if_stuck": [
      "Think about what data each rule needs - single expense vs. all trip expenses",
      "Consider: If you had to calculate trip totals manually, you'd group first, then sum",
      "HashMap is your friend for grouping - what's the key? trip_id!",
      "Start with TripTotalLimitRule (simpler), then add filtering for ExpenseTypeAggregationRule"
    ]
  },
  "connection_to_next_part": "Part 2's grouping infrastructure (HashMap<trip_id, List<Expense>>) sets up for Part 3 which might add **time-window based rules** (e.g., 'max $100/day on meals') requiring further grouping by date within trips, or **cross-trip rules** (e.g., 'max 3 trips per month') requiring grouping by employee/time period. The AggregationRule interface can be extended or composed for these more complex scenarios.",
  "generated_at": "2026-01-14T15:07:33.803553",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}