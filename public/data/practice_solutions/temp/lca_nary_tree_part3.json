{
  "problem_title": "Lowest Common Ancestor in N-ary Tree - Part 3: LCA with Parent Pointers",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "In Part 2, we had access to the root and performed DFS traversal. Now each node has a **parent pointer**, and we're given ONLY the two target nodes p and q - no root access. This fundamentally changes our approach from top-down DFS to bottom-up traversal.",
    "new_requirements": [
      "Each node now has a parent pointer field",
      "Must find LCA without access to root node",
      "Given only the two target nodes p and q as input",
      "Should work efficiently without full tree traversal"
    ],
    "new_constraints": [
      "No root access - cannot do traditional DFS",
      "Must traverse upward via parent pointers",
      "Both p and q are guaranteed to exist in the same tree",
      "Optimal solution should use O(1) extra space"
    ],
    "key_insight": "Treat the path from each node to root as a **linked list**! Finding LCA becomes finding the **intersection point of two linked lists** - a classic problem with an elegant O(1) space solution using two pointers."
  },
  "visual_explanation": {
    "before_after": "```\n=== TREE STRUCTURE WITH PARENT POINTERS ===\n\n              1 (root, parent=null)\n           /  |  \\\n          \u2193   \u2193   \u2193\n         2    3    4\n        /|         |\n       \u2193 \u2193         \u2193\n      5  6         8\n      \u2191            \u2191\n   node p       node q\n\nEach node points UP to parent:\n  5.parent = 2\n  2.parent = 1\n  1.parent = null\n  8.parent = 4\n  4.parent = 1\n\n=== PATHS AS LINKED LISTS ===\n\nPath from p(5) to root:\n  5 \u2192 2 \u2192 1 \u2192 null   (length 3)\n\nPath from q(8) to root:\n  8 \u2192 4 \u2192 1 \u2192 null   (length 3)\n\nThese are like two linked lists that\nMERGE at their common ancestor!\n```",
    "algorithm_flow": "```\n=== TWO POINTER TECHNIQUE ===\n\nKey Insight: If we traverse:\n  ptr_a: p's path, then q's path\n  ptr_b: q's path, then p's path\n\nThey'll meet at LCA because both travel\nthe SAME total distance!\n\n   Total distance = len(p\u2192root) + len(q\u2192root)\n\nVisualization:\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\nStep 0: Initialize\n  ptr_a \u2192 5    ptr_b \u2192 8\n\nStep 1: Move up\n  ptr_a \u2192 2    ptr_b \u2192 4\n\nStep 2: Move up  \n  ptr_a \u2192 1    ptr_b \u2192 1\n         \u2191            \u2191\n         \u2514\u2500\u2500\u2500\u2500 MEET! \u2500\u2518\n\nAnswer: Node 1\n\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\nDifferent Depths Example:\n  p = 5 (depth 2)\n  q = 4 (depth 1)\n\n  p's path: 5 \u2192 2 \u2192 1 \u2192 null\n  q's path: 4 \u2192 1 \u2192 null\n\n  ptr_a: 5 \u2192 2 \u2192 1 \u2192 null \u2192 4 \u2192 [1]\n  ptr_b: 4 \u2192 1 \u2192 null \u2192 5 \u2192 2 \u2192 [1]\n                               \u2191\n                          MEET AT LCA!\n\n  After switching at null, both travel\n  same remaining distance to LCA.\n```"
  },
  "approaches": [
    {
      "name": "HashSet Approach",
      "description": "Store all ancestors of p in a HashSet, then walk q upward until we find a node in the set. The first match is the LCA.",
      "time_complexity": "O(h)",
      "space_complexity": "O(h)",
      "why_not_optimal": "Uses O(h) extra space for storing ancestors. Works well but not space-optimal. Good as a first solution to mention in interview."
    },
    {
      "name": "Depth Alignment Approach",
      "description": "Calculate depths of both nodes by walking to root. Align the deeper node by moving it up. Then walk both up in sync until they meet.",
      "time_complexity": "O(h)",
      "space_complexity": "O(1)",
      "why_not_optimal": "Requires two passes: one to find depths, one to find LCA. Slightly more code than two-pointer approach."
    },
    {
      "name": "Two Pointer Technique (Optimal)",
      "description": "Use two pointers starting at p and q. Move each up via parent. When a pointer reaches null (past root), reset it to the OTHER starting node. They'll meet at LCA.",
      "time_complexity": "O(h)",
      "space_complexity": "O(1)",
      "key_insight": "Both pointers travel: len(p\u2192root) + len(q\u2192root). Since they travel the same total distance, they meet at LCA. This is the linked list intersection algorithm adapted for trees!"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Two-Pointer Magic \u2728\n\nThis solution leverages a beautiful mathematical property:\n\n**If pointer A travels:** `path(p\u2192root) + path(q\u2192root)`\n**And pointer B travels:** `path(q\u2192root) + path(p\u2192root)`\n\n**They travel the SAME total distance!**\n\nSince the paths share a common suffix (from LCA to root), the pointers **must meet at the LCA**.\n\n### Why It Works\n\nLet's denote:\n- `a` = distance from p to LCA\n- `b` = distance from q to LCA  \n- `c` = distance from LCA to root\n\n**Pointer A travels:** `a + c + b + c` (p\u2192root, then q\u2192root)\n**Pointer B travels:** `b + c + a + c` (q\u2192root, then p\u2192root)\n\nBoth equal `a + b + 2c`, so they're synchronized after the switch!\n\n### The Algorithm\n\n1. Start `ptr_a` at `p`, `ptr_b` at `q`\n2. While pointers differ:\n   - Move `ptr_a` up (or switch to q if null)\n   - Move `ptr_b` up (or switch to p if null)\n3. Return meeting point (the LCA)\n\nThis is **O(1) space** and elegantly handles different depths without explicit calculation!",
    "data_structures": [
      {
        "structure": "Two Pointers",
        "purpose": "Traverse paths without storing them"
      },
      {
        "structure": "Parent Pointers",
        "purpose": "Enable bottom-up traversal"
      },
      {
        "structure": "HashSet (alternative)",
        "purpose": "Store ancestors for O(h) space solution"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize ptr_a = p, ptr_b = q",
      "Step 2: Enter loop while ptr_a != ptr_b",
      "Step 3: For ptr_a: if has parent, move up; else switch to q",
      "Step 4: For ptr_b: if has parent, move up; else switch to p",
      "Step 5: When loop exits, both point to LCA - return either",
      "Note: Handles edge case where p or q IS the LCA automatically"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Lowest Common Ancestor in N-ary Tree - Part 3: LCA with Parent Pointers",
    "",
    "This module extends the LCA solution to handle parent pointers,",
    "enabling bottom-up traversal without root access.",
    "\"\"\"",
    "",
    "from typing import List, Optional, Set",
    "",
    "",
    "class Node:",
    "    \"\"\"N-ary tree node with parent pointer.\"\"\"",
    "    ",
    "    def __init__(self, val: int):",
    "        self.val = val",
    "        self.children: List['Node'] = []",
    "        self.parent: Optional['Node'] = None  # NEW: parent pointer",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Node({self.val})\"",
    "",
    "",
    "class LCAWithParentSolution:",
    "    \"\"\"",
    "    Solutions for LCA when nodes have parent pointers.",
    "    ",
    "    Provides multiple approaches:",
    "    1. Two-pointer technique (O(1) space) - OPTIMAL",
    "    2. HashSet approach (O(h) space) - Good fallback",
    "    3. Depth alignment (O(1) space) - Alternative",
    "    \"\"\"",
    "    ",
    "    def lca_with_parent(self, p: Node, q: Node) -> Optional[Node]:",
    "        \"\"\"",
    "        Find LCA using two-pointer technique (OPTIMAL).",
    "        ",
    "        This is analogous to finding intersection of two linked lists.",
    "        Both pointers travel the same total distance, so they meet at LCA.",
    "        ",
    "        Args:",
    "            p: First target node with parent pointer",
    "            q: Second target node with parent pointer",
    "        ",
    "        Returns:",
    "            The LCA node, or None if nodes aren't in same tree",
    "        ",
    "        Time Complexity: O(h) where h is tree height",
    "        Space Complexity: O(1) - only two pointers",
    "        \"\"\"",
    "        if not p or not q:",
    "            return None",
    "        ",
    "        ptr_a, ptr_b = p, q",
    "        ",
    "        # Each pointer traverses its path to root, then switches to other's path",
    "        # They meet at LCA because they travel the same total distance",
    "        while ptr_a != ptr_b:",
    "            # Move up or switch to other starting point",
    "            ptr_a = ptr_a.parent if ptr_a else q",
    "            ptr_b = ptr_b.parent if ptr_b else p",
    "        ",
    "        return ptr_a",
    "    ",
    "    def lca_with_parent_hashset(self, p: Node, q: Node) -> Optional[Node]:",
    "        \"\"\"",
    "        Find LCA using HashSet approach.",
    "        ",
    "        Store all ancestors of p, then find first ancestor of q in the set.",
    "        ",
    "        Args:",
    "            p: First target node",
    "            q: Second target node",
    "        ",
    "        Returns:",
    "            The LCA node",
    "        ",
    "        Time Complexity: O(h)",
    "        Space Complexity: O(h) for storing ancestors",
    "        \"\"\"",
    "        if not p or not q:",
    "            return None",
    "        ",
    "        # Collect all ancestors of p (including p itself)",
    "        ancestors: Set[Node] = set()",
    "        current = p",
    "        while current:",
    "            ancestors.add(current)",
    "            current = current.parent",
    "        ",
    "        # Find first ancestor of q that's in the set",
    "        current = q",
    "        while current:",
    "            if current in ancestors:",
    "                return current",
    "            current = current.parent",
    "        ",
    "        return None  # Different trees",
    "    ",
    "    def lca_with_parent_depth_align(self, p: Node, q: Node) -> Optional[Node]:",
    "        \"\"\"",
    "        Find LCA by aligning depths first.",
    "        ",
    "        1. Calculate depth of both nodes",
    "        2. Bring deeper node up to same level",
    "        3. Walk both up together until they meet",
    "        ",
    "        Time Complexity: O(h)",
    "        Space Complexity: O(1)",
    "        \"\"\"",
    "        if not p or not q:",
    "            return None",
    "        ",
    "        def get_depth(node: Node) -> int:",
    "            \"\"\"Count steps from node to root.\"\"\"",
    "            depth = 0",
    "            while node.parent:",
    "                depth += 1",
    "                node = node.parent",
    "            return depth",
    "        ",
    "        depth_p, depth_q = get_depth(p), get_depth(q)",
    "        ",
    "        # Make p the deeper node for simplicity",
    "        if depth_p < depth_q:",
    "            p, q = q, p",
    "            depth_p, depth_q = depth_q, depth_p",
    "        ",
    "        # Bring p up to same level as q",
    "        diff = depth_p - depth_q",
    "        while diff > 0:",
    "            p = p.parent",
    "            diff -= 1",
    "        ",
    "        # Walk both up together until they meet",
    "        while p != q:",
    "            p = p.parent",
    "            q = q.parent",
    "        ",
    "        return p",
    "",
    "",
    "# ============ TREE BUILDER UTILITY ============",
    "",
    "def build_tree_with_parents(root_val: int, children_map: dict) -> dict:",
    "    \"\"\"",
    "    Build N-ary tree with parent pointers from adjacency map.",
    "    ",
    "    Args:",
    "        root_val: Value of root node",
    "        children_map: Dict mapping parent val to list of children vals",
    "    ",
    "    Returns:",
    "        Dict mapping values to Node objects",
    "    \"\"\"",
    "    nodes = {}",
    "    ",
    "    def get_or_create(val: int) -> Node:",
    "        if val not in nodes:",
    "            nodes[val] = Node(val)",
    "        return nodes[val]",
    "    ",
    "    # Build tree with parent pointers",
    "    for parent_val, child_vals in children_map.items():",
    "        parent = get_or_create(parent_val)",
    "        for child_val in child_vals:",
    "            child = get_or_create(child_val)",
    "            parent.children.append(child)",
    "            child.parent = parent",
    "    ",
    "    # Ensure all nodes exist",
    "    get_or_create(root_val)",
    "    ",
    "    return nodes",
    "",
    "",
    "# ============ DEMONSTRATION ============",
    "",
    "def main():",
    "    \"\"\"Demonstrate LCA with parent pointers.\"\"\"",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"LCA WITH PARENT POINTERS - DEMONSTRATION\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Build tree:",
    "    #         1",
    "    #      /  |  \\",
    "    #     2   3   4",
    "    #    /|       |",
    "    #   5 6       8",
    "    ",
    "    children_map = {",
    "        1: [2, 3, 4],",
    "        2: [5, 6],",
    "        4: [8]",
    "    }",
    "    nodes = build_tree_with_parents(1, children_map)",
    "    ",
    "    print(\"\\nTree Structure:\")",
    "    print(\"        1\")",
    "    print(\"     /  |  \\\\\")",
    "    print(\"    2   3   4\")",
    "    print(\"   /|       |\")",
    "    print(\"  5 6       8\")",
    "    print()",
    "    ",
    "    solution = LCAWithParentSolution()",
    "    ",
    "    # Test cases",
    "    test_cases = [",
    "        (5, 8, \"Different subtrees - LCA is root\"),",
    "        (5, 6, \"Siblings - LCA is parent\"),",
    "        (5, 2, \"Node and its ancestor - LCA is ancestor\"),",
    "        (2, 4, \"Different children of root\"),",
    "        (5, 5, \"Same node - LCA is itself\"),",
    "    ]",
    "    ",
    "    print(\"Test Results (Two-Pointer Method):\")",
    "    print(\"-\" * 50)",
    "    ",
    "    for p_val, q_val, description in test_cases:",
    "        p, q = nodes[p_val], nodes[q_val]",
    "        lca = solution.lca_with_parent(p, q)",
    "        print(f\"LCA({p_val}, {q_val}) = {lca.val if lca else None}\")",
    "        print(f\"  \u2192 {description}\")",
    "        print()",
    "    ",
    "    # Verify all methods give same answer",
    "    print(\"\\nVerifying all approaches give same answer:\")",
    "    print(\"-\" * 50)",
    "    ",
    "    p, q = nodes[5], nodes[8]",
    "    result1 = solution.lca_with_parent(p, q)",
    "    result2 = solution.lca_with_parent_hashset(p, q)",
    "    result3 = solution.lca_with_parent_depth_align(p, q)",
    "    ",
    "    print(f\"Two-Pointer:    LCA(5, 8) = {result1.val}\")",
    "    print(f\"HashSet:        LCA(5, 8) = {result2.val}\")",
    "    print(f\"Depth Align:    LCA(5, 8) = {result3.val}\")",
    "    print(f\"\\n\u2713 All methods agree!\") if result1.val == result2.val == result3.val else print(\"\u2717 Mismatch!\")",
    "    ",
    "    # Trace the two-pointer algorithm",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"ALGORITHM TRACE: LCA(5, 8)\")",
    "    print(\"=\" * 60)",
    "    ",
    "    p, q = nodes[5], nodes[8]",
    "    ptr_a, ptr_b = p, q",
    "    step = 0",
    "    ",
    "    print(f\"\\nInitial: ptr_a = {ptr_a.val}, ptr_b = {ptr_b.val}\")",
    "    ",
    "    while ptr_a != ptr_b:",
    "        step += 1",
    "        old_a, old_b = ptr_a, ptr_b",
    "        ptr_a = ptr_a.parent if ptr_a else q",
    "        ptr_b = ptr_b.parent if ptr_b else p",
    "        print(f\"Step {step}: ptr_a: {old_a.val if old_a else 'null'} \u2192 {ptr_a.val if ptr_a else 'null'}, \", end=\"\")",
    "        print(f\"ptr_b: {old_b.val if old_b else 'null'} \u2192 {ptr_b.val if ptr_b else 'null'}\")",
    "    ",
    "    print(f\"\\n\u2713 Pointers meet at node {ptr_a.val}!\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Lowest Common Ancestor in N-ary Tree - Part 3: LCA with Parent Pointers",
    " * ",
    " * This solution handles the case where each node has a parent pointer,",
    " * enabling bottom-up traversal without root access.",
    " */",
    "public class LCAWithParent {",
    "    ",
    "    /**",
    "     * N-ary tree node with parent pointer.",
    "     */",
    "    static class Node {",
    "        int val;",
    "        List<Node> children;",
    "        Node parent;  // NEW: parent pointer",
    "        ",
    "        Node(int val) {",
    "            this.val = val;",
    "            this.children = new ArrayList<>();",
    "            this.parent = null;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return \"Node(\" + val + \")\";",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Find LCA using two-pointer technique (OPTIMAL).",
    "     * ",
    "     * Analogous to finding intersection of two linked lists.",
    "     * Both pointers travel same total distance, meeting at LCA.",
    "     * ",
    "     * Time Complexity: O(h) where h is tree height",
    "     * Space Complexity: O(1)",
    "     */",
    "    public Node lcaWithParent(Node p, Node q) {",
    "        if (p == null || q == null) {",
    "            return null;",
    "        }",
    "        ",
    "        Node ptrA = p;",
    "        Node ptrB = q;",
    "        ",
    "        // Each pointer traverses its path to root, then switches",
    "        while (ptrA != ptrB) {",
    "            ptrA = (ptrA != null) ? ptrA.parent : q;",
    "            ptrB = (ptrB != null) ? ptrB.parent : p;",
    "        }",
    "        ",
    "        return ptrA;",
    "    }",
    "    ",
    "    /**",
    "     * Find LCA using HashSet approach.",
    "     * ",
    "     * Store all ancestors of p, find first ancestor of q in set.",
    "     * ",
    "     * Time Complexity: O(h)",
    "     * Space Complexity: O(h)",
    "     */",
    "    public Node lcaWithParentHashSet(Node p, Node q) {",
    "        if (p == null || q == null) {",
    "            return null;",
    "        }",
    "        ",
    "        Set<Node> ancestors = new HashSet<>();",
    "        ",
    "        // Collect all ancestors of p (including p)",
    "        Node current = p;",
    "        while (current != null) {",
    "            ancestors.add(current);",
    "            current = current.parent;",
    "        }",
    "        ",
    "        // Find first ancestor of q in the set",
    "        current = q;",
    "        while (current != null) {",
    "            if (ancestors.contains(current)) {",
    "                return current;",
    "            }",
    "            current = current.parent;",
    "        }",
    "        ",
    "        return null;",
    "    }",
    "    ",
    "    /**",
    "     * Find LCA by aligning depths first.",
    "     * ",
    "     * Time Complexity: O(h)",
    "     * Space Complexity: O(1)",
    "     */",
    "    public Node lcaWithParentDepthAlign(Node p, Node q) {",
    "        if (p == null || q == null) {",
    "            return null;",
    "        }",
    "        ",
    "        int depthP = getDepth(p);",
    "        int depthQ = getDepth(q);",
    "        ",
    "        // Make p the deeper node",
    "        if (depthP < depthQ) {",
    "            Node temp = p;",
    "            p = q;",
    "            q = temp;",
    "            int tempD = depthP;",
    "            depthP = depthQ;",
    "            depthQ = tempD;",
    "        }",
    "        ",
    "        // Bring p up to same level as q",
    "        int diff = depthP - depthQ;",
    "        while (diff-- > 0) {",
    "            p = p.parent;",
    "        }",
    "        ",
    "        // Walk both up together",
    "        while (p != q) {",
    "            p = p.parent;",
    "            q = q.parent;",
    "        }",
    "        ",
    "        return p;",
    "    }",
    "    ",
    "    private int getDepth(Node node) {",
    "        int depth = 0;",
    "        while (node.parent != null) {",
    "            depth++;",
    "            node = node.parent;",
    "        }",
    "        return depth;",
    "    }",
    "    ",
    "    // ============ TREE BUILDER UTILITY ============",
    "    ",
    "    public static Map<Integer, Node> buildTreeWithParents(",
    "            int rootVal, Map<Integer, List<Integer>> childrenMap) {",
    "        ",
    "        Map<Integer, Node> nodes = new HashMap<>();",
    "        ",
    "        for (Map.Entry<Integer, List<Integer>> entry : childrenMap.entrySet()) {",
    "            int parentVal = entry.getKey();",
    "            Node parent = nodes.computeIfAbsent(parentVal, Node::new);",
    "            ",
    "            for (int childVal : entry.getValue()) {",
    "                Node child = nodes.computeIfAbsent(childVal, Node::new);",
    "                parent.children.add(child);",
    "                child.parent = parent;",
    "            }",
    "        }",
    "        ",
    "        nodes.computeIfAbsent(rootVal, Node::new);",
    "        return nodes;",
    "    }",
    "    ",
    "    // ============ DEMONSTRATION ============",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"LCA WITH PARENT POINTERS - DEMONSTRATION\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Build tree:",
    "        //         1",
    "        //      /  |  \\",
    "        //     2   3   4",
    "        //    /|       |",
    "        //   5 6       8",
    "        ",
    "        Map<Integer, List<Integer>> childrenMap = new HashMap<>();",
    "        childrenMap.put(1, Arrays.asList(2, 3, 4));",
    "        childrenMap.put(2, Arrays.asList(5, 6));",
    "        childrenMap.put(4, Arrays.asList(8));",
    "        ",
    "        Map<Integer, Node> nodes = buildTreeWithParents(1, childrenMap);",
    "        ",
    "        System.out.println(\"\\nTree Structure:\");",
    "        System.out.println(\"        1\");",
    "        System.out.println(\"     /  |  \\\\\");",
    "        System.out.println(\"    2   3   4\");",
    "        System.out.println(\"   /|       |\");",
    "        System.out.println(\"  5 6       8\\n\");",
    "        ",
    "        LCAWithParent solution = new LCAWithParent();",
    "        ",
    "        // Test cases",
    "        int[][] testCases = {{5, 8}, {5, 6}, {5, 2}, {2, 4}, {5, 5}};",
    "        String[] descriptions = {",
    "            \"Different subtrees - LCA is root\",",
    "            \"Siblings - LCA is parent\",",
    "            \"Node and its ancestor - LCA is ancestor\",",
    "            \"Different children of root\",",
    "            \"Same node - LCA is itself\"",
    "        };",
    "        ",
    "        System.out.println(\"Test Results (Two-Pointer Method):\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        for (int i = 0; i < testCases.length; i++) {",
    "            int pVal = testCases[i][0];",
    "            int qVal = testCases[i][1];",
    "            Node p = nodes.get(pVal);",
    "            Node q = nodes.get(qVal);",
    "            Node lca = solution.lcaWithParent(p, q);",
    "            ",
    "            System.out.printf(\"LCA(%d, %d) = %d%n\", pVal, qVal, lca.val);",
    "            System.out.println(\"  \u2192 \" + descriptions[i] + \"\\n\");",
    "        }",
    "        ",
    "        // Verify all methods agree",
    "        System.out.println(\"\\nVerifying all approaches give same answer:\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        Node p = nodes.get(5);",
    "        Node q = nodes.get(8);",
    "        ",
    "        Node result1 = solution.lcaWithParent(p, q);",
    "        Node result2 = solution.lcaWithParentHashSet(p, q);",
    "        Node result3 = solution.lcaWithParentDepthAlign(p, q);",
    "        ",
    "        System.out.printf(\"Two-Pointer:    LCA(5, 8) = %d%n\", result1.val);",
    "        System.out.printf(\"HashSet:        LCA(5, 8) = %d%n\", result2.val);",
    "        System.out.printf(\"Depth Align:    LCA(5, 8) = %d%n\", result3.val);",
    "        ",
    "        if (result1.val == result2.val && result2.val == result3.val) {",
    "            System.out.println(\"\\n\u2713 All methods agree!\");",
    "        }",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "Imports and class documentation explaining the parent pointer extension"
    },
    {
      "lines": "14-28",
      "explanation": "Node class with the NEW parent pointer field - this is what enables bottom-up traversal"
    },
    {
      "lines": "30-53",
      "explanation": "**Core Algorithm**: Two-pointer technique. Both pointers traverse to null then switch, guaranteeing they travel equal total distance and meet at LCA"
    },
    {
      "lines": "55-79",
      "explanation": "HashSet alternative: O(h) space but simpler logic - collect p's ancestors, find first match from q"
    },
    {
      "lines": "81-115",
      "explanation": "Depth alignment approach: Calculate depths, align deeper node, walk together until meeting"
    },
    {
      "lines": "117-135",
      "explanation": "Tree builder utility that properly sets parent pointers during construction"
    },
    {
      "lines": "139-180",
      "explanation": "Comprehensive test harness demonstrating all approaches with multiple test cases"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "lcaWithParent (Two-Pointer)": {
          "complexity": "O(h)",
          "explanation": "Each pointer visits at most 2h nodes (path to root + other path to root)"
        },
        "lcaWithParentHashSet": {
          "complexity": "O(h)",
          "explanation": "One traversal to collect ancestors O(h) + one traversal to find match O(h)"
        },
        "lcaWithParentDepthAlign": {
          "complexity": "O(h)",
          "explanation": "Two depth calculations O(h) each + one sync walk O(h)"
        }
      },
      "overall_change": "All approaches are O(h) where h = tree height. Better than Part 2's O(n) when tree is sparse or nodes are near leaves."
    },
    "space": {
      "additional_space": "O(1) for two-pointer, O(h) for HashSet",
      "explanation": "Two-pointer only uses two pointer variables regardless of tree size. HashSet stores path from p to root. The parent pointers themselves are part of the data structure, not algorithm overhead."
    }
  },
  "dry_run": {
    "example_input": "p = Node(5), q = Node(8) in tree: 1->[2,3,4], 2->[5,6], 4->[8]",
    "steps": [
      {
        "step": 0,
        "action": "Initialize pointers",
        "state": "ptr_a = 5, ptr_b = 8",
        "explanation": "Both pointers start at their respective input nodes"
      },
      {
        "step": 1,
        "action": "Move both up",
        "state": "ptr_a = 2, ptr_b = 4",
        "explanation": "5.parent = 2, 8.parent = 4. Pointers differ, continue."
      },
      {
        "step": 2,
        "action": "Move both up",
        "state": "ptr_a = 1, ptr_b = 1",
        "explanation": "2.parent = 1, 4.parent = 1. Pointers equal! Exit loop."
      },
      {
        "step": 3,
        "action": "Return LCA",
        "state": "return Node(1)",
        "explanation": "Both pointers met at root node 1"
      }
    ],
    "final_output": "Node with value 1 (the root)"
  },
  "edge_cases": [
    {
      "case": "Same node (p == q)",
      "handling": "Loop never executes since ptr_a == ptr_b initially; returns p",
      "gotcha": "Don't forget this case in interviews!"
    },
    {
      "case": "One is ancestor of other",
      "handling": "Two-pointer naturally handles this - they meet at the ancestor node",
      "gotcha": "No special case needed unlike some recursive approaches"
    },
    {
      "case": "Different depths",
      "handling": "After switch at null, pointers sync up automatically",
      "gotcha": "Trust the math - equal total distance guarantees meeting at LCA"
    },
    {
      "case": "Null input",
      "handling": "Check for null p or q at start, return null",
      "gotcha": "Always validate inputs before dereferencing"
    },
    {
      "case": "Root node as LCA",
      "handling": "Pointers may switch once each before meeting at root",
      "gotcha": "The null\u2192switch logic handles this elegantly"
    }
  ],
  "test_cases": [
    {
      "name": "Different subtrees",
      "input": "p = 5 (left subtree), q = 8 (right subtree)",
      "expected": "1 (root)",
      "explanation": "Nodes are in completely different subtrees, so LCA is the root"
    },
    {
      "name": "Siblings",
      "input": "p = 5, q = 6 (both children of 2)",
      "expected": "2",
      "explanation": "Direct siblings share their parent as LCA"
    },
    {
      "name": "Ancestor-descendant",
      "input": "p = 5, q = 2 (q is parent of p)",
      "expected": "2",
      "explanation": "When one node is ancestor of other, the ancestor is the LCA"
    },
    {
      "name": "Same node",
      "input": "p = 5, q = 5",
      "expected": "5",
      "explanation": "A node is its own LCA"
    },
    {
      "name": "Root involved",
      "input": "p = 1 (root), q = 5",
      "expected": "1",
      "explanation": "Root is LCA of itself and any descendant"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking parent before null check",
      "why_wrong": "If ptr_a is null (after reaching past root), accessing ptr_a.parent causes NullPointerException",
      "correct_approach": "Check if pointer itself is null first, then switch to other node",
      "code_example_wrong": "ptrA = ptrA.parent;  // Crashes when ptrA is null!",
      "code_example_correct": "ptrA = (ptrA != null) ? ptrA.parent : q;"
    },
    {
      "mistake": "Not handling the case where p or q is null input",
      "why_wrong": "Dereferencing null input causes immediate crash",
      "correct_approach": "Validate inputs at method start",
      "code_example_wrong": "Node ptrA = p;  // No validation",
      "code_example_correct": "if (p == null || q == null) return null;"
    },
    {
      "mistake": "Switching to wrong node after null",
      "why_wrong": "If ptr_a (starting from p) switches to p instead of q, it retraces same path forever",
      "correct_approach": "When reaching null from p's path, switch to q (the OTHER node)",
      "code_example_wrong": "ptrA = (ptrA != null) ? ptrA.parent : p;  // Wrong! Stays on same path",
      "code_example_correct": "ptrA = (ptrA != null) ? ptrA.parent : q;  // Correct! Switches to other path"
    },
    {
      "mistake": "Adding current node to HashSet AFTER moving up",
      "why_wrong": "Misses the starting node p, so if q == p, LCA won't be found",
      "correct_approach": "Add node to set before moving to parent",
      "code_example_wrong": "while(curr != null) { curr = curr.parent; set.add(curr); }",
      "code_example_correct": "while(curr != null) { set.add(curr); curr = curr.parent; }"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining that parent pointers transform this from a tree problem into a **linked list intersection problem**. Draw the paths from p and q to root as two linked lists that merge at LCA. Then present the elegant two-pointer solution that uses O(1) space.",
    "what_to_mention": [
      "Explicitly state the analogy to linked list intersection - shows pattern recognition",
      "Explain WHY both pointers travel equal distance (a + c + b + c = b + c + a + c)",
      "Mention the HashSet alternative as O(h) space fallback if interviewer asks",
      "Note that this is more efficient than Part 2 when we only need LCA of two nodes near leaves",
      "Discuss that parent pointers have a space cost in the data structure itself"
    ],
    "time_allocation": "2 min: understand new structure, 3 min: explain two-pointer insight, 5 min: code, 3 min: trace through example, 2 min: discuss edge cases",
    "if_stuck": [
      "Think about what unique information parent pointers give you - ability to traverse UP",
      "If you can go up, you can reach the root from any node - what does each path look like?",
      "Two paths that eventually merge... where have you seen this before? (Linked lists!)",
      "How do you find where two linked lists merge? The classic two-pointer technique!"
    ]
  },
  "connection_to_next_part": "Part 4 might introduce **LCA queries on multiple pairs** where we need to answer many LCA queries efficiently. This could lead to techniques like **Binary Lifting** (preprocessing for O(log h) queries) or **Tarjan's offline LCA algorithm**. The parent pointer structure from Part 3 is essential for Binary Lifting where we store 2^i ancestors.",
  "generated_at": "2026-01-14T15:10:17.756606",
  "_meta": {
    "problem_id": "lca_nary_tree",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}