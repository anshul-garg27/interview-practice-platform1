{
  "problem_title": "2D Canvas / Drawing Application - Part 3: Delete Shape and Z-Order Control",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 3 adds three critical operations: deleting shapes completely from the canvas, and manipulating z-order (layer ordering) with bringToFront and sendToBack. This transforms our static canvas into a fully interactive drawing tool where users can organize overlapping shapes visually.",
    "new_requirements": [
      "deleteShape(shapeId) - Remove shape from both data structures completely",
      "bringToFront(shapeId) - Move shape to top of z-order stack (rendered last, appears on top)",
      "sendToBack(shapeId) - Move shape to bottom of z-order stack (rendered first, appears behind others)",
      "All operations must maintain consistency between HashMap and z-order list",
      "Invalid shapeId should be handled gracefully (no-op)"
    ],
    "new_constraints": [
      "Z-order changes must immediately affect getShapeAt results",
      "Deletion must be permanent - shape cannot be recovered",
      "Operations on non-existent shapes should fail silently (no exceptions)"
    ],
    "key_insight": "Z-order is elegantly represented by position in a list - the last element is 'on top'. To change z-order, we simply rearrange list positions. The HashMap provides O(1) lookup while the List provides ordered traversal for hit-testing."
  },
  "visual_explanation": {
    "before_after": "```\nZ-ORDER VISUALIZATION (List index = z-position)\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nINITIAL STATE after creating rect_1, rect_2, circle_1:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Index:    [0]         [1]         [2]                        \u2502\n\u2502  List:   rect_1  \u2192  rect_2  \u2192  circle_1                       \u2502\n\u2502            \u2191           \u2191           \u2191                          \u2502\n\u2502         BOTTOM      MIDDLE       TOP                          \u2502\n\u2502       (drawn first)          (drawn last, visible on top)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER bringToFront(\"rect_1\"):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Index:    [0]         [1]         [2]                        \u2502\n\u2502  List:   rect_2  \u2192  circle_1  \u2192  rect_1                       \u2502\n\u2502            \u2191                       \u2191                          \u2502\n\u2502         BOTTOM                    TOP (rect_1 now on top!)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER sendToBack(\"circle_1\"):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Index:    [0]         [1]         [2]                        \u2502\n\u2502  List:  circle_1  \u2192  rect_2  \u2192  rect_1                        \u2502\n\u2502            \u2191                       \u2191                          \u2502\n\u2502         BOTTOM                    TOP                         \u2502\n\u2502      (circle now behind all)                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER deleteShape(\"rect_2\"):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Index:    [0]         [1]                                    \u2502\n\u2502  List:  circle_1  \u2192  rect_1                                   \u2502\n\u2502                                                               \u2502\n\u2502  HashMap: {circle_1: Circle, rect_1: Rectangle}               \u2502\n\u2502  (rect_2 removed from both structures)                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nDELETE SHAPE ALGORITHM:\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ndeleteShape(\"rect_2\"):\n\n  Step 1: Lookup in HashMap          O(1)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  shapes.get(\"rect_2\") \u2192 Rectangle obj   \u2502\n  \u2502  (returns null if not found \u2192 return)   \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2193\n  Step 2: Remove from z-order list    O(n)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  zOrder: [rect_1, rect_2, circle_1]     \u2502\n  \u2502                   \u2191                     \u2502\n  \u2502              remove this                \u2502\n  \u2502  Result: [rect_1, circle_1]             \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2193\n  Step 3: Remove from HashMap         O(1)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  shapes.remove(\"rect_2\")                \u2502\n  \u2502  (shape now fully deleted)              \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\nBRING TO FRONT ALGORITHM:\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nbringToFront(\"rect_1\"):\n\n  Step 1: Validate exists              O(1)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  shape = shapes.get(\"rect_1\")           \u2502\n  \u2502  if null \u2192 return (no-op)               \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2193\n  Step 2: Remove from current position O(n)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  BEFORE: [rect_1, rect_2, circle_1]     \u2502\n  \u2502             \u2191                           \u2502\n  \u2502         remove                          \u2502\n  \u2502  AFTER:  [rect_2, circle_1]             \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2193\n  Step 3: Append to end (TOP)          O(1)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  zOrder.append(rect_1)                  \u2502\n  \u2502  Result: [rect_2, circle_1, rect_1]     \u2502\n  \u2502                             \u2191           \u2502\n  \u2502                     NOW ON TOP!         \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Linear Search Everything",
      "description": "Simply iterate through list for all operations without HashMap. For each operation, scan the entire list to find the shape by ID.",
      "time_complexity": "O(n) for all operations",
      "space_complexity": "O(n) - just the list",
      "why_not_optimal": "Every operation requires O(n) search to find the shape. With HashMap, we get O(1) lookup. Also, without the HashMap, getShapeAt would need to store IDs separately, complicating the design."
    },
    {
      "name": "Optimal: HashMap + List Combination",
      "description": "Use HashMap for O(1) shape lookup by ID, and List for maintaining z-order. The list position determines drawing order - last element is on top. For z-order changes, we remove from current position and re-add at desired position.",
      "time_complexity": "O(n) for delete/bringToFront/sendToBack due to list operations",
      "space_complexity": "O(n) - each shape stored once in HashMap, once referenced in List",
      "key_insight": "The list naturally represents z-order - index 0 is bottom, last index is top. We traverse in reverse for hit-testing (top to bottom). The HashMap gives us instant access to shape objects, while the list gives us ordered iteration."
    },
    {
      "name": "Advanced: LinkedList with Node References",
      "description": "Store direct references to LinkedList nodes in HashMap. This allows O(1) removal if you have the node reference, but Java's LinkedList doesn't expose nodes.",
      "time_complexity": "Could be O(1) for all z-order operations with custom implementation",
      "space_complexity": "O(n)",
      "key_insight": "For interview context, the ArrayList approach is cleaner and easier to explain. The LinkedList optimization is a great follow-up discussion point but usually overkill."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Dual Data Structure Approach\n\n### Core Insight\nThe key realization is that **z-order is simply list position**. We don't need complex z-index values or sorting - the list's natural ordering does the work:\n- **Index 0** = Bottom (drawn first, can be occluded)\n- **Last index** = Top (drawn last, always visible)\n\n### Data Structures\n1. **HashMap<String, Shape>**: O(1) lookup by shape ID\n2. **List<Shape>**: Ordered by z-position, traversed in reverse for hit-testing\n\n### Algorithm Details\n\n**deleteShape(shapeId)**:\n1. Look up shape in HashMap \u2192 O(1)\n2. If not found, return immediately (fail silently)\n3. Remove shape from z-order list \u2192 O(n) scan to find\n4. Remove from HashMap \u2192 O(1)\n\n**bringToFront(shapeId)**:\n1. Look up shape in HashMap \u2192 O(1)\n2. If not found, return immediately\n3. Remove from current list position \u2192 O(n)\n4. Append to end of list \u2192 O(1) amortized\n\n**sendToBack(shapeId)**:\n1. Look up shape in HashMap \u2192 O(1)\n2. If not found, return immediately\n3. Remove from current list position \u2192 O(n)\n4. Insert at index 0 \u2192 O(n) for ArrayList (shifts all elements)\n\n### Why This Design?\n- **Simplicity**: Easy to understand and implement correctly\n- **Correctness**: List order guarantees correct z-ordering\n- **Extensibility**: Easy to add moveUp/moveDown by 1 position\n- **Interview-Friendly**: Clear separation of concerns",
    "data_structures": [
      {
        "structure": "HashMap<String, Shape>",
        "purpose": "O(1) lookup of shape objects by their unique ID - essential for all operations"
      },
      {
        "structure": "ArrayList<Shape>",
        "purpose": "Maintains z-order through list position. Last element is topmost. Traversed in reverse for hit-testing"
      },
      {
        "structure": "Shape (abstract class)",
        "purpose": "Polymorphic base for Rectangle and Circle - enables uniform handling"
      },
      {
        "structure": "Counters (rectCounter, circleCounter)",
        "purpose": "Generate unique, predictable IDs like 'rect_1', 'circle_2'"
      }
    ],
    "algorithm_steps": [
      "Step 1: For any operation, first validate the shapeId exists using O(1) HashMap lookup",
      "Step 2: For deleteShape - remove from both HashMap and z-order list to ensure complete cleanup",
      "Step 3: For bringToFront - remove from current position, append to end (top of z-stack)",
      "Step 4: For sendToBack - remove from current position, insert at index 0 (bottom of z-stack)",
      "Step 5: getShapeAt must iterate z-order in REVERSE to check topmost shapes first",
      "Step 6: Handle edge cases: non-existent shape ID should be a no-op (no exception)"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "2D Canvas Drawing Application - Part 3",
    "Complete implementation with delete and z-order control",
    "\"\"\"",
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict",
    "import math",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all drawable shapes.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str):",
    "        self.shape_id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains_point(self, x: float, y: float) -> bool:",
    "        \"\"\"Check if point (x, y) is inside this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def move(self, new_x: float, new_y: float) -> None:",
    "        \"\"\"Move shape to new position.\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"Rectangle defined by top-left corner and dimensions.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, x: float, y: float, ",
    "                 width: float, height: float):",
    "        super().__init__(shape_id)",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "    ",
    "    def contains_point(self, px: float, py: float) -> bool:",
    "        \"\"\"Point is inside if within bounds (inclusive).\"\"\"",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "    ",
    "    def move(self, new_x: float, new_y: float) -> None:",
    "        \"\"\"Move top-left corner to new position.\"\"\"",
    "        self.x = new_x",
    "        self.y = new_y",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Rectangle({self.shape_id}, x={self.x}, y={self.y})\"",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"Circle defined by center point and radius.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, center_x: float, ",
    "                 center_y: float, radius: float):",
    "        super().__init__(shape_id)",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "    ",
    "    def contains_point(self, px: float, py: float) -> bool:",
    "        \"\"\"Point is inside if distance to center <= radius.\"\"\"",
    "        dx = px - self.center_x",
    "        dy = py - self.center_y",
    "        distance_squared = dx * dx + dy * dy",
    "        return distance_squared <= self.radius * self.radius",
    "    ",
    "    def move(self, new_center_x: float, new_center_y: float) -> None:",
    "        \"\"\"Move center to new position.\"\"\"",
    "        self.center_x = new_center_x",
    "        self.center_y = new_center_y",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Circle({self.shape_id}, center=({self.center_x}, {self.center_y}))\"",
    "",
    "",
    "class Canvas:",
    "    \"\"\"",
    "    2D Drawing Canvas with shape management and z-ordering.",
    "    ",
    "    Supports creating, querying, moving, deleting shapes,",
    "    and controlling their visual stacking order (z-order).",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # HashMap for O(1) lookup by shape ID",
    "        self._shapes: Dict[str, Shape] = {}",
    "        # List maintains z-order: index 0 = bottom, last = top",
    "        self._z_order: List[Shape] = []",
    "        # Counters for generating unique IDs",
    "        self._rect_counter: int = 0",
    "        self._circle_counter: int = 0",
    "    ",
    "    def create_rectangle(self, x: float, y: float, ",
    "                         width: float, height: float) -> str:",
    "        \"\"\"",
    "        Create a rectangle and add to canvas.",
    "        ",
    "        Args:",
    "            x: Top-left corner x coordinate",
    "            y: Top-left corner y coordinate",
    "            width: Rectangle width",
    "            height: Rectangle height",
    "            ",
    "        Returns:",
    "            Unique shape ID (e.g., 'rect_1')",
    "        \"\"\"",
    "        self._rect_counter += 1",
    "        shape_id = f\"rect_{self._rect_counter}\"",
    "        rect = Rectangle(shape_id, x, y, width, height)",
    "        self._shapes[shape_id] = rect",
    "        self._z_order.append(rect)  # New shapes go on top",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: float, center_y: float, ",
    "                      radius: float) -> str:",
    "        \"\"\"",
    "        Create a circle and add to canvas.",
    "        ",
    "        Args:",
    "            center_x: Center x coordinate",
    "            center_y: Center y coordinate",
    "            radius: Circle radius",
    "            ",
    "        Returns:",
    "            Unique shape ID (e.g., 'circle_1')",
    "        \"\"\"",
    "        self._circle_counter += 1",
    "        shape_id = f\"circle_{self._circle_counter}\"",
    "        circle = Circle(shape_id, center_x, center_y, radius)",
    "        self._shapes[shape_id] = circle",
    "        self._z_order.append(circle)  # New shapes go on top",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: float, y: float) -> Optional[str]:",
    "        \"\"\"",
    "        Find the topmost shape at given coordinates.",
    "        ",
    "        Iterates from top to bottom of z-order stack,",
    "        returning the first shape that contains the point.",
    "        ",
    "        Args:",
    "            x: Query x coordinate",
    "            y: Query y coordinate",
    "            ",
    "        Returns:",
    "            Shape ID of topmost shape at point, or None if empty",
    "        \"\"\"",
    "        # Reverse iteration: check topmost shapes first",
    "        for shape in reversed(self._z_order):",
    "            if shape.contains_point(x, y):",
    "                return shape.shape_id",
    "        return None",
    "    ",
    "    def move_shape(self, shape_id: str, new_x: float, ",
    "                   new_y: float) -> bool:",
    "        \"\"\"",
    "        Move a shape to a new position.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to move",
    "            new_x: New x coordinate (top-left for rect, center for circle)",
    "            new_y: New y coordinate",
    "            ",
    "        Returns:",
    "            True if shape was found and moved, False otherwise",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return False",
    "        self._shapes[shape_id].move(new_x, new_y)",
    "        return True",
    "    ",
    "    # ==================== PART 3: NEW METHODS ====================",
    "    ",
    "    def delete_shape(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Delete a shape from the canvas completely.",
    "        ",
    "        Removes shape from both the HashMap (for lookup) and",
    "        the z-order list (for rendering/hit-testing).",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to delete",
    "            ",
    "        Note:",
    "            If shape doesn't exist, this is a no-op (no exception).",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return  # Fail silently for non-existent shapes",
    "        ",
    "        shape = self._shapes[shape_id]",
    "        self._z_order.remove(shape)  # O(n) - linear scan to find",
    "        del self._shapes[shape_id]   # O(1) - hash removal",
    "    ",
    "    def bring_to_front(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Move shape to top of z-order (will appear above all others).",
    "        ",
    "        The shape is removed from its current position and",
    "        appended to the end of the z-order list.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to bring to front",
    "            ",
    "        Note:",
    "            If shape doesn't exist, this is a no-op.",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return  # Fail silently",
    "        ",
    "        shape = self._shapes[shape_id]",
    "        self._z_order.remove(shape)  # O(n) - remove from current pos",
    "        self._z_order.append(shape)  # O(1) - add to end (top)",
    "    ",
    "    def send_to_back(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Move shape to bottom of z-order (will appear behind all others).",
    "        ",
    "        The shape is removed from its current position and",
    "        inserted at the beginning of the z-order list.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to send to back",
    "            ",
    "        Note:",
    "            If shape doesn't exist, this is a no-op.",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return  # Fail silently",
    "        ",
    "        shape = self._shapes[shape_id]",
    "        self._z_order.remove(shape)     # O(n) - remove from current pos",
    "        self._z_order.insert(0, shape)  # O(n) - insert at beginning",
    "    ",
    "    # ==================== UTILITY METHODS ====================",
    "    ",
    "    def get_z_order(self) -> List[str]:",
    "        \"\"\"Return list of shape IDs in z-order (bottom to top).\"\"\"",
    "        return [shape.shape_id for shape in self._z_order]",
    "    ",
    "    def get_shape_count(self) -> int:",
    "        \"\"\"Return total number of shapes on canvas.\"\"\"",
    "        return len(self._shapes)",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate Part 3 functionality with examples.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"2D Canvas - Part 3: Delete Shape & Z-Order Control\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Example 1: Delete Shape",
    "    print(\"\\n--- Example 1: Delete Shape ---\")",
    "    canvas = Canvas()",
    "    ",
    "    rect1_id = canvas.create_rectangle(0, 0, 50, 50)",
    "    rect2_id = canvas.create_rectangle(25, 25, 50, 50)",
    "    print(f\"Created: {rect1_id}, {rect2_id}\")",
    "    print(f\"Z-order: {canvas.get_z_order()}\")",
    "    ",
    "    # Point (30, 30) is in overlap - should return rect_2 (on top)",
    "    result = canvas.get_shape_at(30, 30)",
    "    print(f\"Shape at (30, 30): {result}  (expected: rect_2)\")",
    "    ",
    "    # Delete rect_2",
    "    canvas.delete_shape(rect2_id)",
    "    print(f\"After deleting {rect2_id}\")",
    "    print(f\"Z-order: {canvas.get_z_order()}\")",
    "    ",
    "    # Now (30, 30) should return rect_1",
    "    result = canvas.get_shape_at(30, 30)",
    "    print(f\"Shape at (30, 30): {result}  (expected: rect_1)\")",
    "    ",
    "    # Example 2: Bring to Front",
    "    print(\"\\n--- Example 2: Bring to Front ---\")",
    "    canvas2 = Canvas()",
    "    ",
    "    r1 = canvas2.create_rectangle(0, 0, 50, 50)",
    "    r2 = canvas2.create_rectangle(25, 25, 50, 50)",
    "    print(f\"Created: {r1}, {r2}\")",
    "    print(f\"Initial z-order: {canvas2.get_z_order()}\")",
    "    ",
    "    result = canvas2.get_shape_at(30, 30)",
    "    print(f\"Shape at (30, 30): {result}  (expected: rect_2)\")",
    "    ",
    "    # Bring rect_1 to front",
    "    canvas2.bring_to_front(r1)",
    "    print(f\"After bringToFront({r1})\")",
    "    print(f\"Z-order: {canvas2.get_z_order()}\")",
    "    ",
    "    result = canvas2.get_shape_at(30, 30)",
    "    print(f\"Shape at (30, 30): {result}  (expected: rect_1)\")",
    "    ",
    "    # Example 3: Send to Back",
    "    print(\"\\n--- Example 3: Send to Back ---\")",
    "    canvas3 = Canvas()",
    "    ",
    "    r1 = canvas3.create_rectangle(0, 0, 100, 100)",
    "    c1 = canvas3.create_circle(50, 50, 30)",
    "    r2 = canvas3.create_rectangle(25, 25, 50, 50)",
    "    print(f\"Created: {r1}, {c1}, {r2}\")",
    "    print(f\"Initial z-order: {canvas3.get_z_order()}\")",
    "    ",
    "    # Send rect_2 to back",
    "    canvas3.send_to_back(r2)",
    "    print(f\"After sendToBack({r2})\")",
    "    print(f\"Z-order: {canvas3.get_z_order()}\")",
    "    ",
    "    # Point (50, 50) is center of circle, should return circle",
    "    result = canvas3.get_shape_at(50, 50)",
    "    print(f\"Shape at (50, 50): {result}  (expected: circle_1)\")",
    "    ",
    "    # Example 4: Edge Cases",
    "    print(\"\\n--- Example 4: Edge Cases ---\")",
    "    canvas4 = Canvas()",
    "    ",
    "    # Operations on non-existent shapes (should not crash)",
    "    canvas4.delete_shape(\"nonexistent\")",
    "    canvas4.bring_to_front(\"fake_id\")",
    "    canvas4.send_to_back(\"missing\")",
    "    print(\"Operations on non-existent shapes: OK (no crash)\")",
    "    ",
    "    # Delete already deleted shape",
    "    r1 = canvas4.create_rectangle(0, 0, 10, 10)",
    "    canvas4.delete_shape(r1)",
    "    canvas4.delete_shape(r1)  # Should be no-op",
    "    print(\"Double delete: OK (no crash)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 3 tests passed!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * 2D Canvas Drawing Application - Part 3",
    " * Complete implementation with delete and z-order control",
    " */",
    "",
    "abstract class Shape {",
    "    protected String shapeId;",
    "    ",
    "    public Shape(String shapeId) {",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    public String getShapeId() {",
    "        return shapeId;",
    "    }",
    "    ",
    "    public abstract boolean containsPoint(double x, double y);",
    "    public abstract void move(double newX, double newY);",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private double x, y, width, height;",
    "    ",
    "    public Rectangle(String shapeId, double x, double y, ",
    "                     double width, double height) {",
    "        super(shapeId);",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(double px, double py) {",
    "        // Point is inside if within bounds (inclusive)",
    "        return px >= x && px <= x + width && ",
    "               py >= y && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public void move(double newX, double newY) {",
    "        this.x = newX;",
    "        this.y = newY;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Rectangle(%s, x=%.1f, y=%.1f)\", ",
    "                             shapeId, x, y);",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private double centerX, centerY, radius;",
    "    ",
    "    public Circle(String shapeId, double centerX, ",
    "                  double centerY, double radius) {",
    "        super(shapeId);",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(double px, double py) {",
    "        // Point inside if distance to center <= radius",
    "        double dx = px - centerX;",
    "        double dy = py - centerY;",
    "        double distanceSquared = dx * dx + dy * dy;",
    "        return distanceSquared <= radius * radius;",
    "    }",
    "    ",
    "    @Override",
    "    public void move(double newCenterX, double newCenterY) {",
    "        this.centerX = newCenterX;",
    "        this.centerY = newCenterY;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Circle(%s, center=(%.1f, %.1f))\", ",
    "                             shapeId, centerX, centerY);",
    "    }",
    "}",
    "",
    "/**",
    " * 2D Drawing Canvas with shape management and z-ordering.",
    " * ",
    " * Supports creating, querying, moving, deleting shapes,",
    " * and controlling their visual stacking order (z-order).",
    " */",
    "public class Canvas {",
    "    // HashMap for O(1) lookup by shape ID",
    "    private Map<String, Shape> shapes;",
    "    // List maintains z-order: index 0 = bottom, last = top",
    "    private List<Shape> zOrder;",
    "    // Counters for generating unique IDs",
    "    private int rectCounter;",
    "    private int circleCounter;",
    "    ",
    "    public Canvas() {",
    "        shapes = new HashMap<>();",
    "        zOrder = new ArrayList<>();",
    "        rectCounter = 0;",
    "        circleCounter = 0;",
    "    }",
    "    ",
    "    /**",
    "     * Create a rectangle and add to canvas.",
    "     * @param x Top-left corner x coordinate",
    "     * @param y Top-left corner y coordinate",
    "     * @param width Rectangle width",
    "     * @param height Rectangle height",
    "     * @return Unique shape ID (e.g., \"rect_1\")",
    "     */",
    "    public String createRectangle(double x, double y, ",
    "                                  double width, double height) {",
    "        rectCounter++;",
    "        String shapeId = \"rect_\" + rectCounter;",
    "        Rectangle rect = new Rectangle(shapeId, x, y, width, height);",
    "        shapes.put(shapeId, rect);",
    "        zOrder.add(rect);  // New shapes go on top",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Create a circle and add to canvas.",
    "     * @param centerX Center x coordinate",
    "     * @param centerY Center y coordinate",
    "     * @param radius Circle radius",
    "     * @return Unique shape ID (e.g., \"circle_1\")",
    "     */",
    "    public String createCircle(double centerX, double centerY, ",
    "                               double radius) {",
    "        circleCounter++;",
    "        String shapeId = \"circle_\" + circleCounter;",
    "        Circle circle = new Circle(shapeId, centerX, centerY, radius);",
    "        shapes.put(shapeId, circle);",
    "        zOrder.add(circle);  // New shapes go on top",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Find the topmost shape at given coordinates.",
    "     * Iterates from top to bottom of z-order stack.",
    "     * @param x Query x coordinate",
    "     * @param y Query y coordinate",
    "     * @return Shape ID of topmost shape at point, or null if none",
    "     */",
    "    public String getShapeAt(double x, double y) {",
    "        // Reverse iteration: check topmost shapes first",
    "        for (int i = zOrder.size() - 1; i >= 0; i--) {",
    "            Shape shape = zOrder.get(i);",
    "            if (shape.containsPoint(x, y)) {",
    "                return shape.getShapeId();",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    /**",
    "     * Move a shape to a new position.",
    "     * @param shapeId ID of shape to move",
    "     * @param newX New x coordinate",
    "     * @param newY New y coordinate",
    "     * @return true if shape was found and moved, false otherwise",
    "     */",
    "    public boolean moveShape(String shapeId, double newX, double newY) {",
    "        Shape shape = shapes.get(shapeId);",
    "        if (shape == null) {",
    "            return false;",
    "        }",
    "        shape.move(newX, newY);",
    "        return true;",
    "    }",
    "    ",
    "    // ==================== PART 3: NEW METHODS ====================",
    "    ",
    "    /**",
    "     * Delete a shape from the canvas completely.",
    "     * Removes from both HashMap and z-order list.",
    "     * @param shapeId ID of shape to delete",
    "     */",
    "    public void deleteShape(String shapeId) {",
    "        Shape shape = shapes.get(shapeId);",
    "        if (shape == null) {",
    "            return;  // Fail silently for non-existent shapes",
    "        }",
    "        zOrder.remove(shape);  // O(n) - linear scan",
    "        shapes.remove(shapeId); // O(1) - hash removal",
    "    }",
    "    ",
    "    /**",
    "     * Move shape to top of z-order (appears above all others).",
    "     * @param shapeId ID of shape to bring to front",
    "     */",
    "    public void bringToFront(String shapeId) {",
    "        Shape shape = shapes.get(shapeId);",
    "        if (shape == null) {",
    "            return;  // Fail silently",
    "        }",
    "        zOrder.remove(shape);  // O(n) - remove from current position",
    "        zOrder.add(shape);     // O(1) - append to end (top)",
    "    }",
    "    ",
    "    /**",
    "     * Move shape to bottom of z-order (appears behind all others).",
    "     * @param shapeId ID of shape to send to back",
    "     */",
    "    public void sendToBack(String shapeId) {",
    "        Shape shape = shapes.get(shapeId);",
    "        if (shape == null) {",
    "            return;  // Fail silently",
    "        }",
    "        zOrder.remove(shape);    // O(n) - remove from current position",
    "        zOrder.add(0, shape);    // O(n) - insert at beginning",
    "    }",
    "    ",
    "    // ==================== UTILITY METHODS ====================",
    "    ",
    "    /** Return list of shape IDs in z-order (bottom to top). */",
    "    public List<String> getZOrder() {",
    "        List<String> result = new ArrayList<>();",
    "        for (Shape shape : zOrder) {",
    "            result.add(shape.getShapeId());",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /** Return total number of shapes on canvas. */",
    "    public int getShapeCount() {",
    "        return shapes.size();",
    "    }",
    "    ",
    "    // ==================== MAIN / DEMO ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"2D Canvas - Part 3: Delete Shape & Z-Order Control\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Example 1: Delete Shape",
    "        System.out.println(\"\\n--- Example 1: Delete Shape ---\");",
    "        Canvas canvas = new Canvas();",
    "        ",
    "        String rect1 = canvas.createRectangle(0, 0, 50, 50);",
    "        String rect2 = canvas.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Created: \" + rect1 + \", \" + rect2);",
    "        System.out.println(\"Z-order: \" + canvas.getZOrder());",
    "        ",
    "        String result = canvas.getShapeAt(30, 30);",
    "        System.out.println(\"Shape at (30,30): \" + result + \"  (expected: rect_2)\");",
    "        ",
    "        canvas.deleteShape(rect2);",
    "        System.out.println(\"After deleting \" + rect2);",
    "        System.out.println(\"Z-order: \" + canvas.getZOrder());",
    "        ",
    "        result = canvas.getShapeAt(30, 30);",
    "        System.out.println(\"Shape at (30,30): \" + result + \"  (expected: rect_1)\");",
    "        ",
    "        // Example 2: Bring to Front",
    "        System.out.println(\"\\n--- Example 2: Bring to Front ---\");",
    "        Canvas canvas2 = new Canvas();",
    "        ",
    "        String r1 = canvas2.createRectangle(0, 0, 50, 50);",
    "        String r2 = canvas2.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Created: \" + r1 + \", \" + r2);",
    "        System.out.println(\"Initial z-order: \" + canvas2.getZOrder());",
    "        ",
    "        result = canvas2.getShapeAt(30, 30);",
    "        System.out.println(\"Shape at (30,30): \" + result + \"  (expected: rect_2)\");",
    "        ",
    "        canvas2.bringToFront(r1);",
    "        System.out.println(\"After bringToFront(\" + r1 + \")\");",
    "        System.out.println(\"Z-order: \" + canvas2.getZOrder());",
    "        ",
    "        result = canvas2.getShapeAt(30, 30);",
    "        System.out.println(\"Shape at (30,30): \" + result + \"  (expected: rect_1)\");",
    "        ",
    "        // Example 3: Send to Back",
    "        System.out.println(\"\\n--- Example 3: Send to Back ---\");",
    "        Canvas canvas3 = new Canvas();",
    "        ",
    "        r1 = canvas3.createRectangle(0, 0, 100, 100);",
    "        String c1 = canvas3.createCircle(50, 50, 30);",
    "        r2 = canvas3.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Created: \" + r1 + \", \" + c1 + \", \" + r2);",
    "        System.out.println(\"Initial z-order: \" + canvas3.getZOrder());",
    "        ",
    "        canvas3.sendToBack(r2);",
    "        System.out.println(\"After sendToBack(\" + r2 + \")\");",
    "        System.out.println(\"Z-order: \" + canvas3.getZOrder());",
    "        ",
    "        result = canvas3.getShapeAt(50, 50);",
    "        System.out.println(\"Shape at (50,50): \" + result + \"  (expected: circle_1)\");",
    "        ",
    "        // Example 4: Edge Cases",
    "        System.out.println(\"\\n--- Example 4: Edge Cases ---\");",
    "        Canvas canvas4 = new Canvas();",
    "        ",
    "        canvas4.deleteShape(\"nonexistent\");",
    "        canvas4.bringToFront(\"fake_id\");",
    "        canvas4.sendToBack(\"missing\");",
    "        System.out.println(\"Operations on non-existent shapes: OK (no crash)\");",
    "        ",
    "        r1 = canvas4.createRectangle(0, 0, 10, 10);",
    "        canvas4.deleteShape(r1);",
    "        canvas4.deleteShape(r1);  // Should be no-op",
    "        System.out.println(\"Double delete: OK (no crash)\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All Part 3 tests passed!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-8",
      "explanation": "Imports and module docstring. We use ABC for abstract base classes, Optional for nullable returns, and typing for type hints."
    },
    {
      "lines": "10-24",
      "explanation": "Shape abstract base class defining the interface. All shapes must implement contains_point() for hit-testing and move() for repositioning."
    },
    {
      "lines": "26-50",
      "explanation": "Rectangle class with bounds checking. contains_point uses simple comparison: x <= px <= x+width AND y <= py <= y+height. Edges are inclusive."
    },
    {
      "lines": "52-78",
      "explanation": "Circle class with distance-based hit testing. Uses distance\u00b2 <= radius\u00b2 to avoid expensive sqrt. Point is inside if distance from center <= radius."
    },
    {
      "lines": "80-98",
      "explanation": "Canvas class initialization. Two data structures: _shapes dict for O(1) ID lookup, _z_order list for ordered traversal. Counters ensure unique IDs."
    },
    {
      "lines": "100-130",
      "explanation": "Shape creation methods. Each increments counter, creates shape, stores in both data structures. New shapes are appended (placed on top)."
    },
    {
      "lines": "132-148",
      "explanation": "getShapeAt traverses z_order in REVERSE (top to bottom). Returns first shape containing point - this ensures topmost shape wins."
    },
    {
      "lines": "150-165",
      "explanation": "moveShape from Part 2 - uses HashMap for O(1) lookup, delegates to shape's move method."
    },
    {
      "lines": "167-185",
      "explanation": "NEW: delete_shape removes from both structures. HashMap lookup first (O(1)), then list removal (O(n)), then dict deletion (O(1))."
    },
    {
      "lines": "187-205",
      "explanation": "NEW: bring_to_front removes from current position and appends to end. End of list = top of z-order = visible over other shapes."
    },
    {
      "lines": "207-225",
      "explanation": "NEW: send_to_back removes and inserts at index 0. Beginning of list = bottom of z-order = rendered first, occluded by others."
    },
    {
      "lines": "227-240",
      "explanation": "Utility methods for debugging and testing - get_z_order returns ID list, get_shape_count returns total shapes."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "deleteShape": {
          "complexity": "O(n)",
          "explanation": "HashMap lookup is O(1), but list.remove() scans the list to find the element - O(n)"
        },
        "bringToFront": {
          "complexity": "O(n)",
          "explanation": "O(1) lookup + O(n) list removal + O(1) append = O(n)"
        },
        "sendToBack": {
          "complexity": "O(n)",
          "explanation": "O(1) lookup + O(n) removal + O(n) insert at 0 (shifts all elements) = O(n)"
        }
      },
      "overall_change": "Part 3 adds O(n) operations for z-order manipulation. This is acceptable for typical canvas sizes (<10,000 shapes). For very large canvases, consider LinkedList with node references."
    },
    "space": {
      "additional_space": "O(1)",
      "explanation": "No new data structures added in Part 3. The same HashMap and List from Part 2 are used. Space remains O(n) where n is number of shapes."
    }
  },
  "dry_run": {
    "example_input": "Example 2: createRectangle(0,0,50,50), createRectangle(25,25,50,50), getShapeAt(30,30), bringToFront('rect_1'), getShapeAt(30,30)",
    "steps": [
      {
        "step": 1,
        "action": "Canvas()",
        "state": "shapes={}, z_order=[], rect_counter=0",
        "explanation": "Initialize empty canvas"
      },
      {
        "step": 2,
        "action": "createRectangle(0, 0, 50, 50)",
        "state": "shapes={'rect_1': Rect}, z_order=[rect_1], rect_counter=1",
        "explanation": "Create rect_1 at (0,0) with 50x50 size. Added to both structures."
      },
      {
        "step": 3,
        "action": "createRectangle(25, 25, 50, 50)",
        "state": "shapes={'rect_1': Rect, 'rect_2': Rect}, z_order=[rect_1, rect_2], rect_counter=2",
        "explanation": "Create rect_2 at (25,25). Appended to end of z_order, so it's on top."
      },
      {
        "step": 4,
        "action": "getShapeAt(30, 30)",
        "state": "Checking from top: rect_2.contains(30,30)?",
        "explanation": "Iterate reverse: rect_2 first. (30,30) is within rect_2 bounds (25<=30<=75, 25<=30<=75). Return 'rect_2'."
      },
      {
        "step": 5,
        "action": "bringToFront('rect_1')",
        "state": "z_order=[rect_2, rect_1]",
        "explanation": "1) Lookup rect_1 in HashMap \u2713. 2) Remove rect_1 from z_order: [rect_2]. 3) Append rect_1: [rect_2, rect_1]. rect_1 now on top!"
      },
      {
        "step": 6,
        "action": "getShapeAt(30, 30)",
        "state": "Checking from top: rect_1.contains(30,30)?",
        "explanation": "Iterate reverse: rect_1 first now. (30,30) is within rect_1 bounds (0<=30<=50, 0<=30<=50). Return 'rect_1'."
      }
    ],
    "final_output": "[null, 'rect_1', 'rect_2', 'rect_2', null, 'rect_1']"
  },
  "edge_cases": [
    {
      "case": "Delete non-existent shape",
      "handling": "Check if shapeId exists in HashMap first; if not, return immediately (no-op)",
      "gotcha": "Don't throw exception - fail silently as specified"
    },
    {
      "case": "Delete already deleted shape",
      "handling": "Second delete will find nothing in HashMap and return immediately",
      "gotcha": "Ensure complete removal from BOTH data structures in first delete"
    },
    {
      "case": "bringToFront shape that's already on top",
      "handling": "Remove and re-add to same position - still works correctly",
      "gotcha": "Could optimize to check position first, but unnecessary complexity for interviews"
    },
    {
      "case": "sendToBack shape that's already at bottom",
      "handling": "Remove and re-add to same position - still works correctly",
      "gotcha": "Same as above - optimize only if interviewer asks"
    },
    {
      "case": "Z-order operations on single shape",
      "handling": "Works fine - shape is removed then re-added, ending in same position",
      "gotcha": "List operations with single element are still valid"
    },
    {
      "case": "getShapeAt after all shapes deleted",
      "handling": "Empty list iteration returns null immediately",
      "gotcha": "Reversed empty list is still empty - no special case needed"
    }
  ],
  "test_cases": [
    {
      "name": "Basic delete",
      "input": "create rect_1, create rect_2, delete rect_2, getShapeAt(overlap point)",
      "expected": "rect_1 (the remaining shape)",
      "explanation": "After deleting the top shape, previously occluded shape is now visible"
    },
    {
      "name": "Basic bring to front",
      "input": "create rect_1, create rect_2, bringToFront(rect_1), getShapeAt(overlap)",
      "expected": "rect_1 (now on top)",
      "explanation": "Bottom shape brought to top, now wins hit-test in overlap region"
    },
    {
      "name": "Basic send to back",
      "input": "create rect_1, create rect_2, create rect_3, sendToBack(rect_3), getShapeAt(overlap)",
      "expected": "rect_2 (middle shape now on top)",
      "explanation": "Top shape sent to back, middle shape is now topmost in overlap"
    },
    {
      "name": "Delete then z-order op",
      "input": "create rect_1, delete rect_1, bringToFront(rect_1)",
      "expected": "No crash, bringToFront is no-op",
      "explanation": "Operations on deleted shapes should fail silently"
    },
    {
      "name": "Multiple z-order changes",
      "input": "create A, B, C. bringToFront(A), sendToBack(B), bringToFront(C)",
      "expected": "Order: B, A, C (C on top)",
      "explanation": "Complex z-order manipulation should track correctly"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Only removing from HashMap, forgetting z_order list",
      "why_wrong": "Shape reference remains in z_order, causing ghost shapes in hit-testing",
      "correct_approach": "Always remove from BOTH data structures in deleteShape",
      "code_example_wrong": "def delete_shape(self, shape_id):\n    del self._shapes[shape_id]  # WRONG: z_order still has reference",
      "code_example_correct": "def delete_shape(self, shape_id):\n    shape = self._shapes.get(shape_id)\n    if shape:\n        self._z_order.remove(shape)\n        del self._shapes[shape_id]"
    },
    {
      "mistake": "Iterating z_order forwards in getShapeAt",
      "why_wrong": "Returns bottom shape instead of topmost shape in overlap regions",
      "correct_approach": "Always iterate in REVERSE for hit-testing - check top shapes first",
      "code_example_wrong": "for shape in self._z_order:  # WRONG: checks bottom first\n    if shape.contains_point(x, y): return shape.shape_id",
      "code_example_correct": "for shape in reversed(self._z_order):  # CORRECT: top first\n    if shape.contains_point(x, y): return shape.shape_id"
    },
    {
      "mistake": "Throwing exception for invalid shapeId",
      "why_wrong": "Problem specifies silent failure - no exceptions for missing shapes",
      "correct_approach": "Check existence first, return early if not found",
      "code_example_wrong": "def bring_to_front(self, shape_id):\n    shape = self._shapes[shape_id]  # WRONG: KeyError if missing",
      "code_example_correct": "def bring_to_front(self, shape_id):\n    if shape_id not in self._shapes:\n        return  # Silent no-op\n    shape = self._shapes[shape_id]"
    },
    {
      "mistake": "Using z-index numbers instead of list position",
      "why_wrong": "Requires sorting and managing numeric z-indices, more complex",
      "correct_approach": "List position IS the z-index - simpler and elegant",
      "code_example_wrong": "class Shape:\n    def __init__(self):\n        self.z_index = 0  # Have to manage this manually",
      "code_example_correct": "# Z-order is implicit in list position\n# z_order[0] = bottom, z_order[-1] = top"
    }
  ],
  "interview_tips": {
    "how_to_present": "1) State that z-order is naturally represented by list position. 2) Explain the dual data structure approach - HashMap for lookup, List for ordering. 3) Walk through one operation (e.g., bringToFront) step by step. 4) Mention the O(n) complexity and discuss potential optimizations if asked.",
    "what_to_mention": [
      "Z-order is elegantly represented by list index - no extra z-index variable needed",
      "Dual data structures serve complementary purposes: HashMap for O(1) lookup, List for ordered traversal",
      "All operations fail silently on invalid IDs - defensive programming",
      "Trade-off: O(n) for z-order ops is acceptable for typical canvas sizes",
      "Could use LinkedList for O(1) removal with node caching, but ArrayList is simpler"
    ],
    "time_allocation": "8-12 minutes. Spend 2 min explaining the approach, 5 min coding, 3 min testing with examples.",
    "if_stuck": [
      "Think about what 'on top' means visually - it's the last thing drawn",
      "List naturally has order - last element is 'highest'",
      "To bring to front: remove from current position, add to end",
      "To send to back: remove from current position, insert at beginning"
    ]
  },
  "connection_to_next_part": "Part 3 establishes full shape lifecycle management (create, move, delete) and z-ordering. Part 4 might introduce: (1) Group operations - select and manipulate multiple shapes together, (2) Undo/Redo functionality requiring command pattern, (3) Shape collision detection for snapping, or (4) Shape resize operations with anchor points. The current architecture with HashMap + List is extensible for all these features.",
  "generated_at": "2026-01-14T15:25:09.940497",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}