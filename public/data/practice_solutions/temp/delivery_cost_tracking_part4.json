{
  "problem_title": "Delivery Cost Tracking System - Part 4: Dynamic Rate Updates",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Previously, each driver had a single fixed hourly rate stored in a simple HashMap. Part 4 introduces dynamic rate updates where a driver's rate can change at specific timestamps. This requires transitioning from a single rate per driver to a **rate history** that tracks all rate changes over time. The key challenge is efficiently looking up the correct rate when calculating delivery costs based on when the delivery started.",
    "new_requirements": [
      "Support updateDriverRate(driverId, newRate, effectiveTime) to change a driver's rate",
      "Rate changes take effect at a specific timestamp (not just immediately)",
      "Deliveries use the rate effective at their start time",
      "Multiple rate changes per driver must be supported",
      "Rate lookup must be efficient (O(log r) where r = number of rate changes)"
    ],
    "new_constraints": [
      "Rate changes can be added in any order (not necessarily chronological)",
      "A rate change at time T applies to all deliveries starting at or after T",
      "Historical deliveries (already recorded) are not affected by new rate changes"
    ],
    "key_insight": "Use a **TreeMap/SortedDict** per driver to store rate history as (timestamp → rate) pairs. When adding a delivery, use a **floor query** (find the largest timestamp ≤ delivery start time) to get the applicable rate. This gives O(log r) lookups instead of O(r) linear search."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Update driver rate with effective timestamp",
        "how_met": "updateDriverRate() adds entry to driver's TreeMap rate history",
        "gotchas": [
          "Must handle updating existing timestamp (overwrite)",
          "Driver must exist first"
        ]
      },
      {
        "requirement": "Rate lookup at delivery start time",
        "how_met": "addDelivery() uses floorEntry(startTime) to find applicable rate",
        "gotchas": [
          "Must have a rate defined before delivery start time",
          "Don't confuse floor vs ceiling"
        ]
      },
      {
        "requirement": "Multiple rate changes per driver",
        "how_met": "TreeMap stores unlimited rate entries sorted by timestamp",
        "gotchas": [
          "Rate changes can arrive out of order - TreeMap handles sorting"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "updateDriverRate",
        "target": "O(log r)",
        "achieved": "O(log r)",
        "why": "TreeMap insertion is logarithmic"
      },
      {
        "operation": "rate lookup in addDelivery",
        "target": "O(log r)",
        "achieved": "O(log r)",
        "why": "floorEntry() is logarithmic in TreeMap"
      },
      {
        "operation": "addDriver",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap put and TreeMap creation are constant"
      }
    ],
    "non_goals": [
      "Pro-rated costs when rate changes mid-delivery (use rate at start time only)",
      "Retroactive recalculation of historical deliveries",
      "Time-travel queries (what was total cost at time X)"
    ]
  },
  "assumptions": [
    "New rate applies to deliveries that START at or after effective_time (not pro-rated mid-delivery)",
    "addDriver() is always called before updateDriverRate() for that driver",
    "Rate at driver creation time is effective from timestamp 0",
    "Interviewers should confirm: Do we need to support rate changes in the past that affect future delivery calculations?"
  ],
  "tradeoffs": [
    {
      "decision": "TreeMap vs List of (time, rate) pairs",
      "chosen": "TreeMap",
      "why": "O(log r) lookups with floorEntry(), automatic sorting on insert",
      "alternative": "Sorted list with binary search",
      "when_to_switch": "If rate changes are rare and mostly sequential, list might have better cache locality"
    },
    {
      "decision": "Rate at start time vs pro-rated calculation",
      "chosen": "Rate at start time only",
      "why": "Simpler implementation, clearer billing semantics, matches most real-world policies",
      "alternative": "Pro-rated based on time spent in each rate period",
      "when_to_switch": "If business requires precise billing across rate change boundaries"
    },
    {
      "decision": "Immutable delivery history vs recalculation",
      "chosen": "Immutable - recorded deliveries keep their calculated cost",
      "why": "Simpler auditing, matches real payroll systems",
      "alternative": "Store raw delivery data and recalculate on demand",
      "when_to_switch": "If retroactive rate corrections are common business requirement"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures (addDriver, addDelivery, getTotalCost)",
      "Cost calculation formula: rate × duration / 3600",
      "Rounding behavior (HALF_UP to integer)"
    ],
    "what_to_change": [
      "Driver storage: HashMap<driverId, rate> → HashMap<driverId, TreeMap<time, rate>>",
      "Rate lookup: direct map get → floorEntry() query"
    ],
    "interfaces_and_boundaries": "The rate lookup is encapsulated in a helper method or class (SortedRateHistory in Python), making it easy to change the underlying data structure without affecting addDelivery()",
    "invariants": [
      "Every driver has at least one rate entry (at time 0 from addDriver)",
      "Rate history is always sorted by timestamp (TreeMap guarantees this)",
      "Total cost is never negative"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n=== BEFORE (Part 3) ===                    === AFTER (Part 4) ===\n                                           \n_drivers: HashMap<driverId, rate>          _driver_rates: HashMap<driverId, TreeMap>\n┌────────┬────────┐                        ┌────────┬─────────────────────────────┐\n│ Driver │  Rate  │                        │ Driver │      Rate History           │\n├────────┼────────┤                        ├────────┼─────────────────────────────┤\n│   1    │  $20   │                        │   1    │ {0→$20, 3600→$30}           │\n│   2    │  $25   │                        │   2    │ {0→$25, 5000→$28, 8000→$32} │\n└────────┴────────┘                        └────────┴─────────────────────────────┘\n                                           \n Rate lookup: O(1)                          Rate lookup: O(log r) via floorEntry\n```",
    "algorithm_flow": "```\n┌─────────────────────────────────────────────────────────────────┐\n│                    RATE LOOKUP ALGORITHM                         │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                  │\n│  addDelivery(driver=1, startTime=5000, endTime=8600)            │\n│                                                                  │\n│  Step 1: Get driver's rate history                              │\n│          rateHistory = {0→$20, 3600→$30, 7200→$35}              │\n│                                                                  │\n│  Step 2: Floor query for startTime=5000                         │\n│          ┌────────────────────────────────────────┐             │\n│          │  0      3600     5000    7200          │             │\n│          │  │       │        ↓       │            │             │\n│          │ $20     $30      ?       $35           │             │\n│          │          ↑                             │             │\n│          │     floor(5000) = 3600                 │             │\n│          └────────────────────────────────────────┘             │\n│          Applicable rate = $30                                  │\n│                                                                  │\n│  Step 3: Calculate cost                                         │\n│          cost = $30 × (8600-5000)/3600 = $30 × 1.0 = $30        │\n│                                                                  │\n└─────────────────────────────────────────────────────────────────┘\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Keep single rate per driver, update rate replaces old rate entirely. When rate changes, the new rate applies to all future deliveries from that moment.",
      "time_complexity": "O(1) for rate update",
      "space_complexity": "O(d) for d drivers",
      "why_not_optimal": "Cannot support effective_time parameter - rate change only applies 'now'. Cannot handle out-of-order rate updates or multiple scheduled rate changes."
    },
    {
      "name": "Linear Search Rate History",
      "description": "Store rate history as unsorted list of (time, rate) pairs. When looking up rate, scan entire list to find latest entry before start time.",
      "time_complexity": "O(r) for rate lookup where r = rate changes",
      "space_complexity": "O(r) per driver",
      "why_not_optimal": "Becomes slow with many rate changes. Common in payroll systems with frequent adjustments."
    },
    {
      "name": "Optimal Approach - TreeMap Rate History",
      "description": "Store rate history as TreeMap<timestamp, rate> per driver. Use floorEntry() for O(log r) rate lookup. Insertions maintain sorted order automatically.",
      "time_complexity": "O(log r) for update and lookup",
      "space_complexity": "O(r) per driver",
      "key_insight": "TreeMap's floorEntry() finds the largest key ≤ given key in O(log n), perfect for time-based rate lookups."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: TreeMap Rate History\n\n### Core Insight\nInstead of storing a **single rate per driver**, store a **rate history** as a sorted map from `timestamp → rate`. The key operation is **floor query**: given a delivery start time, find the most recent rate change that occurred at or before that time.\n\n### Data Structure Change\n```\nBefore: Map<driverId, rate>\nAfter:  Map<driverId, TreeMap<timestamp, rate>>\n```\n\n### Why TreeMap?\n1. **Automatic sorting**: Entries stay sorted by timestamp\n2. **floorEntry(key)**: Returns entry with largest key ≤ given key in O(log n)\n3. **Efficient updates**: O(log n) insertion even for out-of-order timestamps\n\n### Key Design Decisions\n1. **Rate at start time**: Use the rate effective when delivery STARTS, not pro-rated\n2. **Immutable history**: Once a delivery is recorded, its cost doesn't change\n3. **Initial rate**: addDriver() creates entry at timestamp 0, ensuring rate always exists\n\n### Python Note\nPython lacks a built-in TreeMap, so we implement a simple `SortedRateHistory` class using `bisect` module for binary search, or use `sortedcontainers.SortedDict` if available.",
    "data_structures": [
      {
        "structure": "TreeMap<Long, BigDecimal>",
        "purpose": "Store rate history per driver with O(log r) floor queries"
      },
      {
        "structure": "HashMap<Integer, TreeMap>",
        "purpose": "Map driver IDs to their rate histories"
      },
      {
        "structure": "SortedRateHistory (Python)",
        "purpose": "Custom class wrapping bisect for TreeMap-like behavior"
      }
    ],
    "algorithm_steps": [
      "Step 1: addDriver() - Create TreeMap with initial entry (0, rate)",
      "Step 2: updateDriverRate() - Insert (effectiveTime, newRate) into driver's TreeMap",
      "Step 3: addDelivery() - Use floorEntry(startTime) to get applicable rate",
      "Step 4: Calculate cost using retrieved rate × duration / 3600",
      "Step 5: Add cost to running totals (same as before)"
    ]
  },
  "solution_python_lines": [
    "from decimal import Decimal, ROUND_HALF_UP",
    "from typing import Dict, List, Tuple, Optional",
    "from collections import defaultdict",
    "import bisect",
    "",
    "",
    "class SortedRateHistory:",
    "    \"\"\"",
    "    A sorted dictionary for rate history using binary search.",
    "    Mimics Java's TreeMap with floorEntry() capability.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._times: List[int] = []",
    "        self._rates: List[Decimal] = []",
    "    ",
    "    def add(self, time: int, rate: Decimal) -> None:",
    "        \"\"\"Add or update a rate at the given timestamp. O(log r) + O(r) for insert.\"\"\"",
    "        idx = bisect.bisect_left(self._times, time)",
    "        if idx < len(self._times) and self._times[idx] == time:",
    "            # Update existing entry",
    "            self._rates[idx] = rate",
    "        else:",
    "            # Insert new entry (maintains sorted order)",
    "            self._times.insert(idx, time)",
    "            self._rates.insert(idx, rate)",
    "    ",
    "    def get_rate_at(self, time: int) -> Optional[Decimal]:",
    "        \"\"\"",
    "        Get the rate effective at the given time (floor query).",
    "        Returns the rate from the largest timestamp <= given time.",
    "        O(log r) time complexity.",
    "        \"\"\"",
    "        if not self._times:",
    "            return None",
    "        # bisect_right gives insertion point; -1 gives floor index",
    "        idx = bisect.bisect_right(self._times, time) - 1",
    "        if idx >= 0:",
    "            return self._rates[idx]",
    "        return None",
    "",
    "",
    "class DeliveryCostTracker:",
    "    \"\"\"",
    "    Delivery cost tracking system with dynamic rate updates.",
    "    ",
    "    Supports:",
    "    - Adding drivers with initial hourly rates",
    "    - Updating driver rates with effective timestamps (Part 4)",
    "    - Adding deliveries with automatic rate lookup",
    "    - Getting total cost across all deliveries",
    "    - Payment settlement tracking (Part 2)",
    "    - Maximum active drivers analytics (Part 3)",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Part 4: Rate history per driver instead of single rate",
    "        self._driver_rates: Dict[int, SortedRateHistory] = {}",
    "        ",
    "        # Running total cost (Part 1)",
    "        self._total_cost: Decimal = Decimal('0')",
    "        ",
    "        # Unpaid cost per driver (Part 2)",
    "        self._unpaid_costs: Dict[int, Decimal] = defaultdict(lambda: Decimal('0'))",
    "        ",
    "        # Events for max active drivers (Part 3)",
    "        self._events: List[Tuple[int, int]] = []",
    "        self._max_active: int = 0",
    "        self._events_dirty: bool = False",
    "    ",
    "    def add_driver(self, driver_id: int, hourly_rate: int) -> None:",
    "        \"\"\"",
    "        Register a new driver with their initial hourly rate.",
    "        ",
    "        Args:",
    "            driver_id: Unique identifier for the driver",
    "            hourly_rate: Initial hourly rate in dollars",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        rate = Decimal(str(hourly_rate))",
    "        rate_history = SortedRateHistory()",
    "        # Initial rate effective from timestamp 0",
    "        rate_history.add(0, rate)",
    "        self._driver_rates[driver_id] = rate_history",
    "    ",
    "    def update_driver_rate(self, driver_id: int, new_rate: Decimal, effective_time: int) -> None:",
    "        \"\"\"",
    "        Update a driver's hourly rate effective from a given timestamp.",
    "        ",
    "        The new rate applies to deliveries that START at or after effective_time.",
    "        Already recorded deliveries are not affected.",
    "        ",
    "        Args:",
    "            driver_id: ID of driver to update",
    "            new_rate: New hourly rate (Decimal for precision)",
    "            effective_time: Epoch seconds when the new rate takes effect",
    "        ",
    "        Time Complexity: O(log r) where r = number of rate changes for this driver",
    "        ",
    "        Raises:",
    "            ValueError: If driver does not exist",
    "        \"\"\"",
    "        if driver_id not in self._driver_rates:",
    "            raise ValueError(f\"Driver {driver_id} not found\")",
    "        ",
    "        # Convert int to Decimal if needed",
    "        if isinstance(new_rate, int):",
    "            new_rate = Decimal(str(new_rate))",
    "        ",
    "        self._driver_rates[driver_id].add(effective_time, new_rate)",
    "    ",
    "    def add_delivery(self, driver_id: int, start_time: int, end_time: int) -> None:",
    "        \"\"\"",
    "        Record a completed delivery and calculate its cost.",
    "        ",
    "        Cost is calculated using the rate effective at the delivery's START time.",
    "        Formula: cost = hourlyRate × (endTime - startTime) / 3600",
    "        ",
    "        Args:",
    "            driver_id: ID of the driver who made the delivery",
    "            start_time: Delivery start time in epoch seconds",
    "            end_time: Delivery end time in epoch seconds",
    "        ",
    "        Time Complexity: O(log r) for rate lookup + O(1) for cost calculation",
    "        ",
    "        Raises:",
    "            ValueError: If driver does not exist or no rate found",
    "        \"\"\"",
    "        if driver_id not in self._driver_rates:",
    "            raise ValueError(f\"Driver {driver_id} not found\")",
    "        ",
    "        # Look up the rate effective at delivery start time",
    "        rate = self._driver_rates[driver_id].get_rate_at(start_time)",
    "        if rate is None:",
    "            raise ValueError(f\"No rate found for driver {driver_id} at time {start_time}\")",
    "        ",
    "        # Calculate cost: rate × hours",
    "        duration_hours = Decimal(str(end_time - start_time)) / Decimal('3600')",
    "        cost = rate * duration_hours",
    "        ",
    "        # Update totals",
    "        self._total_cost += cost",
    "        self._unpaid_costs[driver_id] += cost",
    "        ",
    "        # Track events for max active drivers (Part 3)",
    "        self._events.append((start_time, 1))   # Driver becomes active",
    "        self._events.append((end_time, -1))    # Driver becomes inactive",
    "        self._events_dirty = True",
    "    ",
    "    def get_total_cost(self) -> int:",
    "        \"\"\"",
    "        Get the total cost of all deliveries, rounded to nearest integer.",
    "        ",
    "        Returns:",
    "            Total cost as integer (HALF_UP rounding)",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        return int(self._total_cost.quantize(Decimal('1'), rounding=ROUND_HALF_UP))",
    "    ",
    "    def settle_payment(self, driver_id: int) -> int:",
    "        \"\"\"",
    "        Settle and return the unpaid amount for a driver (Part 2).",
    "        ",
    "        Args:",
    "            driver_id: ID of the driver to settle",
    "        ",
    "        Returns:",
    "            Unpaid amount as integer (HALF_UP rounding)",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        unpaid = self._unpaid_costs[driver_id]",
    "        result = int(unpaid.quantize(Decimal('1'), rounding=ROUND_HALF_UP))",
    "        self._unpaid_costs[driver_id] = Decimal('0')",
    "        return result",
    "    ",
    "    def get_max_active_drivers(self) -> int:",
    "        \"\"\"",
    "        Get the maximum number of simultaneously active drivers (Part 3).",
    "        ",
    "        Returns:",
    "            Maximum count of drivers with overlapping deliveries",
    "        ",
    "        Time Complexity: O(n log n) on first call after changes, O(1) if cached",
    "        \"\"\"",
    "        if self._events_dirty:",
    "            self._compute_max_active()",
    "            self._events_dirty = False",
    "        return self._max_active",
    "    ",
    "    def _compute_max_active(self) -> None:",
    "        \"\"\"Compute maximum active drivers using line sweep algorithm.\"\"\"",
    "        if not self._events:",
    "            self._max_active = 0",
    "            return",
    "        ",
    "        # Sort events: by time, then by delta (end before start at same time)",
    "        sorted_events = sorted(self._events, key=lambda x: (x[0], x[1]))",
    "        ",
    "        current_active = 0",
    "        max_active = 0",
    "        ",
    "        for _, delta in sorted_events:",
    "            current_active += delta",
    "            max_active = max(max_active, current_active)",
    "        ",
    "        self._max_active = max_active",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstration of Part 4: Dynamic Rate Updates.\"\"\"",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"Part 4: Dynamic Rate Updates - Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Example from problem",
    "    print(\"\\n--- Example from Problem ---\")",
    "    tracker = DeliveryCostTracker()",
    "    ",
    "    print(\"1. addDriver(1, 20) - Add driver 1 with $20/hr\")",
    "    tracker.add_driver(1, 20)",
    "    ",
    "    print(\"2. addDelivery(1, 0, 3600) - 1 hour delivery\")",
    "    tracker.add_delivery(1, 0, 3600)",
    "    print(\"   Cost: $20/hr × 1hr = $20\")",
    "    ",
    "    print(\"3. updateDriverRate(1, 30, 3600) - Rate changes to $30/hr\")",
    "    tracker.update_driver_rate(1, Decimal('30'), 3600)",
    "    ",
    "    print(\"4. addDelivery(1, 3600, 7200) - 1 hour delivery at new rate\")",
    "    tracker.add_delivery(1, 3600, 7200)",
    "    print(\"   Cost: $30/hr × 1hr = $30\")",
    "    ",
    "    result = tracker.get_total_cost()",
    "    print(f\"5. getTotalCost() = {result}\")",
    "    print(\"   Expected: 50\")",
    "    assert result == 50, f\"Expected 50, got {result}\"",
    "    ",
    "    # Complex rate history example",
    "    print(\"\\n--- Complex Rate History Example ---\")",
    "    tracker2 = DeliveryCostTracker()",
    "    ",
    "    tracker2.add_driver(1, 15)",
    "    tracker2.update_driver_rate(1, Decimal('20'), 1000)",
    "    tracker2.update_driver_rate(1, Decimal('25'), 2000)",
    "    ",
    "    print(\"Rate timeline: $15 (t=0) → $20 (t=1000) → $25 (t=2000)\")",
    "    ",
    "    # Deliveries at different rate periods",
    "    tracker2.add_delivery(1, 500, 1500)   # Uses $15/hr (rate at t=500)",
    "    tracker2.add_delivery(1, 1500, 2500)  # Uses $20/hr (rate at t=1500)",
    "    tracker2.add_delivery(1, 2500, 3500)  # Uses $25/hr (rate at t=2500)",
    "    ",
    "    print(f\"Delivery 1 (t=500-1500): $15 × 1000/3600 = ${15*1000/3600:.2f}\")",
    "    print(f\"Delivery 2 (t=1500-2500): $20 × 1000/3600 = ${20*1000/3600:.2f}\")",
    "    print(f\"Delivery 3 (t=2500-3500): $25 × 1000/3600 = ${25*1000/3600:.2f}\")",
    "    print(f\"Total = {tracker2.get_total_cost()}\")",
    "    ",
    "    # Edge case: rate update at same time as delivery start",
    "    print(\"\\n--- Edge Case: Rate at exact delivery start time ---\")",
    "    tracker3 = DeliveryCostTracker()",
    "    tracker3.add_driver(1, 10)",
    "    tracker3.update_driver_rate(1, Decimal('20'), 1000)",
    "    tracker3.add_delivery(1, 1000, 2000)  # Should use $20 (rate effective at t=1000)",
    "    print(f\"Delivery at t=1000 (rate change time): uses ${20}/hr\")",
    "    print(f\"Cost = {tracker3.get_total_cost()}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "/**",
    " * Delivery Cost Tracking System with Dynamic Rate Updates (Part 4).",
    " * ",
    " * Supports:",
    " * - Adding drivers with initial hourly rates",
    " * - Updating driver rates with effective timestamps",
    " * - Adding deliveries with automatic rate lookup",
    " * - Total cost calculation",
    " * - Payment settlement (Part 2)",
    " * - Maximum active drivers analytics (Part 3)",
    " */",
    "public class DeliveryCostTracker {",
    "    ",
    "    // Part 4: Rate history per driver using TreeMap for O(log r) floor queries",
    "    private Map<Integer, TreeMap<Long, BigDecimal>> driverRates;",
    "    ",
    "    // Running total cost (Part 1)",
    "    private BigDecimal totalCost;",
    "    ",
    "    // Unpaid cost per driver (Part 2)",
    "    private Map<Integer, BigDecimal> unpaidCosts;",
    "    ",
    "    // Events for max active drivers (Part 3)",
    "    private List<long[]> events;",
    "    private int maxActive;",
    "    private boolean eventsDirty;",
    "    ",
    "    public DeliveryCostTracker() {",
    "        driverRates = new HashMap<>();",
    "        totalCost = BigDecimal.ZERO;",
    "        unpaidCosts = new HashMap<>();",
    "        events = new ArrayList<>();",
    "        maxActive = 0;",
    "        eventsDirty = false;",
    "    }",
    "    ",
    "    /**",
    "     * Register a new driver with their initial hourly rate.",
    "     * ",
    "     * @param driverId Unique identifier for the driver",
    "     * @param hourlyRate Initial hourly rate in dollars",
    "     * ",
    "     * Time Complexity: O(1)",
    "     */",
    "    public void addDriver(int driverId, int hourlyRate) {",
    "        TreeMap<Long, BigDecimal> rateHistory = new TreeMap<>();",
    "        // Initial rate effective from timestamp 0",
    "        rateHistory.put(0L, new BigDecimal(hourlyRate));",
    "        driverRates.put(driverId, rateHistory);",
    "        unpaidCosts.put(driverId, BigDecimal.ZERO);",
    "    }",
    "    ",
    "    /**",
    "     * Update a driver's hourly rate effective from a given timestamp.",
    "     * ",
    "     * The new rate applies to deliveries that START at or after effectiveTime.",
    "     * Already recorded deliveries are not affected.",
    "     * ",
    "     * @param driverId ID of driver to update",
    "     * @param newRate New hourly rate",
    "     * @param effectiveTime Epoch seconds when the new rate takes effect",
    "     * ",
    "     * Time Complexity: O(log r) where r = number of rate changes for this driver",
    "     * ",
    "     * @throws IllegalArgumentException if driver does not exist",
    "     */",
    "    public void updateDriverRate(int driverId, BigDecimal newRate, long effectiveTime) {",
    "        if (!driverRates.containsKey(driverId)) {",
    "            throw new IllegalArgumentException(\"Driver \" + driverId + \" not found\");",
    "        }",
    "        // TreeMap.put is O(log n)",
    "        driverRates.get(driverId).put(effectiveTime, newRate);",
    "    }",
    "    ",
    "    /**",
    "     * Record a completed delivery and calculate its cost.",
    "     * ",
    "     * Cost is calculated using the rate effective at the delivery's START time.",
    "     * Formula: cost = hourlyRate × (endTime - startTime) / 3600",
    "     * ",
    "     * @param driverId ID of the driver who made the delivery",
    "     * @param startTime Delivery start time in epoch seconds",
    "     * @param endTime Delivery end time in epoch seconds",
    "     * ",
    "     * Time Complexity: O(log r) for rate lookup + O(1) for cost calculation",
    "     * ",
    "     * @throws IllegalArgumentException if driver does not exist",
    "     * @throws IllegalStateException if no rate found for the time",
    "     */",
    "    public void addDelivery(int driverId, long startTime, long endTime) {",
    "        if (!driverRates.containsKey(driverId)) {",
    "            throw new IllegalArgumentException(\"Driver \" + driverId + \" not found\");",
    "        }",
    "        ",
    "        // Look up rate effective at delivery start time using floorEntry",
    "        TreeMap<Long, BigDecimal> rateHistory = driverRates.get(driverId);",
    "        Map.Entry<Long, BigDecimal> entry = rateHistory.floorEntry(startTime);",
    "        ",
    "        if (entry == null) {",
    "            throw new IllegalStateException(",
    "                \"No rate found for driver \" + driverId + \" at time \" + startTime);",
    "        }",
    "        ",
    "        BigDecimal rate = entry.getValue();",
    "        ",
    "        // Calculate cost: rate × (endTime - startTime) / 3600",
    "        BigDecimal durationSeconds = new BigDecimal(endTime - startTime);",
    "        BigDecimal durationHours = durationSeconds.divide(",
    "            new BigDecimal(\"3600\"), 10, RoundingMode.HALF_UP);",
    "        BigDecimal cost = rate.multiply(durationHours);",
    "        ",
    "        // Update totals",
    "        totalCost = totalCost.add(cost);",
    "        unpaidCosts.merge(driverId, cost, BigDecimal::add);",
    "        ",
    "        // Track events for max active drivers (Part 3)",
    "        events.add(new long[]{startTime, 1});",
    "        events.add(new long[]{endTime, -1});",
    "        eventsDirty = true;",
    "    }",
    "    ",
    "    /**",
    "     * Get the total cost of all deliveries, rounded to nearest integer.",
    "     * ",
    "     * @return Total cost as integer (HALF_UP rounding)",
    "     * ",
    "     * Time Complexity: O(1)",
    "     */",
    "    public int getTotalCost() {",
    "        return totalCost.setScale(0, RoundingMode.HALF_UP).intValue();",
    "    }",
    "    ",
    "    /**",
    "     * Settle and return the unpaid amount for a driver (Part 2).",
    "     * ",
    "     * @param driverId ID of the driver to settle",
    "     * @return Unpaid amount as integer (HALF_UP rounding)",
    "     * ",
    "     * Time Complexity: O(1)",
    "     */",
    "    public int settlePayment(int driverId) {",
    "        BigDecimal unpaid = unpaidCosts.getOrDefault(driverId, BigDecimal.ZERO);",
    "        int result = unpaid.setScale(0, RoundingMode.HALF_UP).intValue();",
    "        unpaidCosts.put(driverId, BigDecimal.ZERO);",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get the maximum number of simultaneously active drivers (Part 3).",
    "     * ",
    "     * @return Maximum count of drivers with overlapping deliveries",
    "     * ",
    "     * Time Complexity: O(n log n) on first call after changes, O(1) if cached",
    "     */",
    "    public int getMaxActiveDrivers() {",
    "        if (eventsDirty) {",
    "            computeMaxActive();",
    "            eventsDirty = false;",
    "        }",
    "        return maxActive;",
    "    }",
    "    ",
    "    private void computeMaxActive() {",
    "        if (events.isEmpty()) {",
    "            maxActive = 0;",
    "            return;",
    "        }",
    "        ",
    "        // Sort events: by time, then by delta (end before start at same time)",
    "        events.sort((a, b) -> {",
    "            if (a[0] != b[0]) return Long.compare(a[0], b[0]);",
    "            return Long.compare(a[1], b[1]);",
    "        });",
    "        ",
    "        int currentActive = 0;",
    "        int max = 0;",
    "        ",
    "        for (long[] event : events) {",
    "            currentActive += (int) event[1];",
    "            max = Math.max(max, currentActive);",
    "        }",
    "        ",
    "        maxActive = max;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 4: Dynamic Rate Updates - Demo\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Example from problem",
    "        System.out.println(\"\\n--- Example from Problem ---\");",
    "        DeliveryCostTracker tracker = new DeliveryCostTracker();",
    "        ",
    "        System.out.println(\"1. addDriver(1, 20) - Add driver 1 with $20/hr\");",
    "        tracker.addDriver(1, 20);",
    "        ",
    "        System.out.println(\"2. addDelivery(1, 0, 3600) - 1 hour delivery\");",
    "        tracker.addDelivery(1, 0, 3600);",
    "        System.out.println(\"   Cost: $20/hr × 1hr = $20\");",
    "        ",
    "        System.out.println(\"3. updateDriverRate(1, 30, 3600) - Rate changes to $30/hr\");",
    "        tracker.updateDriverRate(1, new BigDecimal(\"30\"), 3600);",
    "        ",
    "        System.out.println(\"4. addDelivery(1, 3600, 7200) - 1 hour delivery at new rate\");",
    "        tracker.addDelivery(1, 3600, 7200);",
    "        System.out.println(\"   Cost: $30/hr × 1hr = $30\");",
    "        ",
    "        int result = tracker.getTotalCost();",
    "        System.out.println(\"5. getTotalCost() = \" + result);",
    "        System.out.println(\"   Expected: 50\");",
    "        assert result == 50 : \"Expected 50, got \" + result;",
    "        ",
    "        // Complex example with multiple rate changes",
    "        System.out.println(\"\\n--- Multiple Rate Changes ---\");",
    "        DeliveryCostTracker tracker2 = new DeliveryCostTracker();",
    "        tracker2.addDriver(1, 15);",
    "        tracker2.updateDriverRate(1, new BigDecimal(\"20\"), 1000);",
    "        tracker2.updateDriverRate(1, new BigDecimal(\"25\"), 2000);",
    "        ",
    "        tracker2.addDelivery(1, 500, 1500);   // Uses $15",
    "        tracker2.addDelivery(1, 1500, 2500);  // Uses $20",
    "        tracker2.addDelivery(1, 2500, 3500);  // Uses $25",
    "        ",
    "        System.out.println(\"Total with varying rates: \" + tracker2.getTotalCost());",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests passed!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-5 (Python)",
      "explanation": "Import Decimal for precision, typing for annotations, bisect for binary search"
    },
    {
      "lines": "7-41 (Python)",
      "explanation": "SortedRateHistory class - a custom TreeMap-like structure using binary search. add() inserts while maintaining sort order. get_rate_at() does floor query using bisect_right."
    },
    {
      "lines": "43-69 (Python)",
      "explanation": "DeliveryCostTracker class setup. Key change: _driver_rates now maps to SortedRateHistory instead of single Decimal"
    },
    {
      "lines": "71-85 (Python)",
      "explanation": "add_driver() creates rate history with initial entry at timestamp 0, ensuring rate always exists for any positive time"
    },
    {
      "lines": "87-111 (Python)",
      "explanation": "update_driver_rate() - the new Part 4 method. Validates driver exists, converts int to Decimal if needed, adds entry to rate history"
    },
    {
      "lines": "113-160 (Python)",
      "explanation": "add_delivery() modified to use get_rate_at(start_time) for rate lookup instead of direct map access. Rest unchanged."
    },
    {
      "lines": "45-65 (Java)",
      "explanation": "addDriver() creates TreeMap with entry at key 0. TreeMap guarantees O(log n) operations."
    },
    {
      "lines": "67-80 (Java)",
      "explanation": "updateDriverRate() - simple TreeMap.put() which is O(log r). TreeMap handles ordering automatically."
    },
    {
      "lines": "82-115 (Java)",
      "explanation": "addDelivery() uses floorEntry(startTime) - the key TreeMap operation that finds largest key ≤ given key in O(log r)"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "updateDriverRate": {
          "complexity": "O(log r)",
          "explanation": "TreeMap insertion where r = number of rate changes for the driver"
        },
        "rate lookup in addDelivery": {
          "complexity": "O(log r)",
          "explanation": "floorEntry() is logarithmic in TreeMap size"
        }
      },
      "overall_change": "addDelivery changes from O(1) to O(log r) due to rate lookup. With typical small r (few rate changes per driver), this is effectively constant."
    },
    "space": {
      "additional_space": "O(d × r) where d = drivers, r = avg rate changes per driver",
      "explanation": "Each driver now stores a TreeMap of rate history instead of single rate. In practice, r is small (few rate changes per driver per year)."
    }
  },
  "dry_run": {
    "example_input": "addDriver(1,20), addDelivery(1,0,3600), updateDriverRate(1,30,3600), addDelivery(1,3600,7200), getTotalCost()",
    "steps": [
      {
        "step": 1,
        "action": "addDriver(1, 20)",
        "state": "driverRates: {1: {0→$20}}",
        "explanation": "Create rate history with initial rate at t=0"
      },
      {
        "step": 2,
        "action": "addDelivery(1, 0, 3600)",
        "state": "floorEntry(0) returns (0, $20)",
        "explanation": "Rate at t=0 is $20. Cost = $20 × 1hr = $20. totalCost = $20"
      },
      {
        "step": 3,
        "action": "updateDriverRate(1, 30, 3600)",
        "state": "driverRates: {1: {0→$20, 3600→$30}}",
        "explanation": "Add new rate entry at t=3600"
      },
      {
        "step": 4,
        "action": "addDelivery(1, 3600, 7200)",
        "state": "floorEntry(3600) returns (3600, $30)",
        "explanation": "Rate at t=3600 is $30 (exact match). Cost = $30 × 1hr = $30. totalCost = $50"
      },
      {
        "step": 5,
        "action": "getTotalCost()",
        "state": "return round($50) = 50",
        "explanation": "Return integer total"
      }
    ],
    "final_output": "50"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single driver, no rate changes: addDriver(1,20), addDelivery(1,0,3600), getTotalCost() → 20",
      "Rate change before any delivery: addDriver(1,10), updateDriverRate(1,20,0), addDelivery(1,0,3600) → 20"
    ],
    "likely_bugs": [
      "Using ceilingEntry instead of floorEntry (gets future rate instead of current)",
      "Not handling exact timestamp match (rate change at same time as delivery start)",
      "Forgetting to initialize rate history with timestamp 0",
      "Integer division instead of Decimal division in cost calculation"
    ],
    "recommended_logs_or_asserts": [
      "assert rate_history has at least one entry after addDriver",
      "log the rate found before calculating cost: 'Using rate $X at time T for delivery'",
      "assert floorEntry result is not null in addDelivery"
    ],
    "how_to_localize": "1. Print rate history after each updateDriverRate. 2. Print the rate found by floorEntry in addDelivery. 3. Print cost calculation breakdown: rate × duration = cost"
  },
  "edge_cases": [
    {
      "case": "Rate change at exact delivery start time",
      "handling": "floorEntry(startTime) includes exact match, so new rate is used",
      "gotcha": "Some might expect old rate if change happens 'at the same time'"
    },
    {
      "case": "Delivery before any rate change",
      "handling": "Initial rate at t=0 ensures floorEntry always finds something",
      "gotcha": "If initial rate not set at t=0, floorEntry could return null"
    },
    {
      "case": "Multiple rate changes, delivery in middle period",
      "handling": "floorEntry correctly finds most recent rate before delivery start",
      "gotcha": "Don't confuse floor (≤) with lower (strictly <)"
    },
    {
      "case": "Out-of-order rate updates",
      "handling": "TreeMap maintains sorted order regardless of insertion order",
      "gotcha": "Manual list implementation might not handle this"
    },
    {
      "case": "Rate update for non-existent driver",
      "handling": "Throw exception with clear error message",
      "gotcha": "Silent failure could lead to confusing bugs later"
    }
  ],
  "test_cases": [
    {
      "name": "Basic rate update",
      "input": "addDriver(1,20), addDelivery(1,0,3600), updateDriverRate(1,30,3600), addDelivery(1,3600,7200), getTotalCost()",
      "expected": "50",
      "explanation": "First delivery at $20/hr ($20), second at $30/hr ($30)"
    },
    {
      "name": "Multiple rate changes",
      "input": "addDriver(1,10), updateDriverRate(1,20,1000), updateDriverRate(1,30,2000), addDelivery(1,1500,2500)",
      "expected": "6 (approx)",
      "explanation": "Delivery at t=1500 uses $20/hr (floor of 1500 is 1000)"
    },
    {
      "name": "Rate change at exact delivery time",
      "input": "addDriver(1,10), updateDriverRate(1,20,1000), addDelivery(1,1000,2000)",
      "expected": "6 (approx)",
      "explanation": "Delivery at t=1000 uses $20/hr (exact match)"
    },
    {
      "name": "No rate changes",
      "input": "addDriver(1,25), addDelivery(1,0,7200), getTotalCost()",
      "expected": "50",
      "explanation": "2 hours at $25/hr with no rate changes"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using HashMap instead of TreeMap for rate history",
      "why_wrong": "HashMap doesn't support floor queries - would need O(n) scan",
      "correct_approach": "Use TreeMap (Java) or bisect-based structure (Python)",
      "code_example_wrong": "// HashMap<Long, BigDecimal> rateHistory; // Can't do floor query!",
      "code_example_correct": "// TreeMap<Long, BigDecimal> rateHistory; // floorEntry() works!"
    },
    {
      "mistake": "Forgetting to set initial rate at timestamp 0",
      "why_wrong": "floorEntry(startTime) returns null if no rate exists before startTime",
      "correct_approach": "Always add initial rate at timestamp 0 in addDriver()",
      "code_example_wrong": "// TreeMap empty after addDriver - delivery at any time fails",
      "code_example_correct": "rateHistory.put(0L, initialRate); // Ensures rate always exists"
    },
    {
      "mistake": "Using ceilingEntry instead of floorEntry",
      "why_wrong": "ceilingEntry finds FUTURE rate, not current rate",
      "correct_approach": "Use floorEntry to find most recent rate at or before delivery start",
      "code_example_wrong": "// rateHistory.ceilingEntry(startTime) // WRONG - gets future rate",
      "code_example_correct": "rateHistory.floorEntry(startTime) // CORRECT - gets current rate"
    },
    {
      "mistake": "Not converting rate to Decimal/BigDecimal properly",
      "why_wrong": "Precision loss in calculations leads to wrong totals",
      "correct_approach": "Always use Decimal types, convert integers via string",
      "code_example_wrong": "// Decimal(20) might have precision issues",
      "code_example_correct": "Decimal(str(20)) or new BigDecimal(\"20\")"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the rate change policy (when new rate applies). Explain the data structure change from single rate to rate history. Emphasize the floor query as the key operation. Walk through an example showing rate lookup.",
    "what_to_mention": [
      "TreeMap's floorEntry() is the perfect data structure for time-based lookups",
      "Design decision: rate at start time vs pro-rated (confirm with interviewer)",
      "Initial rate at t=0 ensures no edge cases with missing rates",
      "This adds O(log r) to addDelivery but r is typically small"
    ],
    "time_allocation": "2 min clarify requirements, 3 min explain approach, 5 min implement, 2 min test",
    "if_stuck": [
      "Think about what query you need: given a timestamp, find the applicable rate",
      "What data structure supports efficient 'find largest key ≤ X' queries?",
      "TreeMap/SortedMap has floorEntry() for exactly this"
    ]
  },
  "connection_to_next_part": "Part 4's rate history structure could be extended to support: (1) Rate caps/minimums per time period, (2) Multiple rate types (base, surge, bonus), (3) Querying what rate was effective at any historical time. The TreeMap pattern is reusable for any time-series data.",
  "communication_script": {
    "transition_from_previous": "Great, Part 3 handles max active drivers. For Part 4, we need dynamic rate updates. The key change is moving from a single rate per driver to a rate history. Let me explain...",
    "explaining_changes": "Instead of storing just one rate per driver, I'll use a TreeMap mapping timestamps to rates. When a delivery comes in, I use floorEntry(startTime) to find the rate that was effective at that time. This is O(log r) where r is typically small.",
    "while_extending_code": [
      "I'm changing _drivers from Dict[int, Decimal] to Dict[int, TreeMap]...",
      "Adding the updateDriverRate method that inserts into the TreeMap...",
      "Modifying addDelivery to do a floor query instead of direct lookup..."
    ],
    "after_completing": "Now we support dynamic rate changes. updateDriverRate is O(log r), rate lookup in addDelivery is O(log r). The rest remains O(1). Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Clarify: rate at start time only, not pro-rated. Identify TreeMap as the right structure.",
    "by_5_min": "Explain the data structure change and floor query approach. Start modifying code.",
    "by_10_min": "Implementation complete. Test with the provided example.",
    "warning_signs": "If struggling with TreeMap/floor query concept at 4 min, ask for a hint about data structures for range queries."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 3's code has issues, note them but focus on the new rate lookup logic. Say: 'Let me focus on the rate history aspect for now.'",
    "if_new_requirement_unclear": "Ask: 'When a rate changes at time T and a delivery starts at exactly T, which rate applies - old or new?'",
    "if_running_behind": "Implement basic TreeMap version without edge case handling. Mention: 'In production I'd add validation for driver existence and null checks.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately identifying TreeMap/floorEntry as the right pattern",
      "Discussing the design choice of rate-at-start vs pro-rated before coding",
      "Noting that initial rate at t=0 eliminates null-check edge cases",
      "Mentioning this pattern applies to any temporal data (pricing, configs, etc.)",
      "Calculating that O(log r) with small r is effectively O(1) in practice"
    ]
  },
  "generated_at": "2026-01-17T16:20:26.059833",
  "_meta": {
    "problem_id": "delivery_cost_tracking",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}