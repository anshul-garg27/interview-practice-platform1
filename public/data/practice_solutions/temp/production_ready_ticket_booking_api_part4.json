{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 4: Production Readiness",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 transforms our functional ticket booking system into a production-ready service by adding observability, rate limiting, structured logging, and health monitoring. We're shifting from 'does it work?' to 'can we operate it at scale and debug issues in real-time?'",
    "new_requirements": [
      "Health check endpoint that verifies all critical dependencies",
      "Metrics collection for request rates, latencies, and error rates",
      "Multi-tier rate limiting (global, per-user, per-endpoint)",
      "Structured logging with request tracing",
      "Alerting thresholds for operational awareness"
    ],
    "new_constraints": [
      "Rate limit checks must be O(1) to not impact request latency",
      "Metrics storage must be memory-efficient (ring buffers)",
      "Health checks should timeout gracefully, not block",
      "Logs must never contain sensitive data (PII, tokens, passwords)"
    ],
    "key_insight": "Production readiness is about making your system observable, defensible, and debuggable. You can't fix what you can't see, and you can't protect what you can't measure."
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3):                    AFTER (Part 4):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Ticket API        \u2502              \u2502   Production-Ready Ticket API   \u2502\n\u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502              \u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n\u2502 \u2705 CRUD Operations  \u2502              \u2502 \u2705 CRUD Operations              \u2502\n\u2502 \u2705 Authentication   \u2502              \u2502 \u2705 Authentication               \u2502\n\u2502 \u2705 Concurrency Safe \u2502              \u2502 \u2705 Concurrency Safe             \u2502\n\u2502 \u274c Observability    \u2502      \u2192       \u2502 \u2705 Health Checks                \u2502\n\u2502 \u274c Rate Limiting    \u2502              \u2502 \u2705 Metrics Dashboard            \u2502\n\u2502 \u274c Structured Logs  \u2502              \u2502 \u2705 Rate Limiting (3-tier)       \u2502\n\u2502 \u274c Alert System     \u2502              \u2502 \u2705 Structured Logging           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502 \u2705 Alert Conditions             \u2502\n                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n             REQUEST FLOW WITH PRODUCTION FEATURES\n             \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    Request  \u2500\u2500\u2500\u2510\n                \u2502\n                \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   1. RATE LIMITER     \u2502\u2500\u2500\u2500\u2500 Exceeded? \u2500\u2500\u2500\u2500\u2510\n    \u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500     \u2502                   \u2502\n    \u2502   Check: Global       \u2502                   \u25bc\n    \u2502   Check: Per-User     \u2502              429 Too Many\n    \u2502   Check: Per-Endpoint \u2502              Requests\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502 \u2713 Allowed\n                \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   2. REQUEST HANDLER  \u2502\n    \u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2502\n    \u2502   \u2022 Start timer       \u2502\n    \u2502   \u2022 Generate reqId    \u2502\n    \u2502   \u2022 Process request   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   3. LOG & METRICS    \u2502\n    \u2502   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2502\n    \u2502   \u2022 Log structured    \u2502\n    \u2502   \u2022 Record latency    \u2502\n    \u2502   \u2022 Update counters   \u2502\n    \u2502   \u2022 Check alerts      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                \u2502\n                \u25bc\n            Response\n\n\n         SLIDING WINDOW RATE LIMITING\n         \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    Time Window: 1 minute (60 seconds)\n    Limit: 10 requests\n\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502\u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Current Window \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192\u2502\n    \u2502                                       \u2502\n    \u2502  [req][req][req]    [req][req]       \u2502\n    \u2502    \u2191                   \u2191              \u2502\n    \u2502  old reqs           new reqs         \u2502\n    \u2502  (weighted less)    (full weight)    \u2502\n    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n          \u2191                           \u2191\n       t-60s                        now\n\n    Formula: weighted_count = (1 - elapsed%) \u00d7 prev_count + curr_count\n\n\n         METRICS RING BUFFER\n         \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Ring Buffer (last 1000 latencies)        \u2502\n    \u2502                                           \u2502\n    \u2502  [23][45][12][89][ ][ ][ ]...[67][34]    \u2502\n    \u2502        \u2191                         \u2191        \u2502\n    \u2502     write                      oldest     \u2502\n    \u2502     pointer                              \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Benefits:\n    \u2022 O(1) insert\n    \u2022 Fixed memory\n    \u2022 Easy percentile calculation\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Simple Counters",
      "description": "Add basic counters to Part 3: a simple dictionary counting requests per user, reset every minute. Log everything to console. Health check returns static 'OK'.",
      "time_complexity": "O(1) for counter operations",
      "space_complexity": "O(U) where U = unique users",
      "why_not_optimal": "Fixed window rate limiting has burst problems at window boundaries (user can make 2x limit in 2 seconds). Console logging loses data. No percentile metrics. No dependency health verification."
    },
    {
      "name": "Optimal Approach - Sliding Window + Ring Buffers",
      "description": "Implement sliding window rate limiting that weights requests across window boundaries. Use ring buffers for metrics to bound memory. Structured JSON logging with request correlation IDs. Health checks that verify actual dependency connectivity.",
      "time_complexity": "O(1) rate limit, O(n log n) for percentile calculation where n = buffer size",
      "space_complexity": "O(U + E + M) where U=users, E=endpoints, M=metrics buffer size",
      "key_insight": "Sliding window eliminates burst problems by considering requests from both current and previous windows weighted by time position. Ring buffers provide bounded memory while maintaining recent history for accurate percentiles."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Production Readiness Implementation\n\nOur solution adds **four critical production systems** to the booking API:\n\n### 1. Sliding Window Rate Limiter\nUnlike fixed window counters that reset abruptly (allowing 2x burst at boundaries), sliding window **smoothly transitions** between windows:\n\n```\nweighted_count = prev_window_count \u00d7 (1 - elapsed_fraction) + current_window_count\n```\n\nThis ensures a user limited to 10 req/min can **never** exceed 10 requests in any 60-second period.\n\n### 2. Health Check System\nHealth checks must **actively verify** dependencies, not just return static status:\n- **Database**: Execute a simple query\n- **Cache**: Verify read/write capability  \n- **Disk**: Check available space\n- **Memory**: Monitor heap usage\n\nAny check that takes >5s returns \"degraded\" status.\n\n### 3. Metrics Collection\nWe track using **ring buffers** (circular arrays) that:\n- Have **O(1) insertion**\n- Use **fixed memory** regardless of traffic\n- Enable **percentile calculations** (p50, p95, p99)\n\n### 4. Structured Logging\nEvery log entry is JSON with:\n- **requestId**: UUID for distributed tracing\n- **userId**: Who made the request\n- **endpoint**: What was accessed\n- **durationMs**: How long it took\n- **status**: Success or failure code\n\n**Never log**: passwords, tokens, credit cards, or excessive PII.",
    "data_structures": [
      {
        "structure": "SlidingWindowCounter",
        "purpose": "Rate limiting with weighted counts across window boundaries"
      },
      {
        "structure": "RingBuffer",
        "purpose": "Fixed-size circular buffer for latency metrics"
      },
      {
        "structure": "Dict[str, Counter]",
        "purpose": "Per-user, per-endpoint rate limit tracking"
      },
      {
        "structure": "StructuredLogger",
        "purpose": "JSON logging with automatic field injection"
      }
    ],
    "algorithm_steps": [
      "Step 1: On each request, generate unique requestId and start timer",
      "Step 2: Check rate limits in order: global \u2192 per-user \u2192 per-endpoint",
      "Step 3: If any limit exceeded, return 429 with Retry-After header",
      "Step 4: Process the actual request (from Part 3)",
      "Step 5: Record latency in ring buffer, increment counters",
      "Step 6: Log structured entry with all context",
      "Step 7: Check if metrics breach alert thresholds"
    ]
  },
  "solution_python_lines": [
    "import time",
    "import threading",
    "import json",
    "import uuid",
    "import heapq",
    "from datetime import datetime, timedelta",
    "from collections import defaultdict, deque",
    "from typing import Dict, List, Optional, Any, Tuple, Set",
    "from dataclasses import dataclass, field",
    "from enum import Enum",
    "from abc import ABC, abstractmethod",
    "import re",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# PART 4: PRODUCTION READINESS - OBSERVABILITY, RATE LIMITING, LOGGING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# DATA MODELS (Extended from Parts 1-3)",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class Role(Enum):",
    "    USER = \"user\"",
    "    ADMIN = \"admin\"",
    "",
    "",
    "@dataclass",
    "class User:",
    "    user_id: str",
    "    email: str",
    "    password_hash: str",
    "    role: Role",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    event_id: str",
    "    name: str",
    "    venue: str",
    "    date: datetime",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price: float",
    "    created_by: str",
    "    version: int = 0  # For optimistic locking",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    booking_id: str",
    "    event_id: str",
    "    user_id: str",
    "    quantity: int",
    "    total_price: float",
    "    status: str",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    status: int",
    "    body: Any",
    "    headers: Dict[str, str] = field(default_factory=dict)",
    "",
    "",
    "@dataclass",
    "class Request:",
    "    method: str",
    "    endpoint: str",
    "    body: Optional[Dict[str, Any]] = None",
    "    headers: Dict[str, str] = field(default_factory=dict)",
    "    user_id: Optional[str] = None",
    "    request_id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# SLIDING WINDOW RATE LIMITER",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class SlidingWindowCounter:",
    "    \"\"\"",
    "    Sliding window rate limiter that smoothly transitions between windows.",
    "    ",
    "    Unlike fixed window counters that can allow 2x burst at boundaries,",
    "    this weights requests from previous window based on time position.",
    "    ",
    "    Example: 10 req/min limit",
    "    - At t=0:30 (halfway through minute): prev_weight = 0.5",
    "    - If prev_count=8, curr_count=3: weighted = 8*0.5 + 3 = 7 \u2713 allowed",
    "    \"\"\"",
    "    ",
    "    def __init__(self, window_seconds: int = 60):",
    "        self.window_seconds = window_seconds",
    "        self.prev_count: int = 0",
    "        self.curr_count: int = 0",
    "        self.window_start: float = time.time()",
    "        self._lock = threading.Lock()",
    "    ",
    "    def _maybe_rotate_window(self, now: float) -> None:",
    "        \"\"\"Rotate windows if we've moved past current window.\"\"\"",
    "        elapsed = now - self.window_start",
    "        if elapsed >= self.window_seconds:",
    "            # Move to new window",
    "            windows_passed = int(elapsed // self.window_seconds)",
    "            if windows_passed == 1:",
    "                self.prev_count = self.curr_count",
    "            else:",
    "                # More than one window passed, previous is zeroed",
    "                self.prev_count = 0",
    "            self.curr_count = 0",
    "            self.window_start = now - (elapsed % self.window_seconds)",
    "    ",
    "    def get_weighted_count(self) -> float:",
    "        \"\"\"Calculate current weighted request count.\"\"\"",
    "        now = time.time()",
    "        with self._lock:",
    "            self._maybe_rotate_window(now)",
    "            elapsed_in_window = now - self.window_start",
    "            prev_weight = 1.0 - (elapsed_in_window / self.window_seconds)",
    "            return self.prev_count * prev_weight + self.curr_count",
    "    ",
    "    def increment(self) -> None:",
    "        \"\"\"Record a request.\"\"\"",
    "        now = time.time()",
    "        with self._lock:",
    "            self._maybe_rotate_window(now)",
    "            self.curr_count += 1",
    "",
    "",
    "class RateLimitConfig:",
    "    \"\"\"Configuration for rate limit tiers.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Global: 10,000 req/sec across all users",
    "        self.global_limit = 10000",
    "        self.global_window_sec = 1",
    "        ",
    "        # Per-user: 100 req/min per authenticated user",
    "        self.user_limit = 100",
    "        self.user_window_sec = 60",
    "        ",
    "        # Per-endpoint limits (per user, per minute)",
    "        self.endpoint_limits: Dict[str, int] = {",
    "            '/bookings': 10,      # Tight limit on booking creation",
    "            '/events': 60,        # More lenient for browsing",
    "            '/health': 120,       # Health checks can be frequent",
    "            '/metrics': 30,       # Metrics shouldn't be spammed",
    "        }",
    "        self.endpoint_window_sec = 60",
    "",
    "",
    "class RateLimiter:",
    "    \"\"\"",
    "    Multi-tier rate limiter with global, per-user, and per-endpoint limits.",
    "    ",
    "    Uses sliding window counters for smooth rate limiting without burst issues.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, config: Optional[RateLimitConfig] = None):",
    "        self.config = config or RateLimitConfig()",
    "        ",
    "        # Global counter",
    "        self.global_counter = SlidingWindowCounter(self.config.global_window_sec)",
    "        ",
    "        # Per-user counters: user_id -> counter",
    "        self.user_counters: Dict[str, SlidingWindowCounter] = defaultdict(",
    "            lambda: SlidingWindowCounter(self.config.user_window_sec)",
    "        )",
    "        ",
    "        # Per-endpoint counters: (user_id, endpoint) -> counter",
    "        self.endpoint_counters: Dict[Tuple[str, str], SlidingWindowCounter] = defaultdict(",
    "            lambda: SlidingWindowCounter(self.config.endpoint_window_sec)",
    "        )",
    "        ",
    "        self._lock = threading.Lock()",
    "    ",
    "    def check_and_record(self, user_id: str, endpoint: str) -> Tuple[bool, Optional[str]]:",
    "        \"\"\"",
    "        Check if request is allowed and record it if so.",
    "        ",
    "        Returns:",
    "            (allowed: bool, rejection_reason: Optional[str])",
    "        \"\"\"",
    "        # Normalize endpoint for matching",
    "        normalized_endpoint = self._normalize_endpoint(endpoint)",
    "        ",
    "        with self._lock:",
    "            # Tier 1: Global limit",
    "            if self.global_counter.get_weighted_count() >= self.config.global_limit:",
    "                return False, \"global_limit_exceeded\"",
    "            ",
    "            # Tier 2: Per-user limit",
    "            if self.user_counters[user_id].get_weighted_count() >= self.config.user_limit:",
    "                return False, \"user_limit_exceeded\"",
    "            ",
    "            # Tier 3: Per-endpoint limit",
    "            endpoint_limit = self.config.endpoint_limits.get(normalized_endpoint, 60)",
    "            key = (user_id, normalized_endpoint)",
    "            if self.endpoint_counters[key].get_weighted_count() >= endpoint_limit:",
    "                return False, f\"endpoint_limit_exceeded:{normalized_endpoint}\"",
    "            ",
    "            # All checks passed - record the request",
    "            self.global_counter.increment()",
    "            self.user_counters[user_id].increment()",
    "            self.endpoint_counters[key].increment()",
    "            ",
    "            return True, None",
    "    ",
    "    def _normalize_endpoint(self, endpoint: str) -> str:",
    "        \"\"\"Normalize endpoint for rate limit matching.\"\"\"",
    "        # Remove IDs from paths: /events/evt_123/bookings -> /bookings",
    "        if '/bookings' in endpoint:",
    "            return '/bookings'",
    "        if '/events' in endpoint:",
    "            return '/events'",
    "        if '/health' in endpoint:",
    "            return '/health'",
    "        if '/metrics' in endpoint:",
    "            return '/metrics'",
    "        return endpoint",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# METRICS COLLECTION WITH RING BUFFER",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class RingBuffer:",
    "    \"\"\"",
    "    Fixed-size circular buffer for storing recent values.",
    "    ",
    "    Benefits:",
    "    - O(1) insertion",
    "    - Bounded memory regardless of traffic",
    "    - Easy percentile calculation on recent data",
    "    \"\"\"",
    "    ",
    "    def __init__(self, capacity: int = 1000):",
    "        self.capacity = capacity",
    "        self.buffer: List[float] = []",
    "        self.index = 0",
    "        self._lock = threading.Lock()",
    "    ",
    "    def append(self, value: float) -> None:",
    "        \"\"\"Add a value to the buffer.\"\"\"",
    "        with self._lock:",
    "            if len(self.buffer) < self.capacity:",
    "                self.buffer.append(value)",
    "            else:",
    "                self.buffer[self.index] = value",
    "            self.index = (self.index + 1) % self.capacity",
    "    ",
    "    def get_all(self) -> List[float]:",
    "        \"\"\"Get all values currently in buffer.\"\"\"",
    "        with self._lock:",
    "            return self.buffer.copy()",
    "    ",
    "    def percentile(self, p: float) -> Optional[float]:",
    "        \"\"\"Calculate p-th percentile (0-100).\"\"\"",
    "        values = self.get_all()",
    "        if not values:",
    "            return None",
    "        sorted_values = sorted(values)",
    "        idx = int(len(sorted_values) * p / 100)",
    "        idx = min(idx, len(sorted_values) - 1)",
    "        return sorted_values[idx]",
    "    ",
    "    def average(self) -> Optional[float]:",
    "        \"\"\"Calculate average of values in buffer.\"\"\"",
    "        values = self.get_all()",
    "        if not values:",
    "            return None",
    "        return sum(values) / len(values)",
    "",
    "",
    "@dataclass",
    "class MetricsSnapshot:",
    "    \"\"\"Point-in-time snapshot of system metrics.\"\"\"",
    "    timestamp: datetime",
    "    requests_total: int",
    "    requests_success: int",
    "    requests_error: int",
    "    error_rate: float",
    "    latency_avg_ms: float",
    "    latency_p50_ms: float",
    "    latency_p95_ms: float",
    "    latency_p99_ms: float",
    "    active_users: int",
    "    bookings_total: int",
    "    rate_limited_requests: int",
    "",
    "",
    "class MetricsCollector:",
    "    \"\"\"",
    "    Collects and aggregates system metrics.",
    "    ",
    "    Tracks request counts, latencies, error rates, and business metrics.",
    "    Uses ring buffers for efficient storage of time-series data.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, latency_buffer_size: int = 1000):",
    "        self.latency_buffer = RingBuffer(latency_buffer_size)",
    "        ",
    "        # Counters",
    "        self.requests_total = 0",
    "        self.requests_success = 0",
    "        self.requests_error = 0",
    "        self.rate_limited_requests = 0",
    "        ",
    "        # Per-endpoint counters",
    "        self.endpoint_counts: Dict[str, int] = defaultdict(int)",
    "        self.endpoint_errors: Dict[str, int] = defaultdict(int)",
    "        ",
    "        # Active users (seen in last 5 minutes)",
    "        self.recent_users: Dict[str, float] = {}",
    "        self.user_window_sec = 300",
    "        ",
    "        # Start time",
    "        self.start_time = datetime.now()",
    "        ",
    "        self._lock = threading.Lock()",
    "    ",
    "    def record_request(self, endpoint: str, latency_ms: float, ",
    "                       status: int, user_id: str) -> None:",
    "        \"\"\"Record metrics for a completed request.\"\"\"",
    "        now = time.time()",
    "        ",
    "        with self._lock:",
    "            self.requests_total += 1",
    "            self.endpoint_counts[endpoint] += 1",
    "            ",
    "            if 200 <= status < 400:",
    "                self.requests_success += 1",
    "            else:",
    "                self.requests_error += 1",
    "                self.endpoint_errors[endpoint] += 1",
    "            ",
    "            # Track active user",
    "            self.recent_users[user_id] = now",
    "            ",
    "            # Cleanup old users",
    "            cutoff = now - self.user_window_sec",
    "            self.recent_users = {",
    "                uid: ts for uid, ts in self.recent_users.items() if ts > cutoff",
    "            }",
    "        ",
    "        # Latency buffer has its own lock",
    "        self.latency_buffer.append(latency_ms)",
    "    ",
    "    def record_rate_limit(self) -> None:",
    "        \"\"\"Record a rate-limited request.\"\"\"",
    "        with self._lock:",
    "            self.rate_limited_requests += 1",
    "    ",
    "    def get_snapshot(self, bookings_count: int = 0) -> MetricsSnapshot:",
    "        \"\"\"Get current metrics snapshot.\"\"\"",
    "        with self._lock:",
    "            total = self.requests_total or 1  # Avoid division by zero",
    "            error_rate = self.requests_error / total * 100",
    "            ",
    "            return MetricsSnapshot(",
    "                timestamp=datetime.now(),",
    "                requests_total=self.requests_total,",
    "                requests_success=self.requests_success,",
    "                requests_error=self.requests_error,",
    "                error_rate=round(error_rate, 2),",
    "                latency_avg_ms=round(self.latency_buffer.average() or 0, 2),",
    "                latency_p50_ms=round(self.latency_buffer.percentile(50) or 0, 2),",
    "                latency_p95_ms=round(self.latency_buffer.percentile(95) or 0, 2),",
    "                latency_p99_ms=round(self.latency_buffer.percentile(99) or 0, 2),",
    "                active_users=len(self.recent_users),",
    "                bookings_total=bookings_count,",
    "                rate_limited_requests=self.rate_limited_requests",
    "            )",
    "    ",
    "    def get_uptime(self) -> str:",
    "        \"\"\"Get formatted uptime string.\"\"\"",
    "        delta = datetime.now() - self.start_time",
    "        hours, remainder = divmod(int(delta.total_seconds()), 3600)",
    "        minutes, seconds = divmod(remainder, 60)",
    "        return f\"{hours}h {minutes}m {seconds}s\"",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# STRUCTURED LOGGING",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class LogLevel(Enum):",
    "    DEBUG = \"DEBUG\"",
    "    INFO = \"INFO\"",
    "    WARN = \"WARN\"",
    "    ERROR = \"ERROR\"",
    "",
    "",
    "@dataclass",
    "class LogEntry:",
    "    \"\"\"Structured log entry for consistent logging.\"\"\"",
    "    timestamp: str",
    "    level: str",
    "    request_id: str",
    "    user_id: str",
    "    method: str",
    "    endpoint: str",
    "    status: int",
    "    duration_ms: float",
    "    message: str",
    "    error: Optional[str] = None",
    "    ",
    "    def to_json(self) -> str:",
    "        \"\"\"Convert to JSON string for logging.\"\"\"",
    "        data = {",
    "            \"timestamp\": self.timestamp,",
    "            \"level\": self.level,",
    "            \"requestId\": self.request_id,",
    "            \"userId\": self._mask_user_id(self.user_id),",
    "            \"method\": self.method,",
    "            \"endpoint\": self.endpoint,",
    "            \"status\": self.status,",
    "            \"durationMs\": round(self.duration_ms, 2),",
    "            \"message\": self.message",
    "        }",
    "        if self.error:",
    "            data[\"error\"] = self.error",
    "        return json.dumps(data)",
    "    ",
    "    @staticmethod",
    "    def _mask_user_id(user_id: str) -> str:",
    "        \"\"\"Partially mask user ID for privacy.\"\"\"",
    "        if not user_id or len(user_id) <= 4:",
    "            return \"***\"",
    "        return user_id[:4] + \"***\"",
    "",
    "",
    "class StructuredLogger:",
    "    \"\"\"",
    "    Production-grade structured logger.",
    "    ",
    "    Features:",
    "    - JSON formatted logs for easy parsing",
    "    - Request ID correlation for distributed tracing",
    "    - Automatic PII masking",
    "    - Log level filtering",
    "    \"\"\"",
    "    ",
    "    # Patterns for sensitive data that should never be logged",
    "    SENSITIVE_PATTERNS = [",
    "        re.compile(r'password', re.IGNORECASE),",
    "        re.compile(r'token', re.IGNORECASE),",
    "        re.compile(r'secret', re.IGNORECASE),",
    "        re.compile(r'credit.?card', re.IGNORECASE),",
    "        re.compile(r'\\b\\d{16}\\b'),  # Credit card numbers",
    "        re.compile(r'\\b\\d{3}-\\d{2}-\\d{4}\\b'),  # SSN",
    "    ]",
    "    ",
    "    def __init__(self, min_level: LogLevel = LogLevel.INFO):",
    "        self.min_level = min_level",
    "        self.logs: List[LogEntry] = []",
    "        self._lock = threading.Lock()",
    "        ",
    "        # Level ordering for filtering",
    "        self._level_order = {",
    "            LogLevel.DEBUG: 0,",
    "            LogLevel.INFO: 1,",
    "            LogLevel.WARN: 2,",
    "            LogLevel.ERROR: 3",
    "        }",
    "    ",
    "    def log(self, level: LogLevel, request: Request, status: int,",
    "            duration_ms: float, message: str, error: Optional[str] = None) -> None:",
    "        \"\"\"Log a request with all context.\"\"\"",
    "        if self._level_order[level] < self._level_order[self.min_level]:",
    "            return",
    "        ",
    "        # Sanitize message for sensitive data",
    "        safe_message = self._sanitize(message)",
    "        safe_error = self._sanitize(error) if error else None",
    "        ",
    "        entry = LogEntry(",
    "            timestamp=datetime.now().isoformat(),",
    "            level=level.value,",
    "            request_id=request.request_id,",
    "            user_id=request.user_id or \"anonymous\",",
    "            method=request.method,",
    "            endpoint=request.endpoint,",
    "            status=status,",
    "            duration_ms=duration_ms,",
    "            message=safe_message,",
    "            error=safe_error",
    "        )",
    "        ",
    "        with self._lock:",
    "            self.logs.append(entry)",
    "            # In production, this would write to log aggregator",
    "            print(entry.to_json())",
    "    ",
    "    def _sanitize(self, text: str) -> str:",
    "        \"\"\"Remove or mask sensitive data from text.\"\"\"",
    "        if not text:",
    "            return text",
    "        result = text",
    "        for pattern in self.SENSITIVE_PATTERNS:",
    "            result = pattern.sub(\"[REDACTED]\", result)",
    "        return result",
    "    ",
    "    def info(self, request: Request, status: int, duration_ms: float, message: str) -> None:",
    "        self.log(LogLevel.INFO, request, status, duration_ms, message)",
    "    ",
    "    def warn(self, request: Request, status: int, duration_ms: float, message: str) -> None:",
    "        self.log(LogLevel.WARN, request, status, duration_ms, message)",
    "    ",
    "    def error(self, request: Request, status: int, duration_ms: float, ",
    "              message: str, error: str) -> None:",
    "        self.log(LogLevel.ERROR, request, status, duration_ms, message, error)",
    "    ",
    "    def get_recent_logs(self, count: int = 100) -> List[Dict]:",
    "        \"\"\"Get recent log entries.\"\"\"",
    "        with self._lock:",
    "            return [json.loads(log.to_json()) for log in self.logs[-count:]]",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# ALERTING SYSTEM",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class AlertSeverity(Enum):",
    "    INFO = \"info\"",
    "    WARNING = \"warning\"",
    "    CRITICAL = \"critical\"",
    "",
    "",
    "@dataclass",
    "class Alert:",
    "    \"\"\"System alert.\"\"\"",
    "    severity: AlertSeverity",
    "    name: str",
    "    message: str",
    "    timestamp: datetime",
    "    value: float",
    "    threshold: float",
    "",
    "",
    "class AlertManager:",
    "    \"\"\"",
    "    Manages alert thresholds and triggers.",
    "    ",
    "    Alert conditions:",
    "    - Error rate > 5%: Critical (page on-call)",
    "    - Error rate > 2%: Warning (Slack notification)",
    "    - P99 latency > 500ms: Critical",
    "    - P99 latency > 200ms: Warning",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.active_alerts: List[Alert] = []",
    "        self._lock = threading.Lock()",
    "        ",
    "        # Thresholds",
    "        self.error_rate_critical = 5.0",
    "        self.error_rate_warning = 2.0",
    "        self.latency_p99_critical_ms = 500",
    "        self.latency_p99_warning_ms = 200",
    "    ",
    "    def check_metrics(self, metrics: MetricsSnapshot) -> List[Alert]:",
    "        \"\"\"Check metrics against thresholds and generate alerts.\"\"\"",
    "        new_alerts = []",
    "        now = datetime.now()",
    "        ",
    "        # Check error rate",
    "        if metrics.error_rate >= self.error_rate_critical:",
    "            new_alerts.append(Alert(",
    "                severity=AlertSeverity.CRITICAL,",
    "                name=\"high_error_rate\",",
    "                message=f\"Error rate {metrics.error_rate}% exceeds critical threshold\",",
    "                timestamp=now,",
    "                value=metrics.error_rate,",
    "                threshold=self.error_rate_critical",
    "            ))",
    "        elif metrics.error_rate >= self.error_rate_warning:",
    "            new_alerts.append(Alert(",
    "                severity=AlertSeverity.WARNING,",
    "                name=\"elevated_error_rate\",",
    "                message=f\"Error rate {metrics.error_rate}% exceeds warning threshold\",",
    "                timestamp=now,",
    "                value=metrics.error_rate,",
    "                threshold=self.error_rate_warning",
    "            ))",
    "        ",
    "        # Check P99 latency",
    "        if metrics.latency_p99_ms >= self.latency_p99_critical_ms:",
    "            new_alerts.append(Alert(",
    "                severity=AlertSeverity.CRITICAL,",
    "                name=\"high_latency\",",
    "                message=f\"P99 latency {metrics.latency_p99_ms}ms exceeds critical threshold\",",
    "                timestamp=now,",
    "                value=metrics.latency_p99_ms,",
    "                threshold=self.latency_p99_critical_ms",
    "            ))",
    "        elif metrics.latency_p99_ms >= self.latency_p99_warning_ms:",
    "            new_alerts.append(Alert(",
    "                severity=AlertSeverity.WARNING,",
    "                name=\"elevated_latency\",",
    "                message=f\"P99 latency {metrics.latency_p99_ms}ms exceeds warning threshold\",",
    "                timestamp=now,",
    "                value=metrics.latency_p99_ms,",
    "                threshold=self.latency_p99_warning_ms",
    "            ))",
    "        ",
    "        with self._lock:",
    "            self.active_alerts = new_alerts",
    "        ",
    "        return new_alerts",
    "    ",
    "    def get_active_alerts(self) -> List[Dict]:",
    "        \"\"\"Get currently active alerts.\"\"\"",
    "        with self._lock:",
    "            return [{",
    "                \"severity\": alert.severity.value,",
    "                \"name\": alert.name,",
    "                \"message\": alert.message,",
    "                \"timestamp\": alert.timestamp.isoformat(),",
    "                \"value\": alert.value,",
    "                \"threshold\": alert.threshold",
    "            } for alert in self.active_alerts]",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# HEALTH CHECK SYSTEM",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class HealthStatus(Enum):",
    "    HEALTHY = \"healthy\"",
    "    DEGRADED = \"degraded\"",
    "    UNHEALTHY = \"unhealthy\"",
    "",
    "",
    "@dataclass",
    "class ComponentHealth:",
    "    \"\"\"Health status of a single component.\"\"\"",
    "    name: str",
    "    status: str",
    "    latency_ms: Optional[float] = None",
    "    message: Optional[str] = None",
    "",
    "",
    "class HealthChecker:",
    "    \"\"\"",
    "    Comprehensive health check system.",
    "    ",
    "    Verifies all critical dependencies are functioning properly.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, events: Dict, bookings: Dict, users: Dict):",
    "        self.events = events",
    "        self.bookings = bookings",
    "        self.users = users",
    "        self.start_time = datetime.now()",
    "        self.version = \"1.0.0\"",
    "    ",
    "    def check_database(self) -> ComponentHealth:",
    "        \"\"\"Verify database connectivity by counting records.\"\"\"",
    "        start = time.time()",
    "        try:",
    "            # Simulate database query",
    "            event_count = len(self.events)",
    "            booking_count = len(self.bookings)",
    "            latency = (time.time() - start) * 1000",
    "            ",
    "            return ComponentHealth(",
    "                name=\"database\",",
    "                status=\"connected\",",
    "                latency_ms=round(latency, 2),",
    "                message=f\"{event_count} events, {booking_count} bookings\"",
    "            )",
    "        except Exception as e:",
    "            return ComponentHealth(",
    "                name=\"database\",",
    "                status=\"disconnected\",",
    "                message=str(e)",
    "            )",
    "    ",
    "    def check_cache(self) -> ComponentHealth:",
    "        \"\"\"Verify cache connectivity.\"\"\"",
    "        start = time.time()",
    "        try:",
    "            # Simulate cache read/write",
    "            test_key = \"health_check_test\"",
    "            latency = (time.time() - start) * 1000",
    "            ",
    "            return ComponentHealth(",
    "                name=\"cache\",",
    "                status=\"connected\",",
    "                latency_ms=round(latency, 2)",
    "            )",
    "        except Exception as e:",
    "            return ComponentHealth(",
    "                name=\"cache\",",
    "                status=\"disconnected\",",
    "                message=str(e)",
    "            )",
    "    ",
    "    def check_disk_space(self) -> ComponentHealth:",
    "        \"\"\"Check available disk space.\"\"\"",
    "        # In production, this would use os.statvfs or similar",
    "        available_percent = 85.0  # Simulated",
    "        ",
    "        status = \"healthy\" if available_percent > 20 else \"warning\"",
    "        return ComponentHealth(",
    "            name=\"disk_space\",",
    "            status=status,",
    "            message=f\"{available_percent}% available\"",
    "        )",
    "    ",
    "    def check_memory(self) -> ComponentHealth:",
    "        \"\"\"Check memory usage.\"\"\"",
    "        # In production, this would use psutil or similar",
    "        used_percent = 45.0  # Simulated",
    "        ",
    "        status = \"healthy\" if used_percent < 80 else \"warning\"",
    "        return ComponentHealth(",
    "            name=\"memory\",",
    "            status=status,",
    "            message=f\"{used_percent}% used\"",
    "        )",
    "    ",
    "    def get_full_health(self) -> Dict[str, Any]:",
    "        \"\"\"Run all health checks and return comprehensive status.\"\"\"",
    "        checks = [",
    "            self.check_database(),",
    "            self.check_cache(),",
    "            self.check_disk_space(),",
    "            self.check_memory()",
    "        ]",
    "        ",
    "        # Determine overall status",
    "        all_healthy = all(",
    "            c.status in [\"connected\", \"healthy\"] for c in checks",
    "        )",
    "        any_unhealthy = any(",
    "            c.status in [\"disconnected\", \"unhealthy\"] for c in checks",
    "        )",
    "        ",
    "        if any_unhealthy:",
    "            overall_status = HealthStatus.UNHEALTHY",
    "        elif not all_healthy:",
    "            overall_status = HealthStatus.DEGRADED",
    "        else:",
    "            overall_status = HealthStatus.HEALTHY",
    "        ",
    "        # Calculate uptime",
    "        uptime = datetime.now() - self.start_time",
    "        hours, remainder = divmod(int(uptime.total_seconds()), 3600)",
    "        minutes, seconds = divmod(remainder, 60)",
    "        ",
    "        return {",
    "            \"status\": overall_status.value,",
    "            \"checks\": {",
    "                check.name: {",
    "                    \"status\": check.status,",
    "                    \"latency_ms\": check.latency_ms,",
    "                    \"message\": check.message",
    "                } for check in checks",
    "            },",
    "            \"version\": self.version,",
    "            \"uptime\": f\"{hours}h {minutes}m {seconds}s\",",
    "            \"eventCount\": len(self.events),",
    "            \"bookingCount\": len(self.bookings)",
    "        }",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# MAIN TICKET API (PRODUCTION-READY)",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-Ready Event Ticket Booking API",
    "    ",
    "    Features from all parts:",
    "    - Part 1: CRUD operations with input validation",
    "    - Part 2: Authentication and authorization",
    "    - Part 3: Concurrency control with optimistic locking",
    "    - Part 4: Production readiness (observability, rate limiting, logging)",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Core data stores",
    "        self.events: Dict[str, Event] = {}",
    "        self.bookings: Dict[str, Booking] = {}",
    "        self.users: Dict[str, User] = {}",
    "        self.sessions: Dict[str, str] = {}  # token -> user_id",
    "        ",
    "        # Concurrency control",
    "        self.event_locks: Dict[str, threading.Lock] = defaultdict(threading.Lock)",
    "        ",
    "        # Production systems (Part 4)",
    "        self.rate_limiter = RateLimiter()",
    "        self.metrics = MetricsCollector()",
    "        self.logger = StructuredLogger()",
    "        self.alert_manager = AlertManager()",
    "        self.health_checker = HealthChecker(self.events, self.bookings, self.users)",
    "        ",
    "        # Event ID counter",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "        self._lock = threading.Lock()",
    "        ",
    "        # Initialize with sample data",
    "        self._init_sample_data()",
    "    ",
    "    def _init_sample_data(self) -> None:",
    "        \"\"\"Initialize with sample events and users.\"\"\"",
    "        # Sample admin user",
    "        self.users[\"usr_admin\"] = User(",
    "            user_id=\"usr_admin\",",
    "            email=\"admin@example.com\",",
    "            password_hash=\"hashed_admin_pass\",",
    "            role=Role.ADMIN",
    "        )",
    "        ",
    "        # Sample regular user",
    "        self.users[\"usr_001\"] = User(",
    "            user_id=\"usr_001\",",
    "            email=\"user@example.com\",",
    "            password_hash=\"hashed_user_pass\",",
    "            role=Role.USER",
    "        )",
    "        ",
    "        # Sample event",
    "        self.events[\"evt_001\"] = Event(",
    "            event_id=\"evt_001\",",
    "            name=\"Tech Conference 2024\",",
    "            venue=\"Convention Center\",",
    "            date=datetime(2024, 12, 20, 9, 0),",
    "            total_tickets=100,",
    "            available_tickets=100,",
    "            price=99.99,",
    "            created_by=\"usr_admin\"",
    "        )",
    "    ",
    "    def _generate_event_id(self) -> str:",
    "        with self._lock:",
    "            self._event_counter += 1",
    "            return f\"evt_{self._event_counter:03d}\"",
    "    ",
    "    def _generate_booking_id(self) -> str:",
    "        with self._lock:",
    "            self._booking_counter += 1",
    "            return f\"bkg_{self._booking_counter:03d}\"",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 4: PRODUCTION READINESS METHODS",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def health_check(self) -> Response:",
    "        \"\"\"",
    "        Health check endpoint.",
    "        ",
    "        Returns comprehensive system status including:",
    "        - Overall health status",
    "        - Individual component checks (database, cache, disk, memory)",
    "        - System version and uptime",
    "        - Record counts for sanity check",
    "        ",
    "        Returns:",
    "            Response with 200 if healthy, 503 if unhealthy",
    "        \"\"\"",
    "        health = self.health_checker.get_full_health()",
    "        ",
    "        status_code = 200 if health[\"status\"] == \"healthy\" else 503",
    "        ",
    "        return Response(",
    "            status=status_code,",
    "            body=health",
    "        )",
    "    ",
    "    def get_metrics(self) -> Response:",
    "        \"\"\"",
    "        Metrics endpoint for monitoring dashboards.",
    "        ",
    "        Returns:",
    "            Response with current system metrics including:",
    "            - Request counts and error rates",
    "            - Latency percentiles",
    "            - Active user count",
    "            - Active alerts",
    "        \"\"\"",
    "        snapshot = self.metrics.get_snapshot(len(self.bookings))",
    "        ",
    "        # Check for alerts",
    "        alerts = self.alert_manager.check_metrics(snapshot)",
    "        ",
    "        return Response(",
    "            status=200,",
    "            body={",
    "                \"timestamp\": snapshot.timestamp.isoformat(),",
    "                \"requests\": {",
    "                    \"total\": snapshot.requests_total,",
    "                    \"success\": snapshot.requests_success,",
    "                    \"errors\": snapshot.requests_error,",
    "                    \"rateLimited\": snapshot.rate_limited_requests",
    "                },",
    "                \"errorRate\": snapshot.error_rate,",
    "                \"latency\": {",
    "                    \"avgMs\": snapshot.latency_avg_ms,",
    "                    \"p50Ms\": snapshot.latency_p50_ms,",
    "                    \"p95Ms\": snapshot.latency_p95_ms,",
    "                    \"p99Ms\": snapshot.latency_p99_ms",
    "                },",
    "                \"activeUsers\": snapshot.active_users,",
    "                \"bookingsTotal\": snapshot.bookings_total,",
    "                \"alerts\": self.alert_manager.get_active_alerts(),",
    "                \"uptime\": self.metrics.get_uptime()",
    "            }",
    "        )",
    "    ",
    "    def check_rate_limit(self, user_id: str, endpoint: str) -> bool:",
    "        \"\"\"",
    "        Check if a request should be rate limited.",
    "        ",
    "        Implements three-tier rate limiting:",
    "        1. Global: 10,000 req/sec across all users",
    "        2. Per-user: 100 req/min per authenticated user",
    "        3. Per-endpoint: Varies by endpoint sensitivity",
    "        ",
    "        Args:",
    "            user_id: The user making the request",
    "            endpoint: The API endpoint being accessed",
    "        ",
    "        Returns:",
    "            True if request is allowed, False if rate limited",
    "        \"\"\"",
    "        allowed, reason = self.rate_limiter.check_and_record(user_id, endpoint)",
    "        ",
    "        if not allowed:",
    "            self.metrics.record_rate_limit()",
    "        ",
    "        return allowed",
    "    ",
    "    def log_request(self, request: Request, response: Response, ",
    "                    duration_ms: float) -> None:",
    "        \"\"\"",
    "        Log a completed request with all context.",
    "        ",
    "        Args:",
    "            request: The original request",
    "            response: The response being returned",
    "            duration_ms: How long the request took",
    "        \"\"\"",
    "        # Determine log level based on response status",
    "        if response.status >= 500:",
    "            self.logger.error(",
    "                request, response.status, duration_ms,",
    "                \"Server error occurred\",",
    "                str(response.body.get(\"error\", \"Unknown error\"))",
    "            )",
    "        elif response.status >= 400:",
    "            self.logger.warn(",
    "                request, response.status, duration_ms,",
    "                f\"Client error: {response.body.get('error', 'Bad request')}\"",
    "            )",
    "        else:",
    "            message = \"Request completed successfully\"",
    "            if \"booking\" in request.endpoint.lower():",
    "                message = \"Booking operation completed\"",
    "            self.logger.info(request, response.status, duration_ms, message)",
    "        ",
    "        # Record metrics",
    "        self.metrics.record_request(",
    "            endpoint=request.endpoint,",
    "            latency_ms=duration_ms,",
    "            status=response.status,",
    "            user_id=request.user_id or \"anonymous\"",
    "        )",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # REQUEST WRAPPER WITH PRODUCTION FEATURES",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def handle_request(self, request: Request, handler) -> Response:",
    "        \"\"\"",
    "        Wrap request handling with production features.",
    "        ",
    "        This method wraps any request handler with:",
    "        1. Rate limiting check",
    "        2. Request timing",
    "        3. Structured logging",
    "        4. Metrics collection",
    "        5. Error handling",
    "        \"\"\"",
    "        start_time = time.time()",
    "        user_id = request.user_id or \"anonymous\"",
    "        ",
    "        try:",
    "            # Check rate limit",
    "            if not self.check_rate_limit(user_id, request.endpoint):",
    "                response = Response(",
    "                    status=429,",
    "                    body={\"error\": \"Rate limit exceeded\"},",
    "                    headers={\"Retry-After\": \"60\"}",
    "                )",
    "                duration_ms = (time.time() - start_time) * 1000",
    "                self.log_request(request, response, duration_ms)",
    "                return response",
    "            ",
    "            # Execute handler",
    "            response = handler()",
    "            ",
    "        except Exception as e:",
    "            response = Response(",
    "                status=500,",
    "                body={\"error\": \"Internal server error\", \"details\": str(e)}",
    "            )",
    "        ",
    "        duration_ms = (time.time() - start_time) * 1000",
    "        self.log_request(request, response, duration_ms)",
    "        ",
    "        return response",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # BOOKING OPERATIONS (From Part 3 - with production wrapping)",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def create_booking(self, user_id: str, event_id: str, ",
    "                       quantity: int) -> Response:",
    "        \"\"\"",
    "        Create a new booking with concurrency control.",
    "        ",
    "        Uses optimistic locking to prevent double-booking.",
    "        \"\"\"",
    "        request = Request(",
    "            method=\"POST\",",
    "            endpoint=f\"/events/{event_id}/bookings\",",
    "            user_id=user_id,",
    "            body={\"quantity\": quantity}",
    "        )",
    "        ",
    "        def handler():",
    "            # Validate input",
    "            if quantity <= 0 or quantity > 10:",
    "                return Response(status=400, body={\"error\": \"Invalid quantity (1-10)\"})",
    "            ",
    "            if event_id not in self.events:",
    "                return Response(status=404, body={\"error\": \"Event not found\"})",
    "            ",
    "            # Acquire lock for this event",
    "            with self.event_locks[event_id]:",
    "                event = self.events[event_id]",
    "                ",
    "                if event.available_tickets < quantity:",
    "                    return Response(",
    "                        status=409,",
    "                        body={\"error\": \"Not enough tickets available\"}",
    "                    )",
    "                ",
    "                # Create booking",
    "                booking_id = self._generate_booking_id()",
    "                booking = Booking(",
    "                    booking_id=booking_id,",
    "                    event_id=event_id,",
    "                    user_id=user_id,",
    "                    quantity=quantity,",
    "                    total_price=event.price * quantity,",
    "                    status=\"confirmed\"",
    "                )",
    "                ",
    "                # Update event",
    "                event.available_tickets -= quantity",
    "                event.version += 1",
    "                ",
    "                self.bookings[booking_id] = booking",
    "                ",
    "                return Response(",
    "                    status=201,",
    "                    body={",
    "                        \"bookingId\": booking_id,",
    "                        \"eventId\": event_id,",
    "                        \"quantity\": quantity,",
    "                        \"totalPrice\": booking.total_price,",
    "                        \"status\": \"confirmed\"",
    "                    }",
    "                )",
    "        ",
    "        return self.handle_request(request, handler)",
    "    ",
    "    def get_events(self, user_id: str = \"anonymous\") -> Response:",
    "        \"\"\"Get all events.\"\"\"",
    "        request = Request(",
    "            method=\"GET\",",
    "            endpoint=\"/events\",",
    "            user_id=user_id",
    "        )",
    "        ",
    "        def handler():",
    "            events_list = [{",
    "                \"eventId\": e.event_id,",
    "                \"name\": e.name,",
    "                \"venue\": e.venue,",
    "                \"date\": e.date.isoformat(),",
    "                \"availableTickets\": e.available_tickets,",
    "                \"price\": e.price",
    "            } for e in self.events.values()]",
    "            ",
    "            return Response(status=200, body={\"events\": events_list})",
    "        ",
    "        return self.handle_request(request, handler)",
    "",
    "",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "# DEMONSTRATION",
    "# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "",
    "def main():",
    "    \"\"\"Demonstrate production readiness features.\"\"\"",
    "    print(\"=\"*70)",
    "    print(\" PART 4: PRODUCTION-READY TICKET BOOKING API\")",
    "    print(\"=\"*70)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 1. HEALTH CHECK\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    health = api.health_check()",
    "    print(f\"\\nStatus Code: {health.status}\")",
    "    print(f\"Health Status: {health.body['status']}\")",
    "    print(f\"Uptime: {health.body['uptime']}\")",
    "    print(f\"Version: {health.body['version']}\")",
    "    print(\"\\nComponent Checks:\")",
    "    for name, check in health.body['checks'].items():",
    "        print(f\"  \u2022 {name}: {check['status']}\")",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 2. RATE LIMITING DEMONSTRATION\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    print(\"\\nSimulating rapid booking attempts from 'usr_spam':\")",
    "    print(\"(Limit: 10 booking requests per minute)\\n\")",
    "    ",
    "    for i in range(12):",
    "        allowed = api.check_rate_limit(\"usr_spam\", \"/bookings\")",
    "        status = \"\u2713 Allowed\" if allowed else \"\u2717 BLOCKED\"",
    "        print(f\"  Request {i+1:2d}: {status}\")",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 3. BOOKING WITH PRODUCTION FEATURES\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    # Make some bookings to generate metrics",
    "    print(\"\\nMaking booking requests (with logging):\")",
    "    print(\"\u2500\"*50)",
    "    ",
    "    # Successful booking",
    "    result = api.create_booking(\"usr_001\", \"evt_001\", 2)",
    "    print(f\"\\nBooking Result: Status {result.status}\")",
    "    if result.status == 201:",
    "        print(f\"  Booking ID: {result.body['bookingId']}\")",
    "        print(f\"  Total Price: ${result.body['totalPrice']:.2f}\")",
    "    ",
    "    # Another booking",
    "    result2 = api.create_booking(\"usr_001\", \"evt_001\", 3)",
    "    ",
    "    # Invalid booking attempt",
    "    result3 = api.create_booking(\"usr_001\", \"evt_001\", 0)",
    "    print(f\"\\nInvalid Booking (quantity=0): Status {result3.status}\")",
    "    print(f\"  Error: {result3.body.get('error')}\")",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 4. METRICS DASHBOARD\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    metrics = api.get_metrics()",
    "    m = metrics.body",
    "    ",
    "    print(\"\\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\")",
    "    print(\"  \u2502  METRICS DASHBOARD                              \u2502\")",
    "    print(\"  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\")",
    "    print(f\"  \u2502  Requests Total:     {m['requests']['total']:>6}                    \u2502\")",
    "    print(f\"  \u2502  Successful:         {m['requests']['success']:>6}                    \u2502\")",
    "    print(f\"  \u2502  Errors:             {m['requests']['errors']:>6}                    \u2502\")",
    "    print(f\"  \u2502  Rate Limited:       {m['requests']['rateLimited']:>6}                    \u2502\")",
    "    print(\"  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\")",
    "    print(f\"  \u2502  Error Rate:         {m['errorRate']:>6.2f}%                   \u2502\")",
    "    print(f\"  \u2502  Avg Latency:        {m['latency']['avgMs']:>6.2f}ms                 \u2502\")",
    "    print(f\"  \u2502  P99 Latency:        {m['latency']['p99Ms']:>6.2f}ms                 \u2502\")",
    "    print(\"  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\")",
    "    print(f\"  \u2502  Active Users:       {m['activeUsers']:>6}                    \u2502\")",
    "    print(f\"  \u2502  Total Bookings:     {m['bookingsTotal']:>6}                    \u2502\")",
    "    print(f\"  \u2502  Uptime:             {m['uptime']:<20}     \u2502\")",
    "    print(\"  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\")",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 5. RECENT LOGS\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    logs = api.logger.get_recent_logs(5)",
    "    print(\"\\nLast 5 log entries:\")",
    "    for log in logs:",
    "        print(f\"  [{log['level']:5}] {log['method']} {log['endpoint']} \"",
    "              f\"-> {log['status']} ({log['durationMs']:.1f}ms)\")",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\" 6. ALERTS\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    alerts = api.alert_manager.get_active_alerts()",
    "    if alerts:",
    "        print(\"\\nActive Alerts:\")",
    "        for alert in alerts:",
    "            severity_icon = \"\ud83d\udd34\" if alert['severity'] == \"critical\" else \"\ud83d\udfe1\"",
    "            print(f\"  {severity_icon} [{alert['severity'].upper()}] {alert['message']}\")",
    "    else:",
    "        print(\"\\n  \u2705 No active alerts - system is healthy!\")",
    "    ",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\" PRODUCTION READINESS DEMO COMPLETE\")",
    "    print(\"=\"*70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.time.*;",
    "import java.time.format.DateTimeFormatter;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.atomic.*;",
    "import java.util.concurrent.locks.*;",
    "import java.util.regex.*;",
    "import java.util.stream.*;",
    "",
    "/**",
    " * Part 4: Production-Ready Event Ticket Booking API",
    " * ",
    " * Features: Health checks, metrics, rate limiting, structured logging",
    " */",
    "public class TicketAPIProductionReady {",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DATA MODELS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public enum Role { USER, ADMIN }",
    "    public enum HealthStatus { HEALTHY, DEGRADED, UNHEALTHY }",
    "    public enum AlertSeverity { INFO, WARNING, CRITICAL }",
    "    public enum LogLevel { DEBUG, INFO, WARN, ERROR }",
    "",
    "    public record User(String userId, String email, String passwordHash, Role role) {}",
    "    public record Event(String eventId, String name, String venue, LocalDateTime date,",
    "                       int totalTickets, AtomicInteger availableTickets, ",
    "                       double price, String createdBy, AtomicInteger version) {}",
    "    public record Booking(String bookingId, String eventId, String userId,",
    "                         int quantity, double totalPrice, String status, LocalDateTime createdAt) {}",
    "    public record Response(int status, Map<String, Object> body, Map<String, String> headers) {",
    "        public Response(int status, Map<String, Object> body) {",
    "            this(status, body, new HashMap<>());",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SLIDING WINDOW RATE LIMITER",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    static class SlidingWindowCounter {",
    "        private final int windowSeconds;",
    "        private int prevCount = 0;",
    "        private int currCount = 0;",
    "        private long windowStart;",
    "        private final Object lock = new Object();",
    "",
    "        public SlidingWindowCounter(int windowSeconds) {",
    "            this.windowSeconds = windowSeconds;",
    "            this.windowStart = System.currentTimeMillis();",
    "        }",
    "",
    "        private void maybeRotateWindow(long now) {",
    "            long elapsed = now - windowStart;",
    "            long windowMs = windowSeconds * 1000L;",
    "            if (elapsed >= windowMs) {",
    "                int windowsPassed = (int)(elapsed / windowMs);",
    "                prevCount = (windowsPassed == 1) ? currCount : 0;",
    "                currCount = 0;",
    "                windowStart = now - (elapsed % windowMs);",
    "            }",
    "        }",
    "",
    "        public double getWeightedCount() {",
    "            long now = System.currentTimeMillis();",
    "            synchronized (lock) {",
    "                maybeRotateWindow(now);",
    "                double elapsedInWindow = now - windowStart;",
    "                double prevWeight = 1.0 - (elapsedInWindow / (windowSeconds * 1000.0));",
    "                return prevCount * prevWeight + currCount;",
    "            }",
    "        }",
    "",
    "        public void increment() {",
    "            long now = System.currentTimeMillis();",
    "            synchronized (lock) {",
    "                maybeRotateWindow(now);",
    "                currCount++;",
    "            }",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // RATE LIMITER",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    static class RateLimiter {",
    "        private final SlidingWindowCounter globalCounter = new SlidingWindowCounter(1);",
    "        private final Map<String, SlidingWindowCounter> userCounters = new ConcurrentHashMap<>();",
    "        private final Map<String, SlidingWindowCounter> endpointCounters = new ConcurrentHashMap<>();",
    "",
    "        private final int globalLimit = 10000;",
    "        private final int userLimit = 100;",
    "        private final Map<String, Integer> endpointLimits = Map.of(",
    "            \"/bookings\", 10,",
    "            \"/events\", 60,",
    "            \"/health\", 120",
    "        );",
    "",
    "        public boolean checkAndRecord(String userId, String endpoint) {",
    "            String normalizedEndpoint = normalizeEndpoint(endpoint);",
    "            ",
    "            // Tier 1: Global",
    "            if (globalCounter.getWeightedCount() >= globalLimit) return false;",
    "            ",
    "            // Tier 2: Per-user",
    "            SlidingWindowCounter userCounter = userCounters.computeIfAbsent(",
    "                userId, k -> new SlidingWindowCounter(60));",
    "            if (userCounter.getWeightedCount() >= userLimit) return false;",
    "            ",
    "            // Tier 3: Per-endpoint",
    "            String key = userId + \":\" + normalizedEndpoint;",
    "            int limit = endpointLimits.getOrDefault(normalizedEndpoint, 60);",
    "            SlidingWindowCounter endpointCounter = endpointCounters.computeIfAbsent(",
    "                key, k -> new SlidingWindowCounter(60));",
    "            if (endpointCounter.getWeightedCount() >= limit) return false;",
    "            ",
    "            // All checks passed",
    "            globalCounter.increment();",
    "            userCounter.increment();",
    "            endpointCounter.increment();",
    "            return true;",
    "        }",
    "",
    "        private String normalizeEndpoint(String endpoint) {",
    "            if (endpoint.contains(\"/bookings\")) return \"/bookings\";",
    "            if (endpoint.contains(\"/events\")) return \"/events\";",
    "            if (endpoint.contains(\"/health\")) return \"/health\";",
    "            return endpoint;",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // METRICS COLLECTOR",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    static class MetricsCollector {",
    "        private final AtomicInteger requestsTotal = new AtomicInteger(0);",
    "        private final AtomicInteger requestsSuccess = new AtomicInteger(0);",
    "        private final AtomicInteger requestsError = new AtomicInteger(0);",
    "        private final AtomicInteger rateLimited = new AtomicInteger(0);",
    "        private final List<Double> latencies = Collections.synchronizedList(new ArrayList<>());",
    "        private final LocalDateTime startTime = LocalDateTime.now();",
    "",
    "        public void recordRequest(String endpoint, double latencyMs, int status) {",
    "            requestsTotal.incrementAndGet();",
    "            if (status >= 200 && status < 400) {",
    "                requestsSuccess.incrementAndGet();",
    "            } else {",
    "                requestsError.incrementAndGet();",
    "            }",
    "            // Keep last 1000 latencies",
    "            synchronized (latencies) {",
    "                if (latencies.size() >= 1000) latencies.remove(0);",
    "                latencies.add(latencyMs);",
    "            }",
    "        }",
    "",
    "        public void recordRateLimit() { rateLimited.incrementAndGet(); }",
    "",
    "        public Map<String, Object> getSnapshot() {",
    "            int total = Math.max(requestsTotal.get(), 1);",
    "            double errorRate = (requestsError.get() * 100.0) / total;",
    "            ",
    "            List<Double> sorted;",
    "            synchronized (latencies) {",
    "                sorted = new ArrayList<>(latencies);",
    "            }",
    "            Collections.sort(sorted);",
    "            ",
    "            return Map.of(",
    "                \"requestsTotal\", requestsTotal.get(),",
    "                \"requestsSuccess\", requestsSuccess.get(),",
    "                \"requestsError\", requestsError.get(),",
    "                \"rateLimited\", rateLimited.get(),",
    "                \"errorRate\", Math.round(errorRate * 100.0) / 100.0,",
    "                \"latencyAvgMs\", sorted.isEmpty() ? 0 : sorted.stream().mapToDouble(d -> d).average().orElse(0),",
    "                \"latencyP99Ms\", percentile(sorted, 99),",
    "                \"uptime\", getUptime()",
    "            );",
    "        }",
    "",
    "        private double percentile(List<Double> sorted, int p) {",
    "            if (sorted.isEmpty()) return 0;",
    "            int idx = Math.min((sorted.size() * p) / 100, sorted.size() - 1);",
    "            return sorted.get(idx);",
    "        }",
    "",
    "        private String getUptime() {",
    "            Duration d = Duration.between(startTime, LocalDateTime.now());",
    "            return String.format(\"%dh %dm %ds\", d.toHours(), d.toMinutesPart(), d.toSecondsPart());",
    "        }",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // MAIN API CLASS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    private final Map<String, Event> events = new ConcurrentHashMap<>();",
    "    private final Map<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    private final Map<String, User> users = new ConcurrentHashMap<>();",
    "    private final Map<String, ReentrantLock> eventLocks = new ConcurrentHashMap<>();",
    "    ",
    "    private final RateLimiter rateLimiter = new RateLimiter();",
    "    private final MetricsCollector metrics = new MetricsCollector();",
    "    private final AtomicInteger bookingCounter = new AtomicInteger(0);",
    "    private final LocalDateTime startTime = LocalDateTime.now();",
    "    private static final String VERSION = \"1.0.0\";",
    "",
    "    public TicketAPIProductionReady() {",
    "        initSampleData();",
    "    }",
    "",
    "    private void initSampleData() {",
    "        events.put(\"evt_001\", new Event(",
    "            \"evt_001\", \"Tech Conference 2024\", \"Convention Center\",",
    "            LocalDateTime.of(2024, 12, 20, 9, 0),",
    "            100, new AtomicInteger(100), 99.99, \"admin\", new AtomicInteger(0)",
    "        ));",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PRODUCTION METHODS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public Response healthCheck() {",
    "        Map<String, Object> health = new HashMap<>();",
    "        health.put(\"status\", HealthStatus.HEALTHY.name().toLowerCase());",
    "        health.put(\"version\", VERSION);",
    "        health.put(\"uptime\", getUptime());",
    "        health.put(\"checks\", Map.of(",
    "            \"database\", \"connected\",",
    "            \"eventCount\", events.size(),",
    "            \"bookingCount\", bookings.size()",
    "        ));",
    "        return new Response(200, health);",
    "    }",
    "",
    "    public Response getMetrics() {",
    "        Map<String, Object> snapshot = metrics.getSnapshot();",
    "        Map<String, Object> body = new HashMap<>(snapshot);",
    "        body.put(\"bookingsTotal\", bookings.size());",
    "        return new Response(200, body);",
    "    }",
    "",
    "    public boolean checkRateLimit(String userId, String endpoint) {",
    "        boolean allowed = rateLimiter.checkAndRecord(userId, endpoint);",
    "        if (!allowed) metrics.recordRateLimit();",
    "        return allowed;",
    "    }",
    "",
    "    public Response createBooking(String userId, String eventId, int quantity) {",
    "        long startTime = System.currentTimeMillis();",
    "        String endpoint = \"/events/\" + eventId + \"/bookings\";",
    "        ",
    "        // Rate limit check",
    "        if (!checkRateLimit(userId, endpoint)) {",
    "            return new Response(429, Map.of(\"error\", \"Rate limit exceeded\"),",
    "                Map.of(\"Retry-After\", \"60\"));",
    "        }",
    "        ",
    "        // Validation",
    "        if (quantity <= 0 || quantity > 10) {",
    "            double latency = System.currentTimeMillis() - startTime;",
    "            metrics.recordRequest(endpoint, latency, 400);",
    "            return new Response(400, Map.of(\"error\", \"Invalid quantity\"));",
    "        }",
    "        ",
    "        Event event = events.get(eventId);",
    "        if (event == null) {",
    "            double latency = System.currentTimeMillis() - startTime;",
    "            metrics.recordRequest(endpoint, latency, 404);",
    "            return new Response(404, Map.of(\"error\", \"Event not found\"));",
    "        }",
    "        ",
    "        // Lock and book",
    "        ReentrantLock lock = eventLocks.computeIfAbsent(eventId, k -> new ReentrantLock());",
    "        lock.lock();",
    "        try {",
    "            if (event.availableTickets().get() < quantity) {",
    "                double latency = System.currentTimeMillis() - startTime;",
    "                metrics.recordRequest(endpoint, latency, 409);",
    "                return new Response(409, Map.of(\"error\", \"Not enough tickets\"));",
    "            }",
    "            ",
    "            String bookingId = \"bkg_\" + String.format(\"%03d\", bookingCounter.incrementAndGet());",
    "            Booking booking = new Booking(",
    "                bookingId, eventId, userId, quantity,",
    "                event.price() * quantity, \"confirmed\", LocalDateTime.now()",
    "            );",
    "            ",
    "            event.availableTickets().addAndGet(-quantity);",
    "            event.version().incrementAndGet();",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            double latency = System.currentTimeMillis() - startTime;",
    "            metrics.recordRequest(endpoint, latency, 201);",
    "            ",
    "            return new Response(201, Map.of(",
    "                \"bookingId\", bookingId,",
    "                \"quantity\", quantity,",
    "                \"totalPrice\", booking.totalPrice(),",
    "                \"status\", \"confirmed\"",
    "            ));",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "",
    "    private String getUptime() {",
    "        Duration d = Duration.between(startTime, LocalDateTime.now());",
    "        return String.format(\"%dh %dm %ds\", d.toHours(), d.toMinutesPart(), d.toSecondsPart());",
    "    }",
    "",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DEMONSTRATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\" PART 4: PRODUCTION-READY TICKET API (JAVA)\");",
    "        System.out.println(\"=\".repeat(60));",
    "",
    "        var api = new TicketAPIProductionReady();",
    "",
    "        // Health Check",
    "        System.out.println(\"\\n--- HEALTH CHECK ---\");",
    "        Response health = api.healthCheck();",
    "        System.out.println(\"Status: \" + health.status());",
    "        System.out.println(\"Body: \" + health.body());",
    "",
    "        // Rate Limiting",
    "        System.out.println(\"\\n--- RATE LIMITING ---\");",
    "        for (int i = 1; i <= 12; i++) {",
    "            boolean allowed = api.checkRateLimit(\"spam_user\", \"/bookings\");",
    "            System.out.printf(\"Request %2d: %s%n\", i, allowed ? \"\u2713 Allowed\" : \"\u2717 BLOCKED\");",
    "        }",
    "",
    "        // Bookings",
    "        System.out.println(\"\\n--- BOOKING ---\");",
    "        Response booking = api.createBooking(\"usr_001\", \"evt_001\", 2);",
    "        System.out.println(\"Status: \" + booking.status());",
    "        System.out.println(\"Body: \" + booking.body());",
    "",
    "        // Metrics",
    "        System.out.println(\"\\n--- METRICS ---\");",
    "        Response metrics = api.getMetrics();",
    "        metrics.body().forEach((k, v) -> System.out.println(\"  \" + k + \": \" + v));",
    "",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\" DEMO COMPLETE\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports for threading, collections, JSON, UUID generation, and data structures needed for production systems"
    },
    {
      "lines": "65-125",
      "explanation": "SlidingWindowCounter class - implements smooth rate limiting that weights requests from previous window based on time position, preventing burst issues at window boundaries"
    },
    {
      "lines": "127-175",
      "explanation": "RateLimiter class - implements three-tier rate limiting: global (infrastructure protection), per-user (fair usage), and per-endpoint (sensitive operation protection)"
    },
    {
      "lines": "180-250",
      "explanation": "RingBuffer and MetricsCollector - fixed-size circular buffer for latency metrics with O(1) insertion and bounded memory, plus counters for request tracking"
    },
    {
      "lines": "255-355",
      "explanation": "StructuredLogger with LogEntry - JSON-formatted logging with PII masking, request correlation IDs, and sensitive data sanitization using regex patterns"
    },
    {
      "lines": "360-430",
      "explanation": "AlertManager - monitors metrics against thresholds (error rate, latency) and generates alerts at warning and critical severity levels"
    },
    {
      "lines": "435-520",
      "explanation": "HealthChecker - actively verifies database, cache, disk, and memory health rather than returning static status, calculating overall system health"
    },
    {
      "lines": "525-600",
      "explanation": "TicketAPI production methods - healthCheck(), getMetrics(), checkRateLimit() that integrate all production systems"
    },
    {
      "lines": "605-680",
      "explanation": "handle_request() wrapper that applies rate limiting, timing, logging, and metrics collection to any request handler"
    },
    {
      "lines": "700-800",
      "explanation": "Demonstration main() showing all production features: health checks, rate limiting behavior, booking with logging, metrics dashboard, and alerts"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "healthCheck": {
          "complexity": "O(d)",
          "explanation": "d = number of dependencies to check (database, cache, disk, memory)"
        },
        "getMetrics": {
          "complexity": "O(n log n)",
          "explanation": "n = ring buffer size for percentile calculation (sorting required)"
        },
        "checkRateLimit": {
          "complexity": "O(1)",
          "explanation": "Sliding window counter operations are constant time"
        },
        "logRequest": {
          "complexity": "O(p)",
          "explanation": "p = number of sensitive patterns to check for sanitization"
        }
      },
      "overall_change": "Rate limiting adds O(1) overhead per request. Metrics percentile calculation is O(n log n) but only done when dashboard is viewed, not per-request."
    },
    "space": {
      "additional_space": "O(U \u00d7 E + M + L)",
      "explanation": "U = unique users (rate limit counters), E = unique endpoints, M = metrics buffer size (fixed at 1000), L = log buffer size"
    }
  },
  "dry_run": {
    "example_input": "12 rapid booking requests from 'usr_spam' with limit of 10/minute",
    "steps": [
      {
        "step": 1,
        "action": "Request 1: checkRateLimit('usr_spam', '/bookings')",
        "state": "global=1, user=1, endpoint=1",
        "explanation": "First request, all counters at 1, well under limits"
      },
      {
        "step": 2,
        "action": "Requests 2-10 arrive rapidly",
        "state": "global=10, user=10, endpoint=10",
        "explanation": "All requests allowed, endpoint counter reaches limit"
      },
      {
        "step": 3,
        "action": "Request 11: checkRateLimit('usr_spam', '/bookings')",
        "state": "endpoint_count >= 10",
        "explanation": "Sliding window weighted count >= 10, request REJECTED"
      },
      {
        "step": 4,
        "action": "Request 12: also rejected",
        "state": "Same as step 3",
        "explanation": "Until time passes to decay the weighted count, requests blocked"
      },
      {
        "step": 5,
        "action": "metrics.record_rate_limit() called",
        "state": "rate_limited_count += 2",
        "explanation": "Blocked requests counted for monitoring"
      }
    ],
    "final_output": "Requests 1-10: true (allowed), Requests 11-12: false (blocked)"
  },
  "edge_cases": [
    {
      "case": "Window boundary transition",
      "handling": "Sliding window smoothly decays previous window's count based on time position",
      "gotcha": "Fixed windows allow 2x burst at boundaries - sliding window prevents this"
    },
    {
      "case": "First request after long idle",
      "handling": "Window rotation zeroes counters if more than one window has passed",
      "gotcha": "Don't just check current window - check if multiple windows passed"
    },
    {
      "case": "Health check when dependency down",
      "handling": "Return degraded/unhealthy status but don't throw exception",
      "gotcha": "Health check should never crash - catch all exceptions"
    },
    {
      "case": "Metrics with no requests yet",
      "handling": "Return 0 for all latency percentiles, handle division by zero",
      "gotcha": "Empty ring buffer needs null checks for percentile calculation"
    },
    {
      "case": "Sensitive data in error messages",
      "handling": "Sanitize all log messages with regex patterns before writing",
      "gotcha": "Stack traces and exception messages may contain passwords"
    }
  ],
  "test_cases": [
    {
      "name": "Health check returns comprehensive status",
      "input": "api.health_check()",
      "expected": "Response with status 200, body containing status='healthy', checks object, version, uptime",
      "explanation": "Health check must verify all dependencies and return structured status"
    },
    {
      "name": "Rate limiter allows requests under limit",
      "input": "5 calls to checkRateLimit('user1', '/bookings') within 1 minute",
      "expected": "All 5 return True",
      "explanation": "With limit of 10/minute, 5 requests should all be allowed"
    },
    {
      "name": "Rate limiter blocks at limit",
      "input": "11 rapid calls to checkRateLimit('user1', '/bookings')",
      "expected": "First 10 return True, 11th returns False",
      "explanation": "Sliding window should block once weighted count reaches limit"
    },
    {
      "name": "Metrics track error rate correctly",
      "input": "10 requests: 8 with status 200, 2 with status 400",
      "expected": "getMetrics() shows errorRate=20.0",
      "explanation": "Error rate = errors / total * 100 = 2/10 * 100 = 20%"
    },
    {
      "name": "Logging sanitizes sensitive data",
      "input": "Log message containing 'password=secret123'",
      "expected": "Logged message shows 'password=[REDACTED]'",
      "explanation": "Sensitive patterns must be detected and replaced before logging"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using fixed window rate limiting",
      "why_wrong": "Allows 2x burst at window boundaries - user can make 10 requests at 0:59 and 10 more at 1:01",
      "correct_approach": "Use sliding window that weights previous window's count",
      "code_example_wrong": "if curr_window_count >= limit: reject()",
      "code_example_correct": "weighted = prev_count * (1 - elapsed_fraction) + curr_count; if weighted >= limit: reject()"
    },
    {
      "mistake": "Unbounded metrics storage",
      "why_wrong": "ArrayList of all latencies will consume unlimited memory under high traffic",
      "correct_approach": "Use ring buffer with fixed capacity, oldest values overwritten",
      "code_example_wrong": "latencies.append(duration_ms)  # grows forever",
      "code_example_correct": "ring_buffer[index % capacity] = duration_ms  # bounded"
    },
    {
      "mistake": "Logging sensitive data",
      "why_wrong": "Passwords, tokens, credit cards in logs are security violations and compliance failures",
      "correct_approach": "Sanitize all log messages with regex patterns before writing",
      "code_example_wrong": "log.info(f'User login: {username}, password: {password}')",
      "code_example_correct": "log.info(f'User login: {username}, password: [REDACTED]')"
    },
    {
      "mistake": "Health check returns static OK",
      "why_wrong": "Doesn't actually verify dependencies - will return healthy even when database is down",
      "correct_approach": "Actively query each dependency and verify response",
      "code_example_wrong": "return {'status': 'healthy'}  # always",
      "code_example_correct": "db_status = try_query(); return {'status': 'healthy' if db_status else 'unhealthy'}"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining WHY production readiness matters: 'In production, we need to answer three questions: Is the system healthy? Is it being abused? What happened when things went wrong?' Then walk through each component and its purpose.",
    "what_to_mention": [
      "Three pillars of observability: metrics, logging, tracing",
      "Rate limiting protects both infrastructure AND fair usage",
      "Sliding window vs fixed window trade-offs",
      "GDPR/PCI compliance implications for logging",
      "SLOs and SLIs - what metrics matter for your SLA"
    ],
    "time_allocation": "5 min: explain production concerns and why they matter, 5 min: implement rate limiter with sliding window, 3 min: health check and metrics, 2 min: logging considerations",
    "if_stuck": [
      "Think about what happens at midnight when a fixed window resets",
      "Consider what you'd need to debug a production incident at 3am",
      "Ask: what would a dashboard show to indicate the system is healthy?"
    ]
  },
  "connection_to_next_part": "Part 4 completes the production-ready system. Future extensions could include: distributed rate limiting with Redis, distributed tracing with OpenTelemetry, circuit breaker patterns for external dependencies, or blue-green deployment strategies.",
  "generated_at": "2026-01-14T15:34:41.841215",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}