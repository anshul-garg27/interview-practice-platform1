{
  "problem_title": "Task Scheduling with Dependencies - Part 4: Dynamic Task Addition",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 focused on finding the critical path in a static task graph. Part 4 extends this to support **dynamic task addition** during execution. Instead of computing everything upfront, we must efficiently handle tasks being added at runtime while maintaining accurate completion time estimates. The key challenge is achieving O(p) complexity for additions rather than O(V+E) recomputation.",
    "new_requirements": [
      "Support initialize() to set up initial task graph",
      "Support addTask() to add new tasks with prerequisites at runtime",
      "Maintain accurate estimated completion time as tasks are added",
      "Return false for invalid additions (duplicates, cycles, missing prerequisites)",
      "O(p) time complexity for addTask where p = number of prerequisites"
    ],
    "new_constraints": [
      "Cannot recompute entire graph on each addition",
      "Must detect and reject cycle-creating additions",
      "Must validate all prerequisites exist before adding",
      "New tasks can only depend on existing tasks"
    ],
    "key_insight": "A newly added task can only affect future tasks (its dependents), not past tasks. Since the new task has no dependents when added, we don't need to propagate any changes - we simply compute the new task's completion time from its prerequisites' completion times (which are already known) and update the global maximum if needed."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551  BEFORE: Static Graph Computation                                   \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                     \u2551\n\u2551  Input Graph (known upfront):                                       \u2551\n\u2551                                                                     \u2551\n\u2551      1(5) \u2500\u2500\u2192 2(3)                                                  \u2551\n\u2551                                                                     \u2551\n\u2551  Full topological sort required to compute all completion times     \u2551\n\u2551                                                                     \u2551\n\u2551  completion[1] = 5                                                  \u2551\n\u2551  completion[2] = 5 + 3 = 8                                          \u2551\n\u2551  estimated_total = 8                                                \u2551\n\u2551                                                                     \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  AFTER: Dynamic Task Addition                                       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                     \u2551\n\u2551  addTask(3, 4, [1]) called at runtime:                              \u2551\n\u2551                                                                     \u2551\n\u2551      1(5) \u2500\u2500\u2192 2(3)                                                  \u2551\n\u2551        \u2502                                                            \u2551\n\u2551        \u2514\u2500\u2500\u2500\u2500\u2192 3(4) \u2190 NEW!                                           \u2551\n\u2551                                                                     \u2551\n\u2551  Only need to compute ONE completion time:                          \u2551\n\u2551  completion[3] = completion[1] + 4 = 5 + 4 = 9                      \u2551\n\u2551  estimated_total = max(8, 9) = 9                                    \u2551\n\u2551                                                                     \u2551\n\u2551  \u2713 O(p) where p=1 prerequisite, NOT O(V+E) recomputation           \u2551\n\u2551                                                                     \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    DYNAMIC ADDITION ALGORITHM FLOW                       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                          \u2551\n\u2551  addTask(taskId, duration, prerequisites[]):                             \u2551\n\u2551                                                                          \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n\u2551  \u2502 STEP 1: VALIDATION                                              \u2502     \u2551\n\u2551  \u2502                                                                 \u2502     \u2551\n\u2551  \u2502   taskId already exists? \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 return FALSE               \u2502     \u2551\n\u2551  \u2502              \u2502                                                  \u2502     \u2551\n\u2551  \u2502              \u25bc                                                  \u2502     \u2551\n\u2551  \u2502   taskId in prerequisites? \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 return FALSE (self-loop)  \u2502     \u2551\n\u2551  \u2502              \u2502                                                  \u2502     \u2551\n\u2551  \u2502              \u25bc                                                  \u2502     \u2551\n\u2551  \u2502   All prerequisites exist? \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 if not, return FALSE      \u2502     \u2551\n\u2551  \u2502              \u2502                                                  \u2502     \u2551\n\u2551  \u2502              \u25bc YES                                              \u2502     \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n\u2551                \u2502                                                         \u2551\n\u2551                \u25bc                                                         \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n\u2551  \u2502 STEP 2: COMPUTE COMPLETION TIME                                 \u2502     \u2551\n\u2551  \u2502                                                                 \u2502     \u2551\n\u2551  \u2502   prerequisites empty?                                          \u2502     \u2551\n\u2551  \u2502       YES \u2192 completion = duration                               \u2502     \u2551\n\u2551  \u2502       NO  \u2192 completion = MAX(prereq completions) + duration     \u2502     \u2551\n\u2551  \u2502                                                                 \u2502     \u2551\n\u2551  \u2502   Example: prerequisites = [1, 2]                               \u2502     \u2551\n\u2551  \u2502            completion[1] = 5, completion[2] = 8                 \u2502     \u2551\n\u2551  \u2502            new_completion = max(5, 8) + duration                \u2502     \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n\u2551                \u2502                                                         \u2551\n\u2551                \u25bc                                                         \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2551\n\u2551  \u2502 STEP 3: UPDATE STATE                                            \u2502     \u2551\n\u2551  \u2502                                                                 \u2502     \u2551\n\u2551  \u2502   task_ids.add(taskId)                                          \u2502     \u2551\n\u2551  \u2502   completion_times[taskId] = computed_completion                \u2502     \u2551\n\u2551  \u2502   estimated_total = max(estimated_total, computed_completion)   \u2502     \u2551\n\u2551  \u2502                                                                 \u2502     \u2551\n\u2551  \u2502   return TRUE                                                   \u2502     \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2551\n\u2551                                                                          \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  TIME ANALYSIS:                                                          \u2551\n\u2551                                                                          \u2551\n\u2551  \u2022 Validation: O(p) - check p prerequisites                              \u2551\n\u2551  \u2022 Max computation: O(p) - scan p completion times                       \u2551\n\u2551  \u2022 State update: O(p) - update p dependency links                        \u2551\n\u2551  \u2022 TOTAL: O(p) \u2713                                                         \u2551\n\u2551                                                                          \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (Full Recomputation)",
      "description": "On each addTask call, add the new task to the graph and rerun the full topological sort from Part 3 to recompute all completion times. This treats each addition as a new static scheduling problem.",
      "time_complexity": "O(V + E) per addTask call",
      "space_complexity": "O(V + E)",
      "why_not_optimal": "Violates the O(p) constraint. For a system with 10,000 tasks, adding a single task with 2 prerequisites would take O(10,000) instead of O(2). This doesn't scale for real-time systems where tasks are frequently added."
    },
    {
      "name": "Optimal Approach (Incremental Update)",
      "description": "Maintain completion times as persistent state. When adding a new task, observe that it cannot affect any existing task's completion time (since no existing task depends on it). Simply compute the new task's completion from stored prerequisite completion times and update the global maximum.",
      "time_complexity": "O(p) per addTask where p = prerequisites count",
      "space_complexity": "O(V) for storing completion times",
      "key_insight": "Information only flows forward in a DAG. A new node has no outgoing edges to existing nodes (only incoming edges from prerequisites), so it cannot change any previously computed values. We only need to compute one new value and check if it establishes a new maximum."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Incremental State Maintenance\n\nThe key insight is understanding **information flow in DAGs**:\n\n### Why Recomputation is Unnecessary\n\n1. **Completion times propagate forward**: A task's completion time depends only on its prerequisites, never on its dependents.\n\n2. **New tasks have no dependents**: When we add task X, no existing task Y can depend on X (Y was created before X existed).\n\n3. **Therefore**: Adding X cannot change any existing completion time. We only need to compute `completion[X]` from its prerequisites.\n\n### The Elegant Formula\n\n```\ncompletion[new_task] = max(completion[prereq] for prereq in prerequisites) + duration\nestimated_total = max(estimated_total, completion[new_task])\n```\n\n### Cycle Detection Simplification\n\nCycle detection becomes trivial for dynamic addition:\n- A cycle requires task A \u2192 ... \u2192 A\n- But new task A can only point to existing tasks\n- Existing tasks cannot point to A (A didn't exist when they were created)\n- **Only possible cycle**: A points to itself (self-loop)\n\n### Data Structure Design\n\n| Structure | Purpose | Access Pattern |\n|-----------|---------|----------------|\n| `task_ids: Set` | O(1) existence check | Check duplicates/prerequisites |\n| `completion_times: Dict` | O(1) lookup | Get prerequisite completion times |\n| `estimated_completion: int` | O(1) update | Track global maximum |\n| `dependencies: Dict[List]` | O(p) iteration | Store prerequisites |\n| `dependents: Dict[List]` | O(1) append | For future extensions |",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Integer> completionTimes",
        "purpose": "O(1) lookup of when each task completes - essential for fast prerequisite queries"
      },
      {
        "structure": "HashSet<Integer> taskIds",
        "purpose": "O(1) check for task existence - validates prerequisites and detects duplicates"
      },
      {
        "structure": "int estimatedCompletion",
        "purpose": "Cached global maximum - avoids O(V) scan on every query"
      },
      {
        "structure": "HashMap<Integer, List<Integer>> dependencies",
        "purpose": "Stores prerequisites for each task - needed for initialization"
      },
      {
        "structure": "HashMap<Integer, List<Integer>> dependents",
        "purpose": "Reverse adjacency list - useful for future extensions like task updates"
      }
    ],
    "algorithm_steps": [
      "Step 1: **Initialize** - Parse tasks and dependencies, run topological sort once to compute all initial completion times, cache the maximum as estimated_completion",
      "Step 2: **Validate Addition** - Check: (a) task_id not in task_ids, (b) task_id not in prerequisites, (c) all prerequisites in task_ids",
      "Step 3: **Compute New Completion** - If no prerequisites: completion = duration. Else: completion = max(completion_times[p] for p in prerequisites) + duration",
      "Step 4: **Update State** - Add to task_ids, store completion_time, update dependencies/dependents maps",
      "Step 5: **Update Global Max** - estimated_completion = max(estimated_completion, new_completion)",
      "Step 6: **Return Success** - Return true indicating valid addition"
    ]
  },
  "solution_python_lines": [
    "from collections import defaultdict, deque",
    "from typing import List, Dict, Set, Optional",
    "",
    "",
    "class DynamicTaskScheduler:",
    "    \"\"\"",
    "    A dynamic task scheduler supporting runtime task addition.",
    "    ",
    "    This scheduler maintains completion times for all tasks and allows",
    "    efficient O(p) addition of new tasks where p = number of prerequisites.",
    "    ",
    "    Key Insight: New tasks cannot affect existing completion times since",
    "    no existing task can depend on a task that didn't exist when it was created.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize empty scheduler state.\"\"\"",
    "        self.task_ids: Set[int] = set()",
    "        self.durations: Dict[int, int] = {}",
    "        self.completion_times: Dict[int, int] = {}",
    "        self.dependencies: Dict[int, List[int]] = defaultdict(list)  # task -> prerequisites",
    "        self.dependents: Dict[int, List[int]] = defaultdict(list)    # task -> dependent tasks",
    "        self.estimated_completion: int = 0",
    "    ",
    "    def initialize(self, task_list: List[List[int]], dependency_list: List[List[int]]) -> None:",
    "        \"\"\"",
    "        Initialize the scheduler with tasks and dependencies.",
    "        ",
    "        Args:",
    "            task_list: List of [task_id, duration] pairs",
    "            dependency_list: List of [task_a, task_b] where task_a must complete before task_b",
    "        ",
    "        Time Complexity: O(V + E) for initial topological sort",
    "        Space Complexity: O(V + E) for storing graph",
    "        \"\"\"",
    "        # Reset all state",
    "        self.task_ids = set()",
    "        self.durations = {}",
    "        self.completion_times = {}",
    "        self.dependencies = defaultdict(list)",
    "        self.dependents = defaultdict(list)",
    "        ",
    "        # Handle empty input",
    "        if not task_list:",
    "            self.estimated_completion = 0",
    "            return",
    "        ",
    "        # Parse tasks: [task_id, duration]",
    "        for task_id, duration in task_list:",
    "            self.task_ids.add(task_id)",
    "            self.durations[task_id] = duration",
    "        ",
    "        # Parse dependencies: [task_a, task_b] means a -> b (a before b)",
    "        for task_a, task_b in (dependency_list or []):",
    "            self.dependencies[task_b].append(task_a)  # b depends on a",
    "            self.dependents[task_a].append(task_b)    # a has dependent b",
    "        ",
    "        # Compute completion times via topological sort (Kahn's algorithm)",
    "        in_degree = {t: len(self.dependencies[t]) for t in self.task_ids}",
    "        ",
    "        # Start with tasks having no dependencies (sources)",
    "        queue = deque()",
    "        for t in self.task_ids:",
    "            if in_degree[t] == 0:",
    "                queue.append(t)",
    "                self.completion_times[t] = self.durations[t]  # Start at t=0",
    "        ",
    "        # Process tasks in topological order",
    "        while queue:",
    "            task = queue.popleft()",
    "            ",
    "            for dependent in self.dependents[task]:",
    "                in_degree[dependent] -= 1",
    "                ",
    "                if in_degree[dependent] == 0:",
    "                    # All prerequisites processed - compute completion time",
    "                    # Start time = max of all prerequisite completion times",
    "                    start_time = max(",
    "                        self.completion_times[prereq]",
    "                        for prereq in self.dependencies[dependent]",
    "                    )",
    "                    self.completion_times[dependent] = start_time + self.durations[dependent]",
    "                    queue.append(dependent)",
    "        ",
    "        # Cache the maximum completion time",
    "        self.estimated_completion = max(self.completion_times.values()) if self.completion_times else 0",
    "    ",
    "    def add_task(self, task_id: int, duration: int, prerequisites: List[int]) -> bool:",
    "        \"\"\"",
    "        Add a new task dynamically to the scheduler.",
    "        ",
    "        Args:",
    "            task_id: Unique identifier for the new task",
    "            duration: Time required to complete the task",
    "            prerequisites: List of task IDs that must complete before this task",
    "        ",
    "        Returns:",
    "            True if task added successfully",
    "            False if invalid (duplicate ID, self-loop, missing prerequisite)",
    "        ",
    "        Time Complexity: O(p) where p = len(prerequisites)",
    "        Space Complexity: O(p) for storing prerequisite list",
    "        \"\"\"",
    "        # VALIDATION PHASE",
    "        ",
    "        # Check 1: Duplicate task ID",
    "        if task_id in self.task_ids:",
    "            return False",
    "        ",
    "        # Check 2: Self-loop (task depends on itself)",
    "        if task_id in prerequisites:",
    "            return False",
    "        ",
    "        # Check 3: All prerequisites must exist",
    "        # This is O(p) - we check each prerequisite",
    "        for prereq in prerequisites:",
    "            if prereq not in self.task_ids:",
    "                return False",
    "        ",
    "        # COMPUTATION PHASE",
    "        ",
    "        # Calculate completion time based on prerequisites",
    "        if not prerequisites:",
    "            # No dependencies - can start immediately at t=0",
    "            completion_time = duration",
    "        else:",
    "            # Start after all prerequisites complete",
    "            # This is O(p) - scan all prerequisite completion times",
    "            max_prereq_completion = max(",
    "                self.completion_times[prereq]",
    "                for prereq in prerequisites",
    "            )",
    "            completion_time = max_prereq_completion + duration",
    "        ",
    "        # UPDATE PHASE",
    "        ",
    "        # Add to task registry",
    "        self.task_ids.add(task_id)",
    "        self.durations[task_id] = duration",
    "        self.completion_times[task_id] = completion_time",
    "        ",
    "        # Update dependency graph",
    "        self.dependencies[task_id] = list(prerequisites)",
    "        for prereq in prerequisites:",
    "            self.dependents[prereq].append(task_id)",
    "        ",
    "        # Update global maximum if this task finishes later",
    "        self.estimated_completion = max(self.estimated_completion, completion_time)",
    "        ",
    "        return True",
    "    ",
    "    def get_estimated_completion(self) -> int:",
    "        \"\"\"",
    "        Get the estimated time when all tasks will complete.",
    "        ",
    "        Returns:",
    "            The completion time of the critical path (longest chain)",
    "        ",
    "        Time Complexity: O(1) - cached value",
    "        \"\"\"",
    "        return self.estimated_completion",
    "    ",
    "    def get_task_completion_time(self, task_id: int) -> Optional[int]:",
    "        \"\"\"",
    "        Get completion time for a specific task.",
    "        ",
    "        Args:",
    "            task_id: The task to query",
    "        ",
    "        Returns:",
    "            Completion time or None if task doesn't exist",
    "        \"\"\"",
    "        return self.completion_times.get(task_id)",
    "    ",
    "    def get_all_completion_times(self) -> Dict[int, int]:",
    "        \"\"\"Return a copy of all task completion times.\"\"\"",
    "        return dict(self.completion_times)",
    "",
    "",
    "def run_operations(operations: List[str], arguments: List) -> List:",
    "    \"\"\"Execute a sequence of operations and return results.\"\"\"",
    "    scheduler = DynamicTaskScheduler()",
    "    results = []",
    "    ",
    "    for op, args in zip(operations, arguments):",
    "        if op == \"initialize\":",
    "            scheduler.initialize(args[0], args[1])",
    "            results.append(None)",
    "        elif op == \"addTask\":",
    "            result = scheduler.add_task(args[0], args[1], args[2])",
    "            results.append(result)",
    "        elif op == \"getEstimatedCompletion\":",
    "            results.append(scheduler.get_estimated_completion())",
    "        else:",
    "            results.append(None)",
    "    ",
    "    return results",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the DynamicTaskScheduler with examples.\"\"\"",
    "    ",
    "    print(\"=\"*70)",
    "    print(\"DYNAMIC TASK SCHEDULER - Part 4 Demo\")",
    "    print(\"=\"*70)",
    "    ",
    "    # ================================================================",
    "    # Example 1: Basic dynamic addition",
    "    # ================================================================",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\"Example 1: Basic Dynamic Task Addition\")",
    "    print(\"\u2500\"*70)",
    "    print(\"\\nInitial Graph:  1(5) \u2500\u2500\u2192 2(3)\")",
    "    print(\"After add:      1(5) \u2500\u2500\u2192 2(3)\")",
    "    print(\"                  \u2502\")",
    "    print(\"                  \u2514\u2500\u2500\u2192 3(4)\")",
    "    ",
    "    scheduler = DynamicTaskScheduler()",
    "    scheduler.initialize([[1, 5], [2, 3]], [[1, 2]])",
    "    ",
    "    print(f\"\\nAfter initialize:\")",
    "    print(f\"  Task 1 completes at t={scheduler.get_task_completion_time(1)}\")",
    "    print(f\"  Task 2 completes at t={scheduler.get_task_completion_time(2)}\")",
    "    print(f\"  Estimated total: {scheduler.get_estimated_completion()}\")",
    "    ",
    "    result = scheduler.add_task(3, 4, [1])",
    "    print(f\"\\naddTask(3, 4, [1]) returned: {result}\")",
    "    print(f\"  Task 3 completes at t={scheduler.get_task_completion_time(3)}\")",
    "    print(f\"  New estimated total: {scheduler.get_estimated_completion()}\")",
    "    ",
    "    # ================================================================",
    "    # Example 2: Building a chain dynamically",
    "    # ================================================================",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\"Example 2: Building a Chain Dynamically\")",
    "    print(\"\u2500\"*70)",
    "    print(\"\\nBuilding: 1(5) \u2500\u2500\u2192 2(3) \u2500\u2500\u2192 3(2)\")",
    "    ",
    "    scheduler = DynamicTaskScheduler()",
    "    scheduler.initialize([[1, 5]], [])",
    "    print(f\"\\nAfter initialize with task 1: {scheduler.get_estimated_completion()}\")",
    "    ",
    "    scheduler.add_task(2, 3, [1])",
    "    print(f\"After addTask(2, 3, [1]): {scheduler.get_estimated_completion()}\")",
    "    ",
    "    scheduler.add_task(3, 2, [2])",
    "    print(f\"After addTask(3, 2, [2]): {scheduler.get_estimated_completion()}\")",
    "    ",
    "    print(\"\\nFinal chain: 5 + 3 + 2 = 10 \u2713\")",
    "    ",
    "    # ================================================================",
    "    # Example 3: Multiple prerequisites (diamond pattern)",
    "    # ================================================================",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\"Example 3: Diamond Pattern\")",
    "    print(\"\u2500\"*70)",
    "    print(\"\\n     1(4)\")",
    "    print(\"    /    \\\\\")",
    "    print(\"  2(2)  3(3)\")",
    "    print(\"    \\\\    /\")",
    "    print(\"     4(1)  <-- added dynamically\")",
    "    ",
    "    scheduler = DynamicTaskScheduler()",
    "    scheduler.initialize(",
    "        [[1, 4], [2, 2], [3, 3]],",
    "        [[1, 2], [1, 3]]",
    "    )",
    "    ",
    "    print(f\"\\nAfter initialize:\")",
    "    print(f\"  Task 2 completes at: {scheduler.get_task_completion_time(2)} (4+2=6)\")",
    "    print(f\"  Task 3 completes at: {scheduler.get_task_completion_time(3)} (4+3=7)\")",
    "    print(f\"  Estimated total: {scheduler.get_estimated_completion()}\")",
    "    ",
    "    scheduler.add_task(4, 1, [2, 3])  # Depends on both 2 and 3",
    "    print(f\"\\nAfter addTask(4, 1, [2, 3]):\")",
    "    print(f\"  Task 4 completes at: {scheduler.get_task_completion_time(4)} (max(6,7)+1=8)\")",
    "    print(f\"  New estimated total: {scheduler.get_estimated_completion()}\")",
    "    ",
    "    # ================================================================",
    "    # Example 4: Error handling",
    "    # ================================================================",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\"Example 4: Error Handling\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    scheduler = DynamicTaskScheduler()",
    "    scheduler.initialize([[1, 5]], [])",
    "    ",
    "    print(\"\\nTesting invalid additions:\")",
    "    ",
    "    # Duplicate ID",
    "    result = scheduler.add_task(1, 3, [])",
    "    print(f\"  addTask(1, ...) - duplicate ID: {result}\")",
    "    ",
    "    # Missing prerequisite",
    "    result = scheduler.add_task(2, 3, [99])",
    "    print(f\"  addTask(2, 3, [99]) - missing prereq: {result}\")",
    "    ",
    "    # Self-loop",
    "    result = scheduler.add_task(3, 3, [3])",
    "    print(f\"  addTask(3, 3, [3]) - self-loop: {result}\")",
    "    ",
    "    # Valid addition",
    "    result = scheduler.add_task(2, 3, [1])",
    "    print(f\"  addTask(2, 3, [1]) - valid: {result}\")",
    "    ",
    "    # ================================================================",
    "    # Verify with operation sequences from problem examples",
    "    # ================================================================",
    "    print(\"\\n\" + \"\u2500\"*70)",
    "    print(\"Verification: Problem Examples\")",
    "    print(\"\u2500\"*70)",
    "    ",
    "    # Example 1 from problem",
    "    ops1 = [\"initialize\", \"getEstimatedCompletion\", \"addTask\", \"getEstimatedCompletion\"]",
    "    args1 = [[[[1, 5], [2, 3]], [[1, 2]]], [], [3, 4, [1]], []]",
    "    result1 = run_operations(ops1, args1)",
    "    expected1 = [None, 8, True, 9]",
    "    print(f\"\\nExample 1: {result1}\")",
    "    print(f\"Expected:  {expected1}\")",
    "    print(f\"Match: {result1 == expected1} \u2713\" if result1 == expected1 else f\"Match: {result1 == expected1} \u2717\")",
    "    ",
    "    # Example 2 from problem",
    "    ops2 = [\"initialize\", \"addTask\", \"addTask\"]",
    "    args2 = [[[[1, 5]], []], [2, 3, [1]], [3, 2, [2]]]",
    "    result2 = run_operations(ops2, args2)",
    "    expected2 = [None, True, True]",
    "    print(f\"\\nExample 2: {result2}\")",
    "    print(f\"Expected:  {expected2}\")",
    "    print(f\"Match: {result2 == expected2} \u2713\" if result2 == expected2 else f\"Match: {result2 == expected2} \u2717\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Dynamic Task Scheduler supporting runtime task addition.",
    " * ",
    " * Key insight: New tasks cannot affect existing completion times since",
    " * no existing task can depend on a task that didn't exist when created.",
    " * ",
    " * Time Complexity:",
    " *   - initialize: O(V + E) for initial topological sort",
    " *   - addTask: O(p) where p = number of prerequisites",
    " *   - getEstimatedCompletion: O(1)",
    " */",
    "public class DynamicTaskScheduler {",
    "    ",
    "    private Set<Integer> taskIds;",
    "    private Map<Integer, Integer> durations;",
    "    private Map<Integer, Integer> completionTimes;",
    "    private Map<Integer, List<Integer>> dependencies;  // task -> prerequisites",
    "    private Map<Integer, List<Integer>> dependents;    // task -> tasks depending on it",
    "    private int estimatedCompletion;",
    "    ",
    "    public DynamicTaskScheduler() {",
    "        this.taskIds = new HashSet<>();",
    "        this.durations = new HashMap<>();",
    "        this.completionTimes = new HashMap<>();",
    "        this.dependencies = new HashMap<>();",
    "        this.dependents = new HashMap<>();",
    "        this.estimatedCompletion = 0;",
    "    }",
    "    ",
    "    /**",
    "     * Initialize scheduler with tasks and dependencies.",
    "     * ",
    "     * @param taskList Array of [task_id, duration] pairs",
    "     * @param dependencyList Array of [task_a, task_b] where a must complete before b",
    "     */",
    "    public void initialize(int[][] taskList, int[][] dependencyList) {",
    "        // Reset all state",
    "        taskIds.clear();",
    "        durations.clear();",
    "        completionTimes.clear();",
    "        dependencies.clear();",
    "        dependents.clear();",
    "        ",
    "        if (taskList == null || taskList.length == 0) {",
    "            estimatedCompletion = 0;",
    "            return;",
    "        }",
    "        ",
    "        // Parse tasks",
    "        for (int[] task : taskList) {",
    "            int taskId = task[0];",
    "            int duration = task[1];",
    "            taskIds.add(taskId);",
    "            durations.put(taskId, duration);",
    "            dependencies.put(taskId, new ArrayList<>());",
    "            dependents.put(taskId, new ArrayList<>());",
    "        }",
    "        ",
    "        // Parse dependencies",
    "        if (dependencyList != null) {",
    "            for (int[] dep : dependencyList) {",
    "                int taskA = dep[0];",
    "                int taskB = dep[1];",
    "                dependencies.get(taskB).add(taskA);  // B depends on A",
    "                dependents.get(taskA).add(taskB);    // A has dependent B",
    "            }",
    "        }",
    "        ",
    "        // Compute completion times using topological sort",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        for (int t : taskIds) {",
    "            inDegree.put(t, dependencies.get(t).size());",
    "        }",
    "        ",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        for (int t : taskIds) {",
    "            if (inDegree.get(t) == 0) {",
    "                queue.offer(t);",
    "                completionTimes.put(t, durations.get(t));",
    "            }",
    "        }",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            ",
    "            for (int dependent : dependents.get(task)) {",
    "                inDegree.put(dependent, inDegree.get(dependent) - 1);",
    "                ",
    "                if (inDegree.get(dependent) == 0) {",
    "                    // All prerequisites done - compute completion time",
    "                    int maxPrereqTime = 0;",
    "                    for (int prereq : dependencies.get(dependent)) {",
    "                        maxPrereqTime = Math.max(maxPrereqTime, completionTimes.get(prereq));",
    "                    }",
    "                    completionTimes.put(dependent, maxPrereqTime + durations.get(dependent));",
    "                    queue.offer(dependent);",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Cache maximum completion time",
    "        estimatedCompletion = 0;",
    "        for (int time : completionTimes.values()) {",
    "            estimatedCompletion = Math.max(estimatedCompletion, time);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Add a new task dynamically.",
    "     * ",
    "     * @param taskId Unique identifier for the new task",
    "     * @param duration Time required to complete the task",
    "     * @param prerequisites Array of task IDs that must complete first",
    "     * @return true if added successfully, false if invalid",
    "     */",
    "    public boolean addTask(int taskId, int duration, int[] prerequisites) {",
    "        // Check for duplicate",
    "        if (taskIds.contains(taskId)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Check prerequisites",
    "        if (prerequisites != null) {",
    "            for (int prereq : prerequisites) {",
    "                // Self-loop check",
    "                if (prereq == taskId) {",
    "                    return false;",
    "                }",
    "                // Existence check",
    "                if (!taskIds.contains(prereq)) {",
    "                    return false;",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Calculate completion time",
    "        int completionTime;",
    "        if (prerequisites == null || prerequisites.length == 0) {",
    "            completionTime = duration;",
    "        } else {",
    "            int maxPrereqTime = 0;",
    "            for (int prereq : prerequisites) {",
    "                maxPrereqTime = Math.max(maxPrereqTime, completionTimes.get(prereq));",
    "            }",
    "            completionTime = maxPrereqTime + duration;",
    "        }",
    "        ",
    "        // Add to state",
    "        taskIds.add(taskId);",
    "        durations.put(taskId, duration);",
    "        completionTimes.put(taskId, completionTime);",
    "        ",
    "        // Update graph",
    "        List<Integer> prereqList = new ArrayList<>();",
    "        dependents.put(taskId, new ArrayList<>());",
    "        if (prerequisites != null) {",
    "            for (int prereq : prerequisites) {",
    "                prereqList.add(prereq);",
    "                dependents.get(prereq).add(taskId);",
    "            }",
    "        }",
    "        dependencies.put(taskId, prereqList);",
    "        ",
    "        // Update global maximum",
    "        estimatedCompletion = Math.max(estimatedCompletion, completionTime);",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Get estimated completion time for all tasks.",
    "     * @return Time when all tasks will complete",
    "     */",
    "    public int getEstimatedCompletion() {",
    "        return estimatedCompletion;",
    "    }",
    "    ",
    "    /**",
    "     * Get completion time for a specific task.",
    "     * @param taskId The task to query",
    "     * @return Completion time or -1 if task doesn't exist",
    "     */",
    "    public int getTaskCompletionTime(int taskId) {",
    "        return completionTimes.getOrDefault(taskId, -1);",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"DYNAMIC TASK SCHEDULER - Java Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Example 1",
    "        System.out.println(\"\\nExample 1: Basic Dynamic Addition\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        DynamicTaskScheduler scheduler = new DynamicTaskScheduler();",
    "        scheduler.initialize(",
    "            new int[][]{{1, 5}, {2, 3}},",
    "            new int[][]{{1, 2}}",
    "        );",
    "        ",
    "        System.out.println(\"After init: \" + scheduler.getEstimatedCompletion());",
    "        System.out.println(\"Expected: 8\");",
    "        ",
    "        boolean result = scheduler.addTask(3, 4, new int[]{1});",
    "        System.out.println(\"\\naddTask(3, 4, [1]): \" + result);",
    "        System.out.println(\"After add: \" + scheduler.getEstimatedCompletion());",
    "        System.out.println(\"Expected: 9\");",
    "        ",
    "        // Example 2",
    "        System.out.println(\"\\nExample 2: Building Chain\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        scheduler = new DynamicTaskScheduler();",
    "        scheduler.initialize(new int[][]{{1, 5}}, new int[][]{});",
    "        ",
    "        scheduler.addTask(2, 3, new int[]{1});",
    "        scheduler.addTask(3, 2, new int[]{2});",
    "        ",
    "        System.out.println(\"Final: \" + scheduler.getEstimatedCompletion());",
    "        System.out.println(\"Expected: 10 (5+3+2)\");",
    "        ",
    "        // Error handling",
    "        System.out.println(\"\\nExample 3: Error Handling\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        scheduler = new DynamicTaskScheduler();",
    "        scheduler.initialize(new int[][]{{1, 5}}, new int[][]{});",
    "        ",
    "        System.out.println(\"Duplicate: \" + scheduler.addTask(1, 3, new int[]{}));",
    "        System.out.println(\"Missing prereq: \" + scheduler.addTask(2, 3, new int[]{99}));",
    "        System.out.println(\"Self-loop: \" + scheduler.addTask(3, 3, new int[]{3}));",
    "        System.out.println(\"Valid: \" + scheduler.addTask(2, 3, new int[]{1}));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-13",
      "explanation": "**Imports and class documentation** - We use collections for data structures. The docstring explains the key insight: new tasks cannot affect existing completion times."
    },
    {
      "lines": "15-22",
      "explanation": "**State initialization** - Five main data structures: task_ids (existence check), durations, completion_times (the key cache), dependencies (prerequisites), and dependents (reverse edges). estimated_completion caches the global maximum."
    },
    {
      "lines": "24-75",
      "explanation": "**initialize()** - Runs once at setup. Parses tasks and dependencies, then performs topological sort (Kahn's algorithm) to compute all completion times. O(V+E) is acceptable here since we do this only once."
    },
    {
      "lines": "77-130",
      "explanation": "**add_task()** - The core of Part 4. Three phases: VALIDATION (check duplicate, self-loop, prerequisite existence), COMPUTATION (calculate completion from max prereq time + duration), UPDATE (add to all data structures and update global max)."
    },
    {
      "lines": "94-100",
      "explanation": "**Validation** - O(p) checks. Note that checking all prerequisites exist is necessary since we look up their completion times later."
    },
    {
      "lines": "104-114",
      "explanation": "**Completion time calculation** - The key formula: `max(completion_times[prereq]) + duration`. This is O(p) where p is the number of prerequisites."
    },
    {
      "lines": "132-141",
      "explanation": "**get_estimated_completion()** - O(1) return of cached value. No recomputation needed because we update the max on each addTask."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "initialize": {
          "complexity": "O(V + E)",
          "explanation": "Topological sort processes each vertex once and each edge once. This is acceptable as it runs only at startup."
        },
        "addTask": {
          "complexity": "O(p)",
          "explanation": "p = number of prerequisites. We validate p prerequisites (O(p)), find max completion time (O(p)), and update p dependency links (O(p)). Total: O(3p) = O(p)."
        },
        "getEstimatedCompletion": {
          "complexity": "O(1)",
          "explanation": "Returns cached value - no computation needed."
        }
      },
      "overall_change": "addTask is the critical operation. Naive O(V+E) recomputation would make 1000 additions cost O(1000 * (V+E)). With O(p), same additions cost O(sum of all prerequisites) which is typically much smaller."
    },
    "space": {
      "additional_space": "O(V + E)",
      "explanation": "We store: task_ids (O(V)), durations (O(V)), completion_times (O(V)), dependencies (O(E total edges), dependents (O(E)). The estimated_completion is O(1). Total: O(V + E)."
    }
  },
  "dry_run": {
    "example_input": "initialize([[1,5],[2,3]], [[1,2]]) then addTask(3, 4, [1])",
    "steps": [
      {
        "step": 1,
        "action": "Parse tasks",
        "state": "task_ids={1,2}, durations={1:5, 2:3}",
        "explanation": "Create initial task registry"
      },
      {
        "step": 2,
        "action": "Parse dependencies",
        "state": "dependencies={1:[], 2:[1]}, dependents={1:[2], 2:[]}",
        "explanation": "Task 2 depends on task 1"
      },
      {
        "step": 3,
        "action": "Compute in-degrees",
        "state": "in_degree={1:0, 2:1}",
        "explanation": "Task 1 has no prerequisites, task 2 has one"
      },
      {
        "step": 4,
        "action": "Start topo sort with sources",
        "state": "queue=[1], completion[1]=5",
        "explanation": "Task 1 can start immediately"
      },
      {
        "step": 5,
        "action": "Process task 1",
        "state": "in_degree[2]=0, completion[2]=5+3=8, queue=[2]",
        "explanation": "Task 2's prerequisite done, it completes at 8"
      },
      {
        "step": 6,
        "action": "Process task 2",
        "state": "No more dependents to process",
        "explanation": "Queue empties"
      },
      {
        "step": 7,
        "action": "Set estimated_completion",
        "state": "estimated_completion=max(5,8)=8",
        "explanation": "Initialize complete, critical path is 8"
      },
      {
        "step": 8,
        "action": "addTask(3, 4, [1]): Validate",
        "state": "3 not in task_ids \u2713, 3 not in [1] \u2713, 1 in task_ids \u2713",
        "explanation": "All validations pass"
      },
      {
        "step": 9,
        "action": "Compute completion",
        "state": "max(completion[1])=5, completion[3]=5+4=9",
        "explanation": "Task 3 starts after task 1 completes"
      },
      {
        "step": 10,
        "action": "Update state",
        "state": "task_ids={1,2,3}, completion_times[3]=9",
        "explanation": "Add task 3 to registry"
      },
      {
        "step": 11,
        "action": "Update global max",
        "state": "estimated_completion=max(8,9)=9",
        "explanation": "Task 3 creates new longest path"
      }
    ],
    "final_output": "[None, 8, True, 9] - matching expected output"
  },
  "edge_cases": [
    {
      "case": "Empty task list",
      "handling": "initialize sets estimated_completion=0, subsequent addTask with no prerequisites works correctly",
      "gotcha": "Don't forget to handle max() on empty collection"
    },
    {
      "case": "Task with no prerequisites",
      "handling": "completion_time = duration (starts at t=0)",
      "gotcha": "Check for empty prerequisites list before calling max()"
    },
    {
      "case": "Duplicate task ID",
      "handling": "Return False immediately",
      "gotcha": "Must check before any other validation to avoid modifying state"
    },
    {
      "case": "Self-loop (task depends on itself)",
      "handling": "Return False - check if task_id in prerequisites",
      "gotcha": "This is the only way to create a cycle with dynamic addition"
    },
    {
      "case": "Missing prerequisite",
      "handling": "Return False if any prereq not in task_ids",
      "gotcha": "Must validate ALL prerequisites before computing completion time"
    },
    {
      "case": "Multiple prerequisites",
      "handling": "Take max of all prerequisite completion times",
      "gotcha": "Don't accidentally use sum or first value"
    },
    {
      "case": "Adding independent task",
      "handling": "No prerequisites means starts at t=0, may not change estimated_completion",
      "gotcha": "Still need to update estimated_completion with max()"
    }
  ],
  "test_cases": [
    {
      "name": "Basic chain extension",
      "input": "initialize([[1,5]], []), addTask(2, 3, [1])",
      "expected": "estimated_completion = 8",
      "explanation": "Chain 1\u21922: 5 + 3 = 8"
    },
    {
      "name": "Parallel paths (new longer)",
      "input": "initialize([[1,5], [2,3]], [[1,2]]), addTask(3, 10, [1])",
      "expected": "estimated_completion = 15 (was 8)",
      "explanation": "New task creates longer path: 5 + 10 = 15 > 8"
    },
    {
      "name": "Parallel paths (existing longer)",
      "input": "initialize([[1,5], [2,10]], [[1,2]]), addTask(3, 2, [1])",
      "expected": "estimated_completion = 15 (unchanged)",
      "explanation": "New task path (5+2=7) shorter than existing (5+10=15)"
    },
    {
      "name": "Diamond pattern",
      "input": "initialize([[1,4], [2,2], [3,3]], [[1,2], [1,3]]), addTask(4, 1, [2,3])",
      "expected": "estimated_completion = 8",
      "explanation": "Task 4 waits for max(6,7)=7, completes at 8"
    },
    {
      "name": "Reject duplicate",
      "input": "initialize([[1,5]], []), addTask(1, 3, [])",
      "expected": "addTask returns False",
      "explanation": "Task 1 already exists"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Recomputing all completion times on addTask",
      "why_wrong": "Violates O(p) constraint - results in O(V+E) per addition",
      "correct_approach": "Only compute the new task's completion time from cached prerequisite values",
      "code_example_wrong": "def add_task(...):\n    # Add to graph\n    self.recompute_all_completion_times()  # O(V+E)!",
      "code_example_correct": "def add_task(...):\n    completion = max(self.completion_times[p] for p in prereqs) + duration  # O(p)"
    },
    {
      "mistake": "Not checking if prerequisites exist",
      "why_wrong": "KeyError when looking up completion_times for non-existent task",
      "correct_approach": "Validate all prerequisites exist before computing completion time",
      "code_example_wrong": "completion = max(self.completion_times[p] for p in prereqs)  # KeyError if p missing!",
      "code_example_correct": "for p in prereqs:\n    if p not in self.task_ids:\n        return False\ncompletion = max(self.completion_times[p] for p in prereqs)"
    },
    {
      "mistake": "Using sum instead of max for prerequisites",
      "why_wrong": "Prerequisites can run in parallel - we wait for the LAST one, not the sum",
      "correct_approach": "Use max() to find when all prerequisites are done",
      "code_example_wrong": "start_time = sum(self.completion_times[p] for p in prereqs)",
      "code_example_correct": "start_time = max(self.completion_times[p] for p in prereqs)"
    },
    {
      "mistake": "Forgetting to handle empty prerequisites",
      "why_wrong": "max() on empty sequence raises ValueError in Python",
      "correct_approach": "Check for empty prerequisites and use duration directly",
      "code_example_wrong": "completion = max(self.completion_times[p] for p in prereqs) + duration",
      "code_example_correct": "if not prereqs:\n    completion = duration\nelse:\n    completion = max(self.completion_times[p] for p in prereqs) + duration"
    },
    {
      "mistake": "Complex cycle detection for dynamic addition",
      "why_wrong": "Wastes time on DFS/BFS when simple check suffices",
      "correct_approach": "Only check for self-loop - other cycles impossible since new task has no existing dependents",
      "code_example_wrong": "# Full DFS to detect cycles\ndef detect_cycle(self, task_id, prereqs):\n    visited = set()\n    def dfs(node): ...  # O(V+E)!",
      "code_example_correct": "# Self-loop is the only possibility\nif task_id in prerequisites:\n    return False  # O(p)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining WHY incremental update works: 'A new task can only depend on existing tasks, so it cannot affect any existing completion time. This means I only need to compute the new task's completion and check if it creates a new maximum.' Then walk through the three phases: validate, compute, update.",
    "what_to_mention": [
      "Explicitly state the O(p) complexity and why it's better than O(V+E)",
      "Explain the cycle detection simplification - only self-loops are possible",
      "Mention that this design pattern (incremental state maintenance) is common in real systems",
      "Note that this is similar to how build systems like Bazel handle incremental builds"
    ],
    "time_allocation": "15-20 minutes discussion: 3 min understanding requirements, 5 min explaining the insight, 7 min walking through implementation, 3 min discussing edge cases",
    "if_stuck": [
      "Think about what information flows where in a DAG - can a new node affect existing nodes?",
      "What's the simplest case? A new task with no prerequisites - what's its completion time?",
      "If we know all prerequisite completion times, what's the formula for the new task?",
      "Consider: when adding node X, can any existing node depend on X?"
    ]
  },
  "connection_to_next_part": "Part 4 establishes incremental state maintenance. A natural Part 5 could involve **task updates or removals**: 'What if a task's duration changes or a task is cancelled?' This would require propagating changes forward to dependents - a more complex scenario where we'd need to track the dependency graph more carefully and potentially use techniques like lazy evaluation or change propagation.",
  "generated_at": "2026-01-14T15:17:51.709246",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}