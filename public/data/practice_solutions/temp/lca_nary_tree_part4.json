{
  "problem_title": "Lowest Common Ancestor in N-ary Tree - Part 4: Distance Between Nodes Using LCA",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 extends LCA functionality to calculate the **distance** (number of edges) between any two nodes. This requires combining LCA computation with depth calculations using the elegant formula: `distance(p, q) = depth(p) + depth(q) - 2 * depth(LCA(p,q))`. The challenge is to do this efficiently, especially for multiple queries.",
    "new_requirements": [
      "Implement getDepth() method to find depth of any node from root",
      "Implement distance() method using the LCA-based formula",
      "Handle the case where nodes might not exist in tree",
      "Optimize for multiple distance queries on same tree"
    ],
    "new_constraints": [
      "Must reuse existing LCA implementation from Part 1",
      "Single query should be O(n) time",
      "Multiple queries should be optimizable with preprocessing"
    ],
    "key_insight": "The distance formula transforms a path-finding problem into three independent depth computations. The LCA acts as the 'meeting point' - the total distance is simply how far each node is from this meeting point: (depth_p - depth_lca) + (depth_q - depth_lca)."
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3): We can find LCA with parent pointers\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n            1              \n         /  |  \\           LCA(5, 8) = 1 \u2713\n        2   3   4          But how far apart are 5 and 8?\n       /|       |          \n      5 6       8          \n\nAFTER (Part 4): We can calculate exact distances!\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n            1 (d=0)        \n         /  |  \\           distance(5, 8):\n        2   3   4 (d=1)      depth(5) = 2\n       /|       |            depth(8) = 2\n      5 6       8 (d=2)      depth(LCA=1) = 0\n                             \n                             dist = 2 + 2 - 2*0 = 4 edges\n                             Path: 5\u21922\u21921\u21924\u21928 \u2713\n```",
    "algorithm_flow": "```\nDISTANCE CALCULATION ALGORITHM FLOW:\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n   Input: distance(root, p=5, q=8)\n   \n   STEP 1: Find LCA(5, 8)\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502            1 \u2190 LCA found!               \u2502\n   \u2502         /  |  \\                         \u2502\n   \u2502        2   3   4                        \u2502\n   \u2502       /|       |                        \u2502\n   \u2502     [5] 6     [8]                       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \n   STEP 2: Calculate depth(5)\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   DFS: root(0) \u2192 2(1) \u2192 5(2)           \u2502\n   \u2502   depth(5) = 2                          \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \n   STEP 3: Calculate depth(8)\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   DFS: root(0) \u2192 4(1) \u2192 8(2)           \u2502\n   \u2502   depth(8) = 2                          \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \n   STEP 4: Calculate depth(LCA=1)\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   depth(1) = 0  (it's the root!)        \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \n   STEP 5: Apply Formula\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502   distance = 2 + 2 - 2*0 = 4            \u2502\n   \u2502                                         \u2502\n   \u2502   Verification: 5 \u2192 2 \u2192 1 \u2192 4 \u2192 8       \u2502\n   \u2502                 (1)  (2)  (3)  (4)      \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \n   Output: 4 edges\n```"
  },
  "approaches": [
    {
      "name": "Naive Path-Finding Approach",
      "description": "Find the actual path from p to q by first finding paths from root to both nodes, then finding where paths diverge. Count edges along the combined path.",
      "time_complexity": "O(n\u00b2)",
      "space_complexity": "O(n)",
      "why_not_optimal": "Requires storing full paths and comparing them. For each query, we traverse the tree multiple times and store path arrays. With the LCA formula, we can avoid path reconstruction entirely."
    },
    {
      "name": "Basic LCA Formula Approach",
      "description": "Use the mathematical formula: distance = depth(p) + depth(q) - 2*depth(LCA). This approach calls getDepth() separately for each node needed.",
      "time_complexity": "O(n) per query",
      "space_complexity": "O(h) recursion stack",
      "why_not_optimal": "While correct, it performs 4 DFS traversals per query (1 for LCA, 3 for depths). For multiple queries, this becomes expensive."
    },
    {
      "name": "Optimal: Precomputed Depths + LCA",
      "description": "Precompute all node depths in a single O(n) traversal and cache them. For each distance query, only the LCA computation requires tree traversal; depths are O(1) lookups.",
      "time_complexity": "O(n) preprocessing + O(n) per query",
      "space_complexity": "O(n) for depth cache",
      "key_insight": "Depths never change! Precompute once, use many times. Can further optimize LCA to O(log n) with Binary Lifting for truly optimal multiple-query performance."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Optimal Solution: LCA-Based Distance with Depth Caching\n\n### Core Insight\n\nThe **brilliance** of this approach lies in recognizing that distance calculation decomposes into **three independent** depth lookups plus one LCA computation:\n\n```\ndistance(p, q) = (depth_p - depth_lca) + (depth_q - depth_lca)\n              = depth_p + depth_q - 2 * depth_lca\n```\n\n### Why This Works Mathematically\n\n1. The path from `p` to `q` **must** pass through LCA(p, q)\n2. The distance from `p` to LCA is exactly `depth_p - depth_lca`\n3. The distance from `q` to LCA is exactly `depth_q - depth_lca`\n4. Total distance is the sum of these two segments\n\n### Implementation Strategy\n\n**For Single Queries:**\n- Compute LCA using DFS (O(n))\n- Compute each depth using DFS (O(n) each)\n- Apply formula\n- Total: O(n)\n\n**For Multiple Queries (Optimization):**\n- **Precompute all depths** in single O(n) traversal\n- Store in HashMap: `Node \u2192 depth`\n- Each depth lookup becomes O(1)\n- Only LCA needs tree traversal per query\n\n### Key Data Structures\n\n| Structure | Purpose | Complexity |\n|-----------|---------|------------|\n| `depth_cache: Dict[Node, int]` | O(1) depth lookups | O(n) space |\n| DFS recursion stack | LCA and depth computation | O(h) space |",
    "data_structures": [
      {
        "structure": "HashMap/Dict",
        "purpose": "Cache node depths for O(1) lookup in multiple queries"
      },
      {
        "structure": "DFS Recursion",
        "purpose": "Traverse tree for LCA and depth computation"
      },
      {
        "structure": "Node reference equality",
        "purpose": "Identify nodes without value ambiguity"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate inputs - check for null/None nodes",
      "Step 2: Handle edge case where p == q (distance is 0)",
      "Step 3: Find LCA(p, q) using recursive DFS from Part 1",
      "Step 4: Compute depth(p) using DFS from root",
      "Step 5: Compute depth(q) using DFS from root",
      "Step 6: Compute depth(LCA) using DFS from root",
      "Step 7: Apply formula: depth_p + depth_q - 2 * depth_lca",
      "Step 8: Return the computed distance"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Optional, Dict",
    "",
    "",
    "class Node:",
    "    \"\"\"N-ary tree node with value and list of children.\"\"\"",
    "    ",
    "    def __init__(self, val: int, children: List['Node'] = None):",
    "        self.val = val",
    "        self.children = children if children else []",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Node({self.val})\"",
    "",
    "",
    "class NaryTreeDistance:",
    "    \"\"\"",
    "    Complete solution for calculating distance between nodes",
    "    in an N-ary tree using LCA.",
    "    ",
    "    Supports both single queries and optimized multiple queries",
    "    with depth precomputation.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Cache for precomputed depths (optimization for multiple queries)",
    "        self._depth_cache: Dict[Node, int] = {}",
    "        self._node_map: Dict[int, Node] = {}  # val -> Node for easy lookup",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 1: Core LCA Implementation (from previous parts)",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def lca(self, root: Node, p: Node, q: Node) -> Optional[Node]:",
    "        \"\"\"",
    "        Find Lowest Common Ancestor of nodes p and q.",
    "        ",
    "        Args:",
    "            root: Root of the N-ary tree",
    "            p: First node to find ancestor of",
    "            q: Second node to find ancestor of",
    "            ",
    "        Returns:",
    "            The LCA node, or None if either p or q not in tree",
    "            ",
    "        Time Complexity: O(n) where n is number of nodes",
    "        Space Complexity: O(h) for recursion stack, h = tree height",
    "        \"\"\"",
    "        if root is None:",
    "            return None",
    "        ",
    "        # Base case: current node is one of our targets",
    "        if root == p or root == q:",
    "            return root",
    "        ",
    "        # Recursively search all children",
    "        found_nodes: List[Node] = []",
    "        for child in root.children:",
    "            result = self.lca(child, p, q)",
    "            if result is not None:",
    "                found_nodes.append(result)",
    "        ",
    "        # If p and q found in different subtrees, this node is LCA",
    "        if len(found_nodes) >= 2:",
    "            return root",
    "        ",
    "        # If found in exactly one subtree, propagate that result up",
    "        if len(found_nodes) == 1:",
    "            return found_nodes[0]",
    "        ",
    "        # Neither p nor q found in this subtree",
    "        return None",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 4: New Methods - Depth and Distance Calculation",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def get_depth(self, root: Node, target: Node) -> int:",
    "        \"\"\"",
    "        Find the depth of a target node in the tree.",
    "        Depth of root is 0.",
    "        ",
    "        Args:",
    "            root: Root of the tree (depth 0)",
    "            target: Node to find depth of",
    "            ",
    "        Returns:",
    "            Depth of target node, or -1 if not found",
    "            ",
    "        Time Complexity: O(n)",
    "        Space Complexity: O(h) for recursion stack",
    "        \"\"\"",
    "        if root is None or target is None:",
    "            return -1",
    "        ",
    "        # Check cache first (optimization for multiple queries)",
    "        if target in self._depth_cache:",
    "            return self._depth_cache[target]",
    "        ",
    "        def dfs(node: Node, depth: int) -> int:",
    "            \"\"\"DFS helper to find target node's depth.\"\"\"",
    "            if node is None:",
    "                return -1",
    "            ",
    "            # Found the target!",
    "            if node == target:",
    "                return depth",
    "            ",
    "            # Search in all children",
    "            for child in node.children:",
    "                result = dfs(child, depth + 1)",
    "                if result != -1:",
    "                    return result",
    "            ",
    "            return -1",
    "        ",
    "        return dfs(root, 0)",
    "    ",
    "    def distance(self, root: Node, p: Node, q: Node) -> int:",
    "        \"\"\"",
    "        Calculate the distance (number of edges) between nodes p and q.",
    "        ",
    "        Uses the formula:",
    "            distance(p, q) = depth(p) + depth(q) - 2 * depth(LCA(p, q))",
    "        ",
    "        Args:",
    "            root: Root of the tree",
    "            p: First node",
    "            q: Second node",
    "            ",
    "        Returns:",
    "            Number of edges between p and q, or -1 if invalid",
    "            ",
    "        Time Complexity: O(n) for single query",
    "        Space Complexity: O(h) for recursion",
    "        \"\"\"",
    "        # Edge case: null inputs",
    "        if root is None or p is None or q is None:",
    "            return -1",
    "        ",
    "        # Edge case: same node",
    "        if p == q:",
    "            return 0",
    "        ",
    "        # Step 1: Find LCA",
    "        lca_node = self.lca(root, p, q)",
    "        if lca_node is None:",
    "            return -1  # One or both nodes not in tree",
    "        ",
    "        # Step 2: Get all required depths",
    "        depth_p = self.get_depth(root, p)",
    "        depth_q = self.get_depth(root, q)",
    "        depth_lca = self.get_depth(root, lca_node)",
    "        ",
    "        # Validate all depths were found",
    "        if depth_p == -1 or depth_q == -1 or depth_lca == -1:",
    "            return -1",
    "        ",
    "        # Step 3: Apply the magic formula!",
    "        return depth_p + depth_q - 2 * depth_lca",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # OPTIMIZATION: Precomputation for Multiple Queries",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def precompute_depths(self, root: Node) -> Dict[Node, int]:",
    "        \"\"\"",
    "        Precompute depths of ALL nodes in a single O(n) traversal.",
    "        Call this once before making multiple distance queries.",
    "        ",
    "        Args:",
    "            root: Root of the tree",
    "            ",
    "        Returns:",
    "            Dictionary mapping each node to its depth",
    "            ",
    "        Time Complexity: O(n) - visits each node exactly once",
    "        Space Complexity: O(n) for the cache",
    "        \"\"\"",
    "        self._depth_cache.clear()",
    "        self._node_map.clear()",
    "        ",
    "        def dfs(node: Node, depth: int) -> None:",
    "            if node is None:",
    "                return",
    "            ",
    "            self._depth_cache[node] = depth",
    "            self._node_map[node.val] = node",
    "            ",
    "            for child in node.children:",
    "                dfs(child, depth + 1)",
    "        ",
    "        dfs(root, 0)",
    "        return self._depth_cache",
    "    ",
    "    def distance_optimized(self, root: Node, p: Node, q: Node) -> int:",
    "        \"\"\"",
    "        Distance calculation using precomputed depths.",
    "        ",
    "        IMPORTANT: Call precompute_depths() first!",
    "        ",
    "        Time Complexity: O(n) for LCA + O(1) for depth lookups",
    "        \"\"\"",
    "        if p == q:",
    "            return 0",
    "        ",
    "        # LCA still requires traversal",
    "        lca_node = self.lca(root, p, q)",
    "        if lca_node is None:",
    "            return -1",
    "        ",
    "        # Depths are O(1) lookups from cache!",
    "        depth_p = self._depth_cache.get(p, -1)",
    "        depth_q = self._depth_cache.get(q, -1)",
    "        depth_lca = self._depth_cache.get(lca_node, -1)",
    "        ",
    "        if -1 in (depth_p, depth_q, depth_lca):",
    "            return -1",
    "        ",
    "        return depth_p + depth_q - 2 * depth_lca",
    "    ",
    "    def get_node_by_value(self, val: int) -> Optional[Node]:",
    "        \"\"\"Get node reference by value (after precomputation).\"\"\"",
    "        return self._node_map.get(val)",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DEMONSTRATION AND TESTING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "def build_sample_tree() -> tuple:",
    "    \"\"\"",
    "    Build the sample tree from problem description:",
    "    ",
    "            1",
    "         /  |  \\",
    "        2   3   4",
    "       /|       |",
    "      5 6       8",
    "    \"\"\"",
    "    node5 = Node(5)",
    "    node6 = Node(6)",
    "    node8 = Node(8)",
    "    node3 = Node(3)",
    "    node2 = Node(2, [node5, node6])",
    "    node4 = Node(4, [node8])",
    "    node1 = Node(1, [node2, node3, node4])",
    "    ",
    "    return node1, node2, node3, node4, node5, node6, node8",
    "",
    "",
    "def main():",
    "    print(\"\u2550\" * 60)",
    "    print(\"  Part 4: Distance Between Nodes Using LCA\")",
    "    print(\"\u2550\" * 60)",
    "    print()",
    "    ",
    "    # Build tree",
    "    root, n2, n3, n4, n5, n6, n8 = build_sample_tree()",
    "    solution = NaryTreeDistance()",
    "    ",
    "    print(\"Tree Structure:\")",
    "    print(\"        1\")",
    "    print(\"     /  |  \\\\\")",
    "    print(\"    2   3   4\")",
    "    print(\"   /|       |\")",
    "    print(\"  5 6       8\")",
    "    print()",
    "    ",
    "    # Test Example 1: distance(5, 8)",
    "    print(\"\u2500\" * 40)",
    "    print(\"Example 1: distance(5, 8)\")",
    "    print(\"\u2500\" * 40)",
    "    ",
    "    dist = solution.distance(root, n5, n8)",
    "    print(f\"  depth(5) = {solution.get_depth(root, n5)}\")",
    "    print(f\"  depth(8) = {solution.get_depth(root, n8)}\")",
    "    lca_node = solution.lca(root, n5, n8)",
    "    print(f\"  LCA(5, 8) = {lca_node.val}\")",
    "    print(f\"  depth(LCA) = {solution.get_depth(root, lca_node)}\")",
    "    print(f\"  Formula: 2 + 2 - 2*0 = 4\")",
    "    print(f\"  Distance: {dist}\")",
    "    print(f\"  Path: 5 \u2192 2 \u2192 1 \u2192 4 \u2192 8 \u2713\")",
    "    print()",
    "    ",
    "    # Test Example 2: distance(5, 6)",
    "    print(\"\u2500\" * 40)",
    "    print(\"Example 2: distance(5, 6)\")",
    "    print(\"\u2500\" * 40)",
    "    ",
    "    dist = solution.distance(root, n5, n6)",
    "    lca_node = solution.lca(root, n5, n6)",
    "    print(f\"  depth(5) = {solution.get_depth(root, n5)}\")",
    "    print(f\"  depth(6) = {solution.get_depth(root, n6)}\")",
    "    print(f\"  LCA(5, 6) = {lca_node.val}\")",
    "    print(f\"  depth(LCA) = {solution.get_depth(root, lca_node)}\")",
    "    print(f\"  Formula: 2 + 2 - 2*1 = 2\")",
    "    print(f\"  Distance: {dist}\")",
    "    print(f\"  Path: 5 \u2192 2 \u2192 6 \u2713\")",
    "    print()",
    "    ",
    "    # Test Optimized Version (Multiple Queries)",
    "    print(\"\u2500\" * 40)",
    "    print(\"Optimized Version (Precomputed Depths)\")",
    "    print(\"\u2500\" * 40)",
    "    ",
    "    depths = solution.precompute_depths(root)",
    "    print(\"  Precomputed depths:\")",
    "    for node, depth in sorted(depths.items(), key=lambda x: x[0].val):",
    "        print(f\"    Node {node.val}: depth = {depth}\")",
    "    print()",
    "    ",
    "    # Multiple queries with O(1) depth lookups",
    "    queries = [(n5, n8), (n5, n6), (n2, n4), (n3, n8)]",
    "    print(\"  Running multiple queries:\")",
    "    for p, q in queries:",
    "        dist = solution.distance_optimized(root, p, q)",
    "        print(f\"    distance({p.val}, {q.val}) = {dist}\")",
    "    print()",
    "    ",
    "    # Edge Cases",
    "    print(\"\u2500\" * 40)",
    "    print(\"Edge Cases\")",
    "    print(\"\u2500\" * 40)",
    "    print(f\"  distance(5, 5) = {solution.distance(root, n5, n5)} (same node)\")",
    "    print(f\"  distance(1, 8) = {solution.distance(root, root, n8)} (root to leaf)\")",
    "    print()",
    "    ",
    "    print(\"\u2550\" * 60)",
    "    print(\"  All tests passed! \u2713\")",
    "    print(\"\u2550\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * N-ary Tree Node",
    " */",
    "class Node {",
    "    int val;",
    "    List<Node> children;",
    "    ",
    "    Node(int val) {",
    "        this.val = val;",
    "        this.children = new ArrayList<>();",
    "    }",
    "    ",
    "    Node(int val, List<Node> children) {",
    "        this.val = val;",
    "        this.children = children != null ? children : new ArrayList<>();",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return \"Node(\" + val + \")\";",
    "    }",
    "}",
    "",
    "/**",
    " * Complete solution for calculating distance between nodes",
    " * in an N-ary tree using LCA.",
    " */",
    "public class NaryTreeDistance {",
    "    ",
    "    // Cache for precomputed depths (optimization for multiple queries)",
    "    private Map<Node, Integer> depthCache;",
    "    private Map<Integer, Node> nodeMap;",
    "    ",
    "    public NaryTreeDistance() {",
    "        this.depthCache = new HashMap<>();",
    "        this.nodeMap = new HashMap<>();",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 1: Core LCA Implementation (from previous parts)",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Find Lowest Common Ancestor of nodes p and q.",
    "     * ",
    "     * @param root Root of the N-ary tree",
    "     * @param p First node",
    "     * @param q Second node",
    "     * @return The LCA node, or null if not found",
    "     */",
    "    public Node lca(Node root, Node p, Node q) {",
    "        if (root == null) {",
    "            return null;",
    "        }",
    "        ",
    "        // Base case: current node is one of our targets",
    "        if (root == p || root == q) {",
    "            return root;",
    "        }",
    "        ",
    "        // Recursively search all children",
    "        List<Node> foundNodes = new ArrayList<>();",
    "        for (Node child : root.children) {",
    "            Node result = lca(child, p, q);",
    "            if (result != null) {",
    "                foundNodes.add(result);",
    "            }",
    "        }",
    "        ",
    "        // If p and q found in different subtrees, this is LCA",
    "        if (foundNodes.size() >= 2) {",
    "            return root;",
    "        }",
    "        ",
    "        // If found in exactly one subtree, propagate up",
    "        if (foundNodes.size() == 1) {",
    "            return foundNodes.get(0);",
    "        }",
    "        ",
    "        // Neither p nor q found",
    "        return null;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 4: New Methods - Depth and Distance Calculation",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Find the depth of a target node in the tree.",
    "     * ",
    "     * @param root Root of the tree (depth 0)",
    "     * @param target Node to find depth of",
    "     * @return Depth of target, or -1 if not found",
    "     */",
    "    public int getDepth(Node root, Node target) {",
    "        if (root == null || target == null) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Check cache first",
    "        if (depthCache.containsKey(target)) {",
    "            return depthCache.get(target);",
    "        }",
    "        ",
    "        return dfsDepth(root, target, 0);",
    "    }",
    "    ",
    "    private int dfsDepth(Node node, Node target, int depth) {",
    "        if (node == null) {",
    "            return -1;",
    "        }",
    "        ",
    "        if (node == target) {",
    "            return depth;",
    "        }",
    "        ",
    "        for (Node child : node.children) {",
    "            int result = dfsDepth(child, target, depth + 1);",
    "            if (result != -1) {",
    "                return result;",
    "            }",
    "        }",
    "        ",
    "        return -1;",
    "    }",
    "    ",
    "    /**",
    "     * Calculate distance (number of edges) between nodes p and q.",
    "     * ",
    "     * Formula: distance(p, q) = depth(p) + depth(q) - 2 * depth(LCA)",
    "     * ",
    "     * @param root Root of the tree",
    "     * @param p First node",
    "     * @param q Second node",
    "     * @return Number of edges between p and q, or -1 if invalid",
    "     */",
    "    public int distance(Node root, Node p, Node q) {",
    "        // Edge cases",
    "        if (root == null || p == null || q == null) {",
    "            return -1;",
    "        }",
    "        ",
    "        if (p == q) {",
    "            return 0;",
    "        }",
    "        ",
    "        // Step 1: Find LCA",
    "        Node lcaNode = lca(root, p, q);",
    "        if (lcaNode == null) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Step 2: Get depths",
    "        int depthP = getDepth(root, p);",
    "        int depthQ = getDepth(root, q);",
    "        int depthLCA = getDepth(root, lcaNode);",
    "        ",
    "        if (depthP == -1 || depthQ == -1 || depthLCA == -1) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Step 3: Apply formula",
    "        return depthP + depthQ - 2 * depthLCA;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // OPTIMIZATION: Precomputation for Multiple Queries",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Precompute depths of ALL nodes in O(n) time.",
    "     */",
    "    public Map<Node, Integer> precomputeDepths(Node root) {",
    "        depthCache.clear();",
    "        nodeMap.clear();",
    "        precomputeDFS(root, 0);",
    "        return depthCache;",
    "    }",
    "    ",
    "    private void precomputeDFS(Node node, int depth) {",
    "        if (node == null) return;",
    "        ",
    "        depthCache.put(node, depth);",
    "        nodeMap.put(node.val, node);",
    "        ",
    "        for (Node child : node.children) {",
    "            precomputeDFS(child, depth + 1);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Distance calculation using precomputed depths.",
    "     */",
    "    public int distanceOptimized(Node root, Node p, Node q) {",
    "        if (p == q) return 0;",
    "        ",
    "        Node lcaNode = lca(root, p, q);",
    "        if (lcaNode == null) return -1;",
    "        ",
    "        Integer depthP = depthCache.get(p);",
    "        Integer depthQ = depthCache.get(q);",
    "        Integer depthLCA = depthCache.get(lcaNode);",
    "        ",
    "        if (depthP == null || depthQ == null || depthLCA == null) {",
    "            return -1;",
    "        }",
    "        ",
    "        return depthP + depthQ - 2 * depthLCA;",
    "    }",
    "    ",
    "    public Node getNodeByValue(int val) {",
    "        return nodeMap.get(val);",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // MAIN - Demonstration",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\u2550\".repeat(60));",
    "        System.out.println(\"  Part 4: Distance Between Nodes Using LCA\");",
    "        System.out.println(\"\u2550\".repeat(60));",
    "        System.out.println();",
    "        ",
    "        // Build sample tree",
    "        Node node5 = new Node(5);",
    "        Node node6 = new Node(6);",
    "        Node node8 = new Node(8);",
    "        Node node3 = new Node(3);",
    "        Node node2 = new Node(2, Arrays.asList(node5, node6));",
    "        Node node4 = new Node(4, Arrays.asList(node8));",
    "        Node root = new Node(1, Arrays.asList(node2, node3, node4));",
    "        ",
    "        NaryTreeDistance solution = new NaryTreeDistance();",
    "        ",
    "        System.out.println(\"Tree Structure:\");",
    "        System.out.println(\"        1\");",
    "        System.out.println(\"     /  |  \\\\\");",
    "        System.out.println(\"    2   3   4\");",
    "        System.out.println(\"   /|       |\");",
    "        System.out.println(\"  5 6       8\");",
    "        System.out.println();",
    "        ",
    "        // Test Example 1",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        System.out.println(\"Example 1: distance(5, 8)\");",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        ",
    "        int dist = solution.distance(root, node5, node8);",
    "        System.out.println(\"  depth(5) = \" + solution.getDepth(root, node5));",
    "        System.out.println(\"  depth(8) = \" + solution.getDepth(root, node8));",
    "        Node lcaNode = solution.lca(root, node5, node8);",
    "        System.out.println(\"  LCA(5, 8) = \" + lcaNode.val);",
    "        System.out.println(\"  Distance: \" + dist);",
    "        System.out.println(\"  Path: 5 \u2192 2 \u2192 1 \u2192 4 \u2192 8 \u2713\");",
    "        System.out.println();",
    "        ",
    "        // Test Example 2",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        System.out.println(\"Example 2: distance(5, 6)\");",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        ",
    "        dist = solution.distance(root, node5, node6);",
    "        System.out.println(\"  Distance: \" + dist);",
    "        System.out.println(\"  Path: 5 \u2192 2 \u2192 6 \u2713\");",
    "        System.out.println();",
    "        ",
    "        // Optimized version",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        System.out.println(\"Optimized (Precomputed Depths)\");",
    "        System.out.println(\"\u2500\".repeat(40));",
    "        ",
    "        solution.precomputeDepths(root);",
    "        System.out.println(\"  distance(5, 8) = \" + solution.distanceOptimized(root, node5, node8));",
    "        System.out.println(\"  distance(5, 6) = \" + solution.distanceOptimized(root, node5, node6));",
    "        System.out.println(\"  distance(2, 4) = \" + solution.distanceOptimized(root, node2, node4));",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"\u2550\".repeat(60));",
    "        System.out.println(\"  All tests passed! \u2713\");",
    "        System.out.println(\"\u2550\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-12",
      "explanation": "**Imports and Node class**: Define the N-ary tree node structure with value and children list. The Node class is reusable from previous parts."
    },
    {
      "lines": "14-26",
      "explanation": "**Class setup with caching**: Initialize depth cache (HashMap) for O(1) depth lookups after preprocessing. This is the key optimization for multiple queries."
    },
    {
      "lines": "31-65",
      "explanation": "**LCA implementation (from Part 1)**: The core LCA algorithm using post-order DFS. If both p and q are found in different subtrees, the current node is LCA."
    },
    {
      "lines": "71-100",
      "explanation": "**getDepth method**: DFS-based depth finder. First checks cache for O(1) lookup, then falls back to O(n) traversal if not cached."
    },
    {
      "lines": "102-136",
      "explanation": "**distance method**: The main method implementing the formula. Handles edge cases (null, same node), finds LCA, computes depths, applies formula."
    },
    {
      "lines": "142-165",
      "explanation": "**precomputeDepths method**: Single O(n) traversal to cache ALL depths. Essential for multiple-query optimization."
    },
    {
      "lines": "167-186",
      "explanation": "**distanceOptimized method**: Uses cached depths for O(1) lookups. Only LCA computation requires tree traversal."
    },
    {
      "lines": "190-250",
      "explanation": "**Demo main function**: Comprehensive test cases showing both basic and optimized distance calculations with visual output."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "getDepth": {
          "complexity": "O(n)",
          "explanation": "DFS traversal to find target node's depth. In worst case, visits all n nodes."
        },
        "distance": {
          "complexity": "O(n)",
          "explanation": "Calls LCA once (O(n)) and getDepth three times (O(3n) = O(n)). Total: O(n)."
        },
        "precomputeDepths": {
          "complexity": "O(n)",
          "explanation": "Single DFS visiting each node exactly once."
        },
        "distanceOptimized": {
          "complexity": "O(n) + O(1)",
          "explanation": "LCA is O(n), but depth lookups are O(1) from cache."
        }
      },
      "overall_change": "Single query: O(n). Multiple queries with preprocessing: O(n) once + O(n) per query for LCA (can be further optimized to O(log n) with Binary Lifting)."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "Depth cache stores one integer per node. Additional O(h) for recursion stack where h is tree height. Total: O(n + h) = O(n)."
    }
  },
  "dry_run": {
    "example_input": "distance(root, node5, node8) on tree: 1->[2->[5,6], 3, 4->[8]]",
    "steps": [
      {
        "step": 1,
        "action": "Check edge cases",
        "state": "p=node5, q=node8, both non-null, p\u2260q",
        "explanation": "No early return, proceed with calculation"
      },
      {
        "step": 2,
        "action": "Call lca(root, node5, node8)",
        "state": "DFS traversal begins",
        "explanation": "Recursively search tree for both nodes"
      },
      {
        "step": 3,
        "action": "LCA DFS at node 1",
        "state": "Check children: [2, 3, 4]",
        "explanation": "Root is not p or q, search children"
      },
      {
        "step": 4,
        "action": "LCA DFS at node 2",
        "state": "Check children: [5, 6]",
        "explanation": "Node 2 is not p or q, continue"
      },
      {
        "step": 5,
        "action": "LCA DFS at node 5",
        "state": "node5 == p, return node5",
        "explanation": "Found p! Return it upward"
      },
      {
        "step": 6,
        "action": "LCA DFS at node 6",
        "state": "node6 \u2260 p, \u2260 q, return null",
        "explanation": "Node 6 is neither target"
      },
      {
        "step": 7,
        "action": "Back at node 2",
        "state": "foundNodes = [node5]",
        "explanation": "Only one match, propagate up"
      },
      {
        "step": 8,
        "action": "LCA DFS at node 4",
        "state": "Check child: [8]",
        "explanation": "Continue searching"
      },
      {
        "step": 9,
        "action": "LCA DFS at node 8",
        "state": "node8 == q, return node8",
        "explanation": "Found q! Return it upward"
      },
      {
        "step": 10,
        "action": "Back at node 1",
        "state": "foundNodes = [node5, node8]",
        "explanation": "Two matches from different subtrees!"
      },
      {
        "step": 11,
        "action": "LCA result",
        "state": "Return node1 as LCA",
        "explanation": "len(foundNodes) >= 2, so node1 is LCA"
      },
      {
        "step": 12,
        "action": "Call getDepth(root, node5)",
        "state": "DFS: 1(0)->2(1)->5(2)",
        "explanation": "depth(5) = 2"
      },
      {
        "step": 13,
        "action": "Call getDepth(root, node8)",
        "state": "DFS: 1(0)->4(1)->8(2)",
        "explanation": "depth(8) = 2"
      },
      {
        "step": 14,
        "action": "Call getDepth(root, node1)",
        "state": "Root found at depth 0",
        "explanation": "depth(LCA=1) = 0"
      },
      {
        "step": 15,
        "action": "Apply formula",
        "state": "2 + 2 - 2*0 = 4",
        "explanation": "distance = depth_p + depth_q - 2*depth_lca"
      }
    ],
    "final_output": "4 (edges: 5\u21922\u21921\u21924\u21928)"
  },
  "edge_cases": [
    {
      "case": "Same node (p == q)",
      "handling": "Return 0 immediately",
      "gotcha": "Don't forget this optimization - avoids unnecessary LCA computation"
    },
    {
      "case": "One node is root",
      "handling": "Works correctly - LCA will be root, depth_lca = 0",
      "gotcha": "Formula still applies: distance = depth(other_node)"
    },
    {
      "case": "One node is ancestor of other",
      "handling": "LCA is the ancestor node",
      "gotcha": "A node IS its own descendant per problem definition"
    },
    {
      "case": "Nodes in same subtree",
      "handling": "LCA is their common ancestor within that subtree",
      "gotcha": "Don't assume LCA is always the root"
    },
    {
      "case": "Null inputs",
      "handling": "Return -1 for invalid input",
      "gotcha": "Check all three inputs (root, p, q) for null"
    },
    {
      "case": "Node not in tree",
      "handling": "LCA returns null, distance returns -1",
      "gotcha": "Validate that depths were actually found before applying formula"
    }
  ],
  "test_cases": [
    {
      "name": "Basic distance - different subtrees",
      "input": "tree=[1,[2,[5],[6]],[3],[4,[8]]], p=5, q=8",
      "expected": "4",
      "explanation": "Path crosses root: 5\u21922\u21921\u21924\u21928 = 4 edges"
    },
    {
      "name": "Siblings - same parent",
      "input": "tree=[1,[2,[5],[6]],[3],[4,[8]]], p=5, q=6",
      "expected": "2",
      "explanation": "Siblings share immediate parent: 5\u21922\u21926 = 2 edges"
    },
    {
      "name": "Same node",
      "input": "tree=[1,[2,[5],[6]],[3],[4,[8]]], p=5, q=5",
      "expected": "0",
      "explanation": "Distance to self is always 0"
    },
    {
      "name": "Root to leaf",
      "input": "tree=[1,[2,[5],[6]],[3],[4,[8]]], p=1, q=8",
      "expected": "2",
      "explanation": "Direct path: 1\u21924\u21928 = 2 edges"
    },
    {
      "name": "Ancestor to descendant",
      "input": "tree=[1,[2,[5],[6]],[3],[4,[8]]], p=2, q=5",
      "expected": "1",
      "explanation": "Parent to child: 2\u21925 = 1 edge"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Forgetting to handle p == q case",
      "why_wrong": "Calling LCA on same node works but wastes computation. More importantly, some LCA implementations might behave unexpectedly.",
      "correct_approach": "Check if p == q first and return 0 immediately",
      "code_example_wrong": "def distance(root, p, q):\n    lca = find_lca(root, p, q)  # Wasteful\n    ...",
      "code_example_correct": "def distance(root, p, q):\n    if p == q:\n        return 0\n    lca = find_lca(root, p, q)"
    },
    {
      "mistake": "Computing depths multiple times for same node",
      "why_wrong": "In multiple queries, recalculating depths is O(n) each time. With k queries, this becomes O(kn) instead of O(n + k).",
      "correct_approach": "Precompute all depths once, then use O(1) lookups",
      "code_example_wrong": "for p, q in queries:\n    d1 = get_depth(root, p)  # O(n) each time\n    d2 = get_depth(root, q)",
      "code_example_correct": "depths = precompute_depths(root)  # O(n) once\nfor p, q in queries:\n    d1 = depths[p]  # O(1)\n    d2 = depths[q]"
    },
    {
      "mistake": "Incorrect formula application",
      "why_wrong": "Some candidates write depth(p) - depth(q) or forget to multiply depth_lca by 2",
      "correct_approach": "The formula is: depth_p + depth_q - 2 * depth_lca",
      "code_example_wrong": "return depth_p - depth_q - depth_lca  # Wrong!",
      "code_example_correct": "return depth_p + depth_q - 2 * depth_lca  # Correct!"
    },
    {
      "mistake": "Not validating that nodes exist in tree",
      "why_wrong": "If LCA returns null or depth returns -1, applying the formula gives incorrect results",
      "correct_approach": "Always validate LCA and depth results before computation",
      "code_example_wrong": "lca = find_lca(root, p, q)\nreturn get_depth(p) + get_depth(q) - 2 * get_depth(lca)",
      "code_example_correct": "lca = find_lca(root, p, q)\nif lca is None:\n    return -1\n# ... validate depths too"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the mathematical insight: 'The distance between any two nodes equals the sum of their distances to their LCA.' Draw the formula visually showing how depth_p - depth_lca and depth_q - depth_lca combine. Then discuss the implementation strategy before coding.",
    "what_to_mention": [
      "Explicitly state you're reusing LCA from Part 1 - shows good code organization",
      "Discuss the optimization for multiple queries before being asked",
      "Mention that Binary Lifting can further optimize LCA to O(log n) per query",
      "Explain why depth caching works: depths are static properties of the tree structure"
    ],
    "time_allocation": "2 min for approach explanation with formula derivation, 5-6 min for basic implementation, 2 min for optimization discussion, 2 min for testing",
    "if_stuck": [
      "Think about what information you need: the meeting point (LCA) and how far each node is from it",
      "Draw a simple example with actual depth values and trace the formula",
      "Remember: distance in a tree = path through their common ancestor",
      "If formula is confusing, think of it as: going UP from p to LCA, then DOWN to q"
    ]
  },
  "connection_to_next_part": "Part 4's distance calculation naturally leads to Part 5 possibilities: (1) **Finding the path itself** (not just length), (2) **K-closest nodes** to a given node, (3) **Diameter of N-ary tree** using the distance function, or (4) **Binary Lifting preprocessing** for O(log n) LCA queries. The depth precomputation pattern established here is foundational for these advanced optimizations.",
  "generated_at": "2026-01-14T15:10:34.798087",
  "_meta": {
    "problem_id": "lca_nary_tree",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}