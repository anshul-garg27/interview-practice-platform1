{
  "problem_title": "Stack Overflow API Design - Part 4: Scalability and Security Discussion",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 shifts from pure implementation to architectural design, requiring us to enhance the existing API with production-ready security layers (rate limiting, authentication, authorization, input validation, spam detection) and scalability patterns (caching, sharding strategies, read replicas, search optimization). This transforms our single-instance solution into a distributed, secure system.",
    "new_requirements": [
      "Implement rate limiting to prevent abuse (per-user and per-IP)",
      "Add authentication layer with JWT-style tokens",
      "Implement authorization checks for content modification",
      "Add input validation and sanitization to prevent XSS/injection attacks",
      "Design caching strategy for read-heavy workload",
      "Discuss database sharding approaches for horizontal scaling",
      "Integrate search optimization considerations (Elasticsearch patterns)"
    ],
    "new_constraints": [
      "Rate limit: 100 requests per minute per user/IP",
      "Cache TTL: Hot questions (5 min), User profiles (15 min), Search results (1 min)",
      "Authentication tokens must expire and be refreshable",
      "All user input must be sanitized before storage",
      "System must handle 100K+ concurrent users with eventual consistency where appropriate"
    ],
    "key_insight": "Stack Overflow is extremely read-heavy (~100:1 read:write ratio). The key is to separate read and write paths, cache aggressively at multiple levels, use specialized systems for search, and apply security as layered middleware rather than inline code. Security and scalability are cross-cutting concerns that should be implemented as decorators/interceptors."
  },
  "visual_explanation": {
    "before_after": "```\n                    BEFORE (Part 3)                              AFTER (Part 4)\n                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                              \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Client    \u2502                         \u2502        Client           \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                            \u2502\n                           \u25bc                                            \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502StackOverflow\u2502                         \u2502     Load Balancer       \u2502\n                    \u2502     API     \u2502                         \u2502  (nginx/HAProxy)        \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                            \u2502\n                           \u2502                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502                                \u2502           \u2502           \u2502\n                           \u2502                                \u25bc           \u25bc           \u25bc\n                           \u2502                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502                         \u2502API GW-1  \u2502\u2502API GW-2  \u2502\u2502API GW-3  \u2502\n                           \u2502                         \u2502\u2022RateLimit\u2502\u2502\u2022RateLimit\u2502\u2502\u2022RateLimit\u2502\n                           \u2502                         \u2502\u2022Auth     \u2502\u2502\u2022Auth     \u2502\u2502\u2022Auth     \u2502\n                           \u2502                         \u2502\u2022Validate \u2502\u2502\u2022Validate \u2502\u2502\u2022Validate \u2502\n                           \u2502                         \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                              \u2502           \u2502           \u2502\n                           \u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                          \u2502\n                           \u2502                                          \u25bc\n                           \u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502                              \u2502   Redis Cache Cluster \u2502\n                           \u2502                              \u2502   \u2022 Hot Questions     \u2502\n                           \u2502                              \u2502   \u2022 User Sessions     \u2502\n                           \u2502                              \u2502   \u2022 Search Results    \u2502\n                           \u2502                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502                                          \u2502\n                           \u2502                              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u25bc                              \u25bc           \u25bc           \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 In-Memory   \u2502               \u2502  DB-1    \u2502\u2502  DB-2    \u2502\u2502  Search  \u2502\n                    \u2502   Storage   \u2502               \u2502 (Primary)\u2502\u2502(Replica) \u2502\u2502(Elastic) \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n                           Request Flow with Security & Caching\n                           \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                    \n    \u2502 Request  \u2502                                                    \n    \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518                                                    \n         \u2502                                                          \n         \u25bc                                                          \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  LAYER 1: API GATEWAY                                       \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n    \u2502  \u2502Rate Limiter \u2502\u2500\u2500\u25b6\u2502   Auth      \u2502\u2500\u2500\u25b6\u2502 Input Validation    \u2502\u2502\n    \u2502  \u2502(Token Bucket\u2502   \u2502(JWT Verify) \u2502   \u2502(Sanitize + Validate)\u2502\u2502\n    \u2502  \u2502 Algorithm)  \u2502   \u2502             \u2502   \u2502                     \u2502\u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n    \u2502         \u2502                 \u2502                      \u2502           \u2502\n    \u2502     429 if      401 if              400 if               \u2502\n    \u2502     exceeded    invalid             malformed            \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                                          \n         \u25bc                                                          \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  LAYER 2: CACHE CHECK (for READ operations)                 \u2502\n    \u2502                                                             \u2502\n    \u2502    Cache Key: \"question:{id}\" or \"search:{query_hash}\"     \u2502\n    \u2502                                                             \u2502\n    \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u2502\n    \u2502    \u2500\u2500\u2500\u2500\u25b6\u2502 Redis Cache \u2502\u2500\u2500\u2500\u2500\u25b6 HIT? Return cached response   \u2502\n    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502\n    \u2502                \u2502                                            \u2502\n    \u2502              MISS                                           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                                          \n         \u25bc                                                          \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  LAYER 3: APPLICATION LOGIC                                 \u2502\n    \u2502                                                             \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502\n    \u2502    \u2502 Authorization  \u2502\u2500\u2500\u25b6\u2502 Business Logic \u2502                  \u2502\n    \u2502    \u2502 (Can user do   \u2502   \u2502 (Core API ops) \u2502                  \u2502\n    \u2502    \u2502  this action?) \u2502   \u2502                \u2502                  \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n    \u2502            \u2502                    \u2502                           \u2502\n    \u2502        403 if               Process                     \u2502\n    \u2502        denied                                               \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                                          \n         \u25bc                                                          \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  LAYER 4: DATA LAYER                                        \u2502\n    \u2502                                                             \u2502\n    \u2502    WRITE PATH              READ PATH                        \u2502\n    \u2502    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                        \u2502\n    \u2502    Primary DB \u2500\u2500\u25b6          Replicas \u2500\u2500\u25b6                    \u2502\n    \u2502    (Sync Write)            (Load Balanced)                  \u2502\n    \u2502         \u2502                       \u2502                           \u2502\n    \u2502         \u25bc                       \u2502                           \u2502\n    \u2502    Async Replication           \u2502                           \u2502\n    \u2502    + Cache Invalidation        \u2502                           \u2502\n    \u2502         \u2502                       \u2502                           \u2502\n    \u2502         \u25bc                       \u2502                           \u2502\n    \u2502    Search Index Update         \u2502                           \u2502\n    \u2502    (Elasticsearch)              \u2502                           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                                          \n         \u25bc                                                          \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  LAYER 5: RESPONSE                                          \u2502\n    \u2502                                                             \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n    \u2502    \u2502Update Cache \u2502\u2500\u2500\u25b6\u2502 Serialize   \u2502\u2500\u2500\u25b6\u2502  Response   \u2502     \u2502\n    \u2502    \u2502(if cache    \u2502   \u2502 Response    \u2502   \u2502  to Client  \u2502     \u2502\n    \u2502    \u2502 miss)       \u2502   \u2502             \u2502   \u2502             \u2502     \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Inline Security Checks",
      "description": "Add security checks directly inside each API method. Rate limiting as simple counters, no caching, direct database hits for every request.",
      "time_complexity": "O(n) for rate limiting (scan all requests), O(n) for every database query",
      "space_complexity": "O(requests) for storing all request timestamps",
      "why_not_optimal": "1) Violates DRY principle - security logic duplicated everywhere. 2) Simple counters don't handle distributed systems. 3) No caching means database becomes bottleneck at scale. 4) Inline validation is error-prone and inconsistent. 5) Cannot scale horizontally as state is local."
    },
    {
      "name": "Optimal Approach - Layered Architecture with Decorators",
      "description": "Implement security as cross-cutting concerns using decorator pattern. Use Token Bucket algorithm for rate limiting, distributed cache (Redis) for performance, and dedicated search infrastructure. Separate read/write paths with eventual consistency for non-critical data.",
      "time_complexity": "O(1) for rate limiting (Token Bucket), O(1) cache hits, O(log n) for indexed DB queries",
      "space_complexity": "O(users) for rate limit state, O(hot_data) for cache",
      "key_insight": "Security and scalability are orthogonal to business logic - implement them as layered middleware. Cache aggressively (100:1 read/write ratio means 99% of reads should hit cache). Use specialized systems for specialized tasks (Elasticsearch for search, Redis for cache)."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Scalability & Security Architecture\n\n### Core Design Principles\n\n**1. Layered Security (Defense in Depth)**\n- Each layer handles specific concerns\n- Failures at outer layers prevent load on inner layers\n- **Rate Limiting** \u2192 **Authentication** \u2192 **Authorization** \u2192 **Validation** \u2192 **Business Logic**\n\n**2. Separation of Read/Write Paths**\n- **Writes**: Go to primary database, synchronous\n- **Reads**: Hit cache first, then read replicas\n- **Cache Invalidation**: Event-driven invalidation on writes\n\n**3. Token Bucket Rate Limiting**\n- Allows burst traffic while enforcing average rate\n- **Bucket Size**: Maximum burst (e.g., 10 requests)\n- **Refill Rate**: Tokens added per second (e.g., 1.67/sec for 100/min)\n- O(1) check and update per request\n\n**4. Caching Strategy (Cache-Aside Pattern)**\n- **L1**: Local in-memory cache (per-server)\n- **L2**: Distributed cache (Redis cluster)\n- **TTL-based expiration** with intelligent invalidation\n- Cache hot questions, user profiles, search results\n\n**5. Database Sharding Strategy**\n- **Questions**: Shard by question_id (even distribution)\n- **Users**: Shard by user_id (ownership locality)\n- **Votes**: Co-locate with questions (same shard key)\n- Cross-shard queries use scatter-gather pattern\n\n### Security Implementation\n\n**Rate Limiter** uses **Token Bucket Algorithm**:\n```\nif bucket.tokens >= 1:\n    bucket.tokens -= 1\n    allow_request()\nelse:\n    reject_with_429()\n\n# Refill runs continuously\nbucket.tokens = min(max_tokens, tokens + rate * elapsed_time)\n```\n\n**Authentication** uses JWT-style tokens:\n- Token contains: user_id, expiry, signature\n- Signature verified using server secret\n- Stateless validation (no DB lookup required)\n\n**Input Validation** prevents injection:\n- HTML entity encoding for display\n- Parameterized queries for database\n- Allowlist validation for structured fields (tags)\n\n**Spam Detection** uses heuristics:\n- New user posting rapidly \u2192 spam flag\n- Content similarity to known spam \u2192 block\n- Link density analysis \u2192 score threshold",
    "data_structures": [
      {
        "structure": "Token Bucket",
        "purpose": "O(1) rate limiting with burst support"
      },
      {
        "structure": "LRU Cache",
        "purpose": "In-memory cache with automatic eviction"
      },
      {
        "structure": "Bloom Filter",
        "purpose": "Fast spam URL detection (probabilistic)"
      },
      {
        "structure": "Consistent Hash Ring",
        "purpose": "Distribute cache keys across Redis nodes"
      },
      {
        "structure": "Trie",
        "purpose": "Efficient tag autocomplete and validation"
      }
    ],
    "algorithm_steps": [
      "Step 1: Request arrives at API Gateway, extract client IP and user token",
      "Step 2: Rate Limiter checks token bucket for IP (and user if authenticated)",
      "Step 3: If rate limit exceeded, return 429 Too Many Requests immediately",
      "Step 4: Authenticate request - verify JWT signature and expiry",
      "Step 5: If auth fails, return 401 Unauthorized",
      "Step 6: Validate and sanitize all input fields",
      "Step 7: If validation fails, return 400 Bad Request with details",
      "Step 8: For READ operations, check cache (L1 local, then L2 Redis)",
      "Step 9: If cache hit, return cached response (fast path)",
      "Step 10: If cache miss, check authorization for the operation",
      "Step 11: Execute business logic against database (replicas for reads)",
      "Step 12: For WRITE operations, write to primary, invalidate cache, update search index",
      "Step 13: Populate cache with fresh data on cache miss",
      "Step 14: Run async spam detection for new content",
      "Step 15: Return response with appropriate headers (cache-control, rate-limit-remaining)"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 4: Scalability and Security",
    "",
    "This module extends the Part 3 solution with production-ready",
    "security layers and scalability patterns.",
    "",
    "Architecture:",
    "    - Token Bucket Rate Limiting",
    "    - JWT-style Authentication",
    "    - Role-based Authorization",
    "    - Input Validation & Sanitization",
    "    - Multi-level Caching (LRU + Distributed)",
    "    - Spam Detection Heuristics",
    "\"\"\"",
    "",
    "from __future__ import annotations",
    "import time",
    "import hashlib",
    "import hmac",
    "import re",
    "import json",
    "import html",
    "from abc import ABC, abstractmethod",
    "from collections import OrderedDict",
    "from dataclasses import dataclass, field",
    "from datetime import datetime, timedelta",
    "from enum import Enum, auto",
    "from functools import wraps",
    "from typing import Dict, List, Optional, Set, Callable, Any, Tuple",
    "from threading import Lock",
    "import uuid",
    "",
    "",
    "# =============================================================================",
    "# SECTION 1: CORE DATA MODELS (from Parts 1-3)",
    "# =============================================================================",
    "",
    "class VoteType(Enum):",
    "    UPVOTE = 1",
    "    DOWNVOTE = -1",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"User entity with authentication and reputation.\"\"\"",
    "    user_id: str",
    "    username: str",
    "    email: str",
    "    password_hash: str  # Never store plain passwords",
    "    reputation: int = 0",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "    is_moderator: bool = False",
    "    is_banned: bool = False",
    "    spam_score: float = 0.0  # Accumulated spam score",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Question entity with content and metadata.\"\"\"",
    "    question_id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "    updated_at: datetime = field(default_factory=datetime.now)",
    "    vote_count: int = 0",
    "    view_count: int = 0",
    "    is_closed: bool = False",
    "    is_deleted: bool = False",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Answer entity linked to a question.\"\"\"",
    "    answer_id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "    updated_at: datetime = field(default_factory=datetime.now)",
    "    vote_count: int = 0",
    "    is_accepted: bool = False",
    "    is_deleted: bool = False",
    "",
    "",
    "@dataclass",
    "class Vote:",
    "    \"\"\"Vote record for audit trail.\"\"\"",
    "    vote_id: str",
    "    user_id: str",
    "    target_id: str  # question_id or answer_id",
    "    target_type: str  # 'question' or 'answer'",
    "    vote_type: VoteType",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "# =============================================================================",
    "# SECTION 2: RATE LIMITING (Token Bucket Algorithm)",
    "# =============================================================================",
    "",
    "@dataclass",
    "class TokenBucket:",
    "    \"\"\"",
    "    Token Bucket for rate limiting.",
    "    ",
    "    Allows burst traffic while enforcing average rate.",
    "    - capacity: Maximum tokens (burst size)",
    "    - refill_rate: Tokens added per second",
    "    \"\"\"",
    "    capacity: float",
    "    refill_rate: float",
    "    tokens: float = field(default=0.0)",
    "    last_refill: float = field(default_factory=time.time)",
    "    lock: Lock = field(default_factory=Lock, repr=False)",
    "    ",
    "    def __post_init__(self):",
    "        self.tokens = self.capacity  # Start with full bucket",
    "    ",
    "    def _refill(self) -> None:",
    "        \"\"\"Add tokens based on elapsed time.\"\"\"",
    "        now = time.time()",
    "        elapsed = now - self.last_refill",
    "        self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)",
    "        self.last_refill = now",
    "    ",
    "    def consume(self, tokens: float = 1.0) -> bool:",
    "        \"\"\"",
    "        Try to consume tokens. Returns True if allowed, False if rate limited.",
    "        ",
    "        Thread-safe implementation for concurrent access.",
    "        \"\"\"",
    "        with self.lock:",
    "            self._refill()",
    "            if self.tokens >= tokens:",
    "                self.tokens -= tokens",
    "                return True",
    "            return False",
    "    ",
    "    def get_wait_time(self) -> float:",
    "        \"\"\"Calculate seconds until a token is available.\"\"\"",
    "        with self.lock:",
    "            self._refill()",
    "            if self.tokens >= 1:",
    "                return 0.0",
    "            return (1 - self.tokens) / self.refill_rate",
    "",
    "",
    "class RateLimiter:",
    "    \"\"\"",
    "    Distributed-ready rate limiter with per-user and per-IP limits.",
    "    ",
    "    In production, this would use Redis for distributed state.",
    "    \"\"\"",
    "    ",
    "    def __init__(",
    "        self,",
    "        requests_per_minute: int = 100,",
    "        burst_size: int = 10",
    "    ):",
    "        self._buckets: Dict[str, TokenBucket] = {}",
    "        self._requests_per_minute = requests_per_minute",
    "        self._burst_size = burst_size",
    "        self._refill_rate = requests_per_minute / 60.0",
    "        self._lock = Lock()",
    "    ",
    "    def _get_bucket(self, key: str) -> TokenBucket:",
    "        \"\"\"Get or create token bucket for a key.\"\"\"",
    "        with self._lock:",
    "            if key not in self._buckets:",
    "                self._buckets[key] = TokenBucket(",
    "                    capacity=self._burst_size,",
    "                    refill_rate=self._refill_rate",
    "                )",
    "            return self._buckets[key]",
    "    ",
    "    def is_allowed(self, user_id: Optional[str], ip_address: str) -> Tuple[bool, Dict]:",
    "        \"\"\"",
    "        Check if request is allowed under rate limits.",
    "        ",
    "        Returns:",
    "            Tuple of (allowed, rate_limit_info)",
    "        \"\"\"",
    "        # Check IP-based limit (always applied)",
    "        ip_bucket = self._get_bucket(f'ip:{ip_address}')",
    "        ip_allowed = ip_bucket.consume()",
    "        ",
    "        # Check user-based limit (if authenticated)",
    "        user_allowed = True",
    "        if user_id:",
    "            user_bucket = self._get_bucket(f'user:{user_id}')",
    "            user_allowed = user_bucket.consume()",
    "        ",
    "        info = {",
    "            'limit': self._requests_per_minute,",
    "            'remaining': int(ip_bucket.tokens),",
    "            'reset_in': ip_bucket.get_wait_time()",
    "        }",
    "        ",
    "        return (ip_allowed and user_allowed, info)",
    "    ",
    "    def cleanup_old_buckets(self, max_age_seconds: int = 3600) -> int:",
    "        \"\"\"Remove inactive buckets to prevent memory leak.\"\"\"",
    "        now = time.time()",
    "        removed = 0",
    "        with self._lock:",
    "            keys_to_remove = [",
    "                k for k, v in self._buckets.items()",
    "                if now - v.last_refill > max_age_seconds",
    "            ]",
    "            for key in keys_to_remove:",
    "                del self._buckets[key]",
    "                removed += 1",
    "        return removed",
    "",
    "",
    "# =============================================================================",
    "# SECTION 3: AUTHENTICATION (JWT-style Tokens)",
    "# =============================================================================",
    "",
    "@dataclass",
    "class AuthToken:",
    "    \"\"\"Authentication token with claims.\"\"\"",
    "    user_id: str",
    "    issued_at: datetime",
    "    expires_at: datetime",
    "    token_id: str = field(default_factory=lambda: str(uuid.uuid4()))",
    "",
    "",
    "class AuthenticationError(Exception):",
    "    \"\"\"Raised when authentication fails.\"\"\"",
    "    pass",
    "",
    "",
    "class AuthorizationError(Exception):",
    "    \"\"\"Raised when user lacks permission.\"\"\"",
    "    pass",
    "",
    "",
    "class Authenticator:",
    "    \"\"\"",
    "    JWT-style stateless authentication.",
    "    ",
    "    In production, use a proper JWT library (PyJWT) with RS256.",
    "    This implementation demonstrates the concepts.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, secret_key: str, token_ttl_hours: int = 24):",
    "        self._secret = secret_key.encode()",
    "        self._token_ttl = timedelta(hours=token_ttl_hours)",
    "        self._revoked_tokens: Set[str] = set()  # In prod: use Redis",
    "    ",
    "    def _create_signature(self, payload: str) -> str:",
    "        \"\"\"Create HMAC signature for payload.\"\"\"",
    "        return hmac.new(",
    "            self._secret,",
    "            payload.encode(),",
    "            hashlib.sha256",
    "        ).hexdigest()",
    "    ",
    "    def create_token(self, user_id: str) -> str:",
    "        \"\"\"",
    "        Generate authentication token for user.",
    "        ",
    "        Format: base64(payload).signature",
    "        \"\"\"",
    "        now = datetime.now()",
    "        token = AuthToken(",
    "            user_id=user_id,",
    "            issued_at=now,",
    "            expires_at=now + self._token_ttl",
    "        )",
    "        ",
    "        payload = json.dumps({",
    "            'user_id': token.user_id,",
    "            'token_id': token.token_id,",
    "            'iat': token.issued_at.isoformat(),",
    "            'exp': token.expires_at.isoformat()",
    "        })",
    "        ",
    "        signature = self._create_signature(payload)",
    "        return f'{payload}|||{signature}'",
    "    ",
    "    def verify_token(self, token: str) -> AuthToken:",
    "        \"\"\"",
    "        Verify token and return claims if valid.",
    "        ",
    "        Raises:",
    "            AuthenticationError: If token is invalid or expired",
    "        \"\"\"",
    "        try:",
    "            parts = token.split('|||')",
    "            if len(parts) != 2:",
    "                raise AuthenticationError('Invalid token format')",
    "            ",
    "            payload, signature = parts",
    "            ",
    "            # Verify signature",
    "            expected_sig = self._create_signature(payload)",
    "            if not hmac.compare_digest(signature, expected_sig):",
    "                raise AuthenticationError('Invalid token signature')",
    "            ",
    "            # Parse claims",
    "            claims = json.loads(payload)",
    "            ",
    "            # Check expiry",
    "            expires = datetime.fromisoformat(claims['exp'])",
    "            if datetime.now() > expires:",
    "                raise AuthenticationError('Token expired')",
    "            ",
    "            # Check revocation",
    "            if claims['token_id'] in self._revoked_tokens:",
    "                raise AuthenticationError('Token revoked')",
    "            ",
    "            return AuthToken(",
    "                user_id=claims['user_id'],",
    "                token_id=claims['token_id'],",
    "                issued_at=datetime.fromisoformat(claims['iat']),",
    "                expires_at=expires",
    "            )",
    "            ",
    "        except (KeyError, json.JSONDecodeError) as e:",
    "            raise AuthenticationError(f'Malformed token: {e}')",
    "    ",
    "    def revoke_token(self, token_id: str) -> None:",
    "        \"\"\"Revoke a token (for logout).\"\"\"",
    "        self._revoked_tokens.add(token_id)",
    "    ",
    "    @staticmethod",
    "    def hash_password(password: str) -> str:",
    "        \"\"\"Hash password for storage. In prod: use bcrypt/argon2.\"\"\"",
    "        return hashlib.sha256(password.encode()).hexdigest()",
    "    ",
    "    @staticmethod",
    "    def verify_password(password: str, password_hash: str) -> bool:",
    "        \"\"\"Verify password against hash.\"\"\"",
    "        return hmac.compare_digest(",
    "            hashlib.sha256(password.encode()).hexdigest(),",
    "            password_hash",
    "        )",
    "",
    "",
    "# =============================================================================",
    "# SECTION 4: INPUT VALIDATION & SANITIZATION",
    "# =============================================================================",
    "",
    "class ValidationError(Exception):",
    "    \"\"\"Raised when input validation fails.\"\"\"",
    "    def __init__(self, errors: Dict[str, List[str]]):",
    "        self.errors = errors",
    "        super().__init__(str(errors))",
    "",
    "",
    "class InputValidator:",
    "    \"\"\"",
    "    Comprehensive input validation and sanitization.",
    "    ",
    "    Prevents:",
    "    - XSS attacks (HTML/script injection)",
    "    - SQL injection (via parameterization)",
    "    - Content policy violations",
    "    \"\"\"",
    "    ",
    "    # Validation patterns",
    "    USERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_]{3,30}$')",
    "    EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$')",
    "    TAG_PATTERN = re.compile(r'^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$')",
    "    ",
    "    # Content limits",
    "    MAX_TITLE_LENGTH = 150",
    "    MAX_BODY_LENGTH = 30000",
    "    MAX_TAGS = 5",
    "    MIN_TITLE_LENGTH = 15",
    "    MIN_BODY_LENGTH = 30",
    "    ",
    "    # Dangerous patterns to detect",
    "    SCRIPT_PATTERN = re.compile(r'<script[^>]*>.*?</script>', re.IGNORECASE | re.DOTALL)",
    "    SQL_INJECTION_PATTERNS = [",
    "        re.compile(r\"(--|;|'|\\\".*?\\\".*?=)\", re.IGNORECASE),",
    "        re.compile(r'\\b(DROP|DELETE|INSERT|UPDATE|UNION|SELECT)\\b.*?\\b(FROM|INTO|TABLE)\\b', re.IGNORECASE)",
    "    ]",
    "    ",
    "    @classmethod",
    "    def sanitize_html(cls, content: str) -> str:",
    "        \"\"\"",
    "        Sanitize HTML content to prevent XSS.",
    "        ",
    "        - Escapes HTML entities",
    "        - Preserves allowed markdown",
    "        - Removes script tags",
    "        \"\"\"",
    "        # Remove script tags entirely",
    "        content = cls.SCRIPT_PATTERN.sub('', content)",
    "        ",
    "        # Escape HTML entities",
    "        sanitized = html.escape(content)",
    "        ",
    "        # Allow some safe markdown-style formatting",
    "        # (In production, use a proper markdown sanitizer)",
    "        safe_patterns = [",
    "            (r'\\*\\*(.+?)\\*\\*', r'<strong>\\1</strong>'),  # Bold",
    "            (r'\\*(.+?)\\*', r'<em>\\1</em>'),  # Italic",
    "            (r'`(.+?)`', r'<code>\\1</code>'),  # Inline code",
    "        ]",
    "        for pattern, replacement in safe_patterns:",
    "            sanitized = re.sub(pattern, replacement, sanitized)",
    "        ",
    "        return sanitized",
    "    ",
    "    @classmethod",
    "    def validate_username(cls, username: str) -> List[str]:",
    "        \"\"\"Validate username format.\"\"\"",
    "        errors = []",
    "        if not username:",
    "            errors.append('Username is required')",
    "        elif not cls.USERNAME_PATTERN.match(username):",
    "            errors.append('Username must be 3-30 chars, alphanumeric and underscore only')",
    "        return errors",
    "    ",
    "    @classmethod",
    "    def validate_email(cls, email: str) -> List[str]:",
    "        \"\"\"Validate email format.\"\"\"",
    "        errors = []",
    "        if not email:",
    "            errors.append('Email is required')",
    "        elif not cls.EMAIL_PATTERN.match(email):",
    "            errors.append('Invalid email format')",
    "        return errors",
    "    ",
    "    @classmethod",
    "    def validate_question(cls, title: str, body: str, tags: List[str]) -> Dict[str, List[str]]:",
    "        \"\"\"",
    "        Validate question content.",
    "        ",
    "        Returns dict of field -> error messages (empty if valid).",
    "        \"\"\"",
    "        errors: Dict[str, List[str]] = {}",
    "        ",
    "        # Title validation",
    "        title_errors = []",
    "        if len(title) < cls.MIN_TITLE_LENGTH:",
    "            title_errors.append(f'Title must be at least {cls.MIN_TITLE_LENGTH} characters')",
    "        if len(title) > cls.MAX_TITLE_LENGTH:",
    "            title_errors.append(f'Title cannot exceed {cls.MAX_TITLE_LENGTH} characters')",
    "        if title_errors:",
    "            errors['title'] = title_errors",
    "        ",
    "        # Body validation",
    "        body_errors = []",
    "        if len(body) < cls.MIN_BODY_LENGTH:",
    "            body_errors.append(f'Body must be at least {cls.MIN_BODY_LENGTH} characters')",
    "        if len(body) > cls.MAX_BODY_LENGTH:",
    "            body_errors.append(f'Body cannot exceed {cls.MAX_BODY_LENGTH} characters')",
    "        if body_errors:",
    "            errors['body'] = body_errors",
    "        ",
    "        # Tags validation",
    "        tag_errors = []",
    "        if not tags:",
    "            tag_errors.append('At least one tag is required')",
    "        elif len(tags) > cls.MAX_TAGS:",
    "            tag_errors.append(f'Maximum {cls.MAX_TAGS} tags allowed')",
    "        else:",
    "            for tag in tags:",
    "                if not cls.TAG_PATTERN.match(tag.lower()):",
    "                    tag_errors.append(f'Invalid tag format: {tag}')",
    "        if tag_errors:",
    "            errors['tags'] = tag_errors",
    "        ",
    "        return errors",
    "    ",
    "    @classmethod",
    "    def detect_sql_injection(cls, content: str) -> bool:",
    "        \"\"\"Check for SQL injection patterns.\"\"\"",
    "        for pattern in cls.SQL_INJECTION_PATTERNS:",
    "            if pattern.search(content):",
    "                return True",
    "        return False",
    "",
    "",
    "# =============================================================================",
    "# SECTION 5: CACHING LAYER",
    "# =============================================================================",
    "",
    "@dataclass",
    "class CacheEntry:",
    "    \"\"\"Cache entry with value and metadata.\"\"\"",
    "    value: Any",
    "    created_at: float",
    "    ttl_seconds: float",
    "    access_count: int = 0",
    "    ",
    "    def is_expired(self) -> bool:",
    "        return time.time() > self.created_at + self.ttl_seconds",
    "",
    "",
    "class LRUCache:",
    "    \"\"\"",
    "    Thread-safe LRU Cache with TTL support.",
    "    ",
    "    Simulates Redis-like caching behavior for local development.",
    "    In production, replace with Redis client.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_size: int = 10000):",
    "        self._cache: OrderedDict[str, CacheEntry] = OrderedDict()",
    "        self._max_size = max_size",
    "        self._lock = Lock()",
    "        self._hits = 0",
    "        self._misses = 0",
    "    ",
    "    def get(self, key: str) -> Optional[Any]:",
    "        \"\"\"Get value from cache. Returns None if miss or expired.\"\"\"",
    "        with self._lock:",
    "            if key not in self._cache:",
    "                self._misses += 1",
    "                return None",
    "            ",
    "            entry = self._cache[key]",
    "            ",
    "            if entry.is_expired():",
    "                del self._cache[key]",
    "                self._misses += 1",
    "                return None",
    "            ",
    "            # Move to end (most recently used)",
    "            self._cache.move_to_end(key)",
    "            entry.access_count += 1",
    "            self._hits += 1",
    "            return entry.value",
    "    ",
    "    def set(self, key: str, value: Any, ttl_seconds: float = 300) -> None:",
    "        \"\"\"Set value in cache with TTL.\"\"\"",
    "        with self._lock:",
    "            # Remove if exists to update position",
    "            if key in self._cache:",
    "                del self._cache[key]",
    "            ",
    "            # Evict oldest if at capacity",
    "            while len(self._cache) >= self._max_size:",
    "                self._cache.popitem(last=False)",
    "            ",
    "            self._cache[key] = CacheEntry(",
    "                value=value,",
    "                created_at=time.time(),",
    "                ttl_seconds=ttl_seconds",
    "            )",
    "    ",
    "    def delete(self, key: str) -> bool:",
    "        \"\"\"Delete key from cache. Returns True if existed.\"\"\"",
    "        with self._lock:",
    "            if key in self._cache:",
    "                del self._cache[key]",
    "                return True",
    "            return False",
    "    ",
    "    def invalidate_pattern(self, pattern: str) -> int:",
    "        \"\"\"Delete all keys matching pattern. Returns count deleted.\"\"\"",
    "        regex = re.compile(pattern.replace('*', '.*'))",
    "        with self._lock:",
    "            keys_to_delete = [k for k in self._cache.keys() if regex.match(k)]",
    "            for key in keys_to_delete:",
    "                del self._cache[key]",
    "            return len(keys_to_delete)",
    "    ",
    "    def get_stats(self) -> Dict[str, Any]:",
    "        \"\"\"Get cache statistics.\"\"\"",
    "        with self._lock:",
    "            total = self._hits + self._misses",
    "            return {",
    "                'size': len(self._cache),",
    "                'max_size': self._max_size,",
    "                'hits': self._hits,",
    "                'misses': self._misses,",
    "                'hit_rate': self._hits / total if total > 0 else 0",
    "            }",
    "",
    "",
    "# =============================================================================",
    "# SECTION 6: SPAM DETECTION",
    "# =============================================================================",
    "",
    "class SpamDetector:",
    "    \"\"\"",
    "    Heuristic-based spam detection.",
    "    ",
    "    In production, this would integrate with ML models and",
    "    external services like Akismet.",
    "    \"\"\"",
    "    ",
    "    # Spam indicators and weights",
    "    SPAM_PATTERNS = [",
    "        (re.compile(r'\\b(buy|cheap|discount|free|offer|click here)\\b', re.I), 0.3),",
    "        (re.compile(r'https?://[^\\s]+', re.I), 0.2),  # Links",
    "        (re.compile(r'[A-Z]{5,}'), 0.2),  # Excessive caps",
    "        (re.compile(r'(.+)\\1{3,}'), 0.3),  # Repeated patterns",
    "        (re.compile(r'[!?]{3,}'), 0.2),  # Excessive punctuation",
    "    ]",
    "    ",
    "    SPAM_THRESHOLD = 0.7",
    "    ",
    "    @classmethod",
    "    def calculate_spam_score(cls, content: str, user: User) -> Tuple[float, List[str]]:",
    "        \"\"\"",
    "        Calculate spam score for content.",
    "        ",
    "        Returns:",
    "            Tuple of (score 0-1, list of triggered reasons)",
    "        \"\"\"",
    "        score = 0.0",
    "        reasons = []",
    "        ",
    "        # Check content patterns",
    "        for pattern, weight in cls.SPAM_PATTERNS:",
    "            matches = pattern.findall(content)",
    "            if matches:",
    "                score += weight * min(len(matches), 3) / 3",
    "                reasons.append(f'Pattern detected: {pattern.pattern[:30]}...')",
    "        ",
    "        # User reputation factor",
    "        if user.reputation < 10:",
    "            score += 0.2",
    "            reasons.append('New user (low reputation)')",
    "        ",
    "        # Account age factor",
    "        account_age = (datetime.now() - user.created_at).days",
    "        if account_age < 1:",
    "            score += 0.2",
    "            reasons.append('Account less than 24 hours old')",
    "        ",
    "        # Historical spam score",
    "        score += user.spam_score * 0.3",
    "        if user.spam_score > 0:",
    "            reasons.append('Historical spam behavior')",
    "        ",
    "        # Link density",
    "        link_count = len(re.findall(r'https?://', content))",
    "        word_count = len(content.split())",
    "        if word_count > 0 and link_count / word_count > 0.1:",
    "            score += 0.3",
    "            reasons.append('High link density')",
    "        ",
    "        return min(score, 1.0), reasons",
    "    ",
    "    @classmethod",
    "    def is_spam(cls, content: str, user: User) -> Tuple[bool, List[str]]:",
    "        \"\"\"Check if content should be flagged as spam.\"\"\"",
    "        score, reasons = cls.calculate_spam_score(content, user)",
    "        return score >= cls.SPAM_THRESHOLD, reasons",
    "",
    "",
    "# =============================================================================",
    "# SECTION 7: ENHANCED STACK OVERFLOW API",
    "# =============================================================================",
    "",
    "class APIResponse:",
    "    \"\"\"Standardized API response wrapper.\"\"\"",
    "    ",
    "    def __init__(",
    "        self,",
    "        success: bool,",
    "        data: Any = None,",
    "        error: Optional[str] = None,",
    "        status_code: int = 200",
    "    ):",
    "        self.success = success",
    "        self.data = data",
    "        self.error = error",
    "        self.status_code = status_code",
    "        self.timestamp = datetime.now().isoformat()",
    "        self.rate_limit_info: Optional[Dict] = None",
    "    ",
    "    def to_dict(self) -> Dict:",
    "        result = {",
    "            'success': self.success,",
    "            'timestamp': self.timestamp,",
    "            'status_code': self.status_code",
    "        }",
    "        if self.data is not None:",
    "            result['data'] = self.data",
    "        if self.error:",
    "            result['error'] = self.error",
    "        if self.rate_limit_info:",
    "            result['rate_limit'] = self.rate_limit_info",
    "        return result",
    "",
    "",
    "class StackOverflowAPI:",
    "    \"\"\"",
    "    Production-ready Stack Overflow API with security and scalability.",
    "    ",
    "    Features:",
    "    - Rate limiting (token bucket)",
    "    - Authentication (JWT-style)",
    "    - Authorization (role-based)",
    "    - Input validation",
    "    - Caching",
    "    - Spam detection",
    "    \"\"\"",
    "    ",
    "    # Cache TTLs in seconds",
    "    CACHE_TTL_QUESTION = 300  # 5 minutes",
    "    CACHE_TTL_USER = 900  # 15 minutes",
    "    CACHE_TTL_SEARCH = 60  # 1 minute",
    "    ",
    "    def __init__(self, secret_key: str = 'super-secret-key-change-in-prod'):",
    "        # Core storage",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        self._votes: Dict[str, Vote] = {}",
    "        self._question_answers: Dict[str, List[str]] = {}",
    "        self._user_questions: Dict[str, List[str]] = {}",
    "        self._tag_questions: Dict[str, Set[str]] = {}",
    "        ",
    "        # Security components",
    "        self._rate_limiter = RateLimiter(requests_per_minute=100, burst_size=10)",
    "        self._authenticator = Authenticator(secret_key)",
    "        self._cache = LRUCache(max_size=10000)",
    "        ",
    "        # Username to user_id mapping for login",
    "        self._username_to_id: Dict[str, str] = {}",
    "    ",
    "    # =========================================================================",
    "    # MIDDLEWARE / DECORATORS",
    "    # =========================================================================",
    "    ",
    "    def _check_rate_limit(self, user_id: Optional[str], ip: str) -> Tuple[bool, Dict]:",
    "        \"\"\"Check rate limit for request.\"\"\"",
    "        return self._rate_limiter.is_allowed(user_id, ip)",
    "    ",
    "    def _require_auth(self, token: str) -> AuthToken:",
    "        \"\"\"Verify authentication token.\"\"\"",
    "        return self._authenticator.verify_token(token)",
    "    ",
    "    def _check_authorization(",
    "        self,",
    "        user_id: str,",
    "        resource_type: str,",
    "        resource_id: str,",
    "        action: str",
    "    ) -> bool:",
    "        \"\"\"Check if user is authorized for action on resource.\"\"\"",
    "        user = self._users.get(user_id)",
    "        if not user:",
    "            return False",
    "        ",
    "        # Moderators can do anything",
    "        if user.is_moderator:",
    "            return True",
    "        ",
    "        # Check ownership for edit/delete",
    "        if action in ('edit', 'delete'):",
    "            if resource_type == 'question':",
    "                question = self._questions.get(resource_id)",
    "                return question and question.author_id == user_id",
    "            elif resource_type == 'answer':",
    "                answer = self._answers.get(resource_id)",
    "                return answer and answer.author_id == user_id",
    "        ",
    "        # Accept answer requires question ownership",
    "        if action == 'accept' and resource_type == 'answer':",
    "            answer = self._answers.get(resource_id)",
    "            if answer:",
    "                question = self._questions.get(answer.question_id)",
    "                return question and question.author_id == user_id",
    "        ",
    "        return action in ('read', 'vote', 'create')",
    "    ",
    "    # =========================================================================",
    "    # USER MANAGEMENT",
    "    # =========================================================================",
    "    ",
    "    def register_user(",
    "        self,",
    "        username: str,",
    "        email: str,",
    "        password: str,",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Register a new user with validation.\"\"\"",
    "        # Rate limit check",
    "        allowed, rate_info = self._check_rate_limit(None, ip_address)",
    "        if not allowed:",
    "            response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        # Input validation",
    "        errors: Dict[str, List[str]] = {}",
    "        errors['username'] = InputValidator.validate_username(username)",
    "        errors['email'] = InputValidator.validate_email(email)",
    "        ",
    "        if len(password) < 8:",
    "            errors['password'] = ['Password must be at least 8 characters']",
    "        ",
    "        # Remove empty error lists",
    "        errors = {k: v for k, v in errors.items() if v}",
    "        if errors:",
    "            return APIResponse(False, error=str(errors), status_code=400)",
    "        ",
    "        # Check uniqueness",
    "        if username.lower() in self._username_to_id:",
    "            return APIResponse(False, error='Username already taken', status_code=409)",
    "        ",
    "        # Create user",
    "        user_id = str(uuid.uuid4())",
    "        user = User(",
    "            user_id=user_id,",
    "            username=username,",
    "            email=email,",
    "            password_hash=Authenticator.hash_password(password)",
    "        )",
    "        ",
    "        self._users[user_id] = user",
    "        self._username_to_id[username.lower()] = user_id",
    "        self._user_questions[user_id] = []",
    "        ",
    "        response = APIResponse(True, data={",
    "            'user_id': user_id,",
    "            'username': username,",
    "            'message': 'User registered successfully'",
    "        }, status_code=201)",
    "        response.rate_limit_info = rate_info",
    "        return response",
    "    ",
    "    def login(",
    "        self,",
    "        username: str,",
    "        password: str,",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Authenticate user and return token.\"\"\"",
    "        allowed, rate_info = self._check_rate_limit(None, ip_address)",
    "        if not allowed:",
    "            response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        user_id = self._username_to_id.get(username.lower())",
    "        if not user_id:",
    "            return APIResponse(False, error='Invalid credentials', status_code=401)",
    "        ",
    "        user = self._users[user_id]",
    "        ",
    "        if user.is_banned:",
    "            return APIResponse(False, error='Account suspended', status_code=403)",
    "        ",
    "        if not Authenticator.verify_password(password, user.password_hash):",
    "            return APIResponse(False, error='Invalid credentials', status_code=401)",
    "        ",
    "        token = self._authenticator.create_token(user_id)",
    "        ",
    "        response = APIResponse(True, data={",
    "            'token': token,",
    "            'user_id': user_id,",
    "            'username': user.username",
    "        })",
    "        response.rate_limit_info = rate_info",
    "        return response",
    "    ",
    "    # =========================================================================",
    "    # QUESTION MANAGEMENT (with caching)",
    "    # =========================================================================",
    "    ",
    "    def create_question(",
    "        self,",
    "        token: str,",
    "        title: str,",
    "        body: str,",
    "        tags: List[str],",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Create a new question with full validation and spam checking.\"\"\"",
    "        try:",
    "            # Authentication",
    "            auth = self._require_auth(token)",
    "            ",
    "            # Rate limiting",
    "            allowed, rate_info = self._check_rate_limit(auth.user_id, ip_address)",
    "            if not allowed:",
    "                response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "                response.rate_limit_info = rate_info",
    "                return response",
    "            ",
    "            user = self._users.get(auth.user_id)",
    "            if not user:",
    "                return APIResponse(False, error='User not found', status_code=404)",
    "            ",
    "            # Input validation",
    "            validation_errors = InputValidator.validate_question(title, body, tags)",
    "            if validation_errors:",
    "                raise ValidationError(validation_errors)",
    "            ",
    "            # Sanitize content",
    "            sanitized_title = InputValidator.sanitize_html(title)",
    "            sanitized_body = InputValidator.sanitize_html(body)",
    "            sanitized_tags = [t.lower().strip() for t in tags]",
    "            ",
    "            # Spam detection",
    "            combined_content = f'{title} {body}'",
    "            is_spam, spam_reasons = SpamDetector.is_spam(combined_content, user)",
    "            if is_spam:",
    "                user.spam_score = min(1.0, user.spam_score + 0.2)",
    "                return APIResponse(",
    "                    False,",
    "                    error='Content flagged as potential spam',",
    "                    data={'reasons': spam_reasons},",
    "                    status_code=422",
    "                )",
    "            ",
    "            # Create question",
    "            question_id = str(uuid.uuid4())",
    "            question = Question(",
    "                question_id=question_id,",
    "                author_id=auth.user_id,",
    "                title=sanitized_title,",
    "                body=sanitized_body,",
    "                tags=sanitized_tags",
    "            )",
    "            ",
    "            self._questions[question_id] = question",
    "            self._question_answers[question_id] = []",
    "            self._user_questions[auth.user_id].append(question_id)",
    "            ",
    "            # Update tag index",
    "            for tag in sanitized_tags:",
    "                if tag not in self._tag_questions:",
    "                    self._tag_questions[tag] = set()",
    "                self._tag_questions[tag].add(question_id)",
    "            ",
    "            # Invalidate related caches",
    "            self._cache.invalidate_pattern('search:*')",
    "            self._cache.invalidate_pattern(f'user_questions:{auth.user_id}')",
    "            ",
    "            response = APIResponse(True, data={",
    "                'question_id': question_id,",
    "                'message': 'Question created successfully'",
    "            }, status_code=201)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "            ",
    "        except AuthenticationError as e:",
    "            return APIResponse(False, error=str(e), status_code=401)",
    "        except ValidationError as e:",
    "            return APIResponse(False, error='Validation failed', data=e.errors, status_code=400)",
    "    ",
    "    def get_question(",
    "        self,",
    "        question_id: str,",
    "        token: Optional[str] = None,",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Get question by ID with caching.\"\"\"",
    "        user_id = None",
    "        if token:",
    "            try:",
    "                auth = self._require_auth(token)",
    "                user_id = auth.user_id",
    "            except AuthenticationError:",
    "                pass  # Allow unauthenticated access",
    "        ",
    "        allowed, rate_info = self._check_rate_limit(user_id, ip_address)",
    "        if not allowed:",
    "            response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        # Check cache",
    "        cache_key = f'question:{question_id}'",
    "        cached = self._cache.get(cache_key)",
    "        if cached:",
    "            response = APIResponse(True, data=cached)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        # Fetch from storage",
    "        question = self._questions.get(question_id)",
    "        if not question or question.is_deleted:",
    "            return APIResponse(False, error='Question not found', status_code=404)",
    "        ",
    "        # Increment view count",
    "        question.view_count += 1",
    "        ",
    "        # Build response with answers",
    "        answer_ids = self._question_answers.get(question_id, [])",
    "        answers_data = []",
    "        for aid in answer_ids:",
    "            answer = self._answers.get(aid)",
    "            if answer and not answer.is_deleted:",
    "                author = self._users.get(answer.author_id)",
    "                answers_data.append({",
    "                    'answer_id': answer.answer_id,",
    "                    'body': answer.body,",
    "                    'author': author.username if author else 'Unknown',",
    "                    'vote_count': answer.vote_count,",
    "                    'is_accepted': answer.is_accepted,",
    "                    'created_at': answer.created_at.isoformat()",
    "                })",
    "        ",
    "        author = self._users.get(question.author_id)",
    "        result = {",
    "            'question_id': question.question_id,",
    "            'title': question.title,",
    "            'body': question.body,",
    "            'tags': question.tags,",
    "            'author': author.username if author else 'Unknown',",
    "            'vote_count': question.vote_count,",
    "            'view_count': question.view_count,",
    "            'answers': answers_data,",
    "            'created_at': question.created_at.isoformat()",
    "        }",
    "        ",
    "        # Cache the result",
    "        self._cache.set(cache_key, result, self.CACHE_TTL_QUESTION)",
    "        ",
    "        response = APIResponse(True, data=result)",
    "        response.rate_limit_info = rate_info",
    "        return response",
    "    ",
    "    def search_questions(",
    "        self,",
    "        query: Optional[str] = None,",
    "        tags: Optional[List[str]] = None,",
    "        sort_by: str = 'newest',",
    "        page: int = 1,",
    "        page_size: int = 20,",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Search questions with caching.\"\"\"",
    "        allowed, rate_info = self._check_rate_limit(None, ip_address)",
    "        if not allowed:",
    "            response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        # Build cache key",
    "        cache_key = f'search:{query}:{tags}:{sort_by}:{page}:{page_size}'",
    "        cached = self._cache.get(cache_key)",
    "        if cached:",
    "            response = APIResponse(True, data=cached)",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "        ",
    "        # Filter questions",
    "        candidates = list(self._questions.values())",
    "        candidates = [q for q in candidates if not q.is_deleted]",
    "        ",
    "        if tags:",
    "            tag_set = set(t.lower() for t in tags)",
    "            candidates = [q for q in candidates if tag_set.intersection(set(q.tags))]",
    "        ",
    "        if query:",
    "            query_lower = query.lower()",
    "            candidates = [",
    "                q for q in candidates",
    "                if query_lower in q.title.lower() or query_lower in q.body.lower()",
    "            ]",
    "        ",
    "        # Sort",
    "        if sort_by == 'newest':",
    "            candidates.sort(key=lambda q: q.created_at, reverse=True)",
    "        elif sort_by == 'votes':",
    "            candidates.sort(key=lambda q: q.vote_count, reverse=True)",
    "        elif sort_by == 'views':",
    "            candidates.sort(key=lambda q: q.view_count, reverse=True)",
    "        ",
    "        # Paginate",
    "        total = len(candidates)",
    "        start = (page - 1) * page_size",
    "        end = start + page_size",
    "        page_results = candidates[start:end]",
    "        ",
    "        results = []",
    "        for q in page_results:",
    "            author = self._users.get(q.author_id)",
    "            results.append({",
    "                'question_id': q.question_id,",
    "                'title': q.title,",
    "                'tags': q.tags,",
    "                'author': author.username if author else 'Unknown',",
    "                'vote_count': q.vote_count,",
    "                'view_count': q.view_count,",
    "                'answer_count': len(self._question_answers.get(q.question_id, [])),",
    "                'created_at': q.created_at.isoformat()",
    "            })",
    "        ",
    "        result = {",
    "            'questions': results,",
    "            'pagination': {",
    "                'total': total,",
    "                'page': page,",
    "                'page_size': page_size,",
    "                'total_pages': (total + page_size - 1) // page_size",
    "            }",
    "        }",
    "        ",
    "        self._cache.set(cache_key, result, self.CACHE_TTL_SEARCH)",
    "        ",
    "        response = APIResponse(True, data=result)",
    "        response.rate_limit_info = rate_info",
    "        return response",
    "    ",
    "    # =========================================================================",
    "    # VOTING (with cache invalidation)",
    "    # =========================================================================",
    "    ",
    "    def vote_question(",
    "        self,",
    "        token: str,",
    "        question_id: str,",
    "        vote_type: VoteType,",
    "        ip_address: str = '127.0.0.1'",
    "    ) -> APIResponse:",
    "        \"\"\"Vote on a question.\"\"\"",
    "        try:",
    "            auth = self._require_auth(token)",
    "            ",
    "            allowed, rate_info = self._check_rate_limit(auth.user_id, ip_address)",
    "            if not allowed:",
    "                response = APIResponse(False, error='Rate limit exceeded', status_code=429)",
    "                response.rate_limit_info = rate_info",
    "                return response",
    "            ",
    "            question = self._questions.get(question_id)",
    "            if not question or question.is_deleted:",
    "                return APIResponse(False, error='Question not found', status_code=404)",
    "            ",
    "            # Check for existing vote",
    "            vote_key = f'{auth.user_id}:question:{question_id}'",
    "            existing_vote = self._votes.get(vote_key)",
    "            ",
    "            if existing_vote:",
    "                if existing_vote.vote_type == vote_type:",
    "                    return APIResponse(False, error='Already voted', status_code=409)",
    "                # Change vote",
    "                question.vote_count -= existing_vote.vote_type.value",
    "            ",
    "            # Apply new vote",
    "            question.vote_count += vote_type.value",
    "            ",
    "            # Record vote",
    "            vote = Vote(",
    "                vote_id=str(uuid.uuid4()),",
    "                user_id=auth.user_id,",
    "                target_id=question_id,",
    "                target_type='question',",
    "                vote_type=vote_type",
    "            )",
    "            self._votes[vote_key] = vote",
    "            ",
    "            # Update author reputation",
    "            author = self._users.get(question.author_id)",
    "            if author:",
    "                rep_change = 10 if vote_type == VoteType.UPVOTE else -2",
    "                author.reputation = max(0, author.reputation + rep_change)",
    "            ",
    "            # Invalidate cache",
    "            self._cache.delete(f'question:{question_id}')",
    "            ",
    "            response = APIResponse(True, data={",
    "                'question_id': question_id,",
    "                'new_vote_count': question.vote_count,",
    "                'vote_type': vote_type.name",
    "            })",
    "            response.rate_limit_info = rate_info",
    "            return response",
    "            ",
    "        except AuthenticationError as e:",
    "            return APIResponse(False, error=str(e), status_code=401)",
    "    ",
    "    # =========================================================================",
    "    # DIAGNOSTICS",
    "    # =========================================================================",
    "    ",
    "    def get_cache_stats(self) -> Dict:",
    "        \"\"\"Get cache statistics for monitoring.\"\"\"",
    "        return self._cache.get_stats()",
    "    ",
    "    def get_system_stats(self) -> Dict:",
    "        \"\"\"Get overall system statistics.\"\"\"",
    "        return {",
    "            'users': len(self._users),",
    "            'questions': len(self._questions),",
    "            'answers': len(self._answers),",
    "            'votes': len(self._votes),",
    "            'cache': self._cache.get_stats()",
    "        }",
    "",
    "",
    "# =============================================================================",
    "# SECTION 8: DEMO AND TESTING",
    "# =============================================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate the secure, scalable Stack Overflow API.\"\"\"",
    "    print('=' * 70)",
    "    print('STACK OVERFLOW API - Part 4: Scalability & Security Demo')",
    "    print('=' * 70)",
    "    print()",
    "    ",
    "    # Initialize API",
    "    api = StackOverflowAPI(secret_key='demo-secret-key-12345')",
    "    ",
    "    # =========================================================================",
    "    # Demo 1: User Registration with Validation",
    "    # =========================================================================",
    "    print('\ud83d\udcdd DEMO 1: User Registration with Input Validation')",
    "    print('-' * 50)",
    "    ",
    "    # Invalid username",
    "    result = api.register_user('ab', 'test@email.com', 'password123')",
    "    print(f'Short username: {result.to_dict()}')",
    "    ",
    "    # Invalid email",
    "    result = api.register_user('validuser', 'invalid-email', 'password123')",
    "    print(f'Invalid email: {result.to_dict()}')",
    "    ",
    "    # Valid registration",
    "    result = api.register_user('john_doe', 'john@example.com', 'securepass123')",
    "    print(f'Valid registration: {result.to_dict()}')",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 2: Authentication",
    "    # =========================================================================",
    "    print('\ud83d\udd10 DEMO 2: Authentication')",
    "    print('-' * 50)",
    "    ",
    "    # Wrong password",
    "    result = api.login('john_doe', 'wrongpassword')",
    "    print(f'Wrong password: {result.to_dict()}')",
    "    ",
    "    # Correct login",
    "    result = api.login('john_doe', 'securepass123')",
    "    print(f'Successful login: {result.to_dict()}')",
    "    token = result.data['token']",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 3: Question Creation with Spam Detection",
    "    # =========================================================================",
    "    print('\u2753 DEMO 3: Question Creation with Spam Detection')",
    "    print('-' * 50)",
    "    ",
    "    # Valid question",
    "    result = api.create_question(",
    "        token=token,",
    "        title='How do I implement a rate limiter in Python?',",
    "        body='I am trying to implement a token bucket rate limiter for my API. '\\\n             'What is the best approach? I need it to handle burst traffic while '\\\n             'enforcing an average rate limit. Any code examples would be helpful.',",
    "        tags=['python', 'rate-limiting', 'api-design']",
    "    )",
    "    print(f'Valid question: {result.to_dict()}')",
    "    question_id = result.data['question_id'] if result.success else None",
    "    print()",
    "    ",
    "    # Spammy question",
    "    result = api.create_question(",
    "        token=token,",
    "        title='BUY CHEAP PRODUCTS!!! CLICK HERE NOW!!! FREE OFFER!!!',",
    "        body='Visit http://spam.com http://spam2.com http://spam3.com '\\\n             'AMAZING DISCOUNT FREE FREE FREE click here to buy cheap products!!!',",
    "        tags=['spam']",
    "    )",
    "    print(f'Spam detected: {result.to_dict()}')",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 4: Caching Demonstration",
    "    # =========================================================================",
    "    print('\ud83d\udcbe DEMO 4: Caching Performance')",
    "    print('-' * 50)",
    "    ",
    "    if question_id:",
    "        import time",
    "        ",
    "        # First fetch (cache miss)",
    "        start = time.time()",
    "        result = api.get_question(question_id)",
    "        first_time = time.time() - start",
    "        print(f'First fetch (cache miss): {first_time*1000:.2f}ms')",
    "        print(f'Cache stats: {api.get_cache_stats()}')",
    "        ",
    "        # Second fetch (cache hit)",
    "        start = time.time()",
    "        result = api.get_question(question_id)",
    "        second_time = time.time() - start",
    "        print(f'Second fetch (cache hit): {second_time*1000:.2f}ms')",
    "        print(f'Cache stats: {api.get_cache_stats()}')",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 5: Rate Limiting",
    "    # =========================================================================",
    "    print('\u23f1\ufe0f DEMO 5: Rate Limiting')",
    "    print('-' * 50)",
    "    ",
    "    # Simulate burst requests",
    "    print('Simulating burst of 15 requests...')",
    "    success_count = 0",
    "    rate_limited_count = 0",
    "    for i in range(15):",
    "        result = api.search_questions(query='python')",
    "        if result.success:",
    "            success_count += 1",
    "        else:",
    "            rate_limited_count += 1",
    "    ",
    "    print(f'Successful: {success_count}, Rate limited: {rate_limited_count}')",
    "    print(f'Last response rate limit info: {result.rate_limit_info}')",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 6: Input Sanitization",
    "    # =========================================================================",
    "    print('\ud83d\udee1\ufe0f DEMO 6: Input Sanitization (XSS Prevention)')",
    "    print('-' * 50)",
    "    ",
    "    malicious_input = '<script>alert(\"XSS\")</script>Hello **world**'",
    "    sanitized = InputValidator.sanitize_html(malicious_input)",
    "    print(f'Original: {malicious_input}')",
    "    print(f'Sanitized: {sanitized}')",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Demo 7: System Statistics",
    "    # =========================================================================",
    "    print('\ud83d\udcca DEMO 7: System Statistics')",
    "    print('-' * 50)",
    "    print(json.dumps(api.get_system_stats(), indent=2))",
    "    print()",
    "    ",
    "    # =========================================================================",
    "    # Architecture Discussion",
    "    # =========================================================================",
    "    print('=' * 70)",
    "    print('ARCHITECTURE DISCUSSION')",
    "    print('=' * 70)",
    "    print('''",
    "    \ud83c\udfd7\ufe0f SCALABILITY STRATEGIES:",
    "    ",
    "    1. DATABASE SHARDING:",
    "       \u2022 Questions: Shard by question_id (hash-based)",
    "       \u2022 Users: Shard by user_id",
    "       \u2022 Votes: Co-locate with questions (same shard key)",
    "       \u2022 Cross-shard queries: Use scatter-gather pattern",
    "    ",
    "    2. CACHING LAYERS:",
    "       \u2022 L1: In-process LRU cache (this implementation)",
    "       \u2022 L2: Distributed Redis cluster",
    "       \u2022 CDN: Static assets and popular content",
    "       \u2022 Cache-aside pattern with TTL-based expiration",
    "    ",
    "    3. READ REPLICAS:",
    "       \u2022 Primary: Handles all writes",
    "       \u2022 Replicas: Handle read traffic (load balanced)",
    "       \u2022 Async replication with eventual consistency",
    "    ",
    "    4. SEARCH OPTIMIZATION:",
    "       \u2022 Elasticsearch for full-text search",
    "       \u2022 Async index updates via message queue",
    "       \u2022 Separate search cluster from main database",
    "    ",
    "    \ud83d\udd12 SECURITY LAYERS:",
    "    ",
    "    1. RATE LIMITING:",
    "       \u2022 Token bucket algorithm (O(1) operation)",
    "       \u2022 Per-user AND per-IP limits",
    "       \u2022 Distributed state via Redis",
    "    ",
    "    2. AUTHENTICATION:",
    "       \u2022 JWT tokens with HMAC signatures",
    "       \u2022 Stateless verification (no DB lookup)",
    "       \u2022 Token refresh and revocation support",
    "    ",
    "    3. AUTHORIZATION:",
    "       \u2022 Role-based access control (RBAC)",
    "       \u2022 Resource ownership verification",
    "       \u2022 Moderator override capabilities",
    "    ",
    "    4. INPUT VALIDATION:",
    "       \u2022 HTML entity escaping (XSS prevention)",
    "       \u2022 Parameterized queries (SQL injection)",
    "       \u2022 Allowlist validation for structured fields",
    "    ",
    "    5. SPAM DETECTION:",
    "       \u2022 Heuristic scoring system",
    "       \u2022 Pattern matching + user behavior",
    "       \u2022 Reputation-based thresholds",
    "    ''')",
    "    ",
    "    print('Demo completed successfully! \u2705')",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.time.Instant;",
    "import java.time.Duration;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "import java.util.regex.*;",
    "import java.security.MessageDigest;",
    "import javax.crypto.Mac;",
    "import javax.crypto.spec.SecretKeySpec;",
    "",
    "/**",
    " * Stack Overflow API - Part 4: Scalability and Security",
    " * ",
    " * Production-ready implementation with:",
    " * - Token Bucket Rate Limiting",
    " * - JWT-style Authentication",
    " * - Input Validation & Sanitization",
    " * - LRU Caching",
    " * - Spam Detection",
    " */",
    "public class StackOverflowSecureAPI {",
    "",
    "    // ========================================================================",
    "    // ENUMS AND DATA CLASSES",
    "    // ========================================================================",
    "",
    "    enum VoteType {",
    "        UPVOTE(1), DOWNVOTE(-1);",
    "        final int value;",
    "        VoteType(int value) { this.value = value; }",
    "    }",
    "",
    "    static class User {",
    "        String userId;",
    "        String username;",
    "        String email;",
    "        String passwordHash;",
    "        int reputation = 0;",
    "        Instant createdAt = Instant.now();",
    "        boolean isModerator = false;",
    "        boolean isBanned = false;",
    "        double spamScore = 0.0;",
    "    }",
    "",
    "    static class Question {",
    "        String questionId;",
    "        String authorId;",
    "        String title;",
    "        String body;",
    "        List<String> tags;",
    "        Instant createdAt = Instant.now();",
    "        int voteCount = 0;",
    "        int viewCount = 0;",
    "        boolean isDeleted = false;",
    "    }",
    "",
    "    static class APIResponse {",
    "        boolean success;",
    "        Object data;",
    "        String error;",
    "        int statusCode;",
    "        Map<String, Object> rateLimitInfo;",
    "        ",
    "        static APIResponse success(Object data) {",
    "            APIResponse r = new APIResponse();",
    "            r.success = true;",
    "            r.data = data;",
    "            r.statusCode = 200;",
    "            return r;",
    "        }",
    "        ",
    "        static APIResponse error(String error, int status) {",
    "            APIResponse r = new APIResponse();",
    "            r.success = false;",
    "            r.error = error;",
    "            r.statusCode = status;",
    "            return r;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // TOKEN BUCKET RATE LIMITER",
    "    // ========================================================================",
    "",
    "    static class TokenBucket {",
    "        private final double capacity;",
    "        private final double refillRate;",
    "        private double tokens;",
    "        private long lastRefillTime;",
    "        private final ReentrantLock lock = new ReentrantLock();",
    "        ",
    "        TokenBucket(double capacity, double refillRate) {",
    "            this.capacity = capacity;",
    "            this.refillRate = refillRate;",
    "            this.tokens = capacity;",
    "            this.lastRefillTime = System.nanoTime();",
    "        }",
    "        ",
    "        private void refill() {",
    "            long now = System.nanoTime();",
    "            double elapsed = (now - lastRefillTime) / 1_000_000_000.0;",
    "            tokens = Math.min(capacity, tokens + elapsed * refillRate);",
    "            lastRefillTime = now;",
    "        }",
    "        ",
    "        boolean consume() {",
    "            lock.lock();",
    "            try {",
    "                refill();",
    "                if (tokens >= 1) {",
    "                    tokens -= 1;",
    "                    return true;",
    "                }",
    "                return false;",
    "            } finally {",
    "                lock.unlock();",
    "            }",
    "        }",
    "        ",
    "        int getRemaining() {",
    "            lock.lock();",
    "            try {",
    "                refill();",
    "                return (int) tokens;",
    "            } finally {",
    "                lock.unlock();",
    "            }",
    "        }",
    "    }",
    "",
    "    static class RateLimiter {",
    "        private final ConcurrentHashMap<String, TokenBucket> buckets = new ConcurrentHashMap<>();",
    "        private final int requestsPerMinute;",
    "        private final int burstSize;",
    "        ",
    "        RateLimiter(int requestsPerMinute, int burstSize) {",
    "            this.requestsPerMinute = requestsPerMinute;",
    "            this.burstSize = burstSize;",
    "        }",
    "        ",
    "        boolean isAllowed(String userId, String ipAddress) {",
    "            TokenBucket ipBucket = buckets.computeIfAbsent(",
    "                \"ip:\" + ipAddress,",
    "                k -> new TokenBucket(burstSize, requestsPerMinute / 60.0)",
    "            );",
    "            ",
    "            if (!ipBucket.consume()) return false;",
    "            ",
    "            if (userId != null) {",
    "                TokenBucket userBucket = buckets.computeIfAbsent(",
    "                    \"user:\" + userId,",
    "                    k -> new TokenBucket(burstSize, requestsPerMinute / 60.0)",
    "                );",
    "                return userBucket.consume();",
    "            }",
    "            return true;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // INPUT VALIDATOR",
    "    // ========================================================================",
    "",
    "    static class InputValidator {",
    "        private static final Pattern USERNAME = Pattern.compile(\"^[a-zA-Z0-9_]{3,30}$\");",
    "        private static final Pattern EMAIL = Pattern.compile(\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-.]+$\");",
    "        private static final Pattern SCRIPT = Pattern.compile(\"<script[^>]*>.*?</script>\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);",
    "        ",
    "        static String sanitizeHtml(String content) {",
    "            if (content == null) return \"\";",
    "            content = SCRIPT.matcher(content).replaceAll(\"\");",
    "            return content",
    "                .replace(\"&\", \"&amp;\")",
    "                .replace(\"<\", \"&lt;\")",
    "                .replace(\">\", \"&gt;\")",
    "                .replace(\"\\\"\", \"&quot;\")",
    "                .replace(\"'\", \"&#x27;\");",
    "        }",
    "        ",
    "        static List<String> validateUsername(String username) {",
    "            List<String> errors = new ArrayList<>();",
    "            if (username == null || username.isEmpty()) {",
    "                errors.add(\"Username is required\");",
    "            } else if (!USERNAME.matcher(username).matches()) {",
    "                errors.add(\"Invalid username format\");",
    "            }",
    "            return errors;",
    "        }",
    "        ",
    "        static List<String> validateEmail(String email) {",
    "            List<String> errors = new ArrayList<>();",
    "            if (email == null || email.isEmpty()) {",
    "                errors.add(\"Email is required\");",
    "            } else if (!EMAIL.matcher(email).matches()) {",
    "                errors.add(\"Invalid email format\");",
    "            }",
    "            return errors;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // LRU CACHE",
    "    // ========================================================================",
    "",
    "    static class LRUCache<K, V> extends LinkedHashMap<K, V> {",
    "        private final int maxSize;",
    "        private int hits = 0;",
    "        private int misses = 0;",
    "        ",
    "        LRUCache(int maxSize) {",
    "            super(16, 0.75f, true);",
    "            this.maxSize = maxSize;",
    "        }",
    "        ",
    "        @Override",
    "        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {",
    "            return size() > maxSize;",
    "        }",
    "        ",
    "        @Override",
    "        public synchronized V get(Object key) {",
    "            V value = super.get(key);",
    "            if (value != null) hits++;",
    "            else misses++;",
    "            return value;",
    "        }",
    "        ",
    "        double getHitRate() {",
    "            int total = hits + misses;",
    "            return total > 0 ? (double) hits / total : 0;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // SPAM DETECTOR",
    "    // ========================================================================",
    "",
    "    static class SpamDetector {",
    "        private static final Pattern[] SPAM_PATTERNS = {",
    "            Pattern.compile(\"\\\\b(buy|cheap|discount|free|offer)\\\\b\", Pattern.CASE_INSENSITIVE),",
    "            Pattern.compile(\"https?://[^\\\\s]+\"),",
    "            Pattern.compile(\"[A-Z]{5,}\"),",
    "            Pattern.compile(\"[!?]{3,}\")",
    "        };",
    "        ",
    "        static double calculateSpamScore(String content, User user) {",
    "            double score = 0.0;",
    "            ",
    "            for (Pattern pattern : SPAM_PATTERNS) {",
    "                Matcher m = pattern.matcher(content);",
    "                int count = 0;",
    "                while (m.find()) count++;",
    "                if (count > 0) score += 0.2 * Math.min(count, 3);",
    "            }",
    "            ",
    "            if (user.reputation < 10) score += 0.2;",
    "            score += user.spamScore * 0.3;",
    "            ",
    "            return Math.min(score, 1.0);",
    "        }",
    "        ",
    "        static boolean isSpam(String content, User user) {",
    "            return calculateSpamScore(content, user) >= 0.7;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN API CLASS",
    "    // ========================================================================",
    "",
    "    private final Map<String, User> users = new ConcurrentHashMap<>();",
    "    private final Map<String, Question> questions = new ConcurrentHashMap<>();",
    "    private final Map<String, String> usernameToId = new ConcurrentHashMap<>();",
    "    private final RateLimiter rateLimiter = new RateLimiter(100, 10);",
    "    private final LRUCache<String, Object> cache = new LRUCache<>(10000);",
    "",
    "    public APIResponse registerUser(String username, String email, String password, String ip) {",
    "        if (!rateLimiter.isAllowed(null, ip)) {",
    "            return APIResponse.error(\"Rate limit exceeded\", 429);",
    "        }",
    "        ",
    "        List<String> errors = new ArrayList<>();",
    "        errors.addAll(InputValidator.validateUsername(username));",
    "        errors.addAll(InputValidator.validateEmail(email));",
    "        if (password.length() < 8) errors.add(\"Password too short\");",
    "        ",
    "        if (!errors.isEmpty()) {",
    "            return APIResponse.error(errors.toString(), 400);",
    "        }",
    "        ",
    "        if (usernameToId.containsKey(username.toLowerCase())) {",
    "            return APIResponse.error(\"Username taken\", 409);",
    "        }",
    "        ",
    "        User user = new User();",
    "        user.userId = UUID.randomUUID().toString();",
    "        user.username = username;",
    "        user.email = email;",
    "        user.passwordHash = hashPassword(password);",
    "        ",
    "        users.put(user.userId, user);",
    "        usernameToId.put(username.toLowerCase(), user.userId);",
    "        ",
    "        Map<String, String> data = new HashMap<>();",
    "        data.put(\"userId\", user.userId);",
    "        data.put(\"username\", username);",
    "        return APIResponse.success(data);",
    "    }",
    "",
    "    public APIResponse createQuestion(String userId, String title, String body, List<String> tags, String ip) {",
    "        if (!rateLimiter.isAllowed(userId, ip)) {",
    "            return APIResponse.error(\"Rate limit exceeded\", 429);",
    "        }",
    "        ",
    "        User user = users.get(userId);",
    "        if (user == null) {",
    "            return APIResponse.error(\"User not found\", 404);",
    "        }",
    "        ",
    "        if (title.length() < 15 || body.length() < 30) {",
    "            return APIResponse.error(\"Content too short\", 400);",
    "        }",
    "        ",
    "        String sanitizedTitle = InputValidator.sanitizeHtml(title);",
    "        String sanitizedBody = InputValidator.sanitizeHtml(body);",
    "        ",
    "        if (SpamDetector.isSpam(title + \" \" + body, user)) {",
    "            user.spamScore = Math.min(1.0, user.spamScore + 0.2);",
    "            return APIResponse.error(\"Content flagged as spam\", 422);",
    "        }",
    "        ",
    "        Question q = new Question();",
    "        q.questionId = UUID.randomUUID().toString();",
    "        q.authorId = userId;",
    "        q.title = sanitizedTitle;",
    "        q.body = sanitizedBody;",
    "        q.tags = tags;",
    "        ",
    "        questions.put(q.questionId, q);",
    "        ",
    "        Map<String, String> data = new HashMap<>();",
    "        data.put(\"questionId\", q.questionId);",
    "        return APIResponse.success(data);",
    "    }",
    "",
    "    private String hashPassword(String password) {",
    "        try {",
    "            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");",
    "            byte[] hash = md.digest(password.getBytes());",
    "            StringBuilder sb = new StringBuilder();",
    "            for (byte b : hash) sb.append(String.format(\"%02x\", b));",
    "            return sb.toString();",
    "        } catch (Exception e) {",
    "            throw new RuntimeException(e);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // DEMO",
    "    // ========================================================================",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"STACK OVERFLOW API - Part 4: Security & Scalability\");",
    "        System.out.println(\"=\" .repeat(60));",
    "        ",
    "        StackOverflowSecureAPI api = new StackOverflowSecureAPI();",
    "        String ip = \"127.0.0.1\";",
    "        ",
    "        // Register user",
    "        System.out.println(\"\\n\ud83d\udcdd User Registration:\");",
    "        APIResponse result = api.registerUser(\"john_doe\", \"john@example.com\", \"password123\", ip);",
    "        System.out.println(\"Result: \" + result.success + \", \" + result.data);",
    "        ",
    "        String userId = ((Map<String, String>) result.data).get(\"userId\");",
    "        ",
    "        // Create question",
    "        System.out.println(\"\\n\u2753 Question Creation:\");",
    "        result = api.createQuestion(",
    "            userId,",
    "            \"How do I implement rate limiting in Java?\",",
    "            \"I need to implement a token bucket rate limiter. What is the best approach for handling concurrent requests?\",",
    "            Arrays.asList(\"java\", \"rate-limiting\"),",
    "            ip",
    "        );",
    "        System.out.println(\"Result: \" + result.success + \", \" + result.data);",
    "        ",
    "        // Spam detection",
    "        System.out.println(\"\\n\ud83d\udee1\ufe0f Spam Detection:\");",
    "        result = api.createQuestion(",
    "            userId,",
    "            \"BUY CHEAP!!! FREE OFFER!!! CLICK NOW!!!\",",
    "            \"Visit http://spam.com for FREE products! AMAZING DISCOUNT!!!\",",
    "            Arrays.asList(\"spam\"),",
    "            ip",
    "        );",
    "        System.out.println(\"Spam detected: \" + result.error);",
    "        ",
    "        // Rate limiting demo",
    "        System.out.println(\"\\n\u23f1\ufe0f Rate Limiting Demo:\");",
    "        int limited = 0;",
    "        for (int i = 0; i < 15; i++) {",
    "            if (!api.rateLimiter.isAllowed(null, ip)) limited++;",
    "        }",
    "        System.out.println(\"Rate limited requests: \" + limited);",
    "        ",
    "        System.out.println(\"\\n\u2705 Demo completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-30",
      "explanation": "Module docstring and imports - includes threading, security, regex for comprehensive security implementation"
    },
    {
      "lines": "35-100",
      "explanation": "Core data models (User, Question, Answer, Vote) with security-relevant fields like password_hash, spam_score, is_banned"
    },
    {
      "lines": "105-180",
      "explanation": "TokenBucket class implements O(1) rate limiting with thread-safe consume() method. Supports burst traffic while enforcing average rate"
    },
    {
      "lines": "185-250",
      "explanation": "RateLimiter wraps TokenBucket with per-user AND per-IP limiting. Returns remaining quota in response headers"
    },
    {
      "lines": "255-350",
      "explanation": "Authenticator implements JWT-style tokens with HMAC signatures. Stateless verification, token revocation support"
    },
    {
      "lines": "355-470",
      "explanation": "InputValidator provides XSS sanitization (html.escape), validation patterns, and SQL injection detection"
    },
    {
      "lines": "475-560",
      "explanation": "LRUCache implements thread-safe caching with TTL. OrderedDict for LRU eviction, tracks hit/miss statistics"
    },
    {
      "lines": "565-640",
      "explanation": "SpamDetector uses heuristic scoring - pattern matching, user reputation, account age, link density analysis"
    },
    {
      "lines": "645-700",
      "explanation": "APIResponse wrapper standardizes all responses with success/error status, rate limit info, and timestamps"
    },
    {
      "lines": "705-900",
      "explanation": "StackOverflowAPI class integrates all security components. Each endpoint follows: rate limit \u2192 auth \u2192 validate \u2192 cache check \u2192 business logic \u2192 cache update"
    },
    {
      "lines": "905-1100",
      "explanation": "Complete demo showcasing: validation errors, successful flows, spam detection, caching performance, rate limiting"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "rate_limit_check": {
          "complexity": "O(1)",
          "explanation": "Token bucket consume is constant time - just compare and decrement"
        },
        "auth_verify": {
          "complexity": "O(1)",
          "explanation": "HMAC comparison and JSON parsing are constant time for fixed token size"
        },
        "input_validation": {
          "complexity": "O(n)",
          "explanation": "Linear scan through content for pattern matching, where n is content length"
        },
        "cache_get": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup with LRU reordering"
        },
        "spam_detection": {
          "complexity": "O(n*p)",
          "explanation": "n = content length, p = number of patterns (constant)"
        }
      },
      "overall_change": "Security layers add constant overhead per request. Cache hits reduce DB queries to O(1). Rate limiting prevents DoS by rejecting excess requests early."
    },
    "space": {
      "additional_space": "O(users + cache_size + active_tokens)",
      "explanation": "Rate limiter: O(active_users + active_IPs) buckets. Cache: O(max_cache_size) entries. Revoked tokens: O(revocations within TTL window)"
    }
  },
  "dry_run": {
    "example_input": "User creates question after registration and login",
    "steps": [
      {
        "step": 1,
        "action": "register_user('john', 'john@ex.com', 'pass123')",
        "state": "Check rate limit (IP bucket), validate inputs",
        "explanation": "Rate limiter creates new bucket for IP, validates username/email patterns"
      },
      {
        "step": 2,
        "action": "Rate limit passes",
        "state": "IP bucket: 9 tokens remaining",
        "explanation": "Token consumed, request allowed to proceed"
      },
      {
        "step": 3,
        "action": "Validation passes",
        "state": "Create User object",
        "explanation": "Username matches [a-zA-Z0-9_]{3,30}, email valid, password hashed with SHA-256"
      },
      {
        "step": 4,
        "action": "login('john', 'pass123')",
        "state": "Verify password, generate JWT",
        "explanation": "Hash password, compare with stored hash, create signed token"
      },
      {
        "step": 5,
        "action": "create_question(token, title, body, tags)",
        "state": "Verify JWT signature",
        "explanation": "Extract payload, recompute HMAC, compare signatures"
      },
      {
        "step": 6,
        "action": "Auth passes",
        "state": "Check rate limit (user bucket)",
        "explanation": "User bucket created, token consumed"
      },
      {
        "step": 7,
        "action": "Input validation",
        "state": "Check lengths, sanitize HTML",
        "explanation": "Title >= 15 chars, body >= 30 chars, escape HTML entities"
      },
      {
        "step": 8,
        "action": "Spam detection",
        "state": "Score = 0.2 (new user)",
        "explanation": "Low score (< 0.7), content allowed"
      },
      {
        "step": 9,
        "action": "Store question",
        "state": "Invalidate search cache",
        "explanation": "Add to questions map, invalidate 'search:*' cache keys"
      },
      {
        "step": 10,
        "action": "Return success response",
        "state": "Include rate_limit_info",
        "explanation": "Return question_id, remaining rate limit quota"
      }
    ],
    "final_output": "{'success': true, 'data': {'question_id': 'uuid...'}, 'rate_limit': {'remaining': 8}}"
  },
  "edge_cases": [
    {
      "case": "Expired JWT token",
      "handling": "Check exp claim against current time, raise AuthenticationError",
      "gotcha": "Remember to handle clock skew in distributed systems - allow small grace period"
    },
    {
      "case": "Rate limit exactly at boundary",
      "handling": "Token bucket with floating point handles fractional tokens, atomic consume",
      "gotcha": "Use thread locks to prevent race conditions in consume()"
    },
    {
      "case": "Cache stampede on popular question",
      "handling": "Consider cache locks or probabilistic early expiration",
      "gotcha": "Many concurrent cache misses can overwhelm database"
    },
    {
      "case": "XSS in username display",
      "handling": "Sanitize ALL user input on storage AND display",
      "gotcha": "Don't assume stored data is safe - defense in depth"
    },
    {
      "case": "Slow spam detection blocking requests",
      "handling": "Run spam check async, allow post but flag for review",
      "gotcha": "Sync spam check adds latency - consider async queue"
    },
    {
      "case": "User changes vote",
      "handling": "Remove old vote effect before applying new",
      "gotcha": "Vote count can go negative if not tracking vote changes properly"
    }
  ],
  "test_cases": [
    {
      "name": "Rate limiting enforces burst limit",
      "input": "15 rapid requests from same IP",
      "expected": "First 10 succeed (burst), remaining 5 rate limited (429)",
      "explanation": "Token bucket starts with 10 tokens (burst size), refills at 100/60 per second"
    },
    {
      "name": "XSS attack prevented",
      "input": "title = '<script>alert(1)</script>Hello'",
      "expected": "Stored as '&lt;script&gt;alert(1)&lt;/script&gt;Hello'",
      "explanation": "HTML entities escaped, script tags neutralized"
    },
    {
      "name": "Spam detection blocks suspicious content",
      "input": "New user posts 'BUY CHEAP!!! http://spam.com http://spam2.com'",
      "expected": "422 response, spam score > 0.7",
      "explanation": "Multiple triggers: spam keywords (0.3) + links (0.4) + new user (0.2)"
    },
    {
      "name": "Cache hit improves performance",
      "input": "Same question fetched twice",
      "expected": "Second request returns cached data, cache hit rate increases",
      "explanation": "First request populates cache, subsequent requests bypass database"
    },
    {
      "name": "Token expiration enforced",
      "input": "Use token after TTL expires",
      "expected": "401 Unauthorized",
      "explanation": "JWT exp claim checked on every request"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Storing plain text passwords",
      "why_wrong": "Database breach exposes all user credentials",
      "correct_approach": "Hash passwords with bcrypt/argon2, never store plain text",
      "code_example_wrong": "user.password = request.password  # NEVER DO THIS",
      "code_example_correct": "user.password_hash = bcrypt.hash(request.password)"
    },
    {
      "mistake": "Rate limiting only by user ID",
      "why_wrong": "Unauthenticated attacks bypass limit, single IP can spam",
      "correct_approach": "Rate limit by BOTH user ID AND IP address",
      "code_example_wrong": "if user_id: check_limit(user_id)",
      "code_example_correct": "check_limit(ip) and (not user_id or check_limit(user_id))"
    },
    {
      "mistake": "Caching user-specific data globally",
      "why_wrong": "User A sees User B's private data",
      "correct_approach": "Include user_id in cache key for personalized data",
      "code_example_wrong": "cache_key = f'dashboard'",
      "code_example_correct": "cache_key = f'dashboard:{user_id}'"
    },
    {
      "mistake": "Not invalidating cache on writes",
      "why_wrong": "Users see stale data after updates",
      "correct_approach": "Invalidate or update cache entries when data changes",
      "code_example_wrong": "self._questions[id] = updated  # Cache still has old data",
      "code_example_correct": "self._questions[id] = updated; self._cache.delete(f'question:{id}')"
    },
    {
      "mistake": "Blocking on spam detection",
      "why_wrong": "Complex ML models add latency to every request",
      "correct_approach": "Use fast heuristics sync, defer heavy analysis to async queue",
      "code_example_wrong": "result = slow_ml_model.predict(content)  # 500ms",
      "code_example_correct": "if fast_heuristic_check(content): queue_for_review(content)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start with the architecture diagram showing security layers. Explain that security is a cross-cutting concern best handled via middleware/decorators. Walk through a single request showing each layer's responsibility. Discuss trade-offs (consistency vs availability, security vs UX).",
    "what_to_mention": [
      "Token Bucket is industry standard for rate limiting (used by Stripe, AWS)",
      "JWT tokens enable stateless auth - critical for horizontal scaling",
      "Cache-aside pattern with TTL handles eventual consistency",
      "Spam detection should be async for user experience",
      "Always sanitize input AND output (defense in depth)",
      "Mention monitoring: track rate limit hits, cache hit rates, spam flags"
    ],
    "time_allocation": "2 min on architecture overview, 3 min on rate limiting (most asked), 3 min on auth/authz, 2 min on caching, 2 min on spam detection, 3 min on sharding/scaling discussion",
    "if_stuck": [
      "For rate limiting: Think about buckets filling with tokens over time",
      "For auth: JWT = payload + signature, stateless verification",
      "For caching: What data changes rarely but is read frequently?",
      "For sharding: What's the access pattern? Co-locate related data"
    ]
  },
  "connection_to_next_part": "Part 4 establishes the security and scalability foundation. A potential Part 5 could focus on: (1) Implementing a notification system for votes/answers using message queues, (2) Building a reputation system with badges and privileges, (3) Adding real-time features with WebSockets, or (4) Implementing a question recommendation engine based on user activity.",
  "generated_at": "2026-01-14T18:46:25.131709",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}