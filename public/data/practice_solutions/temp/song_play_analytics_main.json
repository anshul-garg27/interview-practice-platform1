{
  "problem_title": "Song Play Analytics System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP Design** problem that tests fundamental data structure knowledge. At its core, we need to track unique values (listeners) per entity (song) and generate sorted reports. The problem is straightforward but has subtle requirements around uniqueness tracking and custom sorting.",
    "pattern_recognition": "**HashMap + Set + Custom Sorting** - HashMap for O(1) song lookup by ID, Set for automatic unique user tracking, and custom comparator for the two-level sort requirement.",
    "key_constraints": [
      "**Unique listeners only** - Same user playing same song multiple times counts as 1 listener. This screams 'Set'!",
      "**IDs start from 1** - Common trap; many will accidentally start from 0",
      "**Two-level sorting** - Primary: count DESC, Secondary: name ASC. Must handle both directions correctly",
      "**Error handling required** - Invalid song_id must print specific error message",
      "**Songs with 0 listeners included** - Can't skip songs that haven't been played"
    ],
    "clarifying_questions": [
      "**Can the same song name be added twice?** - Yes, creates separate entries with different IDs",
      "**What should happen for invalid song_id?** - Print specific error message, don't throw exception",
      "**Should songs with 0 listeners appear in analytics?** - Yes, they should still be listed",
      "**Is user_id always positive?** - According to constraints, 1 \u2264 user_id \u2264 10^6",
      "**Can we assume song names are non-empty?** - Yes, 1 \u2264 name.length \u2264 100",
      "**How should ties be handled in sorting?** - Lexicographically by name (ascending)",
      "**Is this a single-threaded system?** - Assume yes for Part 1 (thread safety for follow-ups)"
    ],
    "edge_cases_to_consider": [
      "Same user plays same song multiple times",
      "Song with 0 listeners",
      "All songs have same listener count (test alphabetical sorting)",
      "Invalid song_id (doesn't exist)",
      "Duplicate song names (should create separate entries)",
      "Single song, single user (minimal case)",
      "Large number of listeners for one song"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SONG ANALYTICS SYSTEM                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502   add_song()     \u2502\u2500\u2500\u2500\u2500\u2500>\u2502  songs HashMap             \u2502       \u2502\n\u2502  \u2502                  \u2502      \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502       \u2502\n\u2502  \u2502 \"Bohemian\"  \u2500> 1 \u2502      \u2502  \u2502 ID  \u2502 Song Object    \u2502  \u2502       \u2502\n\u2502  \u2502 \"Hotel\"     \u2500> 2 \u2502      \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502  \u2502  1  \u2502 name: Bohemian \u2502  \u2502       \u2502\n\u2502                            \u2502  \u2502     \u2502 listeners:{1,2}\u2502  \u2502       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502  \u2502  2  \u2502 name: Hotel    \u2502  \u2502       \u2502\n\u2502  \u2502   play_song()    \u2502\u2500\u2500\u2500\u2500\u2500>\u2502  \u2502     \u2502 listeners:{1}  \u2502  \u2502       \u2502\n\u2502  \u2502                  \u2502      \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502       \u2502\n\u2502  \u2502 song:1, user:1   \u2502      \u2502                            \u2502       \u2502\n\u2502  \u2502 song:1, user:2   \u2502      \u2502  nextId: 3                 \u2502       \u2502\n\u2502  \u2502 song:1, user:1   \u2502(dup) \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502 print_analytics()\u2502\u2500\u2500\u2500\u2500\u2500>\u2502  Sorted Output             \u2502       \u2502\n\u2502  \u2502                  \u2502      \u2502  1. Bohemian (2 unique)    \u2502       \u2502\n\u2502  \u2502  Sort by:        \u2502      \u2502  2. Hotel (1 unique)       \u2502       \u2502\n\u2502  \u2502  - count DESC    \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502  \u2502  - name ASC      \u2502                                           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n                     INTERNAL STATE EVOLUTION\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nInitial State:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  songs: {}  (empty HashMap)                                      \u2502\n\u2502  nextId: 1                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAfter add_song(\"Song A\"), add_song(\"Song B\"):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  songs: {                                                        \u2502\n\u2502    1: Song(name=\"Song A\", listeners=Set())                      \u2502\n\u2502    2: Song(name=\"Song B\", listeners=Set())                      \u2502\n\u2502  }                                                               \u2502\n\u2502  nextId: 3                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAfter play_song(1, 101), play_song(1, 102), play_song(1, 101):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  songs: {                                                        \u2502\n\u2502    1: Song(name=\"Song A\", listeners={101, 102})  \u2190 Only 2!      \u2502\n\u2502    2: Song(name=\"Song B\", listeners=Set())                      \u2502\n\u2502  }                                                               \u2502\n\u2502  Duplicate user 101 automatically ignored by Set                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize empty HashMap for songs and counter at 1",
        "visualization": "songs = {}\nnextId = 1",
        "key_point": "Start ID from 1, not 0!"
      },
      {
        "step": 2,
        "description": "add_song() creates Song object, assigns ID, stores in HashMap",
        "visualization": "songs[nextId] = Song(name)\nnextId++\nreturn assigned_id",
        "key_point": "Post-increment ensures IDs start at 1"
      },
      {
        "step": 3,
        "description": "play_song() validates ID, then adds user to Set",
        "visualization": "if song_id not in songs:\n  print error\nelse:\n  songs[song_id].listeners.add(user_id)",
        "key_point": "Set.add() handles duplicates automatically"
      },
      {
        "step": 4,
        "description": "print_analytics() collects, sorts, prints",
        "visualization": "all_songs = songs.values()\nsorted_songs = sort(all_songs, key=...)\nfor song in sorted_songs:\n  print(format(song))",
        "key_point": "Two-level sort: count DESC, name ASC"
      }
    ],
    "dry_run_table": "| Step | Operation | songs State | nextId | Output/Return |\n|------|-----------|-------------|--------|---------------|\n| 1 | `SongAnalytics()` | `{}` | 1 | - |\n| 2 | `add_song(\"Song A\")` | `{1: Song(A, {})}` | 2 | **1** |\n| 3 | `add_song(\"Song B\")` | `{1: Song(A, {}), 2: Song(B, {})}` | 3 | **2** |\n| 4 | `add_song(\"Song C\")` | `{1: Song(A, {}), 2: Song(B, {}), 3: Song(C, {})}` | 4 | **3** |\n| 5 | `play_song(1, 1)` | `{1: Song(A, {1}), ...}` | 4 | - |\n| 6 | `play_song(1, 2)` | `{1: Song(A, {1,2}), ...}` | 4 | - |\n| 7 | `play_song(2, 1)` | `{..., 2: Song(B, {1}), ...}` | 4 | - |\n| 8 | `play_song(3, 3)` | `{..., 3: Song(C, {3})}` | 4 | - |\n| 9 | `play_song(3, 3)` | `{..., 3: Song(C, {3})}` \u2190 **No change!** | 4 | - |\n| 10 | `print_analytics()` | - | - | Song A (2)\\nSong B (1)\\nSong C (1) |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'unique listeners'**, I immediately think **Set**. Sets automatically handle deduplication - adding the same user twice has no effect.",
      "**When I see 'lookup by ID'**, I think **HashMap**. We need O(1) lookup when play_song() is called with a song_id.",
      "**When I see 'auto-incrementing ID from 1'**, I think of a simple counter. Important: start at 1, not 0!",
      "**When I see 'sort by X DESC, then Y ASC'**, I think **custom comparator**. In Python, use tuple keys with negation for descending. In Java, use Comparator.comparing().thenComparing().",
      "**When I see OOP design**, I think about **separation of concerns**. Song is an entity - give it its own class. SongAnalytics is the service layer.",
      "**The key insight is**: Use Set for automatic uniqueness, HashMap for O(1) lookup, and custom sorting for the analytics."
    ],
    "key_insight": "The problem cleverly tests whether you understand that **popularity by unique reach** differs from **raw play count**. The Set data structure perfectly models this - it doesn't care how many times you add the same element.",
    "why_this_works": "**Set** provides O(1) membership test and automatic deduplication. **HashMap** provides O(1) song lookup. The **two-level sort** can be achieved with a single sort call using the right comparator. Together, all operations are efficient: add_song O(1), play_song O(1), print_analytics O(n log n) where n = number of songs."
  },
  "approaches": [
    {
      "name": "Brute Force - Using Lists",
      "description": "Store listeners in a List instead of Set. On each play, linearly search to check if user already exists.",
      "pseudocode": "class Song:\n  listeners = []\n\ndef play_song(song_id, user_id):\n  if user_id not in song.listeners:  # O(n) search!\n    song.listeners.append(user_id)",
      "time_complexity": "O(k) per play_song where k = number of listeners for that song",
      "space_complexity": "O(n) for n total listeners",
      "pros": [
        "Simple to understand",
        "No Set knowledge required"
      ],
      "cons": [
        "O(k) per play instead of O(1)",
        "Could be O(100,000) for popular songs",
        "Inefficient for high-frequency plays"
      ],
      "when_to_use": "Never in production - only if Sets are somehow unavailable"
    },
    {
      "name": "Optimal: HashMap + Set + Custom Sorting",
      "description": "Use HashMap<ID, Song> for O(1) song lookup, Set<Integer> in each Song for O(1) unique listener tracking, and custom comparator for sorting.",
      "pseudocode": "class Song:\n  name: str\n  listeners: Set<int>\n  \ndef add_song(name):\n  songs[nextId] = Song(name)\n  return nextId++\n  \ndef play_song(song_id, user_id):\n  songs[song_id].listeners.add(user_id)  # O(1)!\n  \ndef print_analytics():\n  sorted_songs = sort(songs.values(),\n    key = lambda s: (-len(s.listeners), s.name))\n  for song in sorted_songs:\n    print(f\"{song.name} ({len(s.listeners)} unique listeners)\")",
      "time_complexity": "add_song: O(1), play_song: O(1), print_analytics: O(n log n)",
      "space_complexity": "O(S + L) where S = songs, L = total unique listener entries",
      "pros": [
        "All operations are optimal",
        "Clean OOP design",
        "Scalable to production"
      ],
      "cons": [
        "Slightly more code than brute force",
        "Need to understand custom sorting"
      ],
      "key_insight": "Use Set.add() for O(1) unique tracking - it handles duplicates automatically!"
    }
  ],
  "optimal_solution": {
    "name": "HashMap + Set with Custom Comparator",
    "explanation_md": "## Approach\n\nWe design two classes following **Single Responsibility Principle**:\n\n### 1. Song Class (Entity)\n- Stores song name and its unique listeners\n- Encapsulates listener management (adding, counting)\n- Has methods: `add_listener()`, `get_listener_count()`, `get_name()`\n\n### 2. SongAnalytics Class (Service)\n- Manages the collection of songs\n- Handles ID assignment\n- Provides analytics functionality\n\n### Why This Works\n\n1. **Set for Uniqueness**: When user 101 plays song 1 three times:\n   ```python\n   listeners = set()\n   listeners.add(101)  # {101}\n   listeners.add(101)  # {101} - no change!\n   listeners.add(101)  # {101} - still no change!\n   len(listeners)  # 1\n   ```\n\n2. **HashMap for O(1) Lookup**: Finding a song by ID is instant.\n\n3. **Custom Sort for Analytics**:\n   ```python\n   # Python trick: negate count for descending, name for ascending\n   sorted(songs, key=lambda s: (-s.count, s.name))\n   ```",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Song>",
        "purpose": "O(1) song lookup by ID"
      },
      {
        "structure": "Set<Integer> in Song",
        "purpose": "O(1) unique listener tracking with automatic deduplication"
      },
      {
        "structure": "int nextId",
        "purpose": "Auto-incrementing ID counter starting at 1"
      }
    ],
    "algorithm_steps": [
      "1. **__init__**: Create empty HashMap for songs, set nextId = 1",
      "2. **add_song**: Create Song object, store at current nextId, increment counter, return ID",
      "3. **play_song**: Validate song_id exists (print error if not), add user_id to song's listener Set",
      "4. **print_analytics**: Collect all songs, sort by (-listener_count, name), print formatted output"
    ],
    "why_set_over_list": "Using a List would require O(k) linear scan to check if user exists before adding. Set's add() is O(1) and handles duplicates automatically - if user already exists, it simply does nothing."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Song Play Analytics System",
    "",
    "A music streaming analytics system that tracks unique listeners per song",
    "and generates sorted analytics reports.",
    "",
    "Time Complexity:",
    "    - add_song: O(1)",
    "    - play_song: O(1)",
    "    - print_analytics: O(n log n) where n = number of songs",
    "",
    "Space Complexity: O(S + L) where S = songs, L = total listener entries",
    "\"\"\"",
    "",
    "from typing import Set, Dict, List",
    "",
    "",
    "class Song:",
    "    \"\"\"Represents a song with its unique listeners.\"\"\"",
    "    ",
    "    def __init__(self, name: str) -> None:",
    "        \"\"\"",
    "        Initialize a song with a name and empty listener set.",
    "        ",
    "        Args:",
    "            name: The name of the song",
    "        \"\"\"",
    "        self._name: str = name",
    "        self._listeners: Set[int] = set()",
    "    ",
    "    def add_listener(self, user_id: int) -> None:",
    "        \"\"\"",
    "        Add a listener to this song. Duplicates are automatically ignored.",
    "        ",
    "        Args:",
    "            user_id: The unique identifier of the user",
    "        \"\"\"",
    "        self._listeners.add(user_id)",
    "    ",
    "    def get_listener_count(self) -> int:",
    "        \"\"\"Return the number of unique listeners.\"\"\"",
    "        return len(self._listeners)",
    "    ",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the song name.\"\"\"",
    "        return self._name",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Song('{self._name}', listeners={len(self._listeners)})\"",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Analytics system for tracking song plays and generating reports.",
    "    ",
    "    Tracks unique listeners per song (not raw play counts) and provides",
    "    sorted analytics based on popularity.",
    "    ",
    "    Example:",
    "        >>> analytics = SongAnalytics()",
    "        >>> song_id = analytics.add_song(\"Bohemian Rhapsody\")",
    "        >>> analytics.play_song(song_id, user_id=101)",
    "        >>> analytics.play_song(song_id, user_id=102)",
    "        >>> analytics.print_analytics()",
    "        Bohemian Rhapsody (2 unique listeners)",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize the analytics system with empty song collection.\"\"\"",
    "        self._songs: Dict[int, Song] = {}",
    "        self._next_id: int = 1  # IDs start from 1, not 0!",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"",
    "        Add a new song to the system.",
    "        ",
    "        Args:",
    "            name: The name of the song to add",
    "            ",
    "        Returns:",
    "            The auto-assigned unique ID for the song (starting from 1)",
    "            ",
    "        Note:",
    "            Same song name can be added multiple times, creating separate entries.",
    "        \"\"\"",
    "        song_id = self._next_id",
    "        self._songs[song_id] = Song(name)",
    "        self._next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"",
    "        Record a play event for the given song by the given user.",
    "        ",
    "        Args:",
    "            song_id: The ID of the song being played",
    "            user_id: The ID of the user playing the song",
    "            ",
    "        Note:",
    "            - Prints error if song_id does not exist",
    "            - Each user is counted only once per song (unique listeners)",
    "        \"\"\"",
    "        if song_id not in self._songs:",
    "            print(f\"Error: Song ID {song_id} does not exist.\")",
    "            return",
    "        ",
    "        self._songs[song_id].add_listener(user_id)",
    "    ",
    "    def print_analytics(self) -> None:",
    "        \"\"\"",
    "        Print all songs sorted by unique listener count.",
    "        ",
    "        Sorting rules:",
    "            1. Primary: Unique listeners (descending - highest first)",
    "            2. Secondary: Song name (ascending - alphabetical)",
    "            ",
    "        Format: \"<song_name> (<count> unique listeners)\"",
    "        \"\"\"",
    "        # Collect all songs",
    "        all_songs: List[Song] = list(self._songs.values())",
    "        ",
    "        # Sort by (-listener_count, name)",
    "        # Negative count for descending, name for ascending",
    "        sorted_songs = sorted(",
    "            all_songs,",
    "            key=lambda song: (-song.get_listener_count(), song.get_name())",
    "        )",
    "        ",
    "        # Print formatted output",
    "        for song in sorted_songs:",
    "            print(f\"{song.get_name()} ({song.get_listener_count()} unique listeners)\")",
    "",
    "",
    "def run_example_1():",
    "    \"\"\"Basic Operations Example.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 1: Basic Operations\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    ",
    "    # Add songs",
    "    id1 = analytics.add_song(\"Song A\")",
    "    id2 = analytics.add_song(\"Song B\")",
    "    id3 = analytics.add_song(\"Song C\")",
    "    print(f\"Added songs with IDs: {id1}, {id2}, {id3}\")",
    "    ",
    "    # Record plays",
    "    analytics.play_song(1, 1)  # User 1 plays Song A",
    "    analytics.play_song(1, 2)  # User 2 plays Song A",
    "    analytics.play_song(2, 1)  # User 1 plays Song B",
    "    analytics.play_song(3, 3)  # User 3 plays Song C",
    "    analytics.play_song(3, 3)  # User 3 plays Song C again (no change)",
    "    ",
    "    print(\"\\nAnalytics Report:\")",
    "    analytics.print_analytics()",
    "",
    "",
    "def run_example_2():",
    "    \"\"\"Tie-Breaking by Name Example.\"\"\"",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 2: Tie-Breaking by Name\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    ",
    "    analytics.add_song(\"Zebra\")",
    "    analytics.add_song(\"Apple\")",
    "    analytics.add_song(\"Mango\")",
    "    ",
    "    analytics.play_song(1, 100)  # Zebra: 1 listener",
    "    analytics.play_song(2, 200)  # Apple: 1 listener",
    "    analytics.play_song(3, 300)  # Mango: 1 listener",
    "    ",
    "    print(\"\\nAll songs have 1 listener - sorted alphabetically:\")",
    "    analytics.print_analytics()",
    "",
    "",
    "def run_example_3():",
    "    \"\"\"Error Handling Example.\"\"\"",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 3: Error Handling\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    analytics.add_song(\"Hello\")",
    "    ",
    "    analytics.play_song(1, 5)    # Valid",
    "    analytics.play_song(999, 5)  # Invalid - should print error",
    "",
    "",
    "def run_example_4():",
    "    \"\"\"Zero Listeners Example.\"\"\"",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 4: Songs with Zero Listeners\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    analytics.add_song(\"Popular\")",
    "    analytics.add_song(\"Unpopular\")",
    "    ",
    "    analytics.play_song(1, 1)  # Only Popular gets played",
    "    ",
    "    print(\"\\nUnpopular song still appears with 0 listeners:\")",
    "    analytics.print_analytics()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_example_1()",
    "    run_example_2()",
    "    run_example_3()",
    "    run_example_4()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Represents a song with its unique listeners.",
    " */",
    "class Song {",
    "    private final String name;",
    "    private final Set<Integer> listeners;",
    "    ",
    "    public Song(String name) {",
    "        this.name = name;",
    "        this.listeners = new HashSet<>();",
    "    }",
    "    ",
    "    /**",
    "     * Add a listener. Duplicates are automatically ignored by Set.",
    "     */",
    "    public void addListener(int userId) {",
    "        listeners.add(userId);",
    "    }",
    "    ",
    "    public int getListenerCount() {",
    "        return listeners.size();",
    "    }",
    "    ",
    "    public String getName() {",
    "        return name;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Song('%s', listeners=%d)\", name, listeners.size());",
    "    }",
    "}",
    "",
    "/**",
    " * Analytics system for tracking song plays and generating reports.",
    " * ",
    " * Tracks unique listeners per song (not raw play counts) and provides",
    " * sorted analytics based on popularity.",
    " * ",
    " * Time Complexity:",
    " *   - addSong: O(1)",
    " *   - playSong: O(1)",
    " *   - printAnalytics: O(n log n) where n = number of songs",
    " * ",
    " * Space Complexity: O(S + L) where S = songs, L = total listener entries",
    " */",
    "public class SongAnalytics {",
    "    private final Map<Integer, Song> songs;",
    "    private int nextId;",
    "    ",
    "    /**",
    "     * Initialize the analytics system with empty song collection.",
    "     */",
    "    public SongAnalytics() {",
    "        this.songs = new HashMap<>();",
    "        this.nextId = 1;  // IDs start from 1, not 0!",
    "    }",
    "    ",
    "    /**",
    "     * Add a new song to the system.",
    "     * ",
    "     * @param name The name of the song to add",
    "     * @return The auto-assigned unique ID for the song (starting from 1)",
    "     */",
    "    public int addSong(String name) {",
    "        int songId = nextId;",
    "        songs.put(songId, new Song(name));",
    "        nextId++;",
    "        return songId;",
    "    }",
    "    ",
    "    /**",
    "     * Record a play event for the given song by the given user.",
    "     * ",
    "     * @param songId The ID of the song being played",
    "     * @param userId The ID of the user playing the song",
    "     */",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            System.out.println(\"Error: Song ID \" + songId + \" does not exist.\");",
    "            return;",
    "        }",
    "        songs.get(songId).addListener(userId);",
    "    }",
    "    ",
    "    /**",
    "     * Print all songs sorted by unique listener count.",
    "     * Primary sort: Unique listeners (descending)",
    "     * Secondary sort: Song name (ascending/alphabetical)",
    "     */",
    "    public void printAnalytics() {",
    "        // Collect all songs",
    "        List<Song> allSongs = new ArrayList<>(songs.values());",
    "        ",
    "        // Sort by listener count DESC, then name ASC",
    "        allSongs.sort((a, b) -> {",
    "            int countCompare = Integer.compare(b.getListenerCount(), a.getListenerCount());",
    "            if (countCompare != 0) {",
    "                return countCompare;  // Different counts: sort by count DESC",
    "            }",
    "            return a.getName().compareTo(b.getName());  // Same count: sort by name ASC",
    "        });",
    "        ",
    "        // Print formatted output",
    "        for (Song song : allSongs) {",
    "            System.out.println(song.getName() + \" (\" + song.getListenerCount() + \" unique listeners)\");",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Demo main method with test cases.",
    "     */",
    "    public static void main(String[] args) {",
    "        // Example 1: Basic Operations",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Example 1: Basic Operations\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        ",
    "        int id1 = analytics.addSong(\"Song A\");",
    "        int id2 = analytics.addSong(\"Song B\");",
    "        int id3 = analytics.addSong(\"Song C\");",
    "        System.out.println(\"Added songs with IDs: \" + id1 + \", \" + id2 + \", \" + id3);",
    "        ",
    "        analytics.playSong(1, 1);",
    "        analytics.playSong(1, 2);",
    "        analytics.playSong(2, 1);",
    "        analytics.playSong(3, 3);",
    "        analytics.playSong(3, 3);  // Duplicate - no change",
    "        ",
    "        System.out.println(\"\\nAnalytics Report:\");",
    "        analytics.printAnalytics();",
    "        ",
    "        // Example 2: Tie-Breaking",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Example 2: Tie-Breaking by Name\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        SongAnalytics analytics2 = new SongAnalytics();",
    "        analytics2.addSong(\"Zebra\");",
    "        analytics2.addSong(\"Apple\");",
    "        analytics2.addSong(\"Mango\");",
    "        analytics2.playSong(1, 100);",
    "        analytics2.playSong(2, 200);",
    "        analytics2.playSong(3, 300);",
    "        ",
    "        System.out.println(\"\\nAll songs have 1 listener - sorted alphabetically:\");",
    "        analytics2.printAnalytics();",
    "        ",
    "        // Example 3: Error Handling",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Example 3: Error Handling\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        SongAnalytics analytics3 = new SongAnalytics();",
    "        analytics3.addSong(\"Hello\");",
    "        analytics3.playSong(1, 5);    // Valid",
    "        analytics3.playSong(999, 5);  // Invalid",
    "        ",
    "        // Example 4: Zero Listeners",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Example 4: Songs with Zero Listeners\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        SongAnalytics analytics4 = new SongAnalytics();",
    "        analytics4.addSong(\"Popular\");",
    "        analytics4.addSong(\"Unpopular\");",
    "        analytics4.playSong(1, 1);",
    "        ",
    "        System.out.println(\"\\nUnpopular song still appears with 0 listeners:\");",
    "        analytics4.printAnalytics();",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-14 (Python)",
      "section": "Module Docstring & Imports",
      "explanation": "We document the overall purpose, time/space complexity at the module level. Import `Set`, `Dict`, `List` from typing for proper type hints."
    },
    {
      "lines": "17-44 (Python)",
      "section": "Song Class",
      "explanation": "**Single Responsibility**: Song only knows about its name and listeners. Uses `Set[int]` for automatic deduplication - when the same user_id is added twice, the set size stays the same. Private attributes with underscores follow Python conventions."
    },
    {
      "lines": "47-69 (Python)",
      "section": "SongAnalytics Class & __init__",
      "explanation": "**Key Design Decisions**: (1) HashMap `_songs` for O(1) lookup by ID, (2) `_next_id` starts at **1** not 0 - this is explicitly stated in requirements and a common mistake!"
    },
    {
      "lines": "71-89 (Python)",
      "section": "add_song Method",
      "explanation": "**ID Assignment Logic**: Capture current `_next_id` first, create Song, increment counter. This ensures IDs are 1, 2, 3... in order. Return the ID to the caller."
    },
    {
      "lines": "91-109 (Python)",
      "section": "play_song Method",
      "explanation": "**Error Handling First**: Check if song_id exists BEFORE trying to access. Print the exact error format from requirements. If valid, `add_listener` handles uniqueness via Set.add()."
    },
    {
      "lines": "111-132 (Python)",
      "section": "print_analytics Method",
      "explanation": "**The Sorting Magic**: `key=lambda song: (-song.get_listener_count(), song.get_name())`. The negative sign on count makes higher counts come first (descending). Name is positive so alphabetical order is ascending. This is the Pythonic way to do multi-level sorting!"
    },
    {
      "lines": "Java Comparator (lines 82-89)",
      "section": "Java Custom Comparator",
      "explanation": "**Java Approach**: Use `Integer.compare(b.getListenerCount(), a.getListenerCount())` for descending (note b vs a order). For ties, use `a.getName().compareTo(b.getName())` for ascending alphabetical."
    }
  ],
  "complexity_analysis": {
    "time": {
      "add_song": {
        "complexity": "O(1)",
        "explanation": "HashMap put operation is O(1) amortized. Creating a Song object is O(1)."
      },
      "play_song": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup is O(1). Set.add() is O(1) amortized. Error check is O(1)."
      },
      "print_analytics": {
        "complexity": "O(n log n)",
        "explanation": "Where n = number of songs. Sorting dominates. Collecting songs is O(n), sorting is O(n log n), printing is O(n)."
      },
      "overall": "add_song and play_song are O(1). print_analytics is O(n log n). This is optimal for the given operations."
    },
    "space": {
      "complexity": "O(S + L)",
      "breakdown": "- **S** = number of songs: HashMap entries\n- **L** = total unique (song, listener) pairs across all songs\n- Each Song object has a Set that could hold up to U users (where U \u2264 10^6)\n- Worst case: every user listens to every song = O(S \u00d7 U)",
      "note": "In practice, L is much smaller than S \u00d7 U because not every user listens to every song."
    },
    "can_we_do_better": "For add_song and play_song, O(1) is optimal. For print_analytics, O(n log n) is optimal since we need sorted output (can't beat comparison-based sorting's lower bound)."
  },
  "dry_run": {
    "example": "add_song(\"Song A\"), add_song(\"Song B\"), add_song(\"Song C\"), play_song(1,1), play_song(1,2), play_song(2,1), play_song(3,3), play_song(3,3), print_analytics()",
    "trace_table": "| Step | Operation | songs State | nextId | Output/Return |\n|------|-----------|-------------|--------|---------------|\n| 0 | `SongAnalytics()` | `{}` | 1 | - |\n| 1 | `add_song(\"Song A\")` | `{1: Song(A, {})}` | 2 | **returns 1** |\n| 2 | `add_song(\"Song B\")` | `{1: Song(A, {}), 2: Song(B, {})}` | 3 | **returns 2** |\n| 3 | `add_song(\"Song C\")` | `{1: Song(A, {}), 2: Song(B, {}), 3: Song(C, {})}` | 4 | **returns 3** |\n| 4 | `play_song(1, 1)` | `{1: Song(A, {1}), 2: Song(B, {}), 3: Song(C, {})}` | 4 | - |\n| 5 | `play_song(1, 2)` | `{1: Song(A, {1,2}), 2: Song(B, {}), 3: Song(C, {})}` | 4 | - |\n| 6 | `play_song(2, 1)` | `{1: Song(A, {1,2}), 2: Song(B, {1}), 3: Song(C, {})}` | 4 | - |\n| 7 | `play_song(3, 3)` | `{1: Song(A, {1,2}), 2: Song(B, {1}), 3: Song(C, {3})}` | 4 | - |\n| 8 | `play_song(3, 3)` | `{1: Song(A, {1,2}), 2: Song(B, {1}), 3: Song(C, {3})}` \u2190 **No change!** | 4 | - |\n| 9 | `print_analytics()` | Collect: [A(2), B(1), C(1)] \u2192 Sort: [A(2), B(1), C(1)] | 4 | **See below** |\n\n**Final Output:**\n```\nSong A (2 unique listeners)\nSong B (1 unique listeners)\nSong C (1 unique listeners)\n```",
    "final_answer": "Song A (2), Song B (1), Song C (1)"
  },
  "test_cases": [
    {
      "name": "Single song, single user",
      "category": "Happy Path - Minimal",
      "input": "add_song(\"Only\"), play_song(1, 1), print_analytics()",
      "expected": "Only (1 unique listeners)",
      "explanation": "Most basic case: one song, one play, one user"
    },
    {
      "name": "Same user plays same song multiple times",
      "category": "Uniqueness Test",
      "input": "add_song(\"Repeat\"), play_song(1,42), play_song(1,42), play_song(1,42), play_song(1,42), print_analytics()",
      "expected": "Repeat (1 unique listeners)",
      "explanation": "User 42 plays 4 times but count stays at 1. This tests Set deduplication."
    },
    {
      "name": "Tie-breaking alphabetically",
      "category": "Sorting Edge Case",
      "input": "add_song(\"Zebra\"), add_song(\"Apple\"), add_song(\"Mango\"), each played by 1 different user",
      "expected": "Apple (1)\\nMango (1)\\nZebra (1)",
      "explanation": "All have 1 listener, so sorted alphabetically: Apple < Mango < Zebra"
    },
    {
      "name": "Complex sorting with ties",
      "category": "Sorting Complex",
      "input": "Zebra(2), Alpha(2), Beta(1), Delta(1), Gamma(1)",
      "expected": "Alpha (2)\\nZebra (2)\\nBeta (1)\\nDelta (1)\\nGamma (1)",
      "explanation": "Alpha and Zebra tied at 2, Alpha comes first alphabetically. Beta/Delta/Gamma tied at 1, sorted alphabetically."
    },
    {
      "name": "Invalid song ID error",
      "category": "Error Handling",
      "input": "add_song(\"Test\"), play_song(999, 1)",
      "expected": "Error: Song ID 999 does not exist.",
      "explanation": "Song 999 was never added. Must print exact error message."
    },
    {
      "name": "Song with zero listeners",
      "category": "Edge Case",
      "input": "add_song(\"Popular\"), add_song(\"Unpopular\"), play_song(1, 1), print_analytics()",
      "expected": "Popular (1)\\nUnpopular (0 unique listeners)",
      "explanation": "Songs with 0 listeners must still appear in output."
    },
    {
      "name": "Many users for one song",
      "category": "Scale Test",
      "input": "add_song(\"Viral\"), play_song(1, user) for users 1-10",
      "expected": "Viral (10 unique listeners)",
      "explanation": "Tests that Set correctly tracks 10 different users"
    },
    {
      "name": "Duplicate song names",
      "category": "Edge Case",
      "input": "add_song(\"Same\") twice, play_song(1, 1), play_song(2, 2)",
      "expected": "Both \"Same\" entries shown separately",
      "explanation": "Same name creates separate entries with different IDs"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using List instead of Set for listeners",
      "why_wrong": "List doesn't automatically deduplicate. Same user added twice increases count.",
      "correct_approach": "Use Set - add() is idempotent for existing elements",
      "code_wrong": "self.listeners = []\ndef add_listener(self, user_id):\n    self.listeners.append(user_id)  # Duplicates counted!",
      "code_correct": "self.listeners = set()\ndef add_listener(self, user_id):\n    self.listeners.add(user_id)  # Duplicates ignored!"
    },
    {
      "mistake": "Starting ID from 0 instead of 1",
      "why_wrong": "Problem explicitly states IDs start from 1",
      "correct_approach": "Initialize nextId = 1, not 0",
      "code_wrong": "self.next_id = 0  # Wrong!",
      "code_correct": "self.next_id = 1  # Correct!"
    },
    {
      "mistake": "Wrong sort direction",
      "why_wrong": "Sorting by count ascending puts least popular first",
      "correct_approach": "Use negative count for descending in Python, or b-a comparison in Java",
      "code_wrong": "sorted(songs, key=lambda s: (s.get_listener_count(), s.get_name()))",
      "code_correct": "sorted(songs, key=lambda s: (-s.get_listener_count(), s.get_name()))"
    },
    {
      "mistake": "Not handling invalid song_id",
      "why_wrong": "Accessing non-existent key throws exception",
      "correct_approach": "Check existence first, print error if not found",
      "code_wrong": "def play_song(self, song_id, user_id):\n    self.songs[song_id].add_listener(user_id)  # KeyError!",
      "code_correct": "def play_song(self, song_id, user_id):\n    if song_id not in self.songs:\n        print(f\"Error: Song ID {song_id} does not exist.\")\n        return\n    self.songs[song_id].add_listener(user_id)"
    },
    {
      "mistake": "Excluding songs with 0 listeners from analytics",
      "why_wrong": "Problem says songs with 0 listeners should still be included",
      "correct_approach": "Include all songs from the HashMap, regardless of listener count",
      "code_wrong": "# Only including songs that have been played",
      "code_correct": "all_songs = list(self.songs.values())  # Include ALL songs"
    },
    {
      "mistake": "Using raw count instead of unique count",
      "why_wrong": "Problem asks for unique listeners, not total plays",
      "correct_approach": "Count size of Set, not increment a counter on each play",
      "code_wrong": "self.play_count += 1  # Tracks total plays",
      "code_correct": "return len(self.listeners)  # Tracks unique users"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem! Before I start coding, I'd like to clarify a few things and think through the design...",
    "clarifying_questions_to_ask": [
      "**Are song IDs 1-indexed or 0-indexed?** This seems like 1-indexed based on the examples.",
      "**Can the same song name be added twice?** I'll assume yes, creating separate entries.",
      "**For ties in listener count, how should songs be ordered?** Alphabetically by name (ascending).",
      "**Should songs with 0 listeners appear in analytics?** I'll include them to show complete library.",
      "**Is thread-safety a concern?** I'll assume single-threaded for now but can add synchronization."
    ],
    "what_to_mention_proactively": [
      "I'll use a **Set** for unique listener tracking - it handles deduplication automatically",
      "I'll use a **HashMap** for O(1) song lookup by ID",
      "The key insight is tracking **unique reach** not raw play counts - that's why Set is perfect",
      "Let me trace through an example after coding to verify correctness"
    ],
    "communication_during_coding": [
      "\"Creating the Song class first - it encapsulates name and listeners...\"",
      "\"Using Set<Integer> for listeners because we need unique tracking...\"",
      "\"Starting nextId at 1, not 0, as specified in requirements...\"",
      "\"For sorting, I'll use negative count for descending, positive name for ascending...\"",
      "\"Adding error handling for invalid song_id before accessing the HashMap...\""
    ],
    "if_stuck": [
      "**For uniqueness**: Ask yourself - what data structure automatically handles deduplication?",
      "**For sorting**: Think about the sort key - how to make one thing descending and another ascending?",
      "**For design**: What are the entities? What are their responsibilities?"
    ],
    "time_management": "0-5 min: Clarify requirements | 5-10 min: Design approach verbally | 10-25 min: Implement | 25-35 min: Test with examples | 35-45 min: Edge cases & follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap + Set + Custom Sorting",
    "indicators": [
      "Need O(1) lookup by ID \u2192 HashMap",
      "Track unique values \u2192 Set",
      "Generate sorted output \u2192 Custom Comparator",
      "OOP design with entities \u2192 Separate classes"
    ],
    "similar_problems": [
      "**LC 347 - Top K Frequent Elements**: Count frequencies (use HashMap), return top K (use heap or sorting)",
      "**LC 355 - Design Twitter**: Track tweets per user, generate feed (OOP design + sorting)",
      "**LC 692 - Top K Frequent Words**: Similar two-level sorting (count DESC, word ASC)",
      "**Design Hit Counter**: Track events over time windows"
    ],
    "template": "1. Use HashMap for O(1) lookup by key\n2. Use Set inside value for unique tracking\n3. Use custom comparator for multi-level sorting\n4. Separate entity class from service class"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Recent Plays** - You'll need to track the last N plays with duplicates allowed. This changes the data structure from Set to a bounded queue/deque. Think about how to efficiently maintain a fixed-size history.",
    "part_3_hint": "**Part 3: Recent Unique Plays** - Combine uniqueness with recency. You might need LinkedHashSet (maintains insertion order) or a combination of HashMap + deque. The tricky part is evicting old entries while maintaining uniqueness.",
    "data_structure_evolution": "Part 1: HashMap<ID, Song(Set)> \u2192 Part 2: Add Deque<Play> for recency \u2192 Part 3: LinkedHashMap or OrderedDict for LRU-style unique tracking"
  },
  "generated_at": "2026-01-14T15:35:00.531599",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}