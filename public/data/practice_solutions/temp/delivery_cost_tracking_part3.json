{
  "problem_title": "Delivery Cost Tracking System - Part 3: Maximum Active Drivers Analytics",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds real-time analytics capability. We now need to track ALL deliveries (not just costs) and compute the maximum number of concurrently active drivers within a 24-hour sliding window. This transforms our system from a simple cost aggregator to an analytics platform capable of answering temporal overlap queries.",
    "new_requirements": [
      "Store complete delivery records (not just costs) with timestamps",
      "Implement getMaxActiveDriversInLast24Hours(currentTime) method",
      "Handle 24-hour sliding window (86400 seconds)",
      "Efficiently compute maximum overlapping intervals",
      "Clip deliveries that partially fall within the query window"
    ],
    "new_constraints": [
      "Must handle large numbers of deliveries efficiently",
      "Window is defined as [currentTime - 86400, currentTime]",
      "Deliveries spanning window boundaries must be clipped",
      "Same-time events need careful ordering (ends before starts)"
    ],
    "key_insight": "This is the classic **Line Sweep** algorithm (Meeting Rooms II pattern). Convert intervals to events (+1 at start, -1 at end), sort by time, and sweep through tracking the running count. The maximum value seen during the sweep is our answer. Time complexity O(n log n) for sorting."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Find maximum concurrent drivers in 24-hour window",
        "how_met": "Line sweep algorithm processes delivery intervals as events, tracking max overlap",
        "gotchas": [
          "Must clip intervals to window boundaries",
          "Zero-duration or invalid intervals"
        ]
      },
      {
        "requirement": "24-hour sliding window",
        "how_met": "Filter deliveries to [currentTime - 86400, currentTime] range before processing",
        "gotchas": [
          "Partial overlaps need clipping, not exclusion"
        ]
      },
      {
        "requirement": "Handle same-time events correctly",
        "how_met": "Sort by (time, delta) where delta=-1 for end, +1 for start; ends processed before starts",
        "gotchas": [
          "Wrong ordering causes double-counting at boundaries"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "getMaxActiveDriversInLast24Hours",
        "target": "O(n log n)",
        "achieved": "O(n log n)",
        "why": "Sorting n events dominates; sweep is O(n)"
      },
      {
        "operation": "addDelivery",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Just append to list, no reordering needed at add time"
      }
    ],
    "non_goals": [
      "Real-time max tracking (we compute on-demand)",
      "Historical queries beyond 24 hours",
      "Per-driver max concurrent deliveries"
    ]
  },
  "assumptions": [
    "Deliveries have positive duration (endTime > startTime) - skip invalid ones",
    "Time values are in epoch seconds as specified",
    "A delivery is 'active' in the half-open interval [start, end)",
    "Touching intervals (end of one == start of another) do NOT overlap",
    "Query time currentTime is always provided and reasonable"
  ],
  "tradeoffs": [
    {
      "decision": "On-demand computation vs. maintaining live state",
      "chosen": "On-demand computation",
      "why": "Simpler implementation, no state maintenance on add/remove, works well for infrequent queries",
      "alternative": "Segment tree or persistent data structure",
      "when_to_switch": "If getMaxActiveDriversInLast24Hours is called very frequently (>1000x per second)"
    },
    {
      "decision": "Store full Delivery objects vs. just intervals",
      "chosen": "Full Delivery objects",
      "why": "Already needed cost tracking from Part 2, minimal overhead, enables future analytics",
      "alternative": "Separate list of just (start, end) tuples",
      "when_to_switch": "If memory is extremely constrained and we don't need delivery costs"
    },
    {
      "decision": "Filter at query time vs. maintain 24-hour window continuously",
      "chosen": "Filter at query time",
      "why": "Window slides with currentTime parameter, so pre-filtering isn't possible",
      "alternative": "Time-bucketed storage for faster range queries",
      "when_to_switch": "If queries always use 'now' as currentTime and we can use TTL-based eviction"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public method signatures from Parts 1-2",
      "Cost calculation logic and precision",
      "Delivery storage structure (enables future analytics)"
    ],
    "what_to_change": [
      "Added deliveries list to store all Delivery objects",
      "Delivery class/struct now a first-class entity"
    ],
    "interfaces_and_boundaries": "The Delivery class is now exposed for analytics. Future parts can query deliveries by driver, time range, etc. The line sweep is encapsulated in the analytics method.",
    "invariants": [
      "deliveries list contains all valid deliveries ever added",
      "Each delivery has driverId matching an existing driver at add time",
      "totalCost equals sum of all delivery costs",
      "unsettledByDriver[id] >= 0 for all drivers"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2):                       AFTER (Part 3):\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ DeliveryCostTracker â”‚                â”‚ DeliveryCostTracker â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ drivers: {1: $10}   â”‚                â”‚ drivers: {1: $10}   â”‚\nâ”‚ totalCost: $25.00   â”‚                â”‚ totalCost: $25.00   â”‚\nâ”‚ unsettled: {1: $25} â”‚                â”‚ unsettled: {1: $25} â”‚\nâ”‚                     â”‚      â”€â”€>       â”‚ deliveries: [       â”‚\nâ”‚ (no delivery list)  â”‚                â”‚   D(1, 0, 3000),    â”‚\nâ”‚                     â”‚                â”‚   D(2, 1000, 2500), â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚   D(3, 1500, 4000)  â”‚\n                                       â”‚ ]                   â”‚\n                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```",
    "algorithm_flow": "```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    LINE SWEEP ALGORITHM FLOW                         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚                                                                      â”‚\nâ”‚   Step 1: COLLECT DELIVERIES IN WINDOW                              â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚\nâ”‚   â”‚ Window: [currentTime - 86400, currentTime]               â”‚       â”‚\nâ”‚   â”‚ Filter: delivery.end > windowStart AND                   â”‚       â”‚\nâ”‚   â”‚         delivery.start < windowEnd                       â”‚       â”‚\nâ”‚   â”‚ Clip:   effectiveStart = max(start, windowStart)        â”‚       â”‚\nâ”‚   â”‚         effectiveEnd = min(end, windowEnd)              â”‚       â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚\nâ”‚                                                                      â”‚\nâ”‚   Step 2: CREATE EVENTS                                             â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚\nâ”‚   â”‚Delivery â”‚ Creates       â”‚ Events                      â”‚        â”‚\nâ”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤        â”‚\nâ”‚   â”‚[0,3000] â”‚ (0,+1),(3000,-1)                            â”‚        â”‚\nâ”‚   â”‚[1000,2500]â”‚ (1000,+1),(2500,-1)                       â”‚        â”‚\nâ”‚   â”‚[1500,4000]â”‚ (1500,+1),(4000,-1)                       â”‚        â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚\nâ”‚                                                                      â”‚\nâ”‚   Step 3: SORT EVENTS by (time, delta)                              â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚\nâ”‚   â”‚ (0,+1), (1000,+1), (1500,+1), (2500,-1),            â”‚         â”‚\nâ”‚   â”‚ (3000,-1), (4000,-1)                                 â”‚         â”‚\nâ”‚   â”‚                                                      â”‚         â”‚\nâ”‚   â”‚ Note: At same time, -1 (end) comes before +1 (start)â”‚         â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ”‚                                                                      â”‚\nâ”‚   Step 4: SWEEP AND TRACK MAX                                       â”‚\nâ”‚   â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚\nâ”‚   â”‚ Time â”‚ Delta â”‚ Current â”‚ Max                        â”‚          â”‚\nâ”‚   â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚\nâ”‚   â”‚   0  â”‚  +1   â”‚    1    â”‚  1                         â”‚          â”‚\nâ”‚   â”‚ 1000 â”‚  +1   â”‚    2    â”‚  2                         â”‚          â”‚\nâ”‚   â”‚ 1500 â”‚  +1   â”‚    3    â”‚  3  â˜… Maximum reached!     â”‚          â”‚\nâ”‚   â”‚ 2500 â”‚  -1   â”‚    2    â”‚  3                         â”‚          â”‚\nâ”‚   â”‚ 3000 â”‚  -1   â”‚    1    â”‚  3                         â”‚          â”‚\nâ”‚   â”‚ 4000 â”‚  -1   â”‚    0    â”‚  3                         â”‚          â”‚\nâ”‚   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚\nâ”‚                                                                      â”‚\nâ”‚   RESULT: max = 3                                                   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```"
  },
  "approaches": [
    {
      "name": "Naive Brute Force",
      "description": "For each second in the 24-hour window, count how many deliveries are active at that moment. Track the maximum count seen.",
      "time_complexity": "O(86400 Ã— n) = O(n)",
      "space_complexity": "O(1)",
      "why_not_optimal": "86400 seconds Ã— n deliveries per second check is extremely slow. Even with optimization (only check at delivery boundaries), requires O(n) per boundary point, giving O(nÂ²) overall."
    },
    {
      "name": "Nested Loop Overlap Check",
      "description": "For each delivery, count how many other deliveries overlap with it. Track the maximum overlap count.",
      "time_complexity": "O(nÂ²)",
      "space_complexity": "O(1)",
      "why_not_optimal": "Doesn't actually solve the problem correctlyâ€”max concurrent isn't the same as max overlapping with any single delivery. Also quadratic time."
    },
    {
      "name": "Optimal: Line Sweep Algorithm",
      "description": "Convert intervals to events (+1 at start, -1 at end). Sort events by time (with ends before starts at same time). Sweep through maintaining running count and track maximum.",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "key_insight": "Instead of checking each time point, we only care about moments where the count CHANGES (delivery starts or ends). Between events, the count is constant, so we only need to check O(n) points."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Line Sweep Algorithm\n\nThe **Line Sweep** technique is perfect for interval overlap problems. Here's how it works:\n\n### Core Insight\nThe number of active drivers only changes at **delivery start** or **end** times. Between these events, the count remains constant. So instead of checking every possible time, we only need to examine O(n) critical points.\n\n### Algorithm Steps\n1. **Filter** deliveries to those overlapping the 24-hour window\n2. **Clip** delivery times to window boundaries\n3. **Create events**: Each delivery produces two events:\n   - `(startTime, +1)` â€” a driver becomes active\n   - `(endTime, -1)` â€” a driver becomes inactive\n4. **Sort events** by time. Crucially, at the **same time**, process **end events before start events**. This prevents double-counting at boundaries.\n5. **Sweep** through events, maintaining a running count. Track the maximum.\n\n### Why Ends Before Starts?\nIf delivery A ends at time T and delivery B starts at time T, they don't overlap (half-open intervals `[start, end)`). Processing end first ensures we decrement before incrementing, avoiding an artificial peak.\n\n### Complexity\n- **Time**: O(n log n) for sorting, O(n) for sweep â†’ **O(n log n)** total\n- **Space**: O(n) for events list",
    "data_structures": [
      {
        "structure": "List<Delivery>",
        "purpose": "Store all deliveries with full timestamps for analytics queries"
      },
      {
        "structure": "List<Tuple<time, delta>>",
        "purpose": "Events list for line sweep; delta is +1 (start) or -1 (end)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Calculate window boundaries [currentTime - 86400, currentTime]",
      "Step 2: Iterate through all deliveries, filter those with no overlap",
      "Step 3: For overlapping deliveries, clip start/end to window bounds",
      "Step 4: Create two events per delivery: (effectiveStart, +1) and (effectiveEnd, -1)",
      "Step 5: Sort events by (time, delta) â€” ends (-1) naturally sort before starts (+1)",
      "Step 6: Initialize currentActive = 0, maxActive = 0",
      "Step 7: For each event (time, delta): currentActive += delta; maxActive = max(maxActive, currentActive)",
      "Step 8: Return maxActive"
    ]
  },
  "solution_python_lines": [
    "from decimal import Decimal, ROUND_HALF_UP",
    "from typing import Dict, List, Tuple, Optional",
    "from collections import defaultdict",
    "from dataclasses import dataclass",
    "",
    "",
    "@dataclass",
    "class Delivery:",
    "    \"\"\"Represents a single delivery with all relevant data.\"\"\"",
    "    driver_id: int",
    "    start_time: int",
    "    end_time: int",
    "    cost: Decimal",
    "",
    "",
    "class DeliveryCostTracker:",
    "    \"\"\"",
    "    A delivery cost tracking system that manages drivers, deliveries,",
    "    payment settlements, and analytics on driver activity.",
    "    ",
    "    Supports:",
    "    - Adding drivers with hourly rates",
    "    - Recording deliveries and calculating costs",
    "    - Payment settlement tracking",
    "    - Analytics: maximum concurrent active drivers in 24-hour window",
    "    \"\"\"",
    "    ",
    "    SECONDS_IN_24_HOURS = 86400",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize an empty delivery cost tracker.\"\"\"",
    "        # Driver ID -> hourly rate (Decimal for precision)",
    "        self._drivers: Dict[int, Decimal] = {}",
    "        ",
    "        # Running total of all delivery costs",
    "        self._total_cost: Decimal = Decimal('0')",
    "        ",
    "        # All deliveries for analytics queries",
    "        self._deliveries: List[Delivery] = []",
    "        ",
    "        # Driver ID -> unsettled payment amount",
    "        self._unsettled_by_driver: Dict[int, Decimal] = defaultdict(lambda: Decimal('0'))",
    "    ",
    "    def add_driver(self, driver_id: int, hourly_rate: float) -> None:",
    "        \"\"\"",
    "        Register a new driver with their hourly rate.",
    "        ",
    "        Args:",
    "            driver_id: Unique identifier for the driver",
    "            hourly_rate: Pay rate in dollars per hour",
    "        \"\"\"",
    "        self._drivers[driver_id] = Decimal(str(hourly_rate))",
    "    ",
    "    def add_delivery(self, driver_id: int, start_time: int, end_time: int) -> None:",
    "        \"\"\"",
    "        Record a delivery and calculate its cost.",
    "        ",
    "        Cost formula: hourlyRate Ã— (endTime - startTime) / 3600",
    "        ",
    "        Args:",
    "            driver_id: ID of the driver who made the delivery",
    "            start_time: Delivery start time (epoch seconds)",
    "            end_time: Delivery end time (epoch seconds)",
    "        \"\"\"",
    "        if driver_id not in self._drivers:",
    "            return  # Unknown driver, ignore",
    "        ",
    "        if end_time <= start_time:",
    "            return  # Invalid delivery duration",
    "        ",
    "        hourly_rate = self._drivers[driver_id]",
    "        duration_hours = Decimal(str(end_time - start_time)) / Decimal('3600')",
    "        cost = (hourly_rate * duration_hours).quantize(",
    "            Decimal('0.01'), rounding=ROUND_HALF_UP",
    "        )",
    "        ",
    "        # Update totals",
    "        self._total_cost += cost",
    "        self._unsettled_by_driver[driver_id] += cost",
    "        ",
    "        # Store delivery for analytics",
    "        delivery = Delivery(driver_id, start_time, end_time, cost)",
    "        self._deliveries.append(delivery)",
    "    ",
    "    def get_total_cost(self) -> float:",
    "        \"\"\"Get total cost across all deliveries, rounded to 2 decimal places.\"\"\"",
    "        return float(self._total_cost.quantize(",
    "            Decimal('0.01'), rounding=ROUND_HALF_UP",
    "        ))",
    "    ",
    "    def settle_payment(self, driver_id: int) -> float:",
    "        \"\"\"",
    "        Settle and return the unsettled amount for a driver.",
    "        Resets their unsettled balance to zero.",
    "        ",
    "        Args:",
    "            driver_id: ID of the driver to settle",
    "            ",
    "        Returns:",
    "            The amount settled (rounded to 2 decimal places)",
    "        \"\"\"",
    "        amount = self._unsettled_by_driver[driver_id]",
    "        self._unsettled_by_driver[driver_id] = Decimal('0')",
    "        return float(amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "    ",
    "    def get_unsettled_amount(self, driver_id: int) -> float:",
    "        \"\"\"Get the current unsettled amount for a driver.\"\"\"",
    "        amount = self._unsettled_by_driver[driver_id]",
    "        return float(amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))",
    "    ",
    "    def get_max_active_drivers_in_last_24_hours(self, current_time: int) -> int:",
    "        \"\"\"",
    "        Find the maximum number of drivers simultaneously delivering",
    "        at any point in the last 24 hours.",
    "        ",
    "        Uses the Line Sweep algorithm:",
    "        1. Create events for delivery starts (+1) and ends (-1)",
    "        2. Filter/clip to 24-hour window",
    "        3. Sort events by time (ends before starts at same time)",
    "        4. Sweep through tracking running count",
    "        ",
    "        Args:",
    "            current_time: Current timestamp in epoch seconds",
    "            ",
    "        Returns:",
    "            Maximum number of concurrent active drivers",
    "            ",
    "        Time Complexity: O(n log n) where n = number of deliveries",
    "        Space Complexity: O(n) for events list",
    "        \"\"\"",
    "        window_start = current_time - self.SECONDS_IN_24_HOURS",
    "        window_end = current_time",
    "        ",
    "        # Create events: (time, delta) where delta is +1 for start, -1 for end",
    "        events: List[Tuple[int, int]] = []",
    "        ",
    "        for delivery in self._deliveries:",
    "            # Check if delivery overlaps with the window",
    "            if delivery.end_time <= window_start or delivery.start_time >= window_end:",
    "                continue  # No overlap with window",
    "            ",
    "            # Clip delivery times to window boundaries",
    "            effective_start = max(delivery.start_time, window_start)",
    "            effective_end = min(delivery.end_time, window_end)",
    "            ",
    "            # Add events: +1 at start, -1 at end",
    "            events.append((effective_start, 1))   # Start event",
    "            events.append((effective_end, -1))    # End event",
    "        ",
    "        if not events:",
    "            return 0",
    "        ",
    "        # Sort events: by time first, then by delta",
    "        # Since -1 < 1, ends naturally sort before starts at same time",
    "        # This prevents double-counting at boundaries",
    "        events.sort(key=lambda x: (x[0], x[1]))",
    "        ",
    "        max_active = 0",
    "        current_active = 0",
    "        ",
    "        for time, delta in events:",
    "            current_active += delta",
    "            max_active = max(max_active, current_active)",
    "        ",
    "        return max_active",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the DeliveryCostTracker with Part 3 functionality.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"DELIVERY COST TRACKER - PART 3 DEMO\")",
    "    print(\"Maximum Active Drivers Analytics\")",
    "    print(\"=\" * 60)",
    "    ",
    "    tracker = DeliveryCostTracker()",
    "    ",
    "    # Add drivers",
    "    print(\"\\nðŸ“‹ Adding drivers...\")",
    "    tracker.add_driver(1, 10.0)",
    "    tracker.add_driver(2, 10.0)",
    "    tracker.add_driver(3, 10.0)",
    "    print(\"   Driver 1: $10/hour\")",
    "    print(\"   Driver 2: $10/hour\")",
    "    print(\"   Driver 3: $10/hour\")",
    "    ",
    "    # Add overlapping deliveries",
    "    print(\"\\nðŸšš Adding deliveries (overlapping scenario)...\")",
    "    print(\"\"\"",
    "    Timeline:      0 â”€â”€â”€â”€ 1000 â”€â”€â”€â”€ 2000 â”€â”€â”€â”€ 3000 â”€â”€â”€â”€ 4000",
    "",
    "    Driver 1:      [=========D1=========]",
    "                   0                    3000",
    "",
    "    Driver 2:            [====D2====]",
    "                         1000      2500",
    "",
    "    Driver 3:                  [========D3========]",
    "                               1500              4000",
    "    \"\"\")",
    "    ",
    "    tracker.add_delivery(1, 0, 3000)",
    "    tracker.add_delivery(2, 1000, 2500)",
    "    tracker.add_delivery(3, 1500, 4000)",
    "    ",
    "    # Query max active drivers",
    "    current_time = 86400  # 24 hours from epoch",
    "    max_active = tracker.get_max_active_drivers_in_last_24_hours(current_time)",
    "    ",
    "    print(f\"\\nðŸ“Š Max active drivers in last 24 hours: {max_active}\")",
    "    print(\"   Expected: 3 (all three overlap at t=1500-2500)\")",
    "    ",
    "    # Test non-overlapping scenario",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Testing non-overlapping deliveries...\")",
    "    print(\"=\" * 60)",
    "    ",
    "    tracker2 = DeliveryCostTracker()",
    "    tracker2.add_driver(1, 10.0)",
    "    tracker2.add_driver(2, 10.0)",
    "    ",
    "    print(\"\"\"",
    "    Timeline:      0 â”€â”€â”€â”€ 1000 â”€â”€â”€â”€ 2000 â”€â”€â”€â”€ 3000",
    "",
    "    Driver 1:      [==D1==]",
    "                   0     1000",
    "",
    "    Driver 2:                     [==D2==]",
    "                                  2000   3000",
    "    \"\"\")",
    "    ",
    "    tracker2.add_delivery(1, 0, 1000)",
    "    tracker2.add_delivery(2, 2000, 3000)",
    "    ",
    "    max_active2 = tracker2.get_max_active_drivers_in_last_24_hours(86400)",
    "    print(f\"ðŸ“Š Max active drivers: {max_active2}\")",
    "    print(\"   Expected: 1 (deliveries don't overlap)\")",
    "    ",
    "    # Test partial window overlap",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Testing partial window overlap...\")",
    "    print(\"=\" * 60)",
    "    ",
    "    tracker3 = DeliveryCostTracker()",
    "    tracker3.add_driver(1, 10.0)",
    "    tracker3.add_driver(2, 10.0)",
    "    ",
    "    # Deliveries at times 0-1000 and 1000-2000",
    "    # Query at time 1500 with window [1500-86400, 1500] = [-84900, 1500]",
    "    # Only the second delivery (1000-2000) overlaps with window",
    "    tracker3.add_delivery(1, 0, 500)",
    "    tracker3.add_delivery(2, 1000, 2000)",
    "    ",
    "    # Query at time 1500 - window is [-84900, 1500]",
    "    # But times are positive, so effectively [0, 1500]",
    "    # D1 [0,500] is fully in window",
    "    # D2 [1000,2000] partially in window, clipped to [1000, 1500]",
    "    # They don't overlap, max = 1",
    "    max_active3 = tracker3.get_max_active_drivers_in_last_24_hours(1500)",
    "    print(f\"ðŸ“Š Max active drivers (query at t=1500): {max_active3}\")",
    "    print(\"   D1 [0,500] and D2 [1000,1500 clipped] don't overlap\")",
    "    print(\"   Expected: 1\")",
    "    ",
    "    # Edge case: empty tracker",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Testing edge cases...\")",
    "    print(\"=\" * 60)",
    "    ",
    "    empty_tracker = DeliveryCostTracker()",
    "    empty_max = empty_tracker.get_max_active_drivers_in_last_24_hours(86400)",
    "    print(f\"ðŸ“Š Empty tracker max active: {empty_max}\")",
    "    print(\"   Expected: 0\")",
    "    ",
    "    print(\"\\nâœ… All tests completed!\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "/**",
    " * Delivery Cost Tracking System - Part 3",
    " * Supports driver management, delivery tracking, payment settlement,",
    " * and analytics for maximum concurrent active drivers.",
    " */",
    "public class DeliveryCostTracker {",
    "    ",
    "    private static final long SECONDS_IN_24_HOURS = 86400L;",
    "    private static final int DECIMAL_SCALE = 10;",
    "    ",
    "    // Driver ID -> hourly rate",
    "    private final Map<Integer, BigDecimal> drivers;",
    "    ",
    "    // Running total of all delivery costs",
    "    private BigDecimal totalCost;",
    "    ",
    "    // All deliveries for analytics",
    "    private final List<Delivery> deliveries;",
    "    ",
    "    // Driver ID -> unsettled amount",
    "    private final Map<Integer, BigDecimal> unsettledByDriver;",
    "    ",
    "    /**",
    "     * Represents a single delivery with all relevant data.",
    "     */",
    "    private static class Delivery {",
    "        final int driverId;",
    "        final long startTime;",
    "        final long endTime;",
    "        final BigDecimal cost;",
    "        ",
    "        Delivery(int driverId, long startTime, long endTime, BigDecimal cost) {",
    "            this.driverId = driverId;",
    "            this.startTime = startTime;",
    "            this.endTime = endTime;",
    "            this.cost = cost;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Initialize an empty delivery cost tracker.",
    "     */",
    "    public DeliveryCostTracker() {",
    "        this.drivers = new HashMap<>();",
    "        this.totalCost = BigDecimal.ZERO;",
    "        this.deliveries = new ArrayList<>();",
    "        this.unsettledByDriver = new HashMap<>();",
    "    }",
    "    ",
    "    /**",
    "     * Register a new driver with their hourly rate.",
    "     * @param driverId Unique identifier for the driver",
    "     * @param hourlyRate Pay rate in dollars per hour",
    "     */",
    "    public void addDriver(int driverId, double hourlyRate) {",
    "        drivers.put(driverId, BigDecimal.valueOf(hourlyRate));",
    "    }",
    "    ",
    "    /**",
    "     * Record a delivery and calculate its cost.",
    "     * Cost = hourlyRate Ã— (endTime - startTime) / 3600",
    "     * ",
    "     * @param driverId ID of the driver who made the delivery",
    "     * @param startTime Delivery start time (epoch seconds)",
    "     * @param endTime Delivery end time (epoch seconds)",
    "     */",
    "    public void addDelivery(int driverId, long startTime, long endTime) {",
    "        if (!drivers.containsKey(driverId)) {",
    "            return; // Unknown driver",
    "        }",
    "        ",
    "        if (endTime <= startTime) {",
    "            return; // Invalid duration",
    "        }",
    "        ",
    "        BigDecimal hourlyRate = drivers.get(driverId);",
    "        BigDecimal durationHours = BigDecimal.valueOf(endTime - startTime)",
    "                .divide(BigDecimal.valueOf(3600), DECIMAL_SCALE, RoundingMode.HALF_UP);",
    "        BigDecimal cost = hourlyRate.multiply(durationHours)",
    "                .setScale(2, RoundingMode.HALF_UP);",
    "        ",
    "        // Update totals",
    "        totalCost = totalCost.add(cost);",
    "        unsettledByDriver.merge(driverId, cost, BigDecimal::add);",
    "        ",
    "        // Store delivery for analytics",
    "        deliveries.add(new Delivery(driverId, startTime, endTime, cost));",
    "    }",
    "    ",
    "    /**",
    "     * Get total cost across all deliveries.",
    "     * @return Total cost rounded to 2 decimal places",
    "     */",
    "    public double getTotalCost() {",
    "        return totalCost.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    /**",
    "     * Settle and return the unsettled amount for a driver.",
    "     * Resets their unsettled balance to zero.",
    "     * ",
    "     * @param driverId ID of the driver to settle",
    "     * @return The amount settled",
    "     */",
    "    public double settlePayment(int driverId) {",
    "        BigDecimal amount = unsettledByDriver.getOrDefault(driverId, BigDecimal.ZERO);",
    "        unsettledByDriver.put(driverId, BigDecimal.ZERO);",
    "        return amount.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    /**",
    "     * Get the current unsettled amount for a driver.",
    "     * @param driverId ID of the driver",
    "     * @return Unsettled amount",
    "     */",
    "    public double getUnsettledAmount(int driverId) {",
    "        BigDecimal amount = unsettledByDriver.getOrDefault(driverId, BigDecimal.ZERO);",
    "        return amount.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    /**",
    "     * Find the maximum number of drivers simultaneously delivering",
    "     * at any point in the last 24 hours.",
    "     * ",
    "     * Uses the Line Sweep algorithm:",
    "     * 1. Create events for delivery starts (+1) and ends (-1)",
    "     * 2. Filter/clip to 24-hour window",
    "     * 3. Sort events by time (ends before starts at same time)",
    "     * 4. Sweep through tracking running count",
    "     * ",
    "     * Time Complexity: O(n log n) where n = number of deliveries",
    "     * Space Complexity: O(n) for events list",
    "     * ",
    "     * @param currentTime Current timestamp in epoch seconds",
    "     * @return Maximum number of concurrent active drivers",
    "     */",
    "    public int getMaxActiveDriversInLast24Hours(long currentTime) {",
    "        long windowStart = currentTime - SECONDS_IN_24_HOURS;",
    "        long windowEnd = currentTime;",
    "        ",
    "        // Create events: [time, delta] where delta is +1 for start, -1 for end",
    "        List<long[]> events = new ArrayList<>();",
    "        ",
    "        for (Delivery delivery : deliveries) {",
    "            // Check if delivery overlaps with the window",
    "            if (delivery.endTime <= windowStart || delivery.startTime >= windowEnd) {",
    "                continue; // No overlap",
    "            }",
    "            ",
    "            // Clip delivery times to window boundaries",
    "            long effectiveStart = Math.max(delivery.startTime, windowStart);",
    "            long effectiveEnd = Math.min(delivery.endTime, windowEnd);",
    "            ",
    "            // Add events: +1 at start, -1 at end",
    "            events.add(new long[]{effectiveStart, 1});",
    "            events.add(new long[]{effectiveEnd, -1});",
    "        }",
    "        ",
    "        if (events.isEmpty()) {",
    "            return 0;",
    "        }",
    "        ",
    "        // Sort: by time first, then by delta",
    "        // -1 < 1, so ends come before starts at same time",
    "        events.sort((a, b) -> {",
    "            if (a[0] != b[0]) {",
    "                return Long.compare(a[0], b[0]);",
    "            }",
    "            return Long.compare(a[1], b[1]);",
    "        });",
    "        ",
    "        int maxActive = 0;",
    "        int currentActive = 0;",
    "        ",
    "        for (long[] event : events) {",
    "            currentActive += (int) event[1];",
    "            maxActive = Math.max(maxActive, currentActive);",
    "        }",
    "        ",
    "        return maxActive;",
    "    }",
    "    ",
    "    /**",
    "     * Demo and test the DeliveryCostTracker functionality.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================\");",
    "        System.out.println(\"DELIVERY COST TRACKER - PART 3 DEMO\");",
    "        System.out.println(\"Maximum Active Drivers Analytics\");",
    "        System.out.println(\"============================================\");",
    "        ",
    "        DeliveryCostTracker tracker = new DeliveryCostTracker();",
    "        ",
    "        // Add drivers",
    "        System.out.println(\"\\nAdding drivers...\");",
    "        tracker.addDriver(1, 10.0);",
    "        tracker.addDriver(2, 10.0);",
    "        tracker.addDriver(3, 10.0);",
    "        ",
    "        // Add overlapping deliveries",
    "        System.out.println(\"Adding overlapping deliveries...\");",
    "        System.out.println(\"  D1: [0, 3000]\");",
    "        System.out.println(\"  D2: [1000, 2500]\");",
    "        System.out.println(\"  D3: [1500, 4000]\");",
    "        ",
    "        tracker.addDelivery(1, 0, 3000);",
    "        tracker.addDelivery(2, 1000, 2500);",
    "        tracker.addDelivery(3, 1500, 4000);",
    "        ",
    "        // Query max active drivers",
    "        int maxActive = tracker.getMaxActiveDriversInLast24Hours(86400L);",
    "        System.out.println(\"\\nMax active drivers in last 24 hours: \" + maxActive);",
    "        System.out.println(\"Expected: 3 (all three overlap at t=1500-2500)\");",
    "        ",
    "        // Test non-overlapping",
    "        System.out.println(\"\\n============================================\");",
    "        System.out.println(\"Testing non-overlapping deliveries...\");",
    "        ",
    "        DeliveryCostTracker tracker2 = new DeliveryCostTracker();",
    "        tracker2.addDriver(1, 10.0);",
    "        tracker2.addDriver(2, 10.0);",
    "        tracker2.addDelivery(1, 0, 1000);",
    "        tracker2.addDelivery(2, 2000, 3000);",
    "        ",
    "        int maxActive2 = tracker2.getMaxActiveDriversInLast24Hours(86400L);",
    "        System.out.println(\"Max active: \" + maxActive2 + \" (expected: 1)\");",
    "        ",
    "        // Edge case: empty",
    "        DeliveryCostTracker empty = new DeliveryCostTracker();",
    "        int emptyMax = empty.getMaxActiveDriversInLast24Hours(86400L);",
    "        System.out.println(\"\\nEmpty tracker max: \" + emptyMax + \" (expected: 0)\");",
    "        ",
    "        System.out.println(\"\\nAll tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-6 (Python) / 1-4 (Java)",
      "explanation": "**Imports**: We import Decimal/BigDecimal for precise cost calculations, collections for data structures, and dataclass for clean Delivery objects."
    },
    {
      "lines": "8-14 (Python) / 27-38 (Java)",
      "explanation": "**Delivery class**: Encapsulates all delivery data (driver_id, start_time, end_time, cost). This is new in Part 3â€”we need to store full delivery records for analytics."
    },
    {
      "lines": "16-42 (Python) / 40-48 (Java)",
      "explanation": "**Constructor**: Initialize all data structures. Key addition for Part 3 is `_deliveries` list to store all Delivery objects for later analytics queries."
    },
    {
      "lines": "54-82 (Python) / 66-86 (Java)",
      "explanation": "**addDelivery**: Same as Part 2, but now also appends to `deliveries` list. This enables the analytics query while maintaining O(1) add time."
    },
    {
      "lines": "111-165 (Python) / 114-157 (Java)",
      "explanation": "**getMaxActiveDriversInLast24Hours** - THE CORE ALGORITHM:\n1. Calculate window boundaries\n2. Loop through all deliveries, filter out non-overlapping ones\n3. Clip overlapping deliveries to window bounds\n4. Create events: (start, +1) and (end, -1)\n5. Sort events by (time, delta) - ends before starts at same time\n6. Sweep through events, tracking running count and maximum"
    },
    {
      "lines": "147-148 (Python) / 144-147 (Java)",
      "explanation": "**Sorting trick**: By sorting (time, delta) and using -1 for ends, +1 for starts, ends naturally sort before starts at the same timestamp. This prevents double-counting when one delivery ends exactly as another starts."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "getMaxActiveDriversInLast24Hours": {
          "complexity": "O(n log n)",
          "explanation": "Dominated by sorting 2n events. The sweep itself is O(n). Total: O(n log n) where n = number of deliveries (not just in window, as we scan all)."
        }
      },
      "overall_change": "addDelivery remains O(1). The new analytics method is O(n log n). This is optimal for on-demand queriesâ€”we can't do better than O(n) to even read the intervals."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "We now store all Delivery objects (O(n)). The analytics method creates O(n) events temporarily. No change to other space requirements."
    }
  },
  "dry_run": {
    "example_input": "Drivers: {1: $10, 2: $10, 3: $10}, Deliveries: D1[0,3000], D2[1000,2500], D3[1500,4000], Query at t=86400",
    "steps": [
      {
        "step": 1,
        "action": "Calculate window",
        "state": "windowStart = 86400 - 86400 = 0, windowEnd = 86400",
        "explanation": "The 24-hour window is [0, 86400], covering all our deliveries"
      },
      {
        "step": 2,
        "action": "Process D1 [0, 3000]",
        "state": "events = [(0, +1), (3000, -1)]",
        "explanation": "D1 fully within window. Create start (+1) and end (-1) events."
      },
      {
        "step": 3,
        "action": "Process D2 [1000, 2500]",
        "state": "events = [(0, +1), (3000, -1), (1000, +1), (2500, -1)]",
        "explanation": "D2 fully within window. Add its events."
      },
      {
        "step": 4,
        "action": "Process D3 [1500, 4000]",
        "state": "events = [(0,+1), (3000,-1), (1000,+1), (2500,-1), (1500,+1), (4000,-1)]",
        "explanation": "D3 fully within window. Add its events."
      },
      {
        "step": 5,
        "action": "Sort events by (time, delta)",
        "state": "events = [(0,+1), (1000,+1), (1500,+1), (2500,-1), (3000,-1), (4000,-1)]",
        "explanation": "Sorted by time. At same time, ends (-1) would come before starts (+1), but no same-time events here."
      },
      {
        "step": 6,
        "action": "Sweep: process (0, +1)",
        "state": "currentActive = 1, maxActive = 1",
        "explanation": "Driver 1 starts delivering. Max so far is 1."
      },
      {
        "step": 7,
        "action": "Sweep: process (1000, +1)",
        "state": "currentActive = 2, maxActive = 2",
        "explanation": "Driver 2 starts delivering. Max so far is 2."
      },
      {
        "step": 8,
        "action": "Sweep: process (1500, +1)",
        "state": "currentActive = 3, maxActive = 3",
        "explanation": "Driver 3 starts delivering. â˜… MAX REACHED = 3!"
      },
      {
        "step": 9,
        "action": "Sweep: process (2500, -1)",
        "state": "currentActive = 2, maxActive = 3",
        "explanation": "Driver 2 finishes. Count decreases but max unchanged."
      },
      {
        "step": 10,
        "action": "Sweep: process (3000, -1)",
        "state": "currentActive = 1, maxActive = 3",
        "explanation": "Driver 1 finishes."
      },
      {
        "step": 11,
        "action": "Sweep: process (4000, -1)",
        "state": "currentActive = 0, maxActive = 3",
        "explanation": "Driver 3 finishes. All done."
      }
    ],
    "final_output": "3"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Empty tracker: should return 0",
      "Single delivery: should return 1",
      "Two non-overlapping deliveries: should return 1"
    ],
    "likely_bugs": [
      "Wrong sort order: starts before ends at same time causes overcounting",
      "Off-by-one in window check: using < instead of <= or vice versa",
      "Not clipping to window: partial overlaps counted fully",
      "Forgetting to filter deliveries outside window entirely"
    ],
    "recommended_logs_or_asserts": [
      "log events list after creation: verify (time, delta) pairs",
      "log events after sorting: verify order is correct",
      "assert currentActive >= 0 after each decrement",
      "log running count at each step during sweep"
    ],
    "how_to_localize": "1. Print all deliveries and the window boundaries. 2. Print events before sorting. 3. Print events after sorting. 4. Print (time, delta, currentActive, maxActive) at each sweep step. The bug will reveal itself by showing unexpected state."
  },
  "edge_cases": [
    {
      "case": "Empty tracker (no deliveries)",
      "handling": "Return 0 immediately when events list is empty",
      "gotcha": "Don't try to sort or sweep an empty list"
    },
    {
      "case": "No deliveries in the 24-hour window",
      "handling": "All deliveries filtered out; events list empty; return 0",
      "gotcha": "Old deliveries outside window should not be counted"
    },
    {
      "case": "Delivery spans window boundary (starts before, ends inside)",
      "handling": "Clip start to windowStart, keep original end",
      "gotcha": "Must clip, not excludeâ€”the driver was active during part of the window"
    },
    {
      "case": "Delivery spans window boundary (starts inside, ends after)",
      "handling": "Keep original start, clip end to windowEnd",
      "gotcha": "Same as aboveâ€”partial overlap counts"
    },
    {
      "case": "Deliveries touch but don't overlap (D1 ends at T, D2 starts at T)",
      "handling": "Processing end before start prevents double-counting",
      "gotcha": "If sorted wrong, count temporarily shows 2 when it should be 1"
    },
    {
      "case": "All deliveries at exact same time",
      "handling": "All starts come after all ends at same time (no ends in this case)",
      "gotcha": "Multiple deliveries [T, T+100] would all contribute to same peak"
    },
    {
      "case": "Very large number of deliveries",
      "handling": "O(n log n) handles gracefully; may want to optimize with indexing",
      "gotcha": "If called frequently, consider caching or preprocessing"
    }
  ],
  "test_cases": [
    {
      "name": "Example 1: Three overlapping deliveries",
      "input": "addDriver(1,10), addDriver(2,10), addDriver(3,10), addDelivery(1,0,3000), addDelivery(2,1000,2500), addDelivery(3,1500,4000), getMaxActiveDriversInLast24Hours(86400)",
      "expected": "3",
      "explanation": "All three drivers active simultaneously between t=1500 and t=2500"
    },
    {
      "name": "Example 2: Non-overlapping deliveries",
      "input": "addDriver(1,10), addDriver(2,10), addDelivery(1,0,1000), addDelivery(2,2000,3000), getMaxActiveDriversInLast24Hours(86400)",
      "expected": "1",
      "explanation": "D1 ends before D2 starts; never more than 1 active"
    },
    {
      "name": "Empty tracker",
      "input": "getMaxActiveDriversInLast24Hours(86400)",
      "expected": "0",
      "explanation": "No deliveries exist"
    },
    {
      "name": "Single delivery",
      "input": "addDriver(1,10), addDelivery(1,0,1000), getMaxActiveDriversInLast24Hours(86400)",
      "expected": "1",
      "explanation": "One driver = max 1"
    },
    {
      "name": "Touching deliveries (same driver)",
      "input": "addDriver(1,10), addDelivery(1,0,1000), addDelivery(1,1000,2000), getMaxActiveDriversInLast24Hours(86400)",
      "expected": "1",
      "explanation": "Same driver, sequential deliveries; still counts as max 1 at any moment"
    },
    {
      "name": "Deliveries outside window",
      "input": "addDriver(1,10), addDelivery(1,0,1000), getMaxActiveDriversInLast24Hours(100000)",
      "expected": "0",
      "explanation": "Window is [13600, 100000]; delivery [0,1000] is entirely before"
    },
    {
      "name": "Partial overlap with window",
      "input": "addDriver(1,10), addDelivery(1,80000,90000), getMaxActiveDriversInLast24Hours(86400)",
      "expected": "1",
      "explanation": "Window is [0, 86400]; delivery [80000,90000] clips to [80000,86400]; 1 driver active"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Wrong sort order: sorting starts before ends at same timestamp",
      "why_wrong": "If D1 ends at T and D2 starts at T, processing start first shows count=2 momentarily, but they don't actually overlap",
      "correct_approach": "Sort by (time, delta) where delta=-1 for end, +1 for start. Since -1 < 1, ends naturally come first.",
      "code_example_wrong": "events.sort(key=lambda x: (x[0], -x[1]))  # WRONG: starts before ends",
      "code_example_correct": "events.sort(key=lambda x: (x[0], x[1]))   # CORRECT: ends before starts"
    },
    {
      "mistake": "Excluding partially overlapping deliveries instead of clipping",
      "why_wrong": "A delivery [0, 50000] with window [40000, 86400] should count! The driver was active from 40000-50000.",
      "correct_approach": "Clip to window: effectiveStart = max(start, windowStart), effectiveEnd = min(end, windowEnd)",
      "code_example_wrong": "if start < windowStart: continue  # WRONG: excludes valid overlap",
      "code_example_correct": "effectiveStart = max(start, windowStart)  # CORRECT: clip"
    },
    {
      "mistake": "Using closed intervals [start, end] instead of half-open [start, end)",
      "why_wrong": "At exact boundary, might count driver as active at both the end of one delivery and start of next",
      "correct_approach": "Treat intervals as half-open. Processing ends before starts at same time achieves this.",
      "code_example_wrong": "// Treating end as inclusive causes boundary issues",
      "code_example_correct": "// Half-open: driver active in [start, end), not at exactly end"
    },
    {
      "mistake": "Not storing deliveries in Part 2, then struggling to add analytics",
      "why_wrong": "Part 3 requires access to all delivery intervals. If only costs were stored, we can't query overlaps.",
      "correct_approach": "Store full Delivery objects from the start (or retrofit in Part 3).",
      "code_example_wrong": "# Only storing: totalCost += cost",
      "code_example_correct": "# Store: deliveries.append(Delivery(driverId, start, end, cost))"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by recognizing the pattern: 'This is a classic interval overlap problem, like Meeting Rooms II. I'll use the Line Sweep algorithm.' Then explain the transformation from intervals to events, the sort order trick, and walk through a small example.",
    "what_to_mention": [
      "Recognize it's Meeting Rooms II / interval counting pattern",
      "Explain why ends must come before starts at same time",
      "Mention the O(n log n) complexity from sorting",
      "Discuss the window clipping requirement for partial overlaps",
      "Note that addDelivery is still O(1); we only pay cost at query time"
    ],
    "time_allocation": "2-3 min: understand requirements, recognize pattern. 3-4 min: explain approach, discuss edge cases. 5-8 min: implement and test.",
    "if_stuck": [
      "Think: what's special about start and end times?",
      "Consider: instead of checking every timestamp, what if I only check when something changes?",
      "Hint: create events at starts and ends, process in order"
    ]
  },
  "connection_to_next_part": "Part 3's delivery storage sets up well for Part 4 scenarios like:\n- Per-driver analytics (filter deliveries by driver_id)\n- Time-range queries (already have clipping logic)\n- Delivery removal/cancellation (would need delivery IDs)\n- Real-time max tracking (would need persistent segment tree or similar)",
  "communication_script": {
    "transition_from_previous": "Great, so Part 2 handles payment settlement. For Part 3, I need to add analyticsâ€”specifically, finding the maximum concurrent drivers in a 24-hour window. This is actually a classic algorithm problem!",
    "explaining_changes": "The key change is that I now need to store complete delivery records, not just aggregate costs. I'll add a Delivery class and a list to store them. For the analytics query, I'll use the Line Sweep algorithmâ€”same technique as Meeting Rooms II.",
    "while_extending_code": [
      "I'm adding a Delivery dataclass to store the full record...",
      "In addDelivery, I'll append to the deliveries listâ€”still O(1)...",
      "For getMaxActiveDriversInLast24Hours, I first filter to the window...",
      "Then I create events: +1 at start, -1 at end...",
      "Sorting by (time, delta) ensures ends come before startsâ€”this is crucial...",
      "Finally, I sweep through tracking the running count and maximum."
    ],
    "after_completing": "This handles Part 3. The new method is O(n log n) due to sorting. Previous operations are unchanged in complexity. Want me to trace through an example, or shall we discuss edge cases?"
  },
  "time_milestones": {
    "time_budget": "8-12 minutes for this part",
    "by_2_min": "Recognize line sweep pattern, identify what data structures to add",
    "by_5_min": "Explain algorithm clearly, start implementing or have pseudocode",
    "by_10_min": "Implementation done, test with example, mention edge cases",
    "warning_signs": "If still designing at 5 min, simplify. If stuck on sort order, just mention 'ends before starts' and move on. Can clarify details after."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 didn't store deliveries, say: 'I realize I need to retrofit delivery storage. Let me add that first.' Add the deliveries list and update addDelivery.",
    "if_new_requirement_unclear": "Ask: 'For the 24-hour window, should I clip partial deliveries to the window, or only count deliveries fully within?' (Answer: clip partial overlaps.)",
    "if_running_behind": "Focus on the core algorithm: event creation and sweep. Skip validation (empty check, invalid duration) initially. Say: 'I'll add edge case handling once the core works.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the Meeting Rooms II pattern",
      "Explaining why sort order matters for correctness",
      "Proactively discussing window clipping for partial overlaps",
      "Mentioning that this could be optimized with a segment tree if queries are frequent",
      "Noting that addDelivery stays O(1)â€”we don't pre-process",
      "Discussing tradeoffs: on-demand computation vs. maintaining live state"
    ]
  },
  "generated_at": "2026-01-17T21:43:22.044388",
  "_meta": {
    "problem_id": "delivery_cost_tracking",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}