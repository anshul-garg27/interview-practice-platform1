{
  "problem_title": "Task Scheduling with Dependencies - Part 2: Limited Workers",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 assumed unlimited workers, so any ready task could start immediately. Part 2 introduces a constraint of exactly k workers, meaning ready tasks may need to **wait** for a worker to become free. This transforms the problem from a simple critical path calculation to an **event-driven simulation** that must track both task dependencies AND worker availability.",
    "new_requirements": [
      "Track which workers are currently busy and when they become free",
      "Queue ready tasks when all workers are occupied",
      "Simulate time progression to process task completions",
      "Assign tasks to earliest-available workers"
    ],
    "new_constraints": [
      "At most k tasks can execute simultaneously",
      "A task may start later than its dependencies allow if no worker is free",
      "Must handle the scheduling order when multiple tasks are ready"
    ],
    "key_insight": "Use a **min-heap of worker free times** to efficiently find the next available worker. When a task becomes ready, it starts at max(ready_time, earliest_worker_free_time). This transforms the problem into an event-driven simulation where we process task completions in chronological order."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551              UNLIMITED vs LIMITED WORKERS COMPARISON               \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                    \u2551\n\u2551  Tasks: [1,5], [2,5], [3,5]  |  No dependencies  |  k = 2         \u2551\n\u2551                                                                    \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551  \u2502   UNLIMITED WORKERS      \u2502  \u2502   LIMITED TO 2 WORKERS       \u2502   \u2551\n\u2551  \u2502                          \u2502  \u2502                              \u2502   \u2551\n\u2551  \u2502   t=0          t=5       \u2502  \u2502   t=0     t=5      t=10      \u2502   \u2551\n\u2551  \u2502   \u2502            \u2502         \u2502  \u2502   \u2502       \u2502        \u2502         \u2502   \u2551\n\u2551  \u2502   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 Task1     \u2502  \u2502   W1 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2502   \u2551\n\u2551  \u2502   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 Task2     \u2502  \u2502         Task1      Task3     \u2502   \u2551\n\u2551  \u2502   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 Task3     \u2502  \u2502   W2 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           \u2502   \u2551\n\u2551  \u2502                          \u2502  \u2502         Task2      (idle)    \u2502   \u2551\n\u2551  \u2502   Total Time: 5          \u2502  \u2502   Total Time: 10             \u2502   \u2551\n\u2551  \u2502                          \u2502  \u2502                              \u2502   \u2551\n\u2551  \u2502   All tasks run in       \u2502  \u2502   Task3 WAITS for worker!    \u2502   \u2551\n\u2551  \u2502   parallel               \u2502  \u2502   Even though it's ready     \u2502   \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                                                                    \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551          EVENT-DRIVEN SIMULATION WITH MIN-HEAPS                       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                       \u2551\n\u2551  STEP 1: Initialize Data Structures                                   \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Workers Heap (k=2):     Ready Tasks:      Completions:        \u2502  \u2551\n\u2551  \u2502   \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502  \u2551\n\u2551  \u2502   \u2502 0 \u2502 0 \u2502               \u2502(0,T1)(0,T2)\u2502    \u2502  (empty)  \u2502       \u2502  \u2551\n\u2551  \u2502   \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518               \u2502  (0,T3)   \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502  \u2551\n\u2551  \u2502   (free times)            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551  STEP 2: Assign Ready Tasks to Available Workers                      \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Task T1: ready_time=0, worker_free=0                          \u2502  \u2551\n\u2551  \u2502            start = max(0, 0) = 0                                \u2502  \u2551\n\u2551  \u2502            end = 0 + 5 = 5                                      \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Task T2: ready_time=0, worker_free=0                          \u2502  \u2551\n\u2551  \u2502            start = max(0, 0) = 0                                \u2502  \u2551\n\u2551  \u2502            end = 0 + 5 = 5                                      \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Task T3: MUST WAIT! (no free workers)                         \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u2551  STEP 3: Process Completions \u2192 Release Workers                        \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   At t=5: T1 completes \u2192 Worker free at t=5                     \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Workers Heap:           Ready Tasks:                          \u2502  \u2551\n\u2551  \u2502   \u250c\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u2502  \u2551\n\u2551  \u2502   \u2502 5 \u2502                   \u2502 (0,T3)  \u2502                           \u2502  \u2551\n\u2551  \u2502   \u2514\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                           \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2502   Now T3 can start!                                             \u2502  \u2551\n\u2551  \u2502   start = max(0, 5) = 5   \u2190 waits for worker!                   \u2502  \u2551\n\u2551  \u2502   end = 5 + 5 = 10                                              \u2502  \u2551\n\u2551  \u2502                                                                 \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                       \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Modify Critical Path Only",
      "description": "Simply divide total work by k workers, ignoring dependency ordering and actual scheduling constraints.",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V + E)",
      "why_not_optimal": "This ignores the actual scheduling dynamics. A task's start time depends on BOTH its dependencies completing AND a worker being available. Simple division doesn't account for dependency chains that force sequential execution regardless of worker count."
    },
    {
      "name": "Simulation Without Priority Queues",
      "description": "Use simple time-stepping simulation, incrementing time by 1 and checking what can happen at each step.",
      "time_complexity": "O(T \u00d7 V) where T is total time",
      "space_complexity": "O(V + E)",
      "why_not_optimal": "When task durations are large (e.g., 10^6), stepping through each time unit is extremely slow. We need to jump directly to meaningful events (task completions) rather than checking every time unit."
    },
    {
      "name": "Optimal: Event-Driven Simulation with Min-Heaps",
      "description": "Use min-heaps to efficiently track: (1) when workers become free, (2) when tasks become ready, and (3) task completion events. Jump directly between completion events rather than simulating each time unit.",
      "time_complexity": "O((V + E) + V log k)",
      "space_complexity": "O(V + E + k)",
      "key_insight": "Maintain a min-heap of worker free times. When assigning a task, start_time = max(task_ready_time, earliest_worker_free). Process completion events in chronological order to release workers and enable dependent tasks."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Event-Driven Simulation Algorithm\n\nThe key insight is that we only need to process **discrete events** (task completions), not every time unit.\n\n### Core Data Structures:\n1. **Workers Min-Heap**: Stores when each of the k workers becomes free\n2. **Ready Tasks Queue**: Tasks whose dependencies are satisfied, waiting for workers\n3. **Completions Min-Heap**: Scheduled task completion events (time, task_id)\n\n### Algorithm Flow:\n1. **Initialize**: All workers free at t=0, all tasks with in_degree=0 are ready at t=0\n2. **Schedule Loop**: While tasks remain:\n   - Assign ready tasks to available workers\n   - Task starts at `max(ready_time, worker_free_time)`\n   - Process earliest completion event\n   - Release worker, update dependent tasks' in-degrees\n   - Newly ready tasks (in_degree=0) join ready queue\n\n### Why This Works:\n- **Correctness**: Respects both dependency constraints AND worker limits\n- **Efficiency**: O(log k) per task assignment via heap operations\n- **Cycle Detection**: If completions heap empties but tasks remain, there's a cycle",
    "data_structures": [
      {
        "structure": "Min-Heap (Workers)",
        "purpose": "Track k worker free times, O(log k) to find/update earliest available worker"
      },
      {
        "structure": "Min-Heap (Ready Tasks)",
        "purpose": "Priority queue of tasks ready to run, ordered by ready_time"
      },
      {
        "structure": "Min-Heap (Completions)",
        "purpose": "Process task completions in chronological order"
      },
      {
        "structure": "Adjacency List (Graph)",
        "purpose": "Store dependency relationships for O(1) neighbor access"
      },
      {
        "structure": "In-Degree Map",
        "purpose": "Track remaining dependencies for each task"
      }
    ],
    "algorithm_steps": [
      "Step 1: Build adjacency list and in-degree map from dependency list",
      "Step 2: Initialize workers heap with k zeros (all workers free at time 0)",
      "Step 3: Add all tasks with in_degree=0 to ready queue with ready_time=0",
      "Step 4: Main loop - while not all tasks completed:",
      "  4a: ASSIGN - Pop ready tasks and assign to earliest-free workers",
      "       start_time = max(task_ready_time, worker_free_time)",
      "       Push completion event to completions heap",
      "  4b: COMPLETE - Pop earliest completion from heap",
      "       Push worker back to heap with new free time",
      "       Decrement in-degrees of all dependents",
      "       Add newly-ready tasks (in_degree=0) to ready queue",
      "Step 5: Return maximum completion time seen"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Dict, Set",
    "from collections import defaultdict",
    "import heapq",
    "",
    "class TaskScheduler:",
    "    \"\"\"",
    "    Task scheduling system with dependency management and worker limits.",
    "    ",
    "    Supports both unlimited parallelism (Part 1) and limited workers (Part 2).",
    "    Uses event-driven simulation with min-heaps for optimal performance.",
    "    \"\"\"",
    "    ",
    "    def schedule_tasks_with_workers(",
    "        self,",
    "        task_list: List[List[int]],",
    "        dependency_list: List[List[int]],",
    "        k: int",
    "    ) -> int:",
    "        \"\"\"",
    "        Schedule tasks with exactly k parallel workers.",
    "        ",
    "        Args:",
    "            task_list: List of [task_id, duration] pairs",
    "            dependency_list: List of [task_a, task_b] where a must complete before b",
    "            k: Number of available workers (1 <= k <= n)",
    "        ",
    "        Returns:",
    "            Minimum total time to complete all tasks, or -1 if cycle exists",
    "        ",
    "        Time Complexity: O((V + E) + V log k)",
    "        Space Complexity: O(V + E + k)",
    "        \"\"\"",
    "        # Edge case: empty task list",
    "        if not task_list:",
    "            return 0",
    "        ",
    "        # Build task information",
    "        n = len(task_list)",
    "        duration: Dict[int, int] = {}",
    "        task_ids: Set[int] = set()",
    "        ",
    "        for task_id, dur in task_list:",
    "            duration[task_id] = dur",
    "            task_ids.add(task_id)",
    "        ",
    "        # Build dependency graph and in-degree map",
    "        graph: Dict[int, List[int]] = defaultdict(list)",
    "        in_degree: Dict[int, int] = {task_id: 0 for task_id in task_ids}",
    "        ",
    "        for task_a, task_b in dependency_list:",
    "            graph[task_a].append(task_b)",
    "            in_degree[task_b] += 1",
    "        ",
    "        # Initialize workers min-heap: all k workers free at time 0",
    "        workers: List[int] = [0] * k",
    "        heapq.heapify(workers)",
    "        ",
    "        # Ready tasks min-heap: (ready_time, task_id)",
    "        # Tasks with no dependencies are ready at time 0",
    "        ready: List[tuple] = [",
    "            (0, task_id) for task_id in task_ids if in_degree[task_id] == 0",
    "        ]",
    "        heapq.heapify(ready)",
    "        ",
    "        # Completion events min-heap: (completion_time, task_id)",
    "        completions: List[tuple] = []",
    "        ",
    "        max_time = 0",
    "        completed_count = 0",
    "        ",
    "        # Main simulation loop",
    "        while completed_count < n:",
    "            # Phase 1: Assign ready tasks to available workers",
    "            while ready and workers:",
    "                ready_time, task_id = heapq.heappop(ready)",
    "                worker_free_time = heapq.heappop(workers)",
    "                ",
    "                # Task starts when BOTH worker is free AND task is ready",
    "                start_time = max(ready_time, worker_free_time)",
    "                end_time = start_time + duration[task_id]",
    "                ",
    "                # Schedule completion event",
    "                heapq.heappush(completions, (end_time, task_id))",
    "                max_time = max(max_time, end_time)",
    "            ",
    "            # Cycle detection: no completions but tasks remain",
    "            if not completions:",
    "                return -1",
    "            ",
    "            # Phase 2: Process next completion event",
    "            completion_time, completed_task = heapq.heappop(completions)",
    "            ",
    "            # Worker becomes free at completion time",
    "            heapq.heappush(workers, completion_time)",
    "            completed_count += 1",
    "            ",
    "            # Enable dependent tasks",
    "            for dependent in graph[completed_task]:",
    "                in_degree[dependent] -= 1",
    "                if in_degree[dependent] == 0:",
    "                    # Dependent is now ready, can start after this task completes",
    "                    heapq.heappush(ready, (completion_time, dependent))",
    "        ",
    "        return max_time",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate task scheduling with limited workers.\"\"\"",
    "    scheduler = TaskScheduler()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"TASK SCHEDULING WITH LIMITED WORKERS - DEMO\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Example 1: Worker limitation matters",
    "    print(\"\\n\ud83d\udccb Example 1: Three independent tasks, 2 workers\")",
    "    tasks1 = [[1, 5], [2, 5], [3, 5]]",
    "    deps1 = []",
    "    k1 = 2",
    "    result1 = scheduler.schedule_tasks_with_workers(tasks1, deps1, k1)",
    "    print(f\"   Tasks: {tasks1}\")",
    "    print(f\"   Dependencies: {deps1}\")",
    "    print(f\"   Workers: {k1}\")",
    "    print(f\"   Result: {result1}\")",
    "    print(\"   Explanation: Tasks 1,2 run parallel (t=0-5), Task 3 waits for worker (t=5-10)\")",
    "    ",
    "    # Example 2: Critical path dominates",
    "    print(\"\\n\ud83d\udccb Example 2: Dependency chain dominates\")",
    "    tasks2 = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "    deps2 = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "    k2 = 2",
    "    result2 = scheduler.schedule_tasks_with_workers(tasks2, deps2, k2)",
    "    print(f\"   Tasks: {tasks2}\")",
    "    print(f\"   Dependencies: {deps2}\")",
    "    print(f\"   Workers: {k2}\")",
    "    print(f\"   Result: {result2}\")",
    "    print(\"   Explanation: Critical path 1\u21923\u21924 (3+5+3=11) determines minimum time\")",
    "    ",
    "    # Example 3: Single worker (sequential execution)",
    "    print(\"\\n\ud83d\udccb Example 3: Single worker (sequential)\")",
    "    tasks3 = [[1, 3], [2, 4], [3, 2]]",
    "    deps3 = []",
    "    k3 = 1",
    "    result3 = scheduler.schedule_tasks_with_workers(tasks3, deps3, k3)",
    "    print(f\"   Tasks: {tasks3}\")",
    "    print(f\"   Workers: {k3}\")",
    "    print(f\"   Result: {result3}\")",
    "    print(\"   Explanation: All tasks sequential: 3 + 4 + 2 = 9\")",
    "    ",
    "    # Example 4: Cycle detection",
    "    print(\"\\n\ud83d\udccb Example 4: Cycle in dependencies\")",
    "    tasks4 = [[1, 3], [2, 4], [3, 2]]",
    "    deps4 = [[1, 2], [2, 3], [3, 1]]",
    "    k4 = 2",
    "    result4 = scheduler.schedule_tasks_with_workers(tasks4, deps4, k4)",
    "    print(f\"   Tasks: {tasks4}\")",
    "    print(f\"   Dependencies: {deps4}\")",
    "    print(f\"   Result: {result4}\")",
    "    print(\"   Explanation: Cycle detected (1\u21922\u21923\u21921), returns -1\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests completed!\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Task scheduling system with dependency management and worker limits.",
    " * Uses event-driven simulation with priority queues for optimal performance.",
    " */",
    "public class TaskScheduler {",
    "    ",
    "    /**",
    "     * Schedule tasks with exactly k parallel workers.",
    "     *",
    "     * @param taskList List of [task_id, duration] pairs",
    "     * @param dependencyList List of [task_a, task_b] where a must complete before b",
    "     * @param k Number of available workers (1 <= k <= n)",
    "     * @return Minimum total time to complete all tasks, or -1 if cycle exists",
    "     *",
    "     * Time Complexity: O((V + E) + V log k)",
    "     * Space Complexity: O(V + E + k)",
    "     */",
    "    public int scheduleTasksWithWorkers(int[][] taskList, int[][] dependencyList, int k) {",
    "        // Edge case: empty task list",
    "        if (taskList == null || taskList.length == 0) {",
    "            return 0;",
    "        }",
    "        ",
    "        int n = taskList.length;",
    "        ",
    "        // Build task information",
    "        Map<Integer, Integer> duration = new HashMap<>();",
    "        Set<Integer> taskIds = new HashSet<>();",
    "        ",
    "        for (int[] task : taskList) {",
    "            duration.put(task[0], task[1]);",
    "            taskIds.add(task[0]);",
    "        }",
    "        ",
    "        // Build dependency graph and in-degree map",
    "        Map<Integer, List<Integer>> graph = new HashMap<>();",
    "        Map<Integer, Integer> inDegree = new HashMap<>();",
    "        ",
    "        for (int taskId : taskIds) {",
    "            graph.put(taskId, new ArrayList<>());",
    "            inDegree.put(taskId, 0);",
    "        }",
    "        ",
    "        for (int[] dep : dependencyList) {",
    "            graph.get(dep[0]).add(dep[1]);",
    "            inDegree.put(dep[1], inDegree.get(dep[1]) + 1);",
    "        }",
    "        ",
    "        // Initialize workers min-heap: all k workers free at time 0",
    "        PriorityQueue<Integer> workers = new PriorityQueue<>();",
    "        for (int i = 0; i < k; i++) {",
    "            workers.offer(0);",
    "        }",
    "        ",
    "        // Ready tasks min-heap: [ready_time, task_id]",
    "        PriorityQueue<int[]> ready = new PriorityQueue<>((a, b) -> {",
    "            if (a[0] != b[0]) return a[0] - b[0];",
    "            return a[1] - b[1];",
    "        });",
    "        ",
    "        for (int taskId : taskIds) {",
    "            if (inDegree.get(taskId) == 0) {",
    "                ready.offer(new int[]{0, taskId});",
    "            }",
    "        }",
    "        ",
    "        // Completion events min-heap: [completion_time, task_id]",
    "        PriorityQueue<int[]> completions = new PriorityQueue<>((a, b) -> {",
    "            if (a[0] != b[0]) return a[0] - b[0];",
    "            return a[1] - b[1];",
    "        });",
    "        ",
    "        int maxTime = 0;",
    "        int completedCount = 0;",
    "        ",
    "        // Main simulation loop",
    "        while (completedCount < n) {",
    "            // Phase 1: Assign ready tasks to available workers",
    "            while (!ready.isEmpty() && !workers.isEmpty()) {",
    "                int[] readyTask = ready.poll();",
    "                int readyTime = readyTask[0];",
    "                int taskId = readyTask[1];",
    "                int workerFreeTime = workers.poll();",
    "                ",
    "                // Task starts when BOTH worker is free AND task is ready",
    "                int startTime = Math.max(readyTime, workerFreeTime);",
    "                int endTime = startTime + duration.get(taskId);",
    "                ",
    "                // Schedule completion event",
    "                completions.offer(new int[]{endTime, taskId});",
    "                maxTime = Math.max(maxTime, endTime);",
    "            }",
    "            ",
    "            // Cycle detection: no completions but tasks remain",
    "            if (completions.isEmpty()) {",
    "                return -1;",
    "            }",
    "            ",
    "            // Phase 2: Process next completion event",
    "            int[] completion = completions.poll();",
    "            int completionTime = completion[0];",
    "            int completedTask = completion[1];",
    "            ",
    "            // Worker becomes free at completion time",
    "            workers.offer(completionTime);",
    "            completedCount++;",
    "            ",
    "            // Enable dependent tasks",
    "            for (int dependent : graph.get(completedTask)) {",
    "                inDegree.put(dependent, inDegree.get(dependent) - 1);",
    "                if (inDegree.get(dependent) == 0) {",
    "                    ready.offer(new int[]{completionTime, dependent});",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return maxTime;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        TaskScheduler scheduler = new TaskScheduler();",
    "        ",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"TASK SCHEDULING WITH LIMITED WORKERS - DEMO\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Example 1: Worker limitation matters",
    "        System.out.println(\"\\n\ud83d\udccb Example 1: Three independent tasks, 2 workers\");",
    "        int[][] tasks1 = {{1, 5}, {2, 5}, {3, 5}};",
    "        int[][] deps1 = {};",
    "        int k1 = 2;",
    "        int result1 = scheduler.scheduleTasksWithWorkers(tasks1, deps1, k1);",
    "        System.out.println(\"   Result: \" + result1 + \" (expected: 10)\");",
    "        ",
    "        // Example 2: Critical path dominates",
    "        System.out.println(\"\\n\ud83d\udccb Example 2: Dependency chain dominates\");",
    "        int[][] tasks2 = {{1, 3}, {2, 2}, {3, 5}, {4, 3}};",
    "        int[][] deps2 = {{1, 2}, {1, 3}, {2, 4}, {3, 4}};",
    "        int k2 = 2;",
    "        int result2 = scheduler.scheduleTasksWithWorkers(tasks2, deps2, k2);",
    "        System.out.println(\"   Result: \" + result2 + \" (expected: 11)\");",
    "        ",
    "        // Example 3: Single worker",
    "        System.out.println(\"\\n\ud83d\udccb Example 3: Single worker (sequential)\");",
    "        int[][] tasks3 = {{1, 3}, {2, 4}, {3, 2}};",
    "        int[][] deps3 = {};",
    "        int k3 = 1;",
    "        int result3 = scheduler.scheduleTasksWithWorkers(tasks3, deps3, k3);",
    "        System.out.println(\"   Result: \" + result3 + \" (expected: 9)\");",
    "        ",
    "        // Example 4: Cycle detection",
    "        System.out.println(\"\\n\ud83d\udccb Example 4: Cycle in dependencies\");",
    "        int[][] tasks4 = {{1, 3}, {2, 4}, {3, 2}};",
    "        int[][] deps4 = {{1, 2}, {2, 3}, {3, 1}};",
    "        int k4 = 2;",
    "        int result4 = scheduler.scheduleTasksWithWorkers(tasks4, deps4, k4);",
    "        System.out.println(\"   Result: \" + result4 + \" (expected: -1)\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Import statements and class docstring. We need heapq for efficient priority queue operations, defaultdict for graph construction, and typing for type hints."
    },
    {
      "lines": "12-32",
      "explanation": "Method signature with comprehensive docstring explaining parameters, return value, and complexity. This is critical for interview clarity."
    },
    {
      "lines": "33-44",
      "explanation": "Build task information: create duration lookup map and set of task IDs. This O(n) preprocessing enables O(1) lookups later."
    },
    {
      "lines": "46-53",
      "explanation": "Build dependency graph as adjacency list and initialize in-degree map. Each task starts with in_degree=0, then we increment for each incoming edge."
    },
    {
      "lines": "55-58",
      "explanation": "Initialize workers heap with k zeros - all workers are free at time 0. This min-heap always gives us the earliest-available worker in O(log k)."
    },
    {
      "lines": "60-65",
      "explanation": "Initialize ready tasks heap with all tasks having in_degree=0. These tasks have no dependencies and can start immediately at time 0."
    },
    {
      "lines": "67-71",
      "explanation": "Initialize completion events heap (empty) and tracking variables for max_time and completed_count."
    },
    {
      "lines": "73-85",
      "explanation": "Phase 1 of main loop: Greedily assign ready tasks to available workers. Each task starts at max(ready_time, worker_free_time). The while loop continues until we run out of either ready tasks or free workers."
    },
    {
      "lines": "87-89",
      "explanation": "Cycle detection: If completions heap is empty but tasks remain unscheduled, there must be a cycle preventing progress. Return -1."
    },
    {
      "lines": "91-102",
      "explanation": "Phase 2: Process the earliest completion event. Release the worker (push completion_time back to workers heap), increment completed count, and enable dependent tasks whose in-degree reaches 0."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "scheduleTasksWithWorkers": {
          "complexity": "O((V + E) + V log k)",
          "explanation": "O(V + E) for building graph and processing all edges once. Each of the V tasks is pushed/popped from workers heap (O(log k) each) and ready/completions heaps (O(log V) each, but bounded by heap sizes)."
        }
      },
      "overall_change": "Same optimal complexity as the hint suggests. The log k factor comes from the workers heap being bounded by k. In practice, when k is small, this is very efficient."
    },
    "space": {
      "additional_space": "O(V + E + k)",
      "explanation": "O(V + E) for the graph and in-degree map. O(k) for the workers heap. O(V) worst case for ready and completions heaps. The workers heap is the key new data structure for Part 2."
    }
  },
  "dry_run": {
    "example_input": "tasks = [[1,5], [2,5], [3,5]], deps = [], k = 2",
    "steps": [
      {
        "step": 1,
        "action": "Initialize data structures",
        "state": "workers=[0,0], ready=[(0,1),(0,2),(0,3)], completions=[], max_time=0",
        "explanation": "All 3 tasks have in_degree=0 (no dependencies), so all are ready at t=0. Both workers are free at t=0."
      },
      {
        "step": 2,
        "action": "Assign Task 1 to Worker 1",
        "state": "workers=[0], ready=[(0,2),(0,3)], completions=[(5,1)], max_time=5",
        "explanation": "Pop (0,1) from ready, pop 0 from workers. start=max(0,0)=0, end=0+5=5. Push (5,1) to completions."
      },
      {
        "step": 3,
        "action": "Assign Task 2 to Worker 2",
        "state": "workers=[], ready=[(0,3)], completions=[(5,1),(5,2)], max_time=5",
        "explanation": "Pop (0,2) from ready, pop 0 from workers. start=max(0,0)=0, end=0+5=5. Workers heap now empty!"
      },
      {
        "step": 4,
        "action": "Exit inner loop (no free workers), process completion",
        "state": "workers=[5], ready=[(0,3)], completions=[(5,2)], completed=1",
        "explanation": "Pop (5,1) from completions. Worker becomes free at t=5. Task 1 has no dependents."
      },
      {
        "step": 5,
        "action": "Assign Task 3 to now-free worker",
        "state": "workers=[], ready=[], completions=[(5,2),(10,3)], max_time=10",
        "explanation": "Pop (0,3) from ready, pop 5 from workers. start=max(0,5)=5 (WAITS!), end=5+5=10."
      },
      {
        "step": 6,
        "action": "Process remaining completions",
        "state": "completed=3, max_time=10",
        "explanation": "Process (5,2) then (10,3). No new tasks become ready. Loop exits when completed=3=n."
      }
    ],
    "final_output": "10 - Task 3 had to wait from t=0 to t=5 for a worker, adding 5 to the total time vs unlimited workers."
  },
  "edge_cases": [
    {
      "case": "Empty task list",
      "handling": "Return 0 immediately",
      "gotcha": "Don't try to process empty heaps"
    },
    {
      "case": "k >= n (more workers than tasks)",
      "handling": "Algorithm works correctly - effectively unlimited parallelism",
      "gotcha": "Result should match Part 1's critical path answer"
    },
    {
      "case": "k = 1 (single worker)",
      "handling": "All tasks execute sequentially in topological order",
      "gotcha": "Total time = sum of all durations (if no deps) or may be less if some paths are parallel in dependencies"
    },
    {
      "case": "Cycle in dependencies",
      "handling": "Detected when completions heap empties but tasks remain",
      "gotcha": "Must check BEFORE trying to pop from empty heap"
    },
    {
      "case": "All tasks depend on one initial task",
      "handling": "First task runs alone, then k tasks can run in parallel",
      "gotcha": "Ready queue fills up after first completion - heap must handle this"
    },
    {
      "case": "Linear chain (1\u21922\u21923\u2192...\u2192n)",
      "handling": "Only one task ready at a time, extra workers are idle",
      "gotcha": "Result same as k=1 case - critical path dominates"
    }
  ],
  "test_cases": [
    {
      "name": "Worker limitation active",
      "input": "tasks=[[1,5],[2,5],[3,5]], deps=[], k=2",
      "expected": "10",
      "explanation": "3 tasks, 2 workers. Two run parallel t=0-5, third runs t=5-10."
    },
    {
      "name": "Critical path dominates",
      "input": "tasks=[[1,3],[2,2],[3,5],[4,3]], deps=[[1,2],[1,3],[2,4],[3,4]], k=2",
      "expected": "11",
      "explanation": "Critical path 1\u21923\u21924 takes 3+5+3=11, same as unlimited workers."
    },
    {
      "name": "Single worker sequential",
      "input": "tasks=[[1,3],[2,4],[3,2]], deps=[], k=1",
      "expected": "9",
      "explanation": "All tasks run sequentially: 3+4+2=9"
    },
    {
      "name": "Cycle detection",
      "input": "tasks=[[1,3],[2,4],[3,2]], deps=[[1,2],[2,3],[3,1]], k=2",
      "expected": "-1",
      "explanation": "Circular dependency detected, impossible to schedule"
    },
    {
      "name": "Abundant workers",
      "input": "tasks=[[1,5],[2,5],[3,5]], deps=[], k=10",
      "expected": "5",
      "explanation": "More workers than tasks, all run in parallel"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not tracking when tasks become READY (dependency completion time)",
      "why_wrong": "A task can't start before its dependencies complete, even if a worker is free",
      "correct_approach": "Store (ready_time, task_id) in ready queue, start = max(ready_time, worker_free)",
      "code_example_wrong": "// Wrong: ignoring when dependencies complete\nstart_time = worker_free_time;",
      "code_example_correct": "// Correct: respect both constraints\nstart_time = max(ready_time, worker_free_time);"
    },
    {
      "mistake": "Using a fixed-size array instead of heap for workers",
      "why_wrong": "Finding earliest-free worker becomes O(k) instead of O(log k)",
      "correct_approach": "Use min-heap for workers to get O(log k) access to earliest free time",
      "code_example_wrong": "// Wrong: O(k) linear scan\nint earliest = Integer.MAX_VALUE;\nfor (int w : workers) earliest = Math.min(earliest, w);",
      "code_example_correct": "// Correct: O(log k) heap operation\nint workerFree = workers.poll();"
    },
    {
      "mistake": "Forgetting to push worker back to heap after assignment",
      "why_wrong": "Worker count decreases over time, eventually no tasks can be scheduled",
      "correct_approach": "Push worker back with completion_time when processing the completion event",
      "code_example_wrong": "// Wrong: worker disappears\nint completion = completions.poll();\ncompletedCount++;",
      "code_example_correct": "// Correct: worker returns to pool\nint completion = completions.poll();\nworkers.offer(completionTime);\ncompletedCount++;"
    },
    {
      "mistake": "Not handling the case where ready queue is empty but completions remain",
      "why_wrong": "Must wait for completions to enable new ready tasks",
      "correct_approach": "Continue processing completions until ready tasks appear",
      "code_example_wrong": "// Wrong: exits early\nif (ready.isEmpty()) break;",
      "code_example_correct": "// Correct: process completion to potentially enable tasks\nif (!completions.isEmpty()) {\n    // process completion, update in-degrees\n}"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the KEY INSIGHT: 'With limited workers, a task might be ready but still have to wait. I need to simulate actual time progression.' Then describe the three heaps and how they interact. Draw the worker timeline to make it concrete.",
    "what_to_mention": [
      "This is an EVENT-DRIVEN SIMULATION - we jump between completion events, not every time unit",
      "The formula: start_time = max(task_ready_time, worker_free_time)",
      "Min-heap for workers gives O(log k) access to earliest available",
      "Cycle detection comes 'for free' - if we can't make progress, there's a cycle",
      "When k is large, this degenerates to Part 1's critical path solution"
    ],
    "time_allocation": "Spend 2-3 minutes explaining the approach BEFORE coding. Draw the worker/task timeline example. This prevents getting lost during implementation.",
    "if_stuck": [
      "Think about what EVENTS matter - only task completions change the state",
      "Ask: 'When can a task actually START?' - needs both dependency AND worker",
      "Consider: 'How do I efficiently find the earliest-free worker?' - that's your heap",
      "Trace through the k=1 case first - it's sequential and easier to verify"
    ]
  },
  "connection_to_next_part": "Part 3 might introduce: (1) Task priorities - which ready task to schedule first when workers are limited, (2) Worker specialization - only certain workers can do certain tasks, (3) Task preemption - higher priority tasks can pause lower priority ones, or (4) Resource constraints - tasks need memory/CPU that's also limited. The event-driven simulation framework extends naturally to handle these by adding more complex scheduling logic in the 'assign ready tasks' phase.",
  "generated_at": "2026-01-14T15:18:05.648626",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}