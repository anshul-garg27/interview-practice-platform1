{
  "problem_title": "Process Scheduling on Processors - Part 3: Token Bucket Rate Limiter",
  "part_number": 3,
  "builds_on": "Part 2 (Different problem in same interview loop)",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "This is a completely **different design problem** from Parts 1-2 (Process Scheduling). It was asked in the same interview loop. You're designing a Token Bucket for rate limiting - a classic system design pattern used in API rate limiting, network traffic shaping, and request throttling.",
    "new_requirements": [
      "Design a bucket with fixed capacity that holds tokens",
      "add(token) - Add explicit token, drop if bucket full",
      "get() - Peek at arbitrary token without removal",
      "setDripRate(rate) - Enable automatic token accumulation over time",
      "Dripped tokens are virtual/synthetic (named 'dripped_0', 'dripped_1', etc.)"
    ],
    "new_constraints": [
      "get() does NOT remove the token - it only peeks",
      "Dripped tokens accumulate lazily based on elapsed time",
      "Total tokens (explicit + dripped) cannot exceed capacity",
      "Must handle time-based calculations efficiently"
    ],
    "key_insight": "**Lazy Evaluation** - Instead of actually simulating time passing and creating tokens every second, we compute the token count on-demand when add() or get() is called. This is O(1) instead of O(time_elapsed)."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    TOKEN BUCKET STATE TRANSITIONS                        \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                          \u2551\n\u2551  INITIAL STATE (capacity=5)           AFTER add('A'), add('B'), add('C') \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2551\n\u2551  \u2502      EMPTY          \u2502              \u2502  [A] [B] [C]        \u2502            \u2551\n\u2551  \u2502                     \u2502    \u2500\u2500\u2500\u25ba      \u2502                     \u2502            \u2551\n\u2551  \u2502  Capacity: 5        \u2502              \u2502  Explicit: 3        \u2502            \u2551\n\u2551  \u2502  Explicit: 0        \u2502              \u2502  Dripped:  0        \u2502            \u2551\n\u2551  \u2502  Dripped:  0        \u2502              \u2502  Total:    3        \u2502            \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2551\n\u2551                                                                          \u2551\n\u2551  WITH DRIP RATE (rate=2/sec, after 3 seconds, capacity=5)                \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                 \u2551\n\u2551  \u2502  [D\u2080][D\u2081][D\u2082][D\u2083][D\u2084]\u2502  \u2190 5 dripped tokens (capped from 6)           \u2551\n\u2551  \u2502                     \u2502                                                 \u2551\n\u2551  \u2502  Potential: 3\u00d72 = 6 \u2502    add('X') \u2192 FALSE (bucket full!)             \u2551\n\u2551  \u2502  Actual:    5 (cap) \u2502    get()    \u2192 'dripped_0'                      \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                 \u2551\n\u2551                                                                          \u2551\n\u2551  MIXED STATE (explicit + dripped)                                        \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                 \u2551\n\u2551  \u2502  [A] [B] [D\u2080][D\u2081][ ]\u2502  \u2190 2 explicit + 2 dripped = 4 total            \u2551\n\u2551  \u2502                     \u2502                                                 \u2551\n\u2551  \u2502  add('C') \u2192 TRUE    \u2502    (space for 1 more)                          \u2551\n\u2551  \u2502  get()    \u2192 'A'     \u2502    (prefers explicit tokens)                   \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                 \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                        LAZY DRIP COMPUTATION FLOW                         \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551  On ANY operation (add/get):                                              \u2551\n\u2551                                                                           \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2551\n\u2551  \u2502 STEP 1: Sync Dripped Tokens                                         \u2502 \u2551\n\u2551  \u2502                                                                      \u2502 \u2551\n\u2551  \u2502   elapsed = current_time - last_update_time                         \u2502 \u2551\n\u2551  \u2502   potential_dripped = floor(elapsed \u00d7 drip_rate)                    \u2502 \u2551\n\u2551  \u2502   space_available = capacity - explicit_count - dripped_count       \u2502 \u2551\n\u2551  \u2502   actual_new = min(potential_dripped, space_available)              \u2502 \u2551\n\u2551  \u2502   dripped_count += actual_new                                       \u2502 \u2551\n\u2551  \u2502   last_update_time = current_time                                   \u2502 \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551\n\u2551                              \u2502                                            \u2551\n\u2551                              \u25bc                                            \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2551\n\u2551  \u2502 STEP 2: Perform Operation                                           \u2502 \u2551\n\u2551  \u2502                                                                      \u2502 \u2551\n\u2551  \u2502   add(token):                      get():                           \u2502 \u2551\n\u2551  \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502 \u2551\n\u2551  \u2502   \u2502 total = explicit +      \u2502     \u2502 if explicit_tokens:     \u2502       \u2502 \u2551\n\u2551  \u2502   \u2502        dripped          \u2502     \u2502   return explicit[0]    \u2502       \u2502 \u2551\n\u2551  \u2502   \u2502 if total >= capacity:   \u2502     \u2502 if dripped_count > 0:   \u2502       \u2502 \u2551\n\u2551  \u2502   \u2502   return FALSE          \u2502     \u2502   return 'dripped_N'    \u2502       \u2502 \u2551\n\u2551  \u2502   \u2502 explicit.append(token)  \u2502     \u2502 return NULL             \u2502       \u2502 \u2551\n\u2551  \u2502   \u2502 return TRUE             \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502 \u2551\n\u2551  \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                       \u2502 \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551\n\u2551                                                                           \u2551\n\u2551  TIME COMPLEXITY: O(1) for all operations!                                \u2551\n\u2551  (No loops, no simulation, just arithmetic)                               \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Timer-Based Approach",
      "description": "Use a background thread/timer that adds tokens every 1/rate seconds",
      "time_complexity": "O(1) per operation, but O(time) background work",
      "space_complexity": "O(capacity)",
      "why_not_optimal": "Requires threading, wastes resources when bucket isn't accessed, potential race conditions, and if rate is high (e.g., 1000/sec), creates enormous overhead. A bucket not accessed for an hour would still 'tick' 3.6 million times."
    },
    {
      "name": "Optimal Lazy Evaluation",
      "description": "Compute dripped token count on-demand based on elapsed time since last access. No background threads, no simulation - pure math.",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(n) where n = number of explicit tokens",
      "key_insight": "Instead of tracking time passing, we track when we LAST computed drips. On any access, we calculate: elapsed_time \u00d7 rate = tokens_that_would_have_dripped. This is a single multiplication, not a loop."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Lazy Evaluation Pattern\n\nThe key insight is that **we don't need to know the exact state of the bucket at every moment** - we only need to know it **when someone asks**.\n\n### Core Data Structures\n\n1. **`explicit_tokens: List[str]`** - Tokens added via `add()`. These are \"real\" tokens with names.\n\n2. **`dripped_count: int`** - Number of virtual dripped tokens. These are synthetic tokens named `dripped_0`, `dripped_1`, etc.\n\n3. **`last_update_time: float`** - Timestamp of last drip computation.\n\n4. **`drip_rate: float`** - Tokens per second.\n\n### The Magic Formula\n\n```\npotential_dripped = floor((current_time - last_update_time) \u00d7 drip_rate)\nspace_available = capacity - len(explicit_tokens) - dripped_count\nactual_new_dripped = min(potential_dripped, max(0, space_available))\n```\n\n### Why This Works\n\n- **Time is continuous**: Even if we don't check for 10 minutes, when we finally check, we compute `10min \u00d7 60sec \u00d7 rate` in O(1).\n- **Space constraint is respected**: We never exceed capacity, even with lazy evaluation.\n- **Explicit tokens have priority**: They take up space, leaving less room for dripped tokens.",
    "data_structures": [
      {
        "structure": "List/ArrayList",
        "purpose": "Store explicit tokens in order"
      },
      {
        "structure": "Timestamp (float/long)",
        "purpose": "Track last drip computation time"
      },
      {
        "structure": "Counter (int)",
        "purpose": "Track number of dripped tokens"
      }
    ],
    "algorithm_steps": [
      "Step 1: On any operation, first call _sync_dripped_tokens() to update drip count",
      "Step 2: In sync, calculate elapsed time since last update",
      "Step 3: Compute potential new drips: floor(elapsed \u00d7 rate)",
      "Step 4: Compute available space: capacity - explicit - current_dripped",
      "Step 5: Add min(potential, available) to dripped_count",
      "Step 6: Update timestamp to current time",
      "Step 7: Perform the actual operation (add/get) using updated counts"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Token Bucket Rate Limiter with Lazy Drip Evaluation",
    "",
    "A production-quality implementation of the Token Bucket algorithm",
    "for rate limiting, featuring time-based token accumulation.",
    "",
    "Key Design Decisions:",
    "1. Lazy evaluation - compute drips on-demand, not continuously",
    "2. Explicit tokens stored in list, dripped tokens are virtual",
    "3. Thread-safety notes included but not fully implemented",
    "   (would need locks in production multi-threaded environment)",
    "",
    "Time Complexity: O(1) for all operations",
    "Space Complexity: O(n) where n = number of explicit tokens",
    "\"\"\"",
    "",
    "import time",
    "from typing import Optional, List",
    "",
    "",
    "class TokenBucket:",
    "    \"\"\"",
    "    A Token Bucket for rate limiting with drip support.",
    "    ",
    "    The bucket has a fixed capacity and supports:",
    "    - Adding explicit tokens (dropped if full)",
    "    - Peeking at tokens (without removal)",
    "    - Automatic token accumulation over time (dripping)",
    "    ",
    "    Example:",
    "        bucket = TokenBucket(5)",
    "        bucket.add('request_1')  # True",
    "        bucket.add('request_2')  # True",
    "        bucket.get()             # 'request_1' (doesn't remove)",
    "    \"\"\"",
    "    ",
    "    def __init__(self, capacity: int) -> None:",
    "        \"\"\"",
    "        Initialize an empty token bucket.",
    "        ",
    "        Args:",
    "            capacity: Maximum number of tokens the bucket can hold.",
    "                      Must be non-negative.",
    "        \"\"\"",
    "        if capacity < 0:",
    "            raise ValueError(f'Capacity must be non-negative, got {capacity}')",
    "        ",
    "        self._capacity: int = capacity",
    "        self._explicit_tokens: List[str] = []",
    "        self._drip_rate: float = 0.0",
    "        self._last_update_time: float = time.time()",
    "        self._dripped_count: int = 0",
    "        self._dripped_base_id: int = 0  # For naming dripped tokens",
    "    ",
    "    def _sync_dripped_tokens(self) -> None:",
    "        \"\"\"",
    "        Lazily compute accumulated dripped tokens based on elapsed time.",
    "        ",
    "        This is the core optimization: instead of running a timer,",
    "        we calculate the drip count on-demand using simple arithmetic.",
    "        ",
    "        Formula: new_dripped = floor(elapsed_seconds \u00d7 drip_rate)",
    "        Actual:  min(new_dripped, available_space)",
    "        \"\"\"",
    "        if self._drip_rate <= 0:",
    "            return  # No dripping configured",
    "        ",
    "        current_time = time.time()",
    "        elapsed_seconds = current_time - self._last_update_time",
    "        ",
    "        if elapsed_seconds <= 0:",
    "            return  # No time has passed",
    "        ",
    "        # Calculate potential new tokens from dripping",
    "        potential_new_tokens = int(elapsed_seconds * self._drip_rate)",
    "        ",
    "        if potential_new_tokens > 0:",
    "            # Calculate available space in bucket",
    "            current_total = len(self._explicit_tokens) + self._dripped_count",
    "            space_available = max(0, self._capacity - current_total)",
    "            ",
    "            # Add what fits",
    "            tokens_to_add = min(potential_new_tokens, space_available)",
    "            self._dripped_count += tokens_to_add",
    "            ",
    "            # Update timestamp for next calculation",
    "            self._last_update_time = current_time",
    "    ",
    "    def set_drip_rate(self, rate: float) -> None:",
    "        \"\"\"",
    "        Set the dripping rate for automatic token accumulation.",
    "        ",
    "        Args:",
    "            rate: Number of tokens to add per second.",
    "                  Set to 0 to disable dripping.",
    "        ",
    "        Note:",
    "            Changing the rate first settles any pending drips at the",
    "            old rate, then starts fresh at the new rate.",
    "        \"\"\"",
    "        if rate < 0:",
    "            raise ValueError(f'Drip rate must be non-negative, got {rate}')",
    "        ",
    "        # Settle pending drips at old rate first",
    "        self._sync_dripped_tokens()",
    "        ",
    "        # Set new rate and reset timer",
    "        self._drip_rate = rate",
    "        self._last_update_time = time.time()",
    "    ",
    "    def add(self, token: str) -> bool:",
    "        \"\"\"",
    "        Add a token to the bucket.",
    "        ",
    "        Args:",
    "            token: The token (typically a request identifier) to add.",
    "        ",
    "        Returns:",
    "            True if the token was successfully added.",
    "            False if the bucket is full (token is dropped).",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        # First, sync dripped tokens to get accurate count",
    "        self._sync_dripped_tokens()",
    "        ",
    "        # Check if we have space",
    "        total_tokens = len(self._explicit_tokens) + self._dripped_count",
    "        ",
    "        if total_tokens >= self._capacity:",
    "            return False  # Bucket full, drop the token",
    "        ",
    "        # Add the explicit token",
    "        self._explicit_tokens.append(token)",
    "        return True",
    "    ",
    "    def get(self) -> Optional[str]:",
    "        \"\"\"",
    "        Retrieve an arbitrary token from the bucket.",
    "        ",
    "        IMPORTANT: This method does NOT remove the token - it only peeks.",
    "        Calling get() multiple times returns the same token.",
    "        ",
    "        Returns:",
    "            A token if the bucket is non-empty.",
    "            None if the bucket is empty.",
    "        ",
    "        Note:",
    "            Explicit tokens are returned before dripped tokens.",
    "            Dripped tokens have synthetic names like 'dripped_0'.",
    "        ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        # Sync dripped tokens first",
    "        self._sync_dripped_tokens()",
    "        ",
    "        # Prefer explicit tokens (they have real names)",
    "        if self._explicit_tokens:",
    "            return self._explicit_tokens[0]",
    "        ",
    "        # Return a dripped token if available",
    "        if self._dripped_count > 0:",
    "            return f'dripped_{self._dripped_base_id}'",
    "        ",
    "        # Bucket is empty",
    "        return None",
    "    ",
    "    def _get_state(self) -> dict:",
    "        \"\"\"Get internal state for debugging/testing.\"\"\"",
    "        self._sync_dripped_tokens()",
    "        return {",
    "            'capacity': self._capacity,",
    "            'explicit_count': len(self._explicit_tokens),",
    "            'explicit_tokens': list(self._explicit_tokens),",
    "            'dripped_count': self._dripped_count,",
    "            'total': len(self._explicit_tokens) + self._dripped_count,",
    "            'drip_rate': self._drip_rate",
    "        }",
    "",
    "",
    "# ============================================================================",
    "# DEMONSTRATION AND TESTING",
    "# ============================================================================",
    "",
    "def demo_basic_operations():",
    "    \"\"\"Demonstrate basic add/get operations.\"\"\"",
    "    print('=' * 60)",
    "    print('DEMO 1: Basic Token Bucket Operations')",
    "    print('=' * 60)",
    "    ",
    "    bucket = TokenBucket(3)",
    "    print(f'Created bucket with capacity 3')",
    "    print()",
    "    ",
    "    # Add tokens",
    "    for token in ['A', 'B', 'C', 'D']:",
    "        result = bucket.add(token)",
    "        status = 'ADDED' if result else 'DROPPED (bucket full)'",
    "        print(f\"  add('{token}') -> {result} [{status}]\")",
    "    ",
    "    print()",
    "    ",
    "    # Get tokens (peek only)",
    "    print(f\"  get() -> '{bucket.get()}' (doesn't remove)\")",
    "    print(f\"  get() -> '{bucket.get()}' (same token again)\")",
    "    print()",
    "    ",
    "    print(f'Final state: {bucket._get_state()}')",
    "    print()",
    "",
    "",
    "def demo_drip_rate():",
    "    \"\"\"Demonstrate drip rate functionality.\"\"\"",
    "    print('=' * 60)",
    "    print('DEMO 2: Drip Rate (Time-Based Token Accumulation)')",
    "    print('=' * 60)",
    "    ",
    "    bucket = TokenBucket(5)",
    "    print(f'Created bucket with capacity 5')",
    "    print()",
    "    ",
    "    # Set drip rate",
    "    bucket.set_drip_rate(2.0)  # 2 tokens per second",
    "    print(f'Set drip rate to 2 tokens/second')",
    "    print()",
    "    ",
    "    # Simulate waiting",
    "    print('Simulating 3 second wait...')",
    "    import time as t",
    "    t.sleep(3.1)  # Wait a bit more to ensure 3 full seconds",
    "    ",
    "    # Check state",
    "    print()",
    "    print(f'After 3 seconds:')",
    "    print(f\"  Expected dripped: 3 \u00d7 2 = 6, capped at 5\")",
    "    print(f\"  get() -> '{bucket.get()}' (dripped token)\")",
    "    print()",
    "    ",
    "    result = bucket.add('X')",
    "    print(f\"  add('X') -> {result} (bucket full!)\")",
    "    print()",
    "    ",
    "    print(f'Final state: {bucket._get_state()}')",
    "    print()",
    "",
    "",
    "def demo_mixed_tokens():",
    "    \"\"\"Demonstrate mixed explicit and dripped tokens.\"\"\"",
    "    print('=' * 60)",
    "    print('DEMO 3: Mixed Explicit and Dripped Tokens')",
    "    print('=' * 60)",
    "    ",
    "    bucket = TokenBucket(5)",
    "    print(f'Created bucket with capacity 5')",
    "    print()",
    "    ",
    "    # Add some explicit tokens first",
    "    bucket.add('Alpha')",
    "    bucket.add('Beta')",
    "    print(f\"Added explicit tokens: 'Alpha', 'Beta'\")",
    "    print(f'State: {bucket._get_state()}')",
    "    print()",
    "    ",
    "    # Set drip rate",
    "    bucket.set_drip_rate(10.0)  # Fast dripping",
    "    print(f'Set drip rate to 10 tokens/second')",
    "    print()",
    "    ",
    "    # Wait briefly",
    "    import time as t",
    "    t.sleep(0.5)  # Should drip ~5 tokens, but only 3 fit",
    "    ",
    "    print('After 0.5 seconds:')",
    "    print(f\"  Would drip: ~5 tokens\")",
    "    print(f\"  Space available: 5 - 2 = 3\")",
    "    print(f\"  Actual dripped: 3 (capped by space)\")",
    "    print()",
    "    ",
    "    # Get should return explicit token first",
    "    print(f\"  get() -> '{bucket.get()}' (explicit token first!)\")",
    "    print()",
    "    ",
    "    print(f'Final state: {bucket._get_state()}')",
    "    print()",
    "",
    "",
    "def run_test_suite():",
    "    \"\"\"Run comprehensive tests.\"\"\"",
    "    print('=' * 60)",
    "    print('TEST SUITE')",
    "    print('=' * 60)",
    "    print()",
    "    ",
    "    tests_passed = 0",
    "    tests_total = 0",
    "    ",
    "    # Test 1: Basic add to empty bucket",
    "    tests_total += 1",
    "    bucket = TokenBucket(3)",
    "    assert bucket.add('A') == True, 'Should add to empty bucket'",
    "    print(f'\u2713 Test 1: Add to empty bucket')",
    "    tests_passed += 1",
    "    ",
    "    # Test 2: Add until full",
    "    tests_total += 1",
    "    bucket.add('B')",
    "    bucket.add('C')",
    "    assert bucket.add('D') == False, 'Should reject when full'",
    "    print(f'\u2713 Test 2: Reject when full')",
    "    tests_passed += 1",
    "    ",
    "    # Test 3: Get from non-empty",
    "    tests_total += 1",
    "    result = bucket.get()",
    "    assert result == 'A', f'Should get first token, got {result}'",
    "    print(f'\u2713 Test 3: Get returns first token')",
    "    tests_passed += 1",
    "    ",
    "    # Test 4: Get doesn't remove",
    "    tests_total += 1",
    "    result2 = bucket.get()",
    "    assert result2 == 'A', 'Get should not remove token'",
    "    print(f'\u2713 Test 4: Get does not remove')",
    "    tests_passed += 1",
    "    ",
    "    # Test 5: Get from empty bucket",
    "    tests_total += 1",
    "    empty_bucket = TokenBucket(3)",
    "    assert empty_bucket.get() is None, 'Should return None for empty'",
    "    print(f'\u2713 Test 5: Get from empty returns None')",
    "    tests_passed += 1",
    "    ",
    "    # Test 6: Zero capacity bucket",
    "    tests_total += 1",
    "    zero_bucket = TokenBucket(0)",
    "    assert zero_bucket.add('X') == False, 'Zero capacity rejects all'",
    "    assert zero_bucket.get() is None, 'Zero capacity always empty'",
    "    print(f'\u2713 Test 6: Zero capacity bucket works correctly')",
    "    tests_passed += 1",
    "    ",
    "    print()",
    "    print(f'Results: {tests_passed}/{tests_total} tests passed')",
    "    print()",
    "",
    "",
    "if __name__ == '__main__':",
    "    # Run all demonstrations",
    "    demo_basic_operations()",
    "    demo_drip_rate()",
    "    demo_mixed_tokens()",
    "    run_test_suite()",
    "    ",
    "    print('=' * 60)",
    "    print('All demonstrations complete!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Token Bucket Rate Limiter with Lazy Drip Evaluation",
    " * ",
    " * A production-quality implementation of the Token Bucket algorithm",
    " * for rate limiting, featuring time-based token accumulation.",
    " * ",
    " * Key Design Decisions:",
    " * 1. Lazy evaluation - compute drips on-demand, not continuously",
    " * 2. Explicit tokens stored in ArrayList, dripped tokens are virtual",
    " * 3. Thread-safety notes: would need synchronization in production",
    " * ",
    " * Time Complexity: O(1) for all operations",
    " * Space Complexity: O(n) where n = number of explicit tokens",
    " */",
    "public class TokenBucket {",
    "    ",
    "    private final int capacity;",
    "    private final List<String> explicitTokens;",
    "    private double dripRate;",
    "    private long lastUpdateTimeMs;",
    "    private int drippedCount;",
    "    private int drippedBaseId;",
    "    ",
    "    /**",
    "     * Initialize an empty token bucket.",
    "     * ",
    "     * @param capacity Maximum number of tokens the bucket can hold",
    "     * @throws IllegalArgumentException if capacity is negative",
    "     */",
    "    public TokenBucket(int capacity) {",
    "        if (capacity < 0) {",
    "            throw new IllegalArgumentException(",
    "                \"Capacity must be non-negative, got \" + capacity);",
    "        }",
    "        ",
    "        this.capacity = capacity;",
    "        this.explicitTokens = new ArrayList<>();",
    "        this.dripRate = 0.0;",
    "        this.lastUpdateTimeMs = System.currentTimeMillis();",
    "        this.drippedCount = 0;",
    "        this.drippedBaseId = 0;",
    "    }",
    "    ",
    "    /**",
    "     * Lazily compute accumulated dripped tokens based on elapsed time.",
    "     * ",
    "     * This is the core optimization: instead of running a timer,",
    "     * we calculate the drip count on-demand using simple arithmetic.",
    "     */",
    "    private void syncDrippedTokens() {",
    "        if (dripRate <= 0) {",
    "            return; // No dripping configured",
    "        }",
    "        ",
    "        long currentTimeMs = System.currentTimeMillis();",
    "        double elapsedSeconds = (currentTimeMs - lastUpdateTimeMs) / 1000.0;",
    "        ",
    "        if (elapsedSeconds <= 0) {",
    "            return; // No time has passed",
    "        }",
    "        ",
    "        // Calculate potential new tokens from dripping",
    "        int potentialNewTokens = (int) (elapsedSeconds * dripRate);",
    "        ",
    "        if (potentialNewTokens > 0) {",
    "            // Calculate available space in bucket",
    "            int currentTotal = explicitTokens.size() + drippedCount;",
    "            int spaceAvailable = Math.max(0, capacity - currentTotal);",
    "            ",
    "            // Add what fits",
    "            int tokensToAdd = Math.min(potentialNewTokens, spaceAvailable);",
    "            drippedCount += tokensToAdd;",
    "            ",
    "            // Update timestamp for next calculation",
    "            lastUpdateTimeMs = currentTimeMs;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Set the dripping rate for automatic token accumulation.",
    "     * ",
    "     * @param rate Number of tokens to add per second (0 to disable)",
    "     * @throws IllegalArgumentException if rate is negative",
    "     */",
    "    public void setDripRate(double rate) {",
    "        if (rate < 0) {",
    "            throw new IllegalArgumentException(",
    "                \"Drip rate must be non-negative, got \" + rate);",
    "        }",
    "        ",
    "        // Settle pending drips at old rate first",
    "        syncDrippedTokens();",
    "        ",
    "        // Set new rate and reset timer",
    "        this.dripRate = rate;",
    "        this.lastUpdateTimeMs = System.currentTimeMillis();",
    "    }",
    "    ",
    "    /**",
    "     * Add a token to the bucket.",
    "     * ",
    "     * @param token The token to add",
    "     * @return true if added, false if dropped (bucket full)",
    "     */",
    "    public boolean add(String token) {",
    "        // Sync dripped tokens to get accurate count",
    "        syncDrippedTokens();",
    "        ",
    "        // Check if we have space",
    "        int totalTokens = explicitTokens.size() + drippedCount;",
    "        ",
    "        if (totalTokens >= capacity) {",
    "            return false; // Bucket full, drop the token",
    "        }",
    "        ",
    "        // Add the explicit token",
    "        explicitTokens.add(token);",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve an arbitrary token from the bucket.",
    "     * ",
    "     * IMPORTANT: This method does NOT remove the token - it only peeks.",
    "     * ",
    "     * @return A token if available, null if bucket is empty",
    "     */",
    "    public String get() {",
    "        // Sync dripped tokens first",
    "        syncDrippedTokens();",
    "        ",
    "        // Prefer explicit tokens (they have real names)",
    "        if (!explicitTokens.isEmpty()) {",
    "            return explicitTokens.get(0);",
    "        }",
    "        ",
    "        // Return a dripped token if available",
    "        if (drippedCount > 0) {",
    "            return \"dripped_\" + drippedBaseId;",
    "        }",
    "        ",
    "        // Bucket is empty",
    "        return null;",
    "    }",
    "    ",
    "    /**",
    "     * Get total token count (for debugging).",
    "     */",
    "    public int getTotalTokens() {",
    "        syncDrippedTokens();",
    "        return explicitTokens.size() + drippedCount;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        syncDrippedTokens();",
    "        return String.format(",
    "            \"TokenBucket{capacity=%d, explicit=%d, dripped=%d, total=%d, rate=%.1f}\",",
    "            capacity,",
    "            explicitTokens.size(),",
    "            drippedCount,",
    "            explicitTokens.size() + drippedCount,",
    "            dripRate",
    "        );",
    "    }",
    "    ",
    "    // ========================================================================",
    "    // DEMONSTRATION AND TESTING",
    "    // ========================================================================",
    "    ",
    "    public static void main(String[] args) throws InterruptedException {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"TOKEN BUCKET RATE LIMITER - JAVA DEMO\");",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println();",
    "        ",
    "        // Demo 1: Basic Operations",
    "        System.out.println(\"DEMO 1: Basic Operations\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        TokenBucket bucket = new TokenBucket(3);",
    "        System.out.println(\"Created bucket with capacity 3\");",
    "        System.out.println();",
    "        ",
    "        String[] tokens = {\"A\", \"B\", \"C\", \"D\"};",
    "        for (String token : tokens) {",
    "            boolean result = bucket.add(token);",
    "            String status = result ? \"ADDED\" : \"DROPPED (full)\";",
    "            System.out.printf(\"  add('%s') -> %s [%s]%n\", token, result, status);",
    "        }",
    "        System.out.println();",
    "        ",
    "        System.out.printf(\"  get() -> '%s' (peek only)%n\", bucket.get());",
    "        System.out.printf(\"  get() -> '%s' (same token)%n\", bucket.get());",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"State: \" + bucket);",
    "        System.out.println();",
    "        ",
    "        // Demo 2: Drip Rate",
    "        System.out.println(\"DEMO 2: Drip Rate\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        TokenBucket dripBucket = new TokenBucket(5);",
    "        dripBucket.setDripRate(2.0);",
    "        System.out.println(\"Bucket capacity=5, drip rate=2/sec\");",
    "        System.out.println(\"Waiting 3 seconds...\");",
    "        System.out.println();",
    "        ",
    "        Thread.sleep(3100); // 3.1 seconds",
    "        ",
    "        System.out.printf(\"  Expected: 3\u00d72=6 dripped, capped at 5%n\");",
    "        System.out.printf(\"  get() -> '%s'%n\", dripBucket.get());",
    "        System.out.printf(\"  add('X') -> %s (should be false)%n\", dripBucket.add(\"X\"));",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"State: \" + dripBucket);",
    "        System.out.println();",
    "        ",
    "        // Test Suite",
    "        System.out.println(\"TEST SUITE\");",
    "        System.out.println(\"-\".repeat(40));",
    "        runTests();",
    "        ",
    "        System.out.println();",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"All demonstrations complete!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "    ",
    "    private static void runTests() {",
    "        int passed = 0;",
    "        int total = 0;",
    "        ",
    "        // Test 1: Add to empty",
    "        total++;",
    "        TokenBucket b1 = new TokenBucket(3);",
    "        if (b1.add(\"A\") == true) {",
    "            System.out.println(\"\u2713 Test 1: Add to empty bucket\");",
    "            passed++;",
    "        }",
    "        ",
    "        // Test 2: Reject when full",
    "        total++;",
    "        b1.add(\"B\");",
    "        b1.add(\"C\");",
    "        if (b1.add(\"D\") == false) {",
    "            System.out.println(\"\u2713 Test 2: Reject when full\");",
    "            passed++;",
    "        }",
    "        ",
    "        // Test 3: Get returns first",
    "        total++;",
    "        if (\"A\".equals(b1.get())) {",
    "            System.out.println(\"\u2713 Test 3: Get returns first token\");",
    "            passed++;",
    "        }",
    "        ",
    "        // Test 4: Get doesn't remove",
    "        total++;",
    "        if (\"A\".equals(b1.get())) {",
    "            System.out.println(\"\u2713 Test 4: Get doesn't remove\");",
    "            passed++;",
    "        }",
    "        ",
    "        // Test 5: Get from empty",
    "        total++;",
    "        TokenBucket b2 = new TokenBucket(3);",
    "        if (b2.get() == null) {",
    "            System.out.println(\"\u2713 Test 5: Get from empty returns null\");",
    "            passed++;",
    "        }",
    "        ",
    "        // Test 6: Zero capacity",
    "        total++;",
    "        TokenBucket b3 = new TokenBucket(0);",
    "        if (b3.add(\"X\") == false && b3.get() == null) {",
    "            System.out.println(\"\u2713 Test 6: Zero capacity works\");",
    "            passed++;",
    "        }",
    "        ",
    "        System.out.println();",
    "        System.out.printf(\"Results: %d/%d tests passed%n\", passed, total);",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Class docstring explaining the Token Bucket pattern, key design decisions, and complexity analysis"
    },
    {
      "lines": "17-25",
      "explanation": "Import statements and class definition with type hints"
    },
    {
      "lines": "27-45",
      "explanation": "Constructor initializes all state: capacity, explicit token list, drip rate, timestamp, and counters"
    },
    {
      "lines": "47-75",
      "explanation": "**_sync_dripped_tokens()** - The core lazy evaluation method. Calculates elapsed time, potential new tokens, available space, and updates the dripped count. This is O(1) - just arithmetic, no loops."
    },
    {
      "lines": "77-95",
      "explanation": "**set_drip_rate()** - Settles pending drips at old rate before switching to new rate. Important to call sync first to avoid losing accumulated tokens."
    },
    {
      "lines": "97-120",
      "explanation": "**add()** - First syncs drips, then checks total capacity, adds if space available. Returns boolean indicating success."
    },
    {
      "lines": "122-150",
      "explanation": "**get()** - Syncs drips, prefers explicit tokens over dripped ones, returns synthetic 'dripped_N' name for virtual tokens. Does NOT remove - peek only."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "__init__": {
          "complexity": "O(1)",
          "explanation": "Just initializes primitive values and empty list"
        },
        "_sync_dripped_tokens": {
          "complexity": "O(1)",
          "explanation": "Pure arithmetic: elapsed \u00d7 rate, no loops or data structure traversal"
        },
        "set_drip_rate": {
          "complexity": "O(1)",
          "explanation": "Calls sync (O(1)) then sets values"
        },
        "add": {
          "complexity": "O(1)",
          "explanation": "Sync + list append (amortized O(1) for Python list/Java ArrayList)"
        },
        "get": {
          "complexity": "O(1)",
          "explanation": "Sync + list access by index"
        }
      },
      "overall_change": "All operations are constant time. The key insight is that time-based accumulation is computed lazily with a single multiplication instead of simulating each tick."
    },
    "space": {
      "additional_space": "O(n) where n = number of explicit tokens",
      "explanation": "We store explicit tokens in a list. Dripped tokens are virtual - we only track the count (O(1)), not actual token objects. This is a huge memory optimization for high drip rates."
    }
  },
  "dry_run": {
    "example_input": "Example 2: TokenBucket(5), setDripRate(2), wait(3), get(), add('X')",
    "steps": [
      {
        "step": 1,
        "action": "TokenBucket(5)",
        "state": "capacity=5, explicit=[], dripped=0, rate=0, last_time=T0",
        "explanation": "Initialize empty bucket with capacity 5"
      },
      {
        "step": 2,
        "action": "setDripRate(2)",
        "state": "capacity=5, explicit=[], dripped=0, rate=2.0, last_time=T0",
        "explanation": "Set drip rate to 2 tokens/sec. Sync is called but no time elapsed, so no change to dripped count."
      },
      {
        "step": 3,
        "action": "wait(3) - 3 seconds pass",
        "state": "(no change until next operation)",
        "explanation": "Time passes but bucket doesn't update automatically - this is lazy evaluation!"
      },
      {
        "step": 4,
        "action": "get() - sync first",
        "state": "capacity=5, explicit=[], dripped=5, rate=2.0, last_time=T0+3",
        "explanation": "Sync calculates: elapsed=3s, potential=3\u00d72=6 tokens, space=5-0-0=5, actual=min(6,5)=5. Updates dripped_count to 5."
      },
      {
        "step": 5,
        "action": "get() - return value",
        "state": "Returns 'dripped_0'",
        "explanation": "No explicit tokens, but dripped_count=5 > 0, so return synthetic token 'dripped_0'"
      },
      {
        "step": 6,
        "action": "add('X') - sync first",
        "state": "(no change - no time elapsed since step 4)",
        "explanation": "Sync called but negligible time passed, so dripped_count stays at 5"
      },
      {
        "step": 7,
        "action": "add('X') - check capacity",
        "state": "Returns false",
        "explanation": "total = 0 (explicit) + 5 (dripped) = 5 >= capacity (5), bucket full, return false"
      }
    ],
    "final_output": "[null, null, null, 'dripped_0', false]"
  },
  "edge_cases": [
    {
      "case": "Zero capacity bucket",
      "handling": "add() always returns false, get() always returns null",
      "gotcha": "Don't forget to handle capacity=0. Some solutions divide by capacity causing errors."
    },
    {
      "case": "Drip rate = 0 (no dripping)",
      "handling": "Skip sync calculation when rate \u2264 0",
      "gotcha": "Check rate before computing elapsed \u00d7 rate to avoid unnecessary work"
    },
    {
      "case": "Very high drip rate",
      "handling": "Lazy evaluation handles this gracefully - we just compute min(huge_number, capacity)",
      "gotcha": "Don't use a loop to 'add one token at a time' - that would be O(rate \u00d7 time)"
    },
    {
      "case": "get() called multiple times",
      "handling": "Returns same token each time (doesn't remove)",
      "gotcha": "Easy to accidentally implement remove logic. get() is peek-only!"
    },
    {
      "case": "Changing drip rate mid-operation",
      "handling": "Settle pending drips at old rate before switching",
      "gotcha": "If you don't sync before changing rate, you lose accumulated tokens"
    },
    {
      "case": "Mixed explicit and dripped tokens",
      "handling": "Both count toward capacity; get() prefers explicit tokens",
      "gotcha": "Total is explicit + dripped, not max(explicit, dripped)"
    }
  ],
  "test_cases": [
    {
      "name": "Basic add/get",
      "input": "TokenBucket(3), add('A'), add('B'), add('C'), get(), add('D')",
      "expected": "[null, true, true, true, 'A', false]",
      "explanation": "Add 3 tokens (fills bucket), get returns first, fourth add fails"
    },
    {
      "name": "Drip rate accumulation",
      "input": "TokenBucket(5), setDripRate(2), wait(3), get(), add('X')",
      "expected": "[null, null, null, 'dripped_0', false]",
      "explanation": "After 3 seconds at 2/sec, 6 dripped (capped at 5), bucket full"
    },
    {
      "name": "Empty bucket get",
      "input": "TokenBucket(5), get()",
      "expected": "[null, null]",
      "explanation": "Get from empty bucket returns null"
    },
    {
      "name": "Partial fill with dripping",
      "input": "TokenBucket(5), add('A'), add('B'), setDripRate(10), wait(1), get()",
      "expected": "[null, true, true, null, null, 'A']",
      "explanation": "2 explicit + 3 dripped = 5 (full), get returns explicit 'A' first"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using a timer/background thread for dripping",
      "why_wrong": "Wastes resources, complex synchronization, doesn't scale. A bucket unused for hours would still 'tick' millions of times.",
      "correct_approach": "Lazy evaluation - compute drips on-demand when add() or get() is called",
      "code_example_wrong": "// DON'T DO THIS\nTimer timer = new Timer();\ntimer.scheduleAtFixedRate(() -> drippedCount++, 0, 1000/rate);",
      "code_example_correct": "// DO THIS\nint newDripped = (int)((now - lastTime) * rate);\ndrippedCount += Math.min(newDripped, spaceAvailable);"
    },
    {
      "mistake": "Implementing get() to remove the token",
      "why_wrong": "Problem explicitly states get() does NOT remove - it only peeks",
      "correct_approach": "Return the token without modifying any state",
      "code_example_wrong": "def get(self):\n    if self.tokens:\n        return self.tokens.pop(0)  # WRONG - removes!",
      "code_example_correct": "def get(self):\n    if self.tokens:\n        return self.tokens[0]  # Correct - peek only"
    },
    {
      "mistake": "Not accounting for explicit tokens when computing drip space",
      "why_wrong": "Explicit and dripped tokens share the same capacity. If you ignore explicit tokens, you'll exceed capacity.",
      "correct_approach": "space_available = capacity - len(explicit) - dripped_count",
      "code_example_wrong": "space = capacity - drippedCount;  // Forgot explicit tokens!",
      "code_example_correct": "space = capacity - explicitTokens.size() - drippedCount;"
    },
    {
      "mistake": "Forgetting to sync before changing drip rate",
      "why_wrong": "If you change the rate without syncing, you lose tokens that should have dripped at the old rate",
      "correct_approach": "Always call sync before changing rate to settle pending drips",
      "code_example_wrong": "void setDripRate(double rate) {\n    this.dripRate = rate;  // Lost pending drips!\n}",
      "code_example_correct": "void setDripRate(double rate) {\n    syncDrippedTokens();  // Settle first!\n    this.dripRate = rate;\n}"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the problem: 'So get() peeks but doesn't remove? And dripped tokens are virtual?' Then explain the lazy evaluation insight: 'The key optimization is that we don't need to track time continuously - we can compute the drip count on-demand using elapsed_time \u00d7 rate.' Draw the bucket diagram to show explicit vs dripped tokens.",
    "what_to_mention": [
      "Lazy evaluation pattern - very common in rate limiters, caching, database pagination",
      "Thread-safety considerations for production (need locks around sync + operation)",
      "Memory efficiency - dripped tokens are virtual, not stored as objects",
      "This pattern is used in real systems: AWS API Gateway, Stripe, Nginx rate limiting"
    ],
    "time_allocation": "3 min clarifying requirements, 5 min explaining approach, 10 min coding, 2 min testing edge cases",
    "if_stuck": [
      "Think about when you actually NEED to know the token count - only during add() and get()",
      "What information do you need to compute drips? Just last_time and rate",
      "How would you implement this if drip rate was always 0? Start there, then add time logic"
    ]
  },
  "connection_to_next_part": "If there's a Part 4, it might involve: (1) Adding remove() functionality to actually consume tokens, (2) Supporting multiple buckets with different rates (multi-tenant rate limiting), (3) Implementing a sliding window variant, or (4) Adding persistence so bucket state survives restarts.",
  "generated_at": "2026-01-14T15:15:13.585671",
  "_meta": {
    "problem_id": "process_scheduling",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}