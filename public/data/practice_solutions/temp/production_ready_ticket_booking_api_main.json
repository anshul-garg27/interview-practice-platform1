{
  "problem_title": "Production-Ready Event Ticket Booking API",
  "difficulty": "hard",
  "category": "LLD/API Design",
  "estimated_time": "60-90 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **Low-Level Design (LLD)** problem focused on building a production-ready REST API. Unlike pure algorithmic problems, this tests your ability to design clean, maintainable systems with proper separation of concerns. Key challenges include: input validation, proper HTTP semantics, currency precision, and concurrency safety. This is a classic system design interview question that companies like Rippling use to evaluate full-stack engineering skills.",
    "pattern_recognition": "**Repository Pattern** for data access abstraction | **Service Layer Pattern** for business logic isolation | **DTO Pattern** for request/response objects | **Builder Pattern** for constructing responses | **Strategy Pattern** for validation | **Singleton** for thread-safe counters | **Decorator** for adding cross-cutting concerns like logging",
    "key_constraints": [
      "**O(1) operations** - HashMap for O(1) event/booking lookup is essential for high-traffic scenarios (10,000 req/s)",
      "**Currency precision** - Must use Decimal/BigDecimal; float causes 0.1+0.1+0.1 \u2260 0.3 errors in production",
      "**Atomic ticket updates** - Race conditions could oversell tickets; need locking mechanism",
      "**HTTP semantics** - 201 for creation, 200 for success, 400 for validation, 404 for not found, 409 for conflicts",
      "**Input validation** - All user input is untrusted; validate types, ranges, required fields before processing",
      "**Max 10 tickets per booking** - Business rule that prevents scalping/hoarding"
    ],
    "clarifying_questions": [
      "**Q: Should bookings be idempotent?** - This reveals whether we need request IDs to prevent duplicate bookings from retries",
      "**Q: What's the expected read/write ratio?** - Helps decide if we should optimize for reads (caching) or writes (simpler model)",
      "**Q: Is eventual consistency acceptable?** - Determines if we can use async processing or need strict consistency",
      "**Q: How should we handle partial failures?** - If booking succeeds but notification fails, what's the correct state?",
      "**Q: What timezone should dates use?** - ISO 8601 with UTC is standard, but interviewer may have preferences",
      "**Q: Should cancelled bookings be hard or soft deleted?** - Affects audit trail and data retention requirements",
      "**Q: What's the SLA for API response times?** - May require different data structure choices if sub-10ms is needed"
    ],
    "edge_cases_to_consider": [
      "Booking exactly the remaining tickets (boundary condition)",
      "Booking 1 more than available (should return 409, not 500)",
      "Cancelling an already cancelled booking (idempotent vs error?)",
      "Creating event with 0 tickets (invalid per constraints)",
      "Price of $0 (free events are valid per constraints)",
      "Event date in the past (should be validated)",
      "Empty string for event name (violates 1-200 char constraint)",
      "Very long event name at exactly 200 characters (boundary)",
      "Concurrent bookings depleting tickets simultaneously (race condition)",
      "Unicode/special characters in event names (sanitization)",
      "Negative ticket count in booking request (type validation)"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n                    \ud83c\udfab TICKET BOOKING SYSTEM ARCHITECTURE\n                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                      CLIENT REQUESTS                            \u2502\n    \u2502  POST /events        GET /events/{id}      POST /bookings      \u2502\n    \u2502  DELETE /bookings/{id}                     GET /events         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                                 \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                    REQUEST VALIDATOR                            \u2502\n    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n    \u2502  \u2502 Type Check  \u2502 \u2502 Range Check \u2502 \u2502 Required Fields Check   \u2502   \u2502\n    \u2502  \u2502 str? int?   \u2502 \u2502 1\u2264n\u2264200     \u2502 \u2502 name, date, venue...    \u2502   \u2502\n    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n    \u2502                         \u2502                                       \u2502\n    \u2502            \u274c Invalid \u2192 400 Bad Request                        \u2502\n    \u2502            \u2705 Valid   \u2192 Continue to Service                    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                      SERVICE LAYER                              \u2502\n    \u2502                                                                 \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n    \u2502    \u2502   EventService   \u2502        \u2502  BookingService  \u2502            \u2502\n    \u2502    \u2502                  \u2502        \u2502                  \u2502            \u2502\n    \u2502    \u2502  \u2022 createEvent() \u2502        \u2502  \u2022 bookTickets() \u2502\u25c4\u2500\u2500 \ud83d\udd12LOCK \u2502\n    \u2502    \u2502  \u2022 getEvent()    \u2502        \u2502  \u2022 cancelBook()  \u2502            \u2502\n    \u2502    \u2502  \u2022 listEvents()  \u2502        \u2502                  \u2502            \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n    \u2502             \u2502                           \u2502                       \u2502\n    \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n    \u2502                         \u2502                                       \u2502\n    \u2502                         \u25bc                                       \u2502\n    \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n    \u2502    \u2502                DATA STORE (In-Memory)               \u2502     \u2502\n    \u2502    \u2502                                                     \u2502     \u2502\n    \u2502    \u2502   events: HashMap<eventId, Event>                   \u2502     \u2502\n    \u2502    \u2502   bookings: HashMap<bookingId, Booking>             \u2502     \u2502\n    \u2502    \u2502                                                     \u2502     \u2502\n    \u2502    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502     \u2502\n    \u2502    \u2502   \u2502 evt_001: Event  \u2502   \u2502 bkg_001: Book   \u2502        \u2502     \u2502\n    \u2502    \u2502   \u2502 evt_002: Event  \u2502   \u2502 bkg_002: Book   \u2502        \u2502     \u2502\n    \u2502    \u2502   \u2502 evt_003: Event  \u2502   \u2502 bkg_003: Book   \u2502        \u2502     \u2502\n    \u2502    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502     \u2502\n    \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n    DATA STRUCTURES & STATE TRANSITIONS\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                        Event Entity                          \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  id: \"evt_001\"                                               \u2502\n    \u2502  name: \"Tech Conference 2024\"                                \u2502\n    \u2502  date: 2024-12-15T09:00:00Z                                  \u2502\n    \u2502  venue: \"Convention Center\"                                  \u2502\n    \u2502  total_tickets: 100        \u25c4\u2500\u2500 Never changes                \u2502\n    \u2502  available_tickets: 98     \u25c4\u2500\u2500 Decremented on book          \u2502\n    \u2502  price_per_ticket: $75.00  \u25c4\u2500\u2500 Decimal for precision        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u2502 one-to-many\n                                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                       Booking Entity                         \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502  id: \"bkg_001\"                                               \u2502\n    \u2502  event_id: \"evt_001\"       \u25c4\u2500\u2500 Foreign key reference        \u2502\n    \u2502  user_id: \"usr_123\"                                         \u2502\n    \u2502  number_of_tickets: 2                                        \u2502\n    \u2502  total_amount: $150.00     \u25c4\u2500\u2500 price \u00d7 quantity             \u2502\n    \u2502  status: CONFIRMED         \u25c4\u2500\u2500 Enum: CONFIRMED | CANCELLED  \u2502\n    \u2502  created_at: 2024-01-15T10:30:00Z                           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    STATE MACHINE FOR BOOKING STATUS:\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     cancelBooking()    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  CONFIRMED  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  \u2502  CANCELLED  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502                                       \u2502\n              \u2502 (can book again)            (cannot re-cancel)\n              \u25bc                                       \u2502\n        tickets available                    tickets restored\n        decreased                            to inventory\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**Request Received** - Parse incoming JSON payload",
        "visualization": "```\nPOST /events/evt_001/bookings\n{\n  \"userId\": \"usr_123\",\n  \"numberOfTickets\": 2\n}\n```",
        "key_point": "All requests are treated as untrusted until validated"
      },
      {
        "step": 2,
        "description": "**Input Validation** - Check required fields, types, and ranges",
        "visualization": "```\nValidation Pipeline:\n  \u2713 eventId present     \u2192 \"evt_001\" \n  \u2713 userId present      \u2192 \"usr_123\"\n  \u2713 numberOfTickets     \u2192 2 (integer \u2713, range 1-10 \u2713)\n  \nAll checks passed \u2192 Continue to business logic\n```",
        "key_point": "Fail fast - return 400 immediately if validation fails"
      },
      {
        "step": 3,
        "description": "**Business Validation** - Check event exists and has tickets",
        "visualization": "```\nevents HashMap:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 evt_001    \u2502 Event(available=100)       \u2502 \u2190 Found!\n\u2502 evt_002    \u2502 Event(available=50)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nCheck: 100 >= 2 \u2192 \u2713 Sufficient tickets\n```",
        "key_point": "Return 404 if event not found, 409 if insufficient tickets"
      },
      {
        "step": 4,
        "description": "**Atomic Booking** - Lock, verify, update, unlock",
        "visualization": "```\n\ud83d\udd12 ACQUIRE LOCK\n  \u2502\n  \u251c\u2500\u2500 Re-check: available(100) >= requested(2) \u2713\n  \u2502\n  \u251c\u2500\u2500 Create booking:\n  \u2502   bkg_001 = Booking(tickets=2, amount=$150)\n  \u2502\n  \u251c\u2500\u2500 Update inventory:\n  \u2502   event.available = 100 - 2 = 98\n  \u2502\n  \u2514\u2500\u2500 Commit changes\n\ud83d\udd13 RELEASE LOCK\n```",
        "key_point": "Double-check availability inside lock to prevent race conditions"
      },
      {
        "step": 5,
        "description": "**Response Construction** - Build success response with booking details",
        "visualization": "```\nHTTP 201 Created\n{\n  \"success\": true,\n  \"data\": {\n    \"bookingId\": \"bkg_001\",\n    \"eventId\": \"evt_001\",\n    \"numberOfTickets\": 2,\n    \"totalAmount\": 150.00,\n    \"status\": \"CONFIRMED\"\n  }\n}\n```",
        "key_point": "Use 201 Created for POST that creates resources"
      }
    ],
    "dry_run_table": "| Step | Operation | Input | Events State | Bookings State | Output |\n|------|-----------|-------|--------------|----------------|--------|\n| 1 | `TicketAPI()` | - | `{}` | `{}` | API initialized |\n| 2 | `createEvent({name:\"Conf\", tickets:100, price:75})` | Event data | `{evt_001: Event(avail=100)}` | `{}` | `201: {eventId:\"evt_001\"}` |\n| 3 | `getEvent(\"evt_001\")` | `\"evt_001\"` | unchanged | unchanged | `200: {avail:100, price:75}` |\n| 4 | `bookTickets({eventId:\"evt_001\", tickets:2})` | Booking req | `{evt_001: Event(avail=98)}` | `{bkg_001: Booking(qty=2)}` | `201: {bookingId:\"bkg_001\"}` |\n| 5 | `getEvent(\"evt_001\")` | `\"evt_001\"` | unchanged | unchanged | `200: {avail:98}` |\n| 6 | `cancelBooking(\"bkg_001\")` | `\"bkg_001\"` | `{evt_001: Event(avail=100)}` | `{bkg_001: status=CANCELLED}` | `200: {status:\"CANCELLED\"}` |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'Production-Ready API'**, I think of input validation, proper HTTP codes, error handling, and observability. This isn't just about making it work\u2014it's about making it robust.",
      "**When I see 'ticket booking' and 'concurrent requests'**, I immediately think of race conditions. Two users booking the last ticket simultaneously could cause overselling without proper locking.",
      "**When I see 'monetary values'**, alarm bells ring for floating-point precision. I must use `Decimal` (Python) or `BigDecimal` (Java) for all currency calculations.",
      "**When I see 'CRUD operations on entities'**, I think Repository pattern with HashMap storage for O(1) lookups, plus a Service layer for business logic.",
      "**When I see 'validation requirements'**, I think of the Strategy pattern\u2014separate validation logic into its own class for single responsibility and testability.",
      "**The key insight is**: This is testing whether you can build a *real* API, not just implement algorithms. They want to see software engineering maturity.",
      "**I should use layered architecture** because it separates concerns: Controller handles HTTP, Validator handles input, Service handles business logic, Repository handles data."
    ],
    "key_insight": "The crucial realization is that this problem tests **software engineering skills**, not just coding ability. The interviewer wants to see:\n\n1. **Defensive programming** - Validate everything before processing\n2. **Proper abstraction** - Clean separation between layers\n3. **Attention to detail** - Correct HTTP codes, currency precision\n4. **Production thinking** - What could go wrong? How do we handle it?\n\nThe ticket booking scenario is a vehicle to test these skills. A junior engineer makes it work; a senior engineer makes it maintainable, observable, and bulletproof.",
    "why_this_works": "This solution works because:\n\n1. **HashMap provides O(1)** lookups for both events and bookings, essential for 10K req/s\n2. **Threading lock ensures atomicity** for ticket updates, preventing overselling\n3. **Decimal prevents currency precision bugs** that would lose real money in production\n4. **Layered architecture** allows each component to be tested and modified independently\n5. **Explicit validation** catches bad input before it reaches business logic\n6. **Proper HTTP semantics** make the API predictable for clients"
  },
  "approaches": [
    {
      "name": "Naive Approach - Single Class, No Validation",
      "description": "Put everything in one class, use basic types, skip validation",
      "pseudocode": "class TicketAPI:\n  def create_event(data):\n    event = Event()\n    event.name = data['name']  # No validation!\n    event.available = data['totalTickets']\n    return {'id': event.id}\n    \n  def book_tickets(data):\n    event = events[data['eventId']]  # Might crash!\n    event.available -= data['tickets']  # Race condition!",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(E + B) for events and bookings",
      "pros": [
        "Simple to implement",
        "Quick to write"
      ],
      "cons": [
        "No validation - crashes on bad input",
        "Race conditions cause overselling",
        "Wrong HTTP codes",
        "Float precision bugs with currency",
        "Unmaintainable spaghetti code"
      ],
      "when_to_use": "Never in production. Only for throwaway prototypes."
    },
    {
      "name": "Optimal: Layered Architecture with Full Validation",
      "description": "Separate concerns into Validator, Service, and Data layers. Use proper types and locking.",
      "pseudocode": "class TicketAPI:\n  validator = RequestValidator()\n  events = {}  # HashMap\n  bookings = {}\n  lock = Lock()\n\n  def create_event(request):\n    errors = validator.validate_event(request)\n    if errors:\n      return Response(400, validation_error(errors))\n    \n    event = Event(\n      id=generate_id(),\n      price=Decimal(request['price'])  # Precision!\n    )\n    events[event.id] = event\n    return Response(201, success(event))\n\n  def book_tickets(request):\n    errors = validator.validate_booking(request)\n    if errors:\n      return Response(400, error)\n    \n    if event_id not in events:\n      return Response(404, not_found)\n    \n    with lock:  # Atomic!\n      event = events[event_id]\n      if event.available < tickets:\n        return Response(409, insufficient)\n      \n      booking = create_booking()\n      event.available -= tickets\n      bookings[booking.id] = booking\n    \n    return Response(201, success(booking))",
      "time_complexity": "O(1) for all operations with HashMap",
      "space_complexity": "O(E + B) where E=events, B=bookings",
      "pros": [
        "Production-ready",
        "Thread-safe",
        "Proper HTTP semantics",
        "Currency precision",
        "Testable and maintainable"
      ],
      "cons": [
        "More code to write",
        "Need to understand design patterns"
      ],
      "key_insight": "Shift complexity from 'making it work' to 'making it robust'. The extra code prevents production incidents."
    }
  ],
  "optimal_solution": {
    "name": "Production-Ready Layered API with Thread-Safe Booking",
    "explanation_md": "## Approach\n\nThe solution uses a **layered architecture** that separates concerns:\n\n### Layer 1: Request Validation\n- Validates all input BEFORE touching business logic\n- Returns detailed field-level errors for client debugging\n- Prevents injection attacks and type confusion\n\n### Layer 2: Business Logic (Services)\n- EventService handles event CRUD\n- BookingService handles booking with thread safety\n- Services return domain objects, not HTTP responses\n\n### Layer 3: Data Access\n- HashMap provides O(1) lookup for events and bookings\n- In production, this would be a database abstraction\n\n### Why This Design?\n\n1. **Testability**: Each layer can be unit tested independently\n2. **Maintainability**: Changes to validation don't affect business logic\n3. **Security**: Validation layer is the single entry point for input\n4. **Performance**: HashMap gives O(1) for all lookups\n\n### Critical Implementation Details\n\n```\nCurrency: Decimal('75.00') NOT float(75.0)\nBooking:  with lock: check \u2192 create \u2192 update\nHTTP:     201=Created, 200=Success, 400=BadInput, 404=NotFound, 409=Conflict\n```",
    "data_structures": [
      {
        "structure": "HashMap<eventId, Event>",
        "purpose": "O(1) event lookup by ID"
      },
      {
        "structure": "HashMap<bookingId, Booking>",
        "purpose": "O(1) booking lookup by ID"
      },
      {
        "structure": "Threading Lock",
        "purpose": "Ensures atomic ticket updates"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise currency calculations"
      },
      {
        "structure": "Enum (BookingStatus)",
        "purpose": "Type-safe status representation"
      }
    ],
    "algorithm_steps": [
      "1. **Parse request** - Extract JSON payload from HTTP request",
      "2. **Validate input** - Check required fields, types, and ranges",
      "3. **Return 400** if validation fails with field-level details",
      "4. **Check existence** - Verify event/booking exists in HashMap",
      "5. **Return 404** if resource not found",
      "6. **Acquire lock** for booking operations (thread safety)",
      "7. **Re-verify availability** inside lock (double-check pattern)",
      "8. **Return 409** if business rule violated (insufficient tickets)",
      "9. **Execute operation** - Create/update entities",
      "10. **Release lock** after committing changes",
      "11. **Return success** with appropriate HTTP code and response body"
    ],
    "why_decimal": "**Float precision disaster example:**\n```python\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # NOT 0.3!\n\n>>> from decimal import Decimal\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1')\nDecimal('0.3')  # Correct!\n```\n\nIn a ticket system processing thousands of transactions, float errors accumulate. A $0.01 error per transaction \u00d7 1 million transactions = $10,000 accounting discrepancy."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Production-Ready Event Ticket Booking API",
    "",
    "A thread-safe, validated REST API for managing event tickets.",
    "Demonstrates production engineering practices including:",
    "- Input validation and sanitization",
    "- Proper HTTP status codes",
    "- Currency precision with Decimal",
    "- Thread-safe concurrent bookings",
    "- Clean layered architecture",
    "",
    "Author: Interview Solution",
    "\"\"\"",
    "",
    "from decimal import Decimal",
    "from typing import Dict, List, Optional, Any",
    "from dataclasses import dataclass, field",
    "from datetime import datetime",
    "from enum import Enum",
    "import threading",
    "",
    "",
    "# =============================================================================",
    "# ENUMS AND CONSTANTS",
    "# =============================================================================",
    "",
    "class BookingStatus(Enum):",
    "    \"\"\"Possible states for a booking.\"\"\"",
    "    CONFIRMED = 'CONFIRMED'",
    "    CANCELLED = 'CANCELLED'",
    "",
    "",
    "class ErrorCode(Enum):",
    "    \"\"\"Standardized error codes for API responses.\"\"\"",
    "    VALIDATION_ERROR = 'VALIDATION_ERROR'",
    "    NOT_FOUND = 'NOT_FOUND'",
    "    INSUFFICIENT_TICKETS = 'INSUFFICIENT_TICKETS'",
    "    ALREADY_CANCELLED = 'ALREADY_CANCELLED'",
    "",
    "",
    "# =============================================================================",
    "# DATA MODELS (Entities)",
    "# =============================================================================",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"",
    "    Represents an event with ticket inventory.",
    "    ",
    "    Attributes:",
    "        id: Unique identifier (e.g., 'evt_001')",
    "        name: Event name (1-200 characters)",
    "        date: Event date and time (UTC)",
    "        venue: Location of the event",
    "        total_tickets: Original ticket count (immutable)",
    "        available_tickets: Current available count (decremented on booking)",
    "        price_per_ticket: Price in dollars (Decimal for precision)",
    "    \"\"\"",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"",
    "    Represents a ticket booking.",
    "    ",
    "    Attributes:",
    "        id: Unique identifier (e.g., 'bkg_001')",
    "        event_id: Reference to the event",
    "        user_id: User who made the booking",
    "        number_of_tickets: Quantity booked (1-10)",
    "        total_amount: Total cost (price \u00d7 quantity)",
    "        status: Current booking status",
    "        created_at: Timestamp of booking creation",
    "    \"\"\"",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_amount: Decimal",
    "    status: BookingStatus",
    "    created_at: datetime",
    "",
    "",
    "@dataclass",
    "class ValidationError:",
    "    \"\"\"Represents a single validation failure.\"\"\"",
    "    field: str",
    "    issue: str",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    \"\"\"",
    "    Standardized API response.",
    "    ",
    "    Attributes:",
    "        status: HTTP status code",
    "        body: Response payload (dict with success, data, error)",
    "    \"\"\"",
    "    status: int",
    "    body: Dict[str, Any]",
    "",
    "",
    "# =============================================================================",
    "# VALIDATION LAYER",
    "# =============================================================================",
    "",
    "class RequestValidator:",
    "    \"\"\"",
    "    Validates incoming API requests.",
    "    ",
    "    Implements the Strategy pattern for validation logic.",
    "    All validation happens BEFORE business logic execution.",
    "    ",
    "    Example:",
    "        >>> validator = RequestValidator()",
    "        >>> errors = validator.validate_event({'name': '', 'totalTickets': -1})",
    "        >>> len(errors) > 0",
    "        True",
    "    \"\"\"",
    "    ",
    "    REQUIRED_EVENT_FIELDS = ['name', 'date', 'venue', 'totalTickets', 'pricePerTicket']",
    "    REQUIRED_BOOKING_FIELDS = ['eventId', 'userId', 'numberOfTickets']",
    "    ",
    "    # Constraints from problem statement",
    "    MAX_NAME_LENGTH = 200",
    "    MIN_NAME_LENGTH = 1",
    "    MAX_TICKETS_PER_EVENT = 100000",
    "    MAX_TICKETS_PER_BOOKING = 10",
    "    MAX_PRICE = Decimal('10000.00')",
    "    ",
    "    def validate_event(self, data: Dict[str, Any]) -> List[ValidationError]:",
    "        \"\"\"",
    "        Validate event creation request.",
    "        ",
    "        Args:",
    "            data: Request payload dictionary",
    "            ",
    "        Returns:",
    "            List of ValidationError objects (empty if valid)",
    "        \"\"\"",
    "        errors: List[ValidationError] = []",
    "        ",
    "        # Check required fields first",
    "        for field_name in self.REQUIRED_EVENT_FIELDS:",
    "            if field_name not in data or data[field_name] is None:",
    "                errors.append(ValidationError(field_name, 'required'))",
    "        ",
    "        # If missing required fields, return early",
    "        if errors:",
    "            return errors",
    "        ",
    "        # Validate name",
    "        name = data.get('name')",
    "        if not isinstance(name, str):",
    "            errors.append(ValidationError('name', 'must be a string'))",
    "        elif len(name) < self.MIN_NAME_LENGTH or len(name) > self.MAX_NAME_LENGTH:",
    "            errors.append(ValidationError('name', f'must be {self.MIN_NAME_LENGTH}-{self.MAX_NAME_LENGTH} characters'))",
    "        ",
    "        # Validate totalTickets",
    "        total_tickets = data.get('totalTickets')",
    "        if not isinstance(total_tickets, int):",
    "            errors.append(ValidationError('totalTickets', 'must be an integer'))",
    "        elif total_tickets < 1 or total_tickets > self.MAX_TICKETS_PER_EVENT:",
    "            errors.append(ValidationError('totalTickets', f'must be between 1 and {self.MAX_TICKETS_PER_EVENT}'))",
    "        ",
    "        # Validate pricePerTicket",
    "        price = data.get('pricePerTicket')",
    "        if not isinstance(price, (int, float, Decimal)):",
    "            errors.append(ValidationError('pricePerTicket', 'must be a number'))",
    "        elif price < 0 or Decimal(str(price)) > self.MAX_PRICE:",
    "            errors.append(ValidationError('pricePerTicket', f'must be between 0 and {self.MAX_PRICE}'))",
    "        ",
    "        # Validate venue",
    "        venue = data.get('venue')",
    "        if not isinstance(venue, str) or len(venue) == 0:",
    "            errors.append(ValidationError('venue', 'must be a non-empty string'))",
    "        ",
    "        return errors",
    "    ",
    "    def validate_booking(self, data: Dict[str, Any]) -> List[ValidationError]:",
    "        \"\"\"",
    "        Validate booking creation request.",
    "        ",
    "        Args:",
    "            data: Request payload dictionary",
    "            ",
    "        Returns:",
    "            List of ValidationError objects (empty if valid)",
    "        \"\"\"",
    "        errors: List[ValidationError] = []",
    "        ",
    "        # Check required fields",
    "        for field_name in self.REQUIRED_BOOKING_FIELDS:",
    "            if field_name not in data or data[field_name] is None:",
    "                errors.append(ValidationError(field_name, 'required'))",
    "        ",
    "        if errors:",
    "            return errors",
    "        ",
    "        # Validate numberOfTickets",
    "        num_tickets = data.get('numberOfTickets')",
    "        if not isinstance(num_tickets, int):",
    "            errors.append(ValidationError('numberOfTickets', 'must be an integer'))",
    "        elif num_tickets < 1 or num_tickets > self.MAX_TICKETS_PER_BOOKING:",
    "            errors.append(ValidationError('numberOfTickets', f'must be between 1 and {self.MAX_TICKETS_PER_BOOKING}'))",
    "        ",
    "        # Validate eventId format",
    "        event_id = data.get('eventId')",
    "        if not isinstance(event_id, str) or len(event_id) == 0:",
    "            errors.append(ValidationError('eventId', 'must be a non-empty string'))",
    "        ",
    "        # Validate userId format",
    "        user_id = data.get('userId')",
    "        if not isinstance(user_id, str) or len(user_id) == 0:",
    "            errors.append(ValidationError('userId', 'must be a non-empty string'))",
    "        ",
    "        return errors",
    "",
    "",
    "# =============================================================================",
    "# MAIN API CLASS",
    "# =============================================================================",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready ticket booking API.",
    "    ",
    "    This class implements a RESTful API for managing events and bookings",
    "    with full input validation, proper HTTP semantics, and thread-safe",
    "    ticket inventory management.",
    "    ",
    "    Thread Safety:",
    "        All booking operations are protected by a lock to prevent",
    "        race conditions that could cause ticket overselling.",
    "    ",
    "    Currency Precision:",
    "        All monetary values use Decimal to avoid floating-point errors.",
    "    ",
    "    Example:",
    "        >>> api = TicketAPI()",
    "        >>> response = api.create_event({",
    "        ...     'name': 'Concert',",
    "        ...     'date': '2024-12-15T20:00:00Z',",
    "        ...     'venue': 'Stadium',",
    "        ...     'totalTickets': 1000,",
    "        ...     'pricePerTicket': 50.00",
    "        ... })",
    "        >>> response.status",
    "        201",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize the API with empty data stores.\"\"\"",
    "        # Data stores (HashMap for O(1) lookup)",
    "        self._events: Dict[str, Event] = {}",
    "        self._bookings: Dict[str, Booking] = {}",
    "        ",
    "        # Components",
    "        self._validator = RequestValidator()",
    "        self._lock = threading.Lock()  # For thread-safe bookings",
    "        ",
    "        # ID counters (for deterministic test IDs)",
    "        self._event_counter = 0",
    "        self._booking_counter = 0",
    "    ",
    "    # =========================================================================",
    "    # HELPER METHODS",
    "    # =========================================================================",
    "    ",
    "    def _generate_event_id(self) -> str:",
    "        \"\"\"Generate unique event ID.\"\"\"",
    "        self._event_counter += 1",
    "        return f'evt_{self._event_counter:03d}'",
    "    ",
    "    def _generate_booking_id(self) -> str:",
    "        \"\"\"Generate unique booking ID.\"\"\"",
    "        self._booking_counter += 1",
    "        return f'bkg_{self._booking_counter:03d}'",
    "    ",
    "    def _success_response(self, status: int, data: Dict[str, Any]) -> Response:",
    "        \"\"\"Build a success response.\"\"\"",
    "        return Response(",
    "            status=status,",
    "            body={",
    "                'success': True,",
    "                'data': data,",
    "                'error': None",
    "            }",
    "        )",
    "    ",
    "    def _error_response(",
    "        self,",
    "        status: int,",
    "        code: str,",
    "        message: str,",
    "        details: Optional[List[Dict[str, str]]] = None",
    "    ) -> Response:",
    "        \"\"\"Build an error response.\"\"\"",
    "        error: Dict[str, Any] = {",
    "            'code': code,",
    "            'message': message",
    "        }",
    "        if details:",
    "            error['details'] = details",
    "        ",
    "        return Response(",
    "            status=status,",
    "            body={",
    "                'success': False,",
    "                'data': None,",
    "                'error': error",
    "            }",
    "        )",
    "    ",
    "    def _parse_datetime(self, date_str: str) -> datetime:",
    "        \"\"\"Parse ISO 8601 datetime string.\"\"\"",
    "        # Handle 'Z' suffix for UTC",
    "        if date_str.endswith('Z'):",
    "            date_str = date_str[:-1] + '+00:00'",
    "        return datetime.fromisoformat(date_str)",
    "    ",
    "    # =========================================================================",
    "    # API ENDPOINTS",
    "    # =========================================================================",
    "    ",
    "    def create_event(self, request: Dict[str, Any]) -> Response:",
    "        \"\"\"",
    "        Create a new event with ticket inventory.",
    "        ",
    "        Args:",
    "            request: Dict containing name, date, venue, totalTickets, pricePerTicket",
    "            ",
    "        Returns:",
    "            Response with 201 Created and event details, or",
    "            Response with 400 Bad Request if validation fails",
    "            ",
    "        Example:",
    "            >>> api = TicketAPI()",
    "            >>> response = api.create_event({",
    "            ...     'name': 'Tech Conference',",
    "            ...     'date': '2024-12-15T09:00:00Z',",
    "            ...     'venue': 'Convention Center',",
    "            ...     'totalTickets': 100,",
    "            ...     'pricePerTicket': 75",
    "            ... })",
    "            >>> response.status",
    "            201",
    "        \"\"\"",
    "        # Step 1: Validate input",
    "        errors = self._validator.validate_event(request)",
    "        if errors:",
    "            return self._error_response(",
    "                status=400,",
    "                code=ErrorCode.VALIDATION_ERROR.value,",
    "                message=f'Missing required field: {errors[0].field}',",
    "                details=[{'field': e.field, 'issue': e.issue} for e in errors]",
    "            )",
    "        ",
    "        # Step 2: Create event entity",
    "        event_id = self._generate_event_id()",
    "        event = Event(",
    "            id=event_id,",
    "            name=request['name'],",
    "            date=self._parse_datetime(request['date']),",
    "            venue=request['venue'],",
    "            total_tickets=request['totalTickets'],",
    "            available_tickets=request['totalTickets'],  # Initially all available",
    "            price_per_ticket=Decimal(str(request['pricePerTicket']))  # Precision!",
    "        )",
    "        ",
    "        # Step 3: Store in data store",
    "        self._events[event_id] = event",
    "        ",
    "        # Step 4: Return success response",
    "        return self._success_response(",
    "            status=201,",
    "            data={",
    "                'eventId': event_id,",
    "                'name': event.name,",
    "                'availableTickets': event.available_tickets",
    "            }",
    "        )",
    "    ",
    "    def get_event(self, event_id: str) -> Response:",
    "        \"\"\"",
    "        Retrieve event details by ID.",
    "        ",
    "        Args:",
    "            event_id: Unique event identifier",
    "            ",
    "        Returns:",
    "            Response with 200 OK and event details, or",
    "            Response with 404 Not Found if event doesn't exist",
    "        \"\"\"",
    "        # Check if event exists",
    "        if event_id not in self._events:",
    "            return self._error_response(",
    "                status=404,",
    "                code=ErrorCode.NOT_FOUND.value,",
    "                message=f'Event {event_id} not found'",
    "            )",
    "        ",
    "        event = self._events[event_id]",
    "        ",
    "        return self._success_response(",
    "            status=200,",
    "            data={",
    "                'eventId': event.id,",
    "                'name': event.name,",
    "                'date': event.date.isoformat(),",
    "                'venue': event.venue,",
    "                'totalTickets': event.total_tickets,",
    "                'availableTickets': event.available_tickets,",
    "                'pricePerTicket': float(event.price_per_ticket)",
    "            }",
    "        )",
    "    ",
    "    def list_events(self, filters: Optional[Dict[str, Any]] = None) -> Response:",
    "        \"\"\"",
    "        List all events with optional pagination.",
    "        ",
    "        Args:",
    "            filters: Optional dict with 'limit' and 'offset' for pagination",
    "            ",
    "        Returns:",
    "            Response with 200 OK and paginated event list",
    "        \"\"\"",
    "        filters = filters or {}",
    "        limit = filters.get('limit', 10)",
    "        offset = filters.get('offset', 0)",
    "        ",
    "        # Get paginated slice of events",
    "        all_events = list(self._events.values())",
    "        paginated_events = all_events[offset:offset + limit]",
    "        ",
    "        return self._success_response(",
    "            status=200,",
    "            data={",
    "                'events': [",
    "                    {",
    "                        'eventId': e.id,",
    "                        'name': e.name,",
    "                        'date': e.date.isoformat(),",
    "                        'venue': e.venue,",
    "                        'availableTickets': e.available_tickets,",
    "                        'pricePerTicket': float(e.price_per_ticket)",
    "                    }",
    "                    for e in paginated_events",
    "                ],",
    "                'total': len(all_events),",
    "                'limit': limit,",
    "                'offset': offset",
    "            }",
    "        )",
    "    ",
    "    def book_tickets(self, request: Dict[str, Any]) -> Response:",
    "        \"\"\"",
    "        Book tickets for an event (THREAD-SAFE).",
    "        ",
    "        This method uses locking to prevent race conditions that could",
    "        cause ticket overselling when multiple users book simultaneously.",
    "        ",
    "        Args:",
    "            request: Dict containing eventId, userId, numberOfTickets",
    "            ",
    "        Returns:",
    "            Response with 201 Created and booking details, or",
    "            Response with 400 for validation errors,",
    "            Response with 404 if event not found,",
    "            Response with 409 if insufficient tickets",
    "            ",
    "        Example:",
    "            >>> api = TicketAPI()",
    "            >>> # ... create event first ...",
    "            >>> response = api.book_tickets({",
    "            ...     'eventId': 'evt_001',",
    "            ...     'userId': 'usr_123',",
    "            ...     'numberOfTickets': 2",
    "            ... })",
    "            >>> response.status",
    "            201",
    "        \"\"\"",
    "        # Step 1: Validate input",
    "        errors = self._validator.validate_booking(request)",
    "        if errors:",
    "            return self._error_response(",
    "                status=400,",
    "                code=ErrorCode.VALIDATION_ERROR.value,",
    "                message='Invalid booking request',",
    "                details=[{'field': e.field, 'issue': e.issue} for e in errors]",
    "            )",
    "        ",
    "        event_id = request['eventId']",
    "        user_id = request['userId']",
    "        num_tickets = request['numberOfTickets']",
    "        ",
    "        # Step 2: Check event exists (before acquiring lock)",
    "        if event_id not in self._events:",
    "            return self._error_response(",
    "                status=404,",
    "                code=ErrorCode.NOT_FOUND.value,",
    "                message=f'Event {event_id} not found'",
    "            )",
    "        ",
    "        # Step 3: Atomic booking with lock",
    "        with self._lock:",
    "            event = self._events[event_id]",
    "            ",
    "            # Re-check availability inside lock (double-check pattern)",
    "            if event.available_tickets < num_tickets:",
    "                return self._error_response(",
    "                    status=409,",
    "                    code=ErrorCode.INSUFFICIENT_TICKETS.value,",
    "                    message=f'Only {event.available_tickets} ticket(s) available, requested {num_tickets}'",
    "                )",
    "            ",
    "            # Create booking",
    "            booking_id = self._generate_booking_id()",
    "            total_amount = event.price_per_ticket * num_tickets",
    "            ",
    "            booking = Booking(",
    "                id=booking_id,",
    "                event_id=event_id,",
    "                user_id=user_id,",
    "                number_of_tickets=num_tickets,",
    "                total_amount=total_amount,",
    "                status=BookingStatus.CONFIRMED,",
    "                created_at=datetime.now()",
    "            )",
    "            ",
    "            # Update inventory (atomic with booking creation)",
    "            event.available_tickets -= num_tickets",
    "            self._bookings[booking_id] = booking",
    "        ",
    "        # Step 4: Return success response",
    "        return self._success_response(",
    "            status=201,",
    "            data={",
    "                'bookingId': booking_id,",
    "                'eventId': event_id,",
    "                'userId': user_id,",
    "                'numberOfTickets': num_tickets,",
    "                'totalAmount': float(total_amount),",
    "                'status': BookingStatus.CONFIRMED.value",
    "            }",
    "        )",
    "    ",
    "    def cancel_booking(self, booking_id: str) -> Response:",
    "        \"\"\"",
    "        Cancel an existing booking and return tickets to inventory.",
    "        ",
    "        Args:",
    "            booking_id: Unique booking identifier",
    "            ",
    "        Returns:",
    "            Response with 200 OK and cancellation confirmation, or",
    "            Response with 404 if booking not found,",
    "            Response with 409 if already cancelled",
    "        \"\"\"",
    "        # Check booking exists",
    "        if booking_id not in self._bookings:",
    "            return self._error_response(",
    "                status=404,",
    "                code=ErrorCode.NOT_FOUND.value,",
    "                message=f'Booking {booking_id} not found'",
    "            )",
    "        ",
    "        # Atomic cancellation with lock",
    "        with self._lock:",
    "            booking = self._bookings[booking_id]",
    "            ",
    "            # Check if already cancelled",
    "            if booking.status == BookingStatus.CANCELLED:",
    "                return self._error_response(",
    "                    status=409,",
    "                    code=ErrorCode.ALREADY_CANCELLED.value,",
    "                    message='Booking already cancelled'",
    "                )",
    "            ",
    "            # Return tickets to inventory",
    "            event = self._events[booking.event_id]",
    "            event.available_tickets += booking.number_of_tickets",
    "            ",
    "            # Update booking status",
    "            booking.status = BookingStatus.CANCELLED",
    "        ",
    "        return self._success_response(",
    "            status=200,",
    "            data={",
    "                'bookingId': booking_id,",
    "                'status': BookingStatus.CANCELLED.value",
    "            }",
    "        )",
    "",
    "",
    "# =============================================================================",
    "# DEMO / TEST HARNESS",
    "# =============================================================================",
    "",
    "def main():",
    "    \"\"\"Demonstrate the Ticket API functionality.\"\"\"",
    "    print('=' * 70)",
    "    print('TICKET BOOKING API - DEMONSTRATION')",
    "    print('=' * 70)",
    "    print()",
    "    ",
    "    # Initialize API",
    "    api = TicketAPI()",
    "    print('\u2713 API initialized')",
    "    print()",
    "    ",
    "    # Test 1: Create Event",
    "    print('TEST 1: Create Event')",
    "    print('-' * 40)",
    "    response = api.create_event({",
    "        'name': 'Tech Conference 2024',",
    "        'date': '2024-12-15T09:00:00Z',",
    "        'venue': 'Convention Center',",
    "        'totalTickets': 100,",
    "        'pricePerTicket': 75.00",
    "    })",
    "    print(f'Status: {response.status}')",
    "    print(f'Response: {response.body}')",
    "    event_id = response.body['data']['eventId']",
    "    print()",
    "    ",
    "    # Test 2: Get Event",
    "    print('TEST 2: Get Event')",
    "    print('-' * 40)",
    "    response = api.get_event(event_id)",
    "    print(f'Status: {response.status}')",
    "    print(f'Available: {response.body[\"data\"][\"availableTickets\"]} tickets')",
    "    print()",
    "    ",
    "    # Test 3: Book Tickets",
    "    print('TEST 3: Book 2 Tickets')",
    "    print('-' * 40)",
    "    response = api.book_tickets({",
    "        'eventId': event_id,",
    "        'userId': 'usr_123',",
    "        'numberOfTickets': 2",
    "    })",
    "    print(f'Status: {response.status}')",
    "    print(f'Total Amount: ${response.body[\"data\"][\"totalAmount\"]}')",
    "    booking_id = response.body['data']['bookingId']",
    "    print()",
    "    ",
    "    # Test 4: Verify Tickets Decremented",
    "    print('TEST 4: Verify Ticket Count After Booking')",
    "    print('-' * 40)",
    "    response = api.get_event(event_id)",
    "    print(f'Available: {response.body[\"data\"][\"availableTickets\"]} tickets (was 100)')",
    "    print()",
    "    ",
    "    # Test 5: Cancel Booking",
    "    print('TEST 5: Cancel Booking')",
    "    print('-' * 40)",
    "    response = api.cancel_booking(booking_id)",
    "    print(f'Status: {response.status}')",
    "    print(f'Booking Status: {response.body[\"data\"][\"status\"]}')",
    "    print()",
    "    ",
    "    # Test 6: Verify Tickets Restored",
    "    print('TEST 6: Verify Tickets Restored After Cancellation')",
    "    print('-' * 40)",
    "    response = api.get_event(event_id)",
    "    print(f'Available: {response.body[\"data\"][\"availableTickets\"]} tickets (restored!)')",
    "    print()",
    "    ",
    "    # Test 7: Validation Error",
    "    print('TEST 7: Validation Error (Missing Fields)')",
    "    print('-' * 40)",
    "    response = api.create_event({",
    "        'date': '2024-12-15T09:00:00Z',",
    "        'venue': 'Test Venue'",
    "    })",
    "    print(f'Status: {response.status}')",
    "    print(f'Error: {response.body[\"error\"][\"message\"]}')",
    "    print()",
    "    ",
    "    # Test 8: Overbooking Attempt",
    "    print('TEST 8: Overbooking Attempt')",
    "    print('-' * 40)",
    "    # Create small event",
    "    api.create_event({",
    "        'name': 'Small Event',",
    "        'date': '2024-12-20T20:00:00Z',",
    "        'venue': 'Small Venue',",
    "        'totalTickets': 5,",
    "        'pricePerTicket': 200",
    "    })",
    "    # Book 4 tickets",
    "    api.book_tickets({",
    "        'eventId': 'evt_002',",
    "        'userId': 'usr_456',",
    "        'numberOfTickets': 4",
    "    })",
    "    # Try to book 3 more (only 1 available)",
    "    response = api.book_tickets({",
    "        'eventId': 'evt_002',",
    "        'userId': 'usr_789',",
    "        'numberOfTickets': 3",
    "    })",
    "    print(f'Status: {response.status}')",
    "    print(f'Error: {response.body[\"error\"][\"message\"]}')",
    "    print()",
    "    ",
    "    print('=' * 70)",
    "    print('ALL TESTS COMPLETED')",
    "    print('=' * 70)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.Instant;",
    "import java.util.*;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "",
    "/**",
    " * Production-Ready Event Ticket Booking API",
    " * ",
    " * Features:",
    " * - Thread-safe booking operations",
    " * - BigDecimal for currency precision",
    " * - Full input validation",
    " * - Proper HTTP status codes",
    " */",
    "public class TicketAPI {",
    "    ",
    "    // Enums",
    "    public enum BookingStatus { CONFIRMED, CANCELLED }",
    "    public enum ErrorCode { VALIDATION_ERROR, NOT_FOUND, INSUFFICIENT_TICKETS, ALREADY_CANCELLED }",
    "    ",
    "    // Data Models",
    "    public static class Event {",
    "        public String id;",
    "        public String name;",
    "        public Instant date;",
    "        public String venue;",
    "        public int totalTickets;",
    "        public int availableTickets;",
    "        public BigDecimal pricePerTicket;",
    "        ",
    "        public Event(String id, String name, Instant date, String venue,",
    "                     int totalTickets, BigDecimal pricePerTicket) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "    }",
    "    ",
    "    public static class Booking {",
    "        public String id;",
    "        public String eventId;",
    "        public String userId;",
    "        public int numberOfTickets;",
    "        public BigDecimal totalAmount;",
    "        public BookingStatus status;",
    "        public Instant createdAt;",
    "        ",
    "        public Booking(String id, String eventId, String userId,",
    "                       int numberOfTickets, BigDecimal totalAmount) {",
    "            this.id = id;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = numberOfTickets;",
    "            this.totalAmount = totalAmount;",
    "            this.status = BookingStatus.CONFIRMED;",
    "            this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    public static class Response {",
    "        public int status;",
    "        public Map<String, Object> body;",
    "        ",
    "        public Response(int status, Map<String, Object> body) {",
    "            this.status = status;",
    "            this.body = body;",
    "        }",
    "    }",
    "    ",
    "    public static class ValidationError {",
    "        public String field;",
    "        public String issue;",
    "        ",
    "        public ValidationError(String field, String issue) {",
    "            this.field = field;",
    "            this.issue = issue;",
    "        }",
    "    }",
    "    ",
    "    // Data stores",
    "    private final Map<String, Event> events = new HashMap<>();",
    "    private final Map<String, Booking> bookings = new HashMap<>();",
    "    private final ReentrantLock lock = new ReentrantLock();",
    "    private int eventCounter = 0;",
    "    private int bookingCounter = 0;",
    "    ",
    "    // ID generation",
    "    private String generateEventId() {",
    "        return String.format(\"evt_%03d\", ++eventCounter);",
    "    }",
    "    ",
    "    private String generateBookingId() {",
    "        return String.format(\"bkg_%03d\", ++bookingCounter);",
    "    }",
    "    ",
    "    // Response builders",
    "    private Response successResponse(int status, Map<String, Object> data) {",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", true);",
    "        body.put(\"data\", data);",
    "        body.put(\"error\", null);",
    "        return new Response(status, body);",
    "    }",
    "    ",
    "    private Response errorResponse(int status, String code, String message,",
    "                                   List<Map<String, String>> details) {",
    "        Map<String, Object> error = new HashMap<>();",
    "        error.put(\"code\", code);",
    "        error.put(\"message\", message);",
    "        if (details != null) {",
    "            error.put(\"details\", details);",
    "        }",
    "        ",
    "        Map<String, Object> body = new HashMap<>();",
    "        body.put(\"success\", false);",
    "        body.put(\"data\", null);",
    "        body.put(\"error\", error);",
    "        return new Response(status, body);",
    "    }",
    "    ",
    "    // Validation",
    "    private List<ValidationError> validateEventRequest(Map<String, Object> request) {",
    "        List<ValidationError> errors = new ArrayList<>();",
    "        String[] required = {\"name\", \"date\", \"venue\", \"totalTickets\", \"pricePerTicket\"};",
    "        ",
    "        for (String field : required) {",
    "            if (!request.containsKey(field) || request.get(field) == null) {",
    "                errors.add(new ValidationError(field, \"required\"));",
    "            }",
    "        }",
    "        ",
    "        if (!errors.isEmpty()) return errors;",
    "        ",
    "        // Type and range validation",
    "        Object totalTickets = request.get(\"totalTickets\");",
    "        if (!(totalTickets instanceof Integer)) {",
    "            errors.add(new ValidationError(\"totalTickets\", \"must be an integer\"));",
    "        } else {",
    "            int tickets = (Integer) totalTickets;",
    "            if (tickets < 1 || tickets > 100000) {",
    "                errors.add(new ValidationError(\"totalTickets\", \"must be between 1 and 100000\"));",
    "            }",
    "        }",
    "        ",
    "        return errors;",
    "    }",
    "    ",
    "    private List<ValidationError> validateBookingRequest(Map<String, Object> request) {",
    "        List<ValidationError> errors = new ArrayList<>();",
    "        String[] required = {\"eventId\", \"userId\", \"numberOfTickets\"};",
    "        ",
    "        for (String field : required) {",
    "            if (!request.containsKey(field) || request.get(field) == null) {",
    "                errors.add(new ValidationError(field, \"required\"));",
    "            }",
    "        }",
    "        ",
    "        if (!errors.isEmpty()) return errors;",
    "        ",
    "        Object numTickets = request.get(\"numberOfTickets\");",
    "        if (!(numTickets instanceof Integer)) {",
    "            errors.add(new ValidationError(\"numberOfTickets\", \"must be an integer\"));",
    "        } else {",
    "            int tickets = (Integer) numTickets;",
    "            if (tickets < 1 || tickets > 10) {",
    "                errors.add(new ValidationError(\"numberOfTickets\", \"must be between 1 and 10\"));",
    "            }",
    "        }",
    "        ",
    "        return errors;",
    "    }",
    "    ",
    "    // API Methods",
    "    public Response createEvent(Map<String, Object> request) {",
    "        List<ValidationError> errors = validateEventRequest(request);",
    "        if (!errors.isEmpty()) {",
    "            List<Map<String, String>> details = new ArrayList<>();",
    "            for (ValidationError e : errors) {",
    "                Map<String, String> detail = new HashMap<>();",
    "                detail.put(\"field\", e.field);",
    "                detail.put(\"issue\", e.issue);",
    "                details.add(detail);",
    "            }",
    "            return errorResponse(400, ErrorCode.VALIDATION_ERROR.name(),",
    "                    \"Missing required field: \" + errors.get(0).field, details);",
    "        }",
    "        ",
    "        String eventId = generateEventId();",
    "        Event event = new Event(",
    "            eventId,",
    "            (String) request.get(\"name\"),",
    "            Instant.parse((String) request.get(\"date\")),",
    "            (String) request.get(\"venue\"),",
    "            (Integer) request.get(\"totalTickets\"),",
    "            new BigDecimal(request.get(\"pricePerTicket\").toString())",
    "        );",
    "        ",
    "        events.put(eventId, event);",
    "        ",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", eventId);",
    "        data.put(\"name\", event.name);",
    "        data.put(\"availableTickets\", event.availableTickets);",
    "        ",
    "        return successResponse(201, data);",
    "    }",
    "    ",
    "    public Response getEvent(String eventId) {",
    "        if (!events.containsKey(eventId)) {",
    "            return errorResponse(404, ErrorCode.NOT_FOUND.name(),",
    "                    \"Event \" + eventId + \" not found\", null);",
    "        }",
    "        ",
    "        Event event = events.get(eventId);",
    "        Map<String, Object> data = new HashMap<>();",
    "        data.put(\"eventId\", event.id);",
    "        data.put(\"name\", event.name);",
    "        data.put(\"availableTickets\", event.availableTickets);",
    "        data.put(\"pricePerTicket\", event.pricePerTicket.doubleValue());",
    "        ",
    "        return successResponse(200, data);",
    "    }",
    "    ",
    "    public Response bookTickets(Map<String, Object> request) {",
    "        List<ValidationError> errors = validateBookingRequest(request);",
    "        if (!errors.isEmpty()) {",
    "            List<Map<String, String>> details = new ArrayList<>();",
    "            for (ValidationError e : errors) {",
    "                Map<String, String> detail = new HashMap<>();",
    "                detail.put(\"field\", e.field);",
    "                detail.put(\"issue\", e.issue);",
    "                details.add(detail);",
    "            }",
    "            return errorResponse(400, ErrorCode.VALIDATION_ERROR.name(),",
    "                    \"Invalid booking request\", details);",
    "        }",
    "        ",
    "        String eventId = (String) request.get(\"eventId\");",
    "        String userId = (String) request.get(\"userId\");",
    "        int numTickets = (Integer) request.get(\"numberOfTickets\");",
    "        ",
    "        if (!events.containsKey(eventId)) {",
    "            return errorResponse(404, ErrorCode.NOT_FOUND.name(),",
    "                    \"Event \" + eventId + \" not found\", null);",
    "        }",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Event event = events.get(eventId);",
    "            ",
    "            if (event.availableTickets < numTickets) {",
    "                return errorResponse(409, ErrorCode.INSUFFICIENT_TICKETS.name(),",
    "                        \"Only \" + event.availableTickets + \" ticket(s) available, requested \" + numTickets, null);",
    "            }",
    "            ",
    "            String bookingId = generateBookingId();",
    "            BigDecimal totalAmount = event.pricePerTicket.multiply(new BigDecimal(numTickets));",
    "            ",
    "            Booking booking = new Booking(bookingId, eventId, userId, numTickets, totalAmount);",
    "            event.availableTickets -= numTickets;",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"eventId\", eventId);",
    "            data.put(\"numberOfTickets\", numTickets);",
    "            data.put(\"totalAmount\", totalAmount.doubleValue());",
    "            data.put(\"status\", BookingStatus.CONFIRMED.name());",
    "            ",
    "            return successResponse(201, data);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    public Response cancelBooking(String bookingId) {",
    "        if (!bookings.containsKey(bookingId)) {",
    "            return errorResponse(404, ErrorCode.NOT_FOUND.name(),",
    "                    \"Booking \" + bookingId + \" not found\", null);",
    "        }",
    "        ",
    "        lock.lock();",
    "        try {",
    "            Booking booking = bookings.get(bookingId);",
    "            ",
    "            if (booking.status == BookingStatus.CANCELLED) {",
    "                return errorResponse(409, ErrorCode.ALREADY_CANCELLED.name(),",
    "                        \"Booking already cancelled\", null);",
    "            }",
    "            ",
    "            Event event = events.get(booking.eventId);",
    "            event.availableTickets += booking.numberOfTickets;",
    "            booking.status = BookingStatus.CANCELLED;",
    "            ",
    "            Map<String, Object> data = new HashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"status\", BookingStatus.CANCELLED.name());",
    "            ",
    "            return successResponse(200, data);",
    "        } finally {",
    "            lock.unlock();",
    "        }",
    "    }",
    "    ",
    "    // Demo",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"TICKET BOOKING API - JAVA DEMO\");",
    "        System.out.println(\"=\" .repeat(60));",
    "        ",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        // Create Event",
    "        Map<String, Object> eventReq = new HashMap<>();",
    "        eventReq.put(\"name\", \"Tech Conference 2024\");",
    "        eventReq.put(\"date\", \"2024-12-15T09:00:00Z\");",
    "        eventReq.put(\"venue\", \"Convention Center\");",
    "        eventReq.put(\"totalTickets\", 100);",
    "        eventReq.put(\"pricePerTicket\", 75.00);",
    "        ",
    "        Response response = api.createEvent(eventReq);",
    "        System.out.println(\"Create Event: \" + response.status);",
    "        System.out.println(response.body);",
    "        ",
    "        // Book Tickets",
    "        Map<String, Object> bookReq = new HashMap<>();",
    "        bookReq.put(\"eventId\", \"evt_001\");",
    "        bookReq.put(\"userId\", \"usr_123\");",
    "        bookReq.put(\"numberOfTickets\", 2);",
    "        ",
    "        response = api.bookTickets(bookReq);",
    "        System.out.println(\"Book Tickets: \" + response.status);",
    "        System.out.println(response.body);",
    "        ",
    "        // Get Event (verify decrement)",
    "        response = api.getEvent(\"evt_001\");",
    "        System.out.println(\"Get Event: \" + response.status);",
    "        System.out.println(response.body);",
    "        ",
    "        System.out.println(\"\\nAll tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "section": "Imports and Module Docstring",
      "explanation": "We import `Decimal` for currency precision (critical!), `threading` for lock-based concurrency control, `dataclass` for clean entity definitions, and `Enum` for type-safe status codes. The docstring explains the module's purpose and key features."
    },
    {
      "lines": "25-40",
      "section": "Enums and Constants",
      "explanation": "`BookingStatus` enum ensures we can only have CONFIRMED or CANCELLED states - no magic strings. `ErrorCode` enum standardizes API error codes for consistent client handling."
    },
    {
      "lines": "45-90",
      "section": "Entity Classes (Event, Booking, Response)",
      "explanation": "Using `@dataclass` gives us clean immutable-style objects with auto-generated `__init__`, `__repr__`, etc. Notice `price_per_ticket` is `Decimal` not `float` - this is CRITICAL for currency. The `Response` class wraps HTTP status + body for consistent API returns."
    },
    {
      "lines": "95-180",
      "section": "RequestValidator Class",
      "explanation": "This implements the **Strategy Pattern** - validation logic is isolated into its own class. Key insight: we validate REQUIRED fields first, then TYPES, then RANGES. This gives clients the most useful error first. All constraints from the problem (max 200 chars, max 100K tickets, etc.) are enforced here."
    },
    {
      "lines": "190-250",
      "section": "TicketAPI Initialization and Helpers",
      "explanation": "The API uses two HashMaps for O(1) lookup of events and bookings. The `threading.Lock()` is CRITICAL - it prevents race conditions where two users booking simultaneously could oversell tickets. Helper methods `_success_response` and `_error_response` ensure consistent response formatting."
    },
    {
      "lines": "255-310",
      "section": "create_event Method",
      "explanation": "Flow: 1) Validate \u2192 2) Create entity with Decimal price \u2192 3) Store in HashMap \u2192 4) Return 201 Created. Note we convert price to Decimal IMMEDIATELY upon receiving it. This prevents float precision errors from propagating through the system."
    },
    {
      "lines": "315-360",
      "section": "book_tickets Method (Thread-Safe)",
      "explanation": "This is the **critical section**. We use `with self._lock:` to ensure atomic booking. Inside the lock, we RECHECK availability (double-check pattern) because another thread might have booked while we were waiting. The lock ensures: check-decrement-store happens atomically. Returns 409 Conflict if insufficient tickets."
    },
    {
      "lines": "365-400",
      "section": "cancel_booking Method",
      "explanation": "Also uses locking to ensure atomic ticket restoration. Checks if already cancelled (idempotency concern) and returns 409 if so. Successfully cancelling restores tickets to the event's `available_tickets` count."
    },
    {
      "lines": "405-500",
      "section": "Main Demo Function",
      "explanation": "Comprehensive test harness demonstrating: 1) Event creation, 2) Ticket booking with price calculation, 3) Verifying ticket count decreased, 4) Cancellation with ticket restoration, 5) Validation error handling, 6) Overbooking rejection. This proves the API handles all scenarios correctly."
    }
  ],
  "complexity_analysis": {
    "time": {
      "create_event": {
        "complexity": "O(V)",
        "explanation": "V = number of validation checks. HashMap insertion is O(1)."
      },
      "get_event": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup by key is constant time."
      },
      "list_events": {
        "complexity": "O(n)",
        "explanation": "Must iterate over n events for pagination. Could be O(1) with proper indexing."
      },
      "book_tickets": {
        "complexity": "O(1)",
        "explanation": "HashMap lookups, arithmetic, and insertion - all O(1). Lock acquisition is O(1) amortized."
      },
      "cancel_booking": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup and update. Lock acquisition O(1) amortized."
      },
      "overall": "All operations except list_events are O(1). System can handle 10K+ req/s."
    },
    "space": {
      "complexity": "O(E + B) where E = events, B = bookings",
      "breakdown": "- HashMap<eventId, Event>: O(E)\n- HashMap<bookingId, Booking>: O(B)\n- Lock object: O(1)\n- Counter variables: O(1)",
      "note": "Space grows linearly with number of events and bookings. In production, this would be database storage with indexing."
    },
    "can_we_do_better": "Time complexity is already optimal - O(1) for all primary operations. Space could be optimized with pagination and lazy loading for very large datasets, but that's a database concern. The threading lock could become a bottleneck at extreme scale - solution is sharding by event ID."
  },
  "dry_run": {
    "example": "createEvent({name:'Concert', tickets:5, price:100}), bookTickets({event:'evt_001', tickets:4}), bookTickets({event:'evt_001', tickets:3})",
    "trace_table": "| Step | Operation | Validation | Event State | Booking State | Response |\n|------|-----------|------------|-------------|---------------|----------|\n| 1 | `createEvent({name:'Concert', tickets:5, price:100})` | \u2713 All fields valid | `{evt_001: Event(avail=5, price=100)}` | `{}` | `201: {eventId:'evt_001'}` |\n| 2 | `bookTickets({event:'evt_001', tickets:4})` | \u2713 Valid, 5 >= 4 | `{evt_001: Event(avail=1)}` | `{bkg_001: Booking(qty=4, amt=400)}` | `201: {bookingId:'bkg_001', total:400}` |\n| 3 | `bookTickets({event:'evt_001', tickets:3})` | \u2717 Fail: 1 < 3 | unchanged | unchanged | `409: 'Only 1 ticket(s) available, requested 3'` |",
    "final_answer": "First booking succeeds ($400 total), second booking rejected with 409 Conflict because only 1 ticket remains but 3 were requested. This demonstrates the overbooking prevention working correctly."
  },
  "test_cases": [
    {
      "name": "Basic Event Creation",
      "category": "Happy Path",
      "input": "createEvent({name:'Tech Conf', date:'2024-12-15T09:00:00Z', venue:'Center', totalTickets:100, pricePerTicket:75})",
      "expected": "201, eventId='evt_001', availableTickets=100",
      "explanation": "Standard event creation with all required fields should succeed with 201 Created."
    },
    {
      "name": "Missing Required Field",
      "category": "Validation Error",
      "input": "createEvent({date:'2024-12-15', venue:'Center', totalTickets:100})",
      "expected": "400, error.code='VALIDATION_ERROR', details include 'name' and 'pricePerTicket'",
      "explanation": "Missing 'name' and 'pricePerTicket' should return 400 with field-level error details."
    },
    {
      "name": "Invalid Type for totalTickets",
      "category": "Type Validation",
      "input": "createEvent({name:'Event', date:'2024-12-15', venue:'V', totalTickets:'100', pricePerTicket:50})",
      "expected": "400, details: [{field:'totalTickets', issue:'must be an integer'}]",
      "explanation": "String '100' instead of integer 100 should be rejected with type error."
    },
    {
      "name": "Book Exactly Remaining Tickets",
      "category": "Boundary",
      "input": "Event with 10 tickets, book 7, then book 3",
      "expected": "Both bookings succeed (201), final availableTickets=0",
      "explanation": "Booking exactly the remaining count should succeed - tests >= vs > in comparison."
    },
    {
      "name": "Overbooking by 1 Ticket",
      "category": "Boundary",
      "input": "Event with 5 tickets, book 4 (leaves 1), book 2",
      "expected": "First: 201, Second: 409 'Only 1 ticket(s) available, requested 2'",
      "explanation": "Attempting to book 1 more than available should fail with 409 Conflict."
    },
    {
      "name": "Event Not Found",
      "category": "Error Handling",
      "input": "getEvent('evt_999')",
      "expected": "404, error.code='NOT_FOUND'",
      "explanation": "Non-existent event ID should return 404 Not Found."
    },
    {
      "name": "Cancel and Re-book",
      "category": "Integration",
      "input": "Create event(10), book(5), cancel, verify available=10, book(5) again",
      "expected": "All succeed, final available=5",
      "explanation": "Cancellation should restore tickets allowing subsequent booking."
    },
    {
      "name": "Double Cancellation",
      "category": "Idempotency",
      "input": "Book tickets, cancel, cancel again",
      "expected": "First cancel: 200, Second cancel: 409 'Already cancelled'",
      "explanation": "Cancelling already-cancelled booking should return 409 Conflict."
    },
    {
      "name": "Currency Precision",
      "category": "Precision",
      "input": "createEvent({price:99.99}), book(3)",
      "expected": "totalAmount = 299.97 exactly (not 299.96999...)",
      "explanation": "Tests that Decimal is used correctly for currency multiplication."
    },
    {
      "name": "Max Tickets Per Booking",
      "category": "Constraint",
      "input": "bookTickets({numberOfTickets:11})",
      "expected": "400, 'must be between 1 and 10'",
      "explanation": "Exceeding max 10 tickets per booking should fail validation."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float/double for currency",
      "why_wrong": "Floating-point arithmetic causes precision errors: `0.1 + 0.1 + 0.1 = 0.30000000000000004`. In production, this leads to accounting discrepancies and audit failures.",
      "correct_approach": "Always use `Decimal` (Python) or `BigDecimal` (Java) for money. Convert immediately upon receiving user input.",
      "code_wrong": "total = price * quantity  # price is float",
      "code_correct": "total = Decimal(str(price)) * quantity  # Decimal for precision"
    },
    {
      "mistake": "No locking on booking operations",
      "why_wrong": "Race condition: Two users check availability(10), both see 10 available, both book 6 tickets, final count = -2 (oversold!)",
      "correct_approach": "Use a lock (mutex) to make check-decrement-store atomic. Re-check availability inside the lock.",
      "code_wrong": "if event.available >= tickets:\n    event.available -= tickets  # Race condition!",
      "code_correct": "with lock:\n    if event.available >= tickets:\n        event.available -= tickets  # Atomic!"
    },
    {
      "mistake": "Wrong HTTP status codes",
      "why_wrong": "Using 200 for everything makes client error handling impossible. Using 500 for user errors makes monitoring useless (false alarms).",
      "correct_approach": "201=Created, 200=Success, 400=Bad Input, 404=Not Found, 409=Conflict, 500=Server Error",
      "code_wrong": "return Response(200, {'error': 'Not found'})  # Wrong!",
      "code_correct": "return Response(404, {'error': {'code': 'NOT_FOUND', ...}})"
    },
    {
      "mistake": "Validation after business logic",
      "why_wrong": "Processing invalid data before validating can cause crashes, security vulnerabilities, or corrupt state.",
      "correct_approach": "Validate ALL input BEFORE touching business logic. Fail fast with clear error messages.",
      "code_wrong": "event = events[request['eventId']]  # Might crash!\ncost = event.price * request['tickets']  # Type error?",
      "code_correct": "errors = validate(request)\nif errors: return error_response(400, errors)\n# Now safe to process"
    },
    {
      "mistake": "Not returning tickets on cancellation",
      "why_wrong": "Tickets disappear from inventory permanently, making them unrecoverable. Venue appears sold out when it isn't.",
      "correct_approach": "Cancellation must restore tickets: `event.available_tickets += booking.number_of_tickets`",
      "code_wrong": "booking.status = CANCELLED  # Forgot to restore tickets!",
      "code_correct": "event.available_tickets += booking.number_of_tickets\nbooking.status = CANCELLED"
    },
    {
      "mistake": "Mutable default arguments in Python",
      "why_wrong": "Using `def func(filters={})` causes the same dict to be reused across calls, leading to bizarre bugs.",
      "correct_approach": "Use `None` as default, then assign empty dict inside function.",
      "code_wrong": "def list_events(self, filters={}):  # Dangerous!",
      "code_correct": "def list_events(self, filters=None):\n    filters = filters or {}"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things and outline my approach. I see this is an API design problem for a ticket booking system. I'll focus on three key aspects: input validation, proper HTTP semantics, and thread-safe booking to prevent overselling. Let me ask a few clarifying questions first...",
    "clarifying_questions_to_ask": [
      "**Should I use a specific date format?** - I'll assume ISO 8601 with UTC timezone unless specified otherwise.",
      "**What precision do we need for currency?** - I'll use Decimal/BigDecimal to avoid floating-point errors.",
      "**How should concurrent bookings be handled?** - I'll implement locking to prevent race conditions.",
      "**Should cancellation be idempotent?** - I'll return 409 for double-cancellation, but we could discuss alternatives.",
      "**Are there any specific error response formats required?** - I'll use the format from the problem statement.",
      "**What authentication/authorization is expected?** - I'll assume Part 1 doesn't require auth, but mention it's needed for production."
    ],
    "what_to_mention_proactively": [
      "I'll use **Decimal for all currency** to avoid float precision issues - this is critical for financial systems.",
      "I'll implement **layered architecture** - separate validation, business logic, and data access for testability.",
      "I'll use **threading locks** for booking operations to prevent race conditions that could cause overselling.",
      "I'll ensure **proper HTTP status codes** - 201 for creation, 200 for success, 400/404/409 for errors.",
      "I'll **validate input exhaustively** before processing - never trust user input."
    ],
    "communication_during_coding": [
      "I'm starting with the **entity classes** - Event and Booking with proper types.",
      "Now implementing the **validator** - this catches bad input before it reaches business logic.",
      "Here's the **critical section** - the lock ensures check-decrement-store is atomic.",
      "Using **Decimal here** to avoid precision loss in currency multiplication.",
      "This **double-check pattern** inside the lock prevents race conditions."
    ],
    "if_stuck": [
      "Let me step back and think about the **key constraint** - what could go wrong in production?",
      "Let me **trace through an example** manually to verify my logic.",
      "I'll start with a **simpler version** without validation, then add it incrementally.",
      "Let me **draw the data flow** to visualize where the problem might be."
    ],
    "time_management": "**0-10 min**: Clarify requirements, ask questions, outline approach | **10-15 min**: Define entities and data structures | **15-35 min**: Implement core API methods | **35-45 min**: Add validation layer | **45-55 min**: Test with examples, handle edge cases | **55-60 min**: Discuss trade-offs, production concerns, follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Repository + Service Layer + Input Validation Pattern",
    "indicators": [
      "CRUD operations on domain entities",
      "Need for input validation before processing",
      "Concurrent access requiring thread safety",
      "HTTP API with proper status codes",
      "Financial calculations requiring precision"
    ],
    "similar_problems": [
      "**Design a Library Management System** - Similar CRUD with availability tracking",
      "**Design a Hotel Booking System** - Same overbooking prevention challenge",
      "**Design an E-commerce Cart** - Currency precision, inventory management",
      "**Design a Movie Ticket Booking System (BookMyShow)** - Exact same domain",
      "**LC 1188 - Design Bounded Blocking Queue** - Thread-safe resource management"
    ],
    "template": "1. Define entities with proper types (Decimal for money)\n2. Create validation layer (fail fast)\n3. Implement service layer with locking for shared resources\n4. Use HashMap for O(1) lookup\n5. Return standardized responses with proper HTTP codes"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Authentication and Authorization** will require adding user tokens, role-based access (admin vs user), and protecting endpoints. Consider adding a middleware pattern for auth checks before handler execution.",
    "part_3_hint": "**Part 3: Concurrency and Race Conditions** will dive deeper into distributed locking, optimistic vs pessimistic locking, and handling concurrent booking attempts. Study the double-check locking pattern and database-level atomic operations (SELECT FOR UPDATE).",
    "part_4_hint": "**Part 4: Production Readiness** will cover logging, monitoring, rate limiting, circuit breakers, and graceful degradation. Research the 12-factor app methodology and observability patterns.",
    "data_structure_evolution": "Part 1: HashMap + Lock \u2192 Part 2: Add User HashMap + Auth middleware \u2192 Part 3: Consider distributed lock (Redis) \u2192 Part 4: Add metrics counters, request tracing IDs"
  },
  "generated_at": "2026-01-14T15:34:13.710059",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}