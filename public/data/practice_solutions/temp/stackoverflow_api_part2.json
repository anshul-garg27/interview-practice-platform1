{
  "problem_title": "Stack Overflow API Design - Part 2: Voting and Reputation System",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 extends the basic Q&A system with a sophisticated voting mechanism and reputation tracking. Users can now upvote/downvote questions and answers, which affects both the content's score and the author's reputation. This introduces the critical concept of vote tracking (preventing duplicate votes, allowing vote changes) and incremental reputation management.",
    "new_requirements": [
      "Track individual votes per user per item (question/answer)",
      "Allow vote changes (upvote to downvote and vice versa)",
      "Prevent users from voting on their own content",
      "Update reputation incrementally based on votes received",
      "Support answer acceptance by question author only",
      "Calculate correct reputation deltas when votes change"
    ],
    "new_constraints": [
      "One vote per user per item",
      "Cannot vote on own content (return -1)",
      "Only question author can accept answers",
      "Reputation changes: +10 for upvote, -2 for downvote, +15 for accepted answer"
    ],
    "key_insight": "The crucial insight is tracking the PREVIOUS vote state to calculate the correct delta. When a user changes from upvote to downvote, it's not just -1 to score, it's -2 (removing the +1 and adding -1). Similarly, reputation must be adjusted by reversing the old vote's effect before applying the new one."
  },
  "visual_explanation": {
    "before_after": "```\n    BEFORE PART 2                          AFTER PART 2\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                          \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    User                                   User\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 id         \u2502                         \u2502 id             \u2502\n    \u2502 username   \u2502                         \u2502 username       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502 reputation: 0  \u2502  \u2190 NEW!\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    Question                               Question\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 id         \u2502                         \u2502 id             \u2502\n    \u2502 title      \u2502                         \u2502 title          \u2502\n    \u2502 body       \u2502                         \u2502 body           \u2502\n    \u2502 tags       \u2502                         \u2502 tags           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502 score: 0       \u2502  \u2190 NEW!\n                                           \u2502 accepted_ans   \u2502  \u2190 NEW!\n                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    NEW DATA STRUCTURES:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  question_votes = {                                 \u2502\n    \u2502    \"q_1\": {\"u2\": 1, \"u3\": -1, \"u4\": 1}            \u2502\n    \u2502  }                                                  \u2502\n    \u2502                                                     \u2502\n    \u2502  answer_votes = {                                   \u2502\n    \u2502    \"a_1\": {\"u1\": 1, \"u3\": 1}                       \u2502\n    \u2502  }                                                  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n                    VOTE CHANGE FLOW\n                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    User B wants to UPVOTE question q_1 (authored by User A)\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 1: VALIDATION                                   \u2502\n    \u2502   \u251c\u2500 Does voter exist? \u2713                            \u2502\n    \u2502   \u251c\u2500 Does question exist? \u2713                         \u2502\n    \u2502   \u2514\u2500 Is voter \u2260 author? \u2713                           \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 2: GET PREVIOUS VOTE                            \u2502\n    \u2502   votes[\"q_1\"][\"u2\"] = ?                            \u2502\n    \u2502                                                      \u2502\n    \u2502   Case A: No previous vote (old_vote = 0)           \u2502\n    \u2502   Case B: Previous upvote (old_vote = 1)            \u2502\n    \u2502   Case C: Previous downvote (old_vote = -1)         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 3: CALCULATE DELTAS                             \u2502\n    \u2502                                                      \u2502\n    \u2502   score_delta = new_vote - old_vote                 \u2502\n    \u2502                                                      \u2502\n    \u2502   Case A: 1 - 0 = +1 (score increases by 1)         \u2502\n    \u2502   Case B: 1 - 1 = 0  (no change, already upvoted)   \u2502\n    \u2502   Case C: 1 - (-1) = +2 (remove downvote + upvote)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 4: UPDATE REPUTATION                            \u2502\n    \u2502                                                      \u2502\n    \u2502   1. Reverse old vote effect on author              \u2502\n    \u2502      old=1: reputation -= 10                        \u2502\n    \u2502      old=-1: reputation += 2                        \u2502\n    \u2502                                                      \u2502\n    \u2502   2. Apply new vote effect on author                \u2502\n    \u2502      new=1: reputation += 10                        \u2502\n    \u2502      new=-1: reputation -= 2                        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Step 5: PERSIST & RETURN                             \u2502\n    \u2502                                                      \u2502\n    \u2502   votes[\"q_1\"][\"u2\"] = 1  // Store vote            \u2502\n    \u2502   return question.score   // Return new score       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Recalculate Everything",
      "description": "Store all votes in a list and recalculate score and reputation by iterating through all votes each time. This would loop through all votes for a question to calculate its score, and loop through all questions/answers for a user to calculate reputation.",
      "time_complexity": "O(V) per operation where V is number of votes",
      "space_complexity": "O(V) for storing vote history",
      "why_not_optimal": "Recalculating scores and reputation from scratch is extremely inefficient. With millions of votes, each operation becomes painfully slow. It also makes duplicate vote detection O(V) instead of O(1)."
    },
    {
      "name": "Better Approach - Store Only Last Vote",
      "description": "Track only whether user voted, but not the vote value. Apply reputation changes directly without tracking history.",
      "time_complexity": "O(1) for vote operations",
      "space_complexity": "O(U\u00d7I) where U is users, I is items",
      "why_not_optimal": "Without storing the actual vote value, we can't correctly handle vote changes. Changing from upvote to downvote requires knowing the previous state to calculate proper deltas."
    },
    {
      "name": "Optimal Approach - Incremental Updates with Vote Tracking",
      "description": "Use nested HashMaps to track votes: item_id -> {voter_id -> vote_value}. Store score and reputation directly in objects, updating incrementally. When a vote changes, calculate the delta by comparing old and new vote values.",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(V) for vote storage where V is number of unique votes",
      "key_insight": "By storing the previous vote value, we can calculate exact deltas: score_delta = new_vote - old_vote. Reputation is updated by first reversing the old vote's effect, then applying the new vote's effect."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution extends Part 1 with **incremental vote and reputation tracking**.\n\n## Core Data Structures\n\n1. **Vote Maps**: `question_votes[question_id][voter_id] = vote_value`\n   - vote_value is **1** for upvote, **-1** for downvote\n   - Absence means no vote (treated as 0)\n\n2. **Score Storage**: Stored directly in Question/Answer objects\n   - Updated incrementally: `score += (new_vote - old_vote)`\n\n3. **Reputation Storage**: Stored in User object\n   - Updated by reversing old effect and applying new effect\n\n## The Delta Calculation Trick\n\nThe brilliant insight is treating vote changes as **deltas**:\n\n```\nold_vote    new_vote    score_delta    reputation_change\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0 (none)    1 (up)      +1             +10 to author\n0 (none)    -1 (down)   -1             -2 to author\n1 (up)      -1 (down)   -2             -12 to author (undo +10, apply -2)\n-1 (down)   1 (up)      +2             +12 to author (undo -2, apply +10)\n1 (up)      1 (up)      0              no change (same vote)\n```\n\n## Why This Works\n\n- **O(1) duplicate detection**: HashMap lookup\n- **O(1) vote update**: Direct score/reputation modification\n- **Correct delta handling**: Old vote value enables precise calculation\n- **Memory efficient**: Only stores actual votes, not history",
    "data_structures": [
      {
        "structure": "Dict[str, Dict[str, int]]",
        "purpose": "Nested HashMap for vote tracking - outer key is item ID, inner key is voter ID, value is vote (+1/-1)"
      },
      {
        "structure": "User.reputation: int",
        "purpose": "Incremental reputation counter, updated on each vote change"
      },
      {
        "structure": "Question/Answer.score: int",
        "purpose": "Incremental score counter, updated as votes come in"
      },
      {
        "structure": "Question.accepted_answer_id: Optional[str]",
        "purpose": "Track which answer (if any) is accepted for a question"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate inputs - check voter exists, item exists, voter is not author",
      "Step 2: Initialize vote map for item if not exists",
      "Step 3: Retrieve old vote value (default to 0 if no previous vote)",
      "Step 4: Calculate score delta = new_vote - old_vote",
      "Step 5: Update item score with delta",
      "Step 6: Update author reputation: reverse old vote effect, apply new vote effect",
      "Step 7: Store new vote value in vote map",
      "Step 8: Return new score (or -1 if validation failed)"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API Design - Part 2: Voting and Reputation System",
    "",
    "This module extends Part 1 with voting capabilities and reputation tracking.",
    "Key features:",
    "- Upvote/downvote questions and answers",
    "- Reputation system based on votes and accepted answers",
    "- Vote change handling with proper delta calculations",
    "\"\"\"",
    "",
    "from typing import Dict, List, Optional, Any",
    "from dataclasses import dataclass, field",
    "from enum import IntEnum",
    "",
    "",
    "class ReputationChange(IntEnum):",
    "    \"\"\"Reputation point values for different actions.\"\"\"",
    "    UPVOTE_RECEIVED = 10",
    "    DOWNVOTE_RECEIVED = -2",
    "    ANSWER_ACCEPTED = 15",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.\"\"\"",
    "    id: str",
    "    username: str",
    "    reputation: int = 0",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        return {",
    "            'id': self.id,",
    "            'username': self.username,",
    "            'reputation': self.reputation",
    "        }",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Represents a question posted on Stack Overflow.\"\"\"",
    "    id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    score: int = 0",
    "    accepted_answer_id: Optional[str] = None",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        result = {",
    "            'id': self.id,",
    "            'author_id': self.author_id,",
    "            'title': self.title,",
    "            'body': self.body,",
    "            'tags': self.tags.copy(),",
    "            'score': self.score",
    "        }",
    "        if self.accepted_answer_id:",
    "            result['accepted_answer_id'] = self.accepted_answer_id",
    "        return result",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.\"\"\"",
    "    id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    score: int = 0",
    "    is_accepted: bool = False",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        return {",
    "            'id': self.id,",
    "            'question_id': self.question_id,",
    "            'author_id': self.author_id,",
    "            'body': self.body,",
    "            'score': self.score,",
    "            'is_accepted': self.is_accepted",
    "        }",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class for Stack Overflow functionality.",
    "    ",
    "    This class provides methods for:",
    "    - User management",
    "    - Question and answer posting",
    "    - Voting on questions and answers",
    "    - Reputation tracking",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize the Stack Overflow system.\"\"\"",
    "        # Core data storage",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        ",
    "        # Vote tracking: item_id -> {voter_id -> vote_value}",
    "        self._question_votes: Dict[str, Dict[str, int]] = {}",
    "        self._answer_votes: Dict[str, Dict[str, int]] = {}",
    "        ",
    "        # ID counters for auto-generation",
    "        self._question_counter: int = 0",
    "        self._answer_counter: int = 0",
    "    ",
    "    # ==================== PART 1: Core Methods ====================",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> Optional[Dict[str, Any]]:",
    "        \"\"\"",
    "        Create a new user in the system.",
    "        ",
    "        Args:",
    "            user_id: Unique identifier for the user",
    "            username: Display name for the user",
    "            ",
    "        Returns:",
    "            User dict if created successfully, None if user_id exists",
    "        \"\"\"",
    "        if user_id in self._users:",
    "            return None",
    "        ",
    "        user = User(id=user_id, username=username)",
    "        self._users[user_id] = user",
    "        return {'id': user.id}",
    "    ",
    "    def post_question(",
    "        self,",
    "        author_id: str,",
    "        title: str,",
    "        body: str,",
    "        tags: List[str]",
    "    ) -> Optional[Dict[str, Any]]:",
    "        \"\"\"",
    "        Post a new question.",
    "        ",
    "        Args:",
    "            author_id: ID of the user posting the question",
    "            title: Question title",
    "            body: Question body/content",
    "            tags: List of tags for categorization",
    "            ",
    "        Returns:",
    "            Question dict with id and score, None if author doesn't exist",
    "        \"\"\"",
    "        if author_id not in self._users:",
    "            return None",
    "        ",
    "        self._question_counter += 1",
    "        question_id = f'q_{self._question_counter}'",
    "        ",
    "        question = Question(",
    "            id=question_id,",
    "            author_id=author_id,",
    "            title=title,",
    "            body=body,",
    "            tags=tags.copy()",
    "        )",
    "        self._questions[question_id] = question",
    "        ",
    "        return {'id': question.id, 'score': question.score}",
    "    ",
    "    def post_answer(",
    "        self,",
    "        author_id: str,",
    "        question_id: str,",
    "        body: str",
    "    ) -> Optional[Dict[str, Any]]:",
    "        \"\"\"",
    "        Post an answer to a question.",
    "        ",
    "        Args:",
    "            author_id: ID of the user posting the answer",
    "            question_id: ID of the question being answered",
    "            body: Answer content",
    "            ",
    "        Returns:",
    "            Answer dict with id and score, None if validation fails",
    "        \"\"\"",
    "        if author_id not in self._users:",
    "            return None",
    "        if question_id not in self._questions:",
    "            return None",
    "        ",
    "        self._answer_counter += 1",
    "        answer_id = f'a_{self._answer_counter}'",
    "        ",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            author_id=author_id,",
    "            body=body",
    "        )",
    "        self._answers[answer_id] = answer",
    "        ",
    "        return {'id': answer.id, 'score': answer.score}",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Dict[str, Any]]:",
    "        \"\"\"Get a question by ID.\"\"\"",
    "        if question_id not in self._questions:",
    "            return None",
    "        return self._questions[question_id].to_dict()",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Dict[str, Any]]:",
    "        \"\"\"Get all questions with a specific tag.\"\"\"",
    "        return [",
    "            q.to_dict() for q in self._questions.values()",
    "            if tag in q.tags",
    "        ]",
    "    ",
    "    def get_answers_for_question(self, question_id: str) -> List[Dict[str, Any]]:",
    "        \"\"\"Get all answers for a question.\"\"\"",
    "        if question_id not in self._questions:",
    "            return []",
    "        return [",
    "            a.to_dict() for a in self._answers.values()",
    "            if a.question_id == question_id",
    "        ]",
    "    ",
    "    # ==================== PART 2: Voting System ====================",
    "    ",
    "    def upvote_question(self, voter_id: str, question_id: str) -> int:",
    "        \"\"\"",
    "        Upvote a question.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            question_id: ID of the question to upvote",
    "            ",
    "        Returns:",
    "            New score of the question, or -1 if invalid",
    "        \"\"\"",
    "        return self._vote_on_question(voter_id, question_id, 1)",
    "    ",
    "    def downvote_question(self, voter_id: str, question_id: str) -> int:",
    "        \"\"\"",
    "        Downvote a question.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            question_id: ID of the question to downvote",
    "            ",
    "        Returns:",
    "            New score of the question, or -1 if invalid",
    "        \"\"\"",
    "        return self._vote_on_question(voter_id, question_id, -1)",
    "    ",
    "    def _vote_on_question(self, voter_id: str, question_id: str, new_vote: int) -> int:",
    "        \"\"\"",
    "        Internal method to handle question voting logic.",
    "        ",
    "        Args:",
    "            voter_id: ID of the voter",
    "            question_id: ID of the question",
    "            new_vote: 1 for upvote, -1 for downvote",
    "            ",
    "        Returns:",
    "            New score or -1 if invalid",
    "        \"\"\"",
    "        # Validation",
    "        if voter_id not in self._users:",
    "            return -1",
    "        if question_id not in self._questions:",
    "            return -1",
    "        ",
    "        question = self._questions[question_id]",
    "        ",
    "        # Cannot vote on own question",
    "        if question.author_id == voter_id:",
    "            return -1",
    "        ",
    "        # Initialize vote tracking for this question if needed",
    "        if question_id not in self._question_votes:",
    "            self._question_votes[question_id] = {}",
    "        ",
    "        votes = self._question_votes[question_id]",
    "        old_vote = votes.get(voter_id, 0)",
    "        ",
    "        # Update score using delta calculation",
    "        score_delta = new_vote - old_vote",
    "        question.score += score_delta",
    "        ",
    "        # Update author reputation",
    "        author = self._users[question.author_id]",
    "        self._update_reputation_for_vote_change(author, old_vote, new_vote)",
    "        ",
    "        # Store the new vote",
    "        votes[voter_id] = new_vote",
    "        ",
    "        return question.score",
    "    ",
    "    def upvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        \"\"\"",
    "        Upvote an answer.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            answer_id: ID of the answer to upvote",
    "            ",
    "        Returns:",
    "            New score of the answer, or -1 if invalid",
    "        \"\"\"",
    "        return self._vote_on_answer(voter_id, answer_id, 1)",
    "    ",
    "    def downvote_answer(self, voter_id: str, answer_id: str) -> int:",
    "        \"\"\"",
    "        Downvote an answer.",
    "        ",
    "        Args:",
    "            voter_id: ID of the user casting the vote",
    "            answer_id: ID of the answer to downvote",
    "            ",
    "        Returns:",
    "            New score of the answer, or -1 if invalid",
    "        \"\"\"",
    "        return self._vote_on_answer(voter_id, answer_id, -1)",
    "    ",
    "    def _vote_on_answer(self, voter_id: str, answer_id: str, new_vote: int) -> int:",
    "        \"\"\"",
    "        Internal method to handle answer voting logic.",
    "        ",
    "        Args:",
    "            voter_id: ID of the voter",
    "            answer_id: ID of the answer",
    "            new_vote: 1 for upvote, -1 for downvote",
    "            ",
    "        Returns:",
    "            New score or -1 if invalid",
    "        \"\"\"",
    "        # Validation",
    "        if voter_id not in self._users:",
    "            return -1",
    "        if answer_id not in self._answers:",
    "            return -1",
    "        ",
    "        answer = self._answers[answer_id]",
    "        ",
    "        # Cannot vote on own answer",
    "        if answer.author_id == voter_id:",
    "            return -1",
    "        ",
    "        # Initialize vote tracking for this answer if needed",
    "        if answer_id not in self._answer_votes:",
    "            self._answer_votes[answer_id] = {}",
    "        ",
    "        votes = self._answer_votes[answer_id]",
    "        old_vote = votes.get(voter_id, 0)",
    "        ",
    "        # Update score using delta calculation",
    "        score_delta = new_vote - old_vote",
    "        answer.score += score_delta",
    "        ",
    "        # Update author reputation",
    "        author = self._users[answer.author_id]",
    "        self._update_reputation_for_vote_change(author, old_vote, new_vote)",
    "        ",
    "        # Store the new vote",
    "        votes[voter_id] = new_vote",
    "        ",
    "        return answer.score",
    "    ",
    "    def _update_reputation_for_vote_change(",
    "        self,",
    "        author: User,",
    "        old_vote: int,",
    "        new_vote: int",
    "    ) -> None:",
    "        \"\"\"",
    "        Update author's reputation when a vote changes.",
    "        ",
    "        The key insight: reverse the old vote's effect, then apply new vote's effect.",
    "        ",
    "        Args:",
    "            author: The content author whose reputation changes",
    "            old_vote: Previous vote value (0, 1, or -1)",
    "            new_vote: New vote value (1 or -1)",
    "        \"\"\"",
    "        # Reverse old vote effect",
    "        if old_vote == 1:",
    "            author.reputation -= ReputationChange.UPVOTE_RECEIVED",
    "        elif old_vote == -1:",
    "            author.reputation -= ReputationChange.DOWNVOTE_RECEIVED",
    "        ",
    "        # Apply new vote effect",
    "        if new_vote == 1:",
    "            author.reputation += ReputationChange.UPVOTE_RECEIVED",
    "        elif new_vote == -1:",
    "            author.reputation += ReputationChange.DOWNVOTE_RECEIVED",
    "    ",
    "    def accept_answer(self, question_author_id: str, answer_id: str) -> bool:",
    "        \"\"\"",
    "        Accept an answer for a question.",
    "        ",
    "        Only the question author can accept an answer. If a different answer",
    "        was previously accepted, it will be unaccepted (but reputation is not revoked).",
    "        ",
    "        Args:",
    "            question_author_id: ID of the question author",
    "            answer_id: ID of the answer to accept",
    "            ",
    "        Returns:",
    "            True if successful, False otherwise",
    "        \"\"\"",
    "        # Validate answer exists",
    "        if answer_id not in self._answers:",
    "            return False",
    "        ",
    "        answer = self._answers[answer_id]",
    "        ",
    "        # Validate question exists",
    "        if answer.question_id not in self._questions:",
    "            return False",
    "        ",
    "        question = self._questions[answer.question_id]",
    "        ",
    "        # Only question author can accept",
    "        if question.author_id != question_author_id:",
    "            return False",
    "        ",
    "        # Validate the requester exists",
    "        if question_author_id not in self._users:",
    "            return False",
    "        ",
    "        # If this answer is already accepted, nothing to do",
    "        if answer.is_accepted:",
    "            return True",
    "        ",
    "        # Unaccept previously accepted answer (if any)",
    "        if question.accepted_answer_id:",
    "            old_accepted = self._answers.get(question.accepted_answer_id)",
    "            if old_accepted:",
    "                old_accepted.is_accepted = False",
    "        ",
    "        # Accept the new answer",
    "        answer.is_accepted = True",
    "        question.accepted_answer_id = answer_id",
    "        ",
    "        # Award reputation to answer author",
    "        answer_author = self._users[answer.author_id]",
    "        answer_author.reputation += ReputationChange.ANSWER_ACCEPTED",
    "        ",
    "        return True",
    "    ",
    "    def get_user_reputation(self, user_id: str) -> int:",
    "        \"\"\"",
    "        Get the current reputation of a user.",
    "        ",
    "        Args:",
    "            user_id: ID of the user",
    "            ",
    "        Returns:",
    "            Current reputation, or -1 if user doesn't exist",
    "        \"\"\"",
    "        if user_id not in self._users:",
    "            return -1",
    "        return self._users[user_id].reputation",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the Stack Overflow API with voting system.\"\"\"",
    "    print('=' * 60)",
    "    print('Stack Overflow API - Part 2: Voting & Reputation Demo')",
    "    print('=' * 60)",
    "    ",
    "    so = StackOverflow()",
    "    ",
    "    # Create users",
    "    print('\\n--- Creating Users ---')",
    "    print(f\"Create Alice: {so.create_user('u1', 'alice')}\")",
    "    print(f\"Create Bob: {so.create_user('u2', 'bob')}\")",
    "    print(f\"Create Charlie: {so.create_user('u3', 'charlie')}\")",
    "    ",
    "    # Alice posts a question",
    "    print('\\n--- Alice Posts a Question ---')",
    "    q_result = so.post_question(",
    "        'u1', ",
    "        'How to implement a HashMap?',",
    "        'I need to understand the internals...',",
    "        ['python', 'data-structures']",
    "    )",
    "    print(f\"Question created: {q_result}\")",
    "    print(f\"Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Bob upvotes Alice's question",
    "    print('\\n--- Bob Upvotes the Question ---')",
    "    score = so.upvote_question('u2', 'q_1')",
    "    print(f\"Question score after Bob's upvote: {score}\")",
    "    print(f\"Alice's reputation after upvote: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Charlie also upvotes",
    "    print('\\n--- Charlie Also Upvotes ---')",
    "    score = so.upvote_question('u3', 'q_1')",
    "    print(f\"Question score after Charlie's upvote: {score}\")",
    "    print(f\"Alice's reputation: {so.get_user_reputation('u1')}\")",
    "    ",
    "    # Alice tries to upvote her own question (should fail)",
    "    print('\\n--- Alice Tries to Upvote Own Question ---')",
    "    result = so.upvote_question('u1', 'q_1')",
    "    print(f\"Result (should be -1): {result}\")",
    "    ",
    "    # Bob changes vote to downvote",
    "    print('\\n--- Bob Changes Vote to Downvote ---')",
    "    score = so.downvote_question('u2', 'q_1')",
    "    print(f\"Question score after Bob's downvote: {score}\")",
    "    print(f\"Alice's reputation after vote change: {so.get_user_reputation('u1')}\")",
    "    print(\"(Note: Changed from +10 to -2, net change of -12)\")",
    "    ",
    "    # Bob posts an answer",
    "    print('\\n--- Bob Posts an Answer ---')",
    "    a_result = so.post_answer(",
    "        'u2',",
    "        'q_1',",
    "        'You can use chaining or open addressing...'",
    "    )",
    "    print(f\"Answer created: {a_result}\")",
    "    ",
    "    # Alice upvotes Bob's answer",
    "    print('\\n--- Alice Upvotes Bob\\'s Answer ---')",
    "    score = so.upvote_answer('u1', 'a_1')",
    "    print(f\"Answer score: {score}\")",
    "    print(f\"Bob's reputation after upvote: {so.get_user_reputation('u2')}\")",
    "    ",
    "    # Alice accepts Bob's answer",
    "    print('\\n--- Alice Accepts Bob\\'s Answer ---')",
    "    accepted = so.accept_answer('u1', 'a_1')",
    "    print(f\"Answer accepted: {accepted}\")",
    "    print(f\"Bob's reputation after acceptance: {so.get_user_reputation('u2')}\")",
    "    ",
    "    # Final state",
    "    print('\\n--- Final Reputations ---')",
    "    print(f\"Alice (question author): {so.get_user_reputation('u1')}\")",
    "    print(f\"Bob (answer author): {so.get_user_reputation('u2')}\")",
    "    print(f\"Charlie (voter only): {so.get_user_reputation('u3')}\")",
    "    ",
    "    print('\\n--- Final Question State ---')",
    "    print(so.get_question('q_1'))",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('Demo Complete!')",
    "    print('=' * 60)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Stack Overflow API Design - Part 2: Voting and Reputation System",
    " * ",
    " * This implementation extends Part 1 with voting capabilities and reputation tracking.",
    " */",
    "public class StackOverflow {",
    "    ",
    "    // Reputation constants",
    "    private static final int UPVOTE_REPUTATION = 10;",
    "    private static final int DOWNVOTE_REPUTATION = -2;",
    "    private static final int ACCEPT_REPUTATION = 15;",
    "    ",
    "    // Inner classes for data models",
    "    static class User {",
    "        String id;",
    "        String username;",
    "        int reputation;",
    "        ",
    "        User(String id, String username) {",
    "            this.id = id;",
    "            this.username = username;",
    "            this.reputation = 0;",
    "        }",
    "        ",
    "        Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"id\", id);",
    "            map.put(\"username\", username);",
    "            map.put(\"reputation\", reputation);",
    "            return map;",
    "        }",
    "    }",
    "    ",
    "    static class Question {",
    "        String id;",
    "        String authorId;",
    "        String title;",
    "        String body;",
    "        List<String> tags;",
    "        int score;",
    "        String acceptedAnswerId;",
    "        ",
    "        Question(String id, String authorId, String title, String body, List<String> tags) {",
    "            this.id = id;",
    "            this.authorId = authorId;",
    "            this.title = title;",
    "            this.body = body;",
    "            this.tags = new ArrayList<>(tags);",
    "            this.score = 0;",
    "            this.acceptedAnswerId = null;",
    "        }",
    "        ",
    "        Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"id\", id);",
    "            map.put(\"author_id\", authorId);",
    "            map.put(\"title\", title);",
    "            map.put(\"body\", body);",
    "            map.put(\"tags\", new ArrayList<>(tags));",
    "            map.put(\"score\", score);",
    "            if (acceptedAnswerId != null) {",
    "                map.put(\"accepted_answer_id\", acceptedAnswerId);",
    "            }",
    "            return map;",
    "        }",
    "    }",
    "    ",
    "    static class Answer {",
    "        String id;",
    "        String questionId;",
    "        String authorId;",
    "        String body;",
    "        int score;",
    "        boolean isAccepted;",
    "        ",
    "        Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id;",
    "            this.questionId = questionId;",
    "            this.authorId = authorId;",
    "            this.body = body;",
    "            this.score = 0;",
    "            this.isAccepted = false;",
    "        }",
    "        ",
    "        Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"id\", id);",
    "            map.put(\"question_id\", questionId);",
    "            map.put(\"author_id\", authorId);",
    "            map.put(\"body\", body);",
    "            map.put(\"score\", score);",
    "            map.put(\"is_accepted\", isAccepted);",
    "            return map;",
    "        }",
    "    }",
    "    ",
    "    // Core data storage",
    "    private Map<String, User> users;",
    "    private Map<String, Question> questions;",
    "    private Map<String, Answer> answers;",
    "    ",
    "    // Vote tracking: item_id -> (voter_id -> vote_value)",
    "    private Map<String, Map<String, Integer>> questionVotes;",
    "    private Map<String, Map<String, Integer>> answerVotes;",
    "    ",
    "    // ID counters",
    "    private int questionCounter;",
    "    private int answerCounter;",
    "    ",
    "    public StackOverflow() {",
    "        users = new HashMap<>();",
    "        questions = new HashMap<>();",
    "        answers = new HashMap<>();",
    "        questionVotes = new HashMap<>();",
    "        answerVotes = new HashMap<>();",
    "        questionCounter = 0;",
    "        answerCounter = 0;",
    "    }",
    "    ",
    "    // ==================== PART 1: Core Methods ====================",
    "    ",
    "    public Map<String, Object> createUser(String userId, String username) {",
    "        if (users.containsKey(userId)) {",
    "            return null;",
    "        }",
    "        User user = new User(userId, username);",
    "        users.put(userId, user);",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", user.id);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> postQuestion(String authorId, String title, ",
    "                                            String body, List<String> tags) {",
    "        if (!users.containsKey(authorId)) {",
    "            return null;",
    "        }",
    "        questionCounter++;",
    "        String questionId = \"q_\" + questionCounter;",
    "        Question question = new Question(questionId, authorId, title, body, tags);",
    "        questions.put(questionId, question);",
    "        ",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", question.id);",
    "        result.put(\"score\", question.score);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> postAnswer(String authorId, String questionId, String body) {",
    "        if (!users.containsKey(authorId) || !questions.containsKey(questionId)) {",
    "            return null;",
    "        }",
    "        answerCounter++;",
    "        String answerId = \"a_\" + answerCounter;",
    "        Answer answer = new Answer(answerId, questionId, authorId, body);",
    "        answers.put(answerId, answer);",
    "        ",
    "        Map<String, Object> result = new HashMap<>();",
    "        result.put(\"id\", answer.id);",
    "        result.put(\"score\", answer.score);",
    "        return result;",
    "    }",
    "    ",
    "    public Map<String, Object> getQuestion(String questionId) {",
    "        Question q = questions.get(questionId);",
    "        return q != null ? q.toMap() : null;",
    "    }",
    "    ",
    "    // ==================== PART 2: Voting System ====================",
    "    ",
    "    /**",
    "     * Upvote a question.",
    "     * @param voterId ID of the user casting the vote",
    "     * @param questionId ID of the question to upvote",
    "     * @return New score of the question, or -1 if invalid",
    "     */",
    "    public int upvoteQuestion(String voterId, String questionId) {",
    "        return voteOnQuestion(voterId, questionId, 1);",
    "    }",
    "    ",
    "    /**",
    "     * Downvote a question.",
    "     * @param voterId ID of the user casting the vote",
    "     * @param questionId ID of the question to downvote",
    "     * @return New score of the question, or -1 if invalid",
    "     */",
    "    public int downvoteQuestion(String voterId, String questionId) {",
    "        return voteOnQuestion(voterId, questionId, -1);",
    "    }",
    "    ",
    "    private int voteOnQuestion(String voterId, String questionId, int newVote) {",
    "        // Validation",
    "        if (!users.containsKey(voterId) || !questions.containsKey(questionId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Question question = questions.get(questionId);",
    "        ",
    "        // Cannot vote on own question",
    "        if (question.authorId.equals(voterId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Initialize vote tracking if needed",
    "        questionVotes.computeIfAbsent(questionId, k -> new HashMap<>());",
    "        Map<String, Integer> votes = questionVotes.get(questionId);",
    "        ",
    "        int oldVote = votes.getOrDefault(voterId, 0);",
    "        ",
    "        // Update score using delta",
    "        int scoreDelta = newVote - oldVote;",
    "        question.score += scoreDelta;",
    "        ",
    "        // Update author reputation",
    "        User author = users.get(question.authorId);",
    "        updateReputationForVoteChange(author, oldVote, newVote);",
    "        ",
    "        // Store the new vote",
    "        votes.put(voterId, newVote);",
    "        ",
    "        return question.score;",
    "    }",
    "    ",
    "    /**",
    "     * Upvote an answer.",
    "     * @param voterId ID of the user casting the vote",
    "     * @param answerId ID of the answer to upvote",
    "     * @return New score of the answer, or -1 if invalid",
    "     */",
    "    public int upvoteAnswer(String voterId, String answerId) {",
    "        return voteOnAnswer(voterId, answerId, 1);",
    "    }",
    "    ",
    "    /**",
    "     * Downvote an answer.",
    "     * @param voterId ID of the user casting the vote",
    "     * @param answerId ID of the answer to downvote",
    "     * @return New score of the answer, or -1 if invalid",
    "     */",
    "    public int downvoteAnswer(String voterId, String answerId) {",
    "        return voteOnAnswer(voterId, answerId, -1);",
    "    }",
    "    ",
    "    private int voteOnAnswer(String voterId, String answerId, int newVote) {",
    "        // Validation",
    "        if (!users.containsKey(voterId) || !answers.containsKey(answerId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        ",
    "        // Cannot vote on own answer",
    "        if (answer.authorId.equals(voterId)) {",
    "            return -1;",
    "        }",
    "        ",
    "        // Initialize vote tracking if needed",
    "        answerVotes.computeIfAbsent(answerId, k -> new HashMap<>());",
    "        Map<String, Integer> votes = answerVotes.get(answerId);",
    "        ",
    "        int oldVote = votes.getOrDefault(voterId, 0);",
    "        ",
    "        // Update score using delta",
    "        int scoreDelta = newVote - oldVote;",
    "        answer.score += scoreDelta;",
    "        ",
    "        // Update author reputation",
    "        User author = users.get(answer.authorId);",
    "        updateReputationForVoteChange(author, oldVote, newVote);",
    "        ",
    "        // Store the new vote",
    "        votes.put(voterId, newVote);",
    "        ",
    "        return answer.score;",
    "    }",
    "    ",
    "    /**",
    "     * Update author's reputation when a vote changes.",
    "     * Key insight: reverse old vote effect, then apply new vote effect.",
    "     */",
    "    private void updateReputationForVoteChange(User author, int oldVote, int newVote) {",
    "        // Reverse old vote effect",
    "        if (oldVote == 1) {",
    "            author.reputation -= UPVOTE_REPUTATION;",
    "        } else if (oldVote == -1) {",
    "            author.reputation -= DOWNVOTE_REPUTATION;",
    "        }",
    "        ",
    "        // Apply new vote effect",
    "        if (newVote == 1) {",
    "            author.reputation += UPVOTE_REPUTATION;",
    "        } else if (newVote == -1) {",
    "            author.reputation += DOWNVOTE_REPUTATION;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Accept an answer for a question.",
    "     * Only the question author can accept an answer.",
    "     * @param questionAuthorId ID of the question author",
    "     * @param answerId ID of the answer to accept",
    "     * @return true if successful, false otherwise",
    "     */",
    "    public boolean acceptAnswer(String questionAuthorId, String answerId) {",
    "        // Validate answer exists",
    "        if (!answers.containsKey(answerId)) {",
    "            return false;",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        ",
    "        // Validate question exists",
    "        if (!questions.containsKey(answer.questionId)) {",
    "            return false;",
    "        }",
    "        ",
    "        Question question = questions.get(answer.questionId);",
    "        ",
    "        // Only question author can accept",
    "        if (!question.authorId.equals(questionAuthorId)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Validate the requester exists",
    "        if (!users.containsKey(questionAuthorId)) {",
    "            return false;",
    "        }",
    "        ",
    "        // If already accepted, nothing to do",
    "        if (answer.isAccepted) {",
    "            return true;",
    "        }",
    "        ",
    "        // Unaccept previously accepted answer (if any)",
    "        if (question.acceptedAnswerId != null) {",
    "            Answer oldAccepted = answers.get(question.acceptedAnswerId);",
    "            if (oldAccepted != null) {",
    "                oldAccepted.isAccepted = false;",
    "            }",
    "        }",
    "        ",
    "        // Accept the new answer",
    "        answer.isAccepted = true;",
    "        question.acceptedAnswerId = answerId;",
    "        ",
    "        // Award reputation to answer author",
    "        User answerAuthor = users.get(answer.authorId);",
    "        answerAuthor.reputation += ACCEPT_REPUTATION;",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Get the current reputation of a user.",
    "     * @param userId ID of the user",
    "     * @return Current reputation, or -1 if user doesn't exist",
    "     */",
    "    public int getUserReputation(String userId) {",
    "        User user = users.get(userId);",
    "        return user != null ? user.reputation : -1;",
    "    }",
    "    ",
    "    // ==================== Main Demo ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API - Part 2: Voting & Reputation Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        ",
    "        // Create users",
    "        System.out.println(\"\\n--- Creating Users ---\");",
    "        System.out.println(\"Create Alice: \" + so.createUser(\"u1\", \"alice\"));",
    "        System.out.println(\"Create Bob: \" + so.createUser(\"u2\", \"bob\"));",
    "        System.out.println(\"Create Charlie: \" + so.createUser(\"u3\", \"charlie\"));",
    "        ",
    "        // Alice posts a question",
    "        System.out.println(\"\\n--- Alice Posts a Question ---\");",
    "        Map<String, Object> qResult = so.postQuestion(",
    "            \"u1\", \"How to implement HashMap?\", \"Details...\",",
    "            Arrays.asList(\"java\", \"data-structures\"));",
    "        System.out.println(\"Question created: \" + qResult);",
    "        System.out.println(\"Alice's reputation: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        // Bob upvotes",
    "        System.out.println(\"\\n--- Bob Upvotes ---\");",
    "        int score = so.upvoteQuestion(\"u2\", \"q_1\");",
    "        System.out.println(\"Score after upvote: \" + score);",
    "        System.out.println(\"Alice's reputation: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        // Alice tries to vote on own question",
    "        System.out.println(\"\\n--- Alice Tries Self-Vote ---\");",
    "        System.out.println(\"Result: \" + so.upvoteQuestion(\"u1\", \"q_1\"));",
    "        ",
    "        // Bob changes to downvote",
    "        System.out.println(\"\\n--- Bob Changes to Downvote ---\");",
    "        score = so.downvoteQuestion(\"u2\", \"q_1\");",
    "        System.out.println(\"Score: \" + score);",
    "        System.out.println(\"Alice's reputation: \" + so.getUserReputation(\"u1\"));",
    "        ",
    "        // Bob answers, Alice accepts",
    "        System.out.println(\"\\n--- Bob Answers, Alice Accepts ---\");",
    "        so.postAnswer(\"u2\", \"q_1\", \"Use chaining...\");",
    "        so.acceptAnswer(\"u1\", \"a_1\");",
    "        System.out.println(\"Bob's reputation: \" + so.getUserReputation(\"u2\"));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-19",
      "explanation": "Imports and reputation constants defined as IntEnum (Python) or static finals (Java). This makes the reputation rules configurable and self-documenting."
    },
    {
      "lines": "21-75",
      "explanation": "Data classes (User, Question, Answer) now include score and reputation fields. Each has a to_dict() method for consistent API responses."
    },
    {
      "lines": "77-115",
      "explanation": "Class initialization now includes two new HashMaps for vote tracking: question_votes and answer_votes. These use nested dictionary structure: item_id -> {voter_id -> vote_value}."
    },
    {
      "lines": "117-175",
      "explanation": "Part 1 methods (create_user, post_question, post_answer) remain largely unchanged, but now return score field where appropriate."
    },
    {
      "lines": "177-230",
      "explanation": "The _vote_on_question internal method implements the core voting logic: validation, delta calculation, score update, reputation update, and vote storage."
    },
    {
      "lines": "232-285",
      "explanation": "Answer voting mirrors question voting with the same pattern. Code is extracted into _vote_on_answer to avoid duplication."
    },
    {
      "lines": "287-315",
      "explanation": "The _update_reputation_for_vote_change method handles the tricky reputation delta calculation - first reversing the old vote's effect, then applying the new vote's effect."
    },
    {
      "lines": "317-370",
      "explanation": "acceptAnswer validates that only the question author can accept, handles switching accepted answers, and awards the +15 reputation bonus."
    },
    {
      "lines": "372-385",
      "explanation": "getUserReputation provides O(1) lookup of cached reputation value."
    },
    {
      "lines": "387-450",
      "explanation": "Comprehensive main() demo showing all voting scenarios including vote changes and edge cases."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "upvoteQuestion": {
          "complexity": "O(1)",
          "explanation": "HashMap lookups for user, question, and vote map. All O(1) operations."
        },
        "downvoteQuestion": {
          "complexity": "O(1)",
          "explanation": "Same as upvoteQuestion - all HashMap operations."
        },
        "upvoteAnswer": {
          "complexity": "O(1)",
          "explanation": "Same pattern as question voting."
        },
        "downvoteAnswer": {
          "complexity": "O(1)",
          "explanation": "Same pattern as question voting."
        },
        "acceptAnswer": {
          "complexity": "O(1)",
          "explanation": "HashMap lookups for answer, question, and user. Setting accepted answer is O(1)."
        },
        "getUserReputation": {
          "complexity": "O(1)",
          "explanation": "Direct lookup from User object."
        }
      },
      "overall_change": "All new operations are O(1), maintaining the efficient performance from Part 1. The system can handle millions of votes without degradation."
    },
    "space": {
      "additional_space": "O(V) where V is total number of votes cast",
      "explanation": "Two new HashMaps store votes. In the worst case where every user votes on every item, this is O(U \u00d7 I) where U is users and I is items. In practice, it's proportional to actual votes cast. Reputation and score are stored as single integers per entity, adding negligible O(U + Q + A) space."
    }
  },
  "dry_run": {
    "example_input": "createUser(u1, alice), createUser(u2, bob), postQuestion(u1, Q, Body, [tag]), upvoteQuestion(u2, q_1), getUserReputation(u1)",
    "steps": [
      {
        "step": 1,
        "action": "createUser('u1', 'alice')",
        "state": "users = {'u1': User(id='u1', username='alice', reputation=0)}",
        "explanation": "Create Alice with 0 starting reputation"
      },
      {
        "step": 2,
        "action": "createUser('u2', 'bob')",
        "state": "users = {'u1': ..., 'u2': User(id='u2', username='bob', reputation=0)}",
        "explanation": "Create Bob with 0 starting reputation"
      },
      {
        "step": 3,
        "action": "postQuestion('u1', 'Q', 'Body', ['tag'])",
        "state": "questions = {'q_1': Question(id='q_1', author_id='u1', score=0)}",
        "explanation": "Alice posts question q_1 with initial score 0"
      },
      {
        "step": 4,
        "action": "upvoteQuestion('u2', 'q_1')",
        "state": "Validation: u2 exists \u2713, q_1 exists \u2713, u2 \u2260 u1 \u2713",
        "explanation": "Bob (u2) can vote on Alice's (u1) question"
      },
      {
        "step": 5,
        "action": "Calculate delta",
        "state": "old_vote = 0 (no prev), new_vote = 1, delta = 1 - 0 = 1",
        "explanation": "First time voting, so old_vote defaults to 0"
      },
      {
        "step": 6,
        "action": "Update score",
        "state": "q_1.score = 0 + 1 = 1",
        "explanation": "Question score increases by delta"
      },
      {
        "step": 7,
        "action": "Update reputation",
        "state": "Alice: undo old (0\u2192nothing), apply new (+10) \u2192 reputation = 10",
        "explanation": "No old vote to undo, just apply +10 for upvote"
      },
      {
        "step": 8,
        "action": "Store vote",
        "state": "question_votes = {'q_1': {'u2': 1}}",
        "explanation": "Record that u2 upvoted q_1"
      },
      {
        "step": 9,
        "action": "Return score = 1",
        "state": "Method returns 1",
        "explanation": "Return the new score of the question"
      },
      {
        "step": 10,
        "action": "getUserReputation('u1')",
        "state": "Return users['u1'].reputation = 10",
        "explanation": "Alice now has 10 reputation from the upvote"
      }
    ],
    "final_output": "[null, {id: u1}, {id: u2}, {id: q_1, score: 0}, 1, 10]"
  },
  "edge_cases": [
    {
      "case": "Self-voting",
      "handling": "Return -1 when voter_id equals author_id",
      "gotcha": "Easy to forget this check. Always compare author_id before processing vote."
    },
    {
      "case": "Duplicate vote (same direction)",
      "handling": "delta = new_vote - old_vote = 0, so no change to score or reputation",
      "gotcha": "The delta calculation naturally handles this - don't add special case logic."
    },
    {
      "case": "Vote change (up \u2192 down)",
      "handling": "delta = -1 - 1 = -2, reputation goes from +10 to -2 (change of -12)",
      "gotcha": "Must track previous vote value to calculate correct delta."
    },
    {
      "case": "Non-existent voter/item",
      "handling": "Return -1 immediately after validation check",
      "gotcha": "Check BOTH voter and item existence before any other logic."
    },
    {
      "case": "Accept answer for wrong question author",
      "handling": "Return false if caller is not question author",
      "gotcha": "Must verify the question author matches the caller, not just that they exist."
    },
    {
      "case": "Re-accept same answer",
      "handling": "Return true but don't add reputation again",
      "gotcha": "Check is_accepted flag before awarding reputation."
    },
    {
      "case": "Accept different answer (change accepted)",
      "handling": "Unaccept old answer, accept new one, award +15 to new answer author",
      "gotcha": "Remember to update both the old answer's is_accepted flag and the question's accepted_answer_id."
    }
  ],
  "test_cases": [
    {
      "name": "Basic upvote flow",
      "input": "createUser(u1, alice), createUser(u2, bob), postQuestion(u1, Q, B, [t]), upvoteQuestion(u2, q_1), getUserReputation(u1)",
      "expected": "score=1, reputation=10",
      "explanation": "Bob upvotes Alice's question. Score +1, Alice gets +10 reputation."
    },
    {
      "name": "Self-vote prevention",
      "input": "createUser(u1, alice), postQuestion(u1, Q, B, [t]), upvoteQuestion(u1, q_1)",
      "expected": "-1",
      "explanation": "Alice cannot upvote her own question."
    },
    {
      "name": "Vote change up to down",
      "input": "..., upvoteQuestion(u2, q_1), downvoteQuestion(u2, q_1), getUserReputation(u1)",
      "expected": "score=-1, reputation=-2",
      "explanation": "Bob changes from upvote to downvote. Score goes from 1 to -1. Alice's reputation goes from +10 to -2."
    },
    {
      "name": "Multiple voters",
      "input": "..., upvoteQuestion(u2, q_1), upvoteQuestion(u3, q_1), downvoteQuestion(u4, q_1)",
      "expected": "score=1, reputation=18",
      "explanation": "Two upvotes (+20) and one downvote (-2) = 18 reputation. Score = 1+1-1 = 1."
    },
    {
      "name": "Accept answer flow",
      "input": "..., postAnswer(u2, q_1, Body), acceptAnswer(u1, a_1), getUserReputation(u2)",
      "expected": "true, reputation=15",
      "explanation": "Alice accepts Bob's answer. Bob gets +15 reputation."
    },
    {
      "name": "Non-author cannot accept",
      "input": "..., postAnswer(u2, q_1, Body), acceptAnswer(u2, a_1)",
      "expected": "false",
      "explanation": "Bob cannot accept his own answer (he's not the question author)."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not tracking previous vote value",
      "why_wrong": "Without the previous vote, you can't calculate the correct delta when votes change. A user changing from upvote to downvote should change the score by -2, not -1.",
      "correct_approach": "Store vote value (1 or -1) in nested HashMap. When vote changes, calculate delta = new_vote - old_vote.",
      "code_example_wrong": "// Wrong: just store whether voted\nvotes.add(voterId);  // Can't tell if up or down\nquestion.score += (isUpvote ? 1 : -1);  // Doesn't handle changes",
      "code_example_correct": "// Correct: store vote value\nint oldVote = votes.getOrDefault(voterId, 0);\nint delta = newVote - oldVote;\nquestion.score += delta;\nvotes.put(voterId, newVote);"
    },
    {
      "mistake": "Forgetting to update reputation when vote changes",
      "why_wrong": "If user A upvotes then changes to downvote, the author loses the +10 AND gets -2, for a total of -12 reputation change.",
      "correct_approach": "First reverse the effect of the old vote, then apply the new vote's effect.",
      "code_example_wrong": "// Wrong: only apply new vote\nauthor.reputation += (newVote == 1 ? 10 : -2);",
      "code_example_correct": "// Correct: reverse old, apply new\nif (oldVote == 1) author.reputation -= 10;\nelse if (oldVote == -1) author.reputation += 2;\nif (newVote == 1) author.reputation += 10;\nelse if (newVote == -1) author.reputation -= 2;"
    },
    {
      "mistake": "Not validating self-voting",
      "why_wrong": "Users shouldn't be able to inflate their own scores/reputation.",
      "correct_approach": "Check if voter_id equals author_id before processing any vote.",
      "code_example_wrong": "// Wrong: no self-vote check\npublic int upvoteQuestion(String voterId, String questionId) {\n    Question q = questions.get(questionId);\n    // proceeds to vote...\n}",
      "code_example_correct": "// Correct: check self-vote\npublic int upvoteQuestion(String voterId, String questionId) {\n    Question q = questions.get(questionId);\n    if (q.authorId.equals(voterId)) return -1;\n    // proceed...\n}"
    },
    {
      "mistake": "Awarding accept reputation multiple times",
      "why_wrong": "If acceptAnswer is called multiple times on the same answer, the author shouldn't get +15 each time.",
      "correct_approach": "Check if answer is already accepted before awarding reputation.",
      "code_example_wrong": "// Wrong: always award reputation\nanswer.isAccepted = true;\nauthor.reputation += 15;",
      "code_example_correct": "// Correct: check first\nif (answer.isAccepted) return true; // Already accepted\nanswer.isAccepted = true;\nauthor.reputation += 15;"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the key challenge: tracking vote changes to calculate deltas. Draw the nested HashMap structure on the whiteboard. Walk through the reputation calculation with a concrete example (upvote \u2192 downvote). Emphasize that all operations remain O(1).",
    "what_to_mention": [
      "The delta calculation trick: new_vote - old_vote handles all cases elegantly",
      "Why we store 1/-1 instead of boolean: enables arithmetic for deltas",
      "Incremental updates vs recalculation: scalability for millions of votes",
      "Separation of concerns: voting logic is centralized in helper methods",
      "Edge case handling: self-votes, duplicate votes, vote changes"
    ],
    "time_allocation": "15-20 minutes. Spend 3-4 minutes explaining the approach, 10-12 minutes coding, 2-3 minutes testing with examples.",
    "if_stuck": [
      "Think about what happens when a user changes their vote from up to down",
      "The score change isn't just -1, it's -2 (remove +1, add -1)",
      "Similarly for reputation: undo the old vote's effect first",
      "Draw a state diagram showing before/after for vote changes"
    ]
  },
  "connection_to_next_part": "Part 3 likely introduces search functionality (by tag, keyword) or sorting (by score, date). The score field we maintain incrementally will enable efficient sorting. Consider adding indexes (tag \u2192 question list) if search becomes a requirement. The reputation system could also expand to include badges or privileges based on reputation thresholds.",
  "generated_at": "2026-01-14T15:35:54.196806",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}