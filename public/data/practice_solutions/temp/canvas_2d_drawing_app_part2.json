{
  "problem_title": "2D Canvas / Drawing Application - Part 2: Move Shape",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 adds the ability to **move existing shapes** to new positions. This requires O(1) lookup of shapes by their ID (necessitating a HashMap), while ensuring the z-ordering (layering) of shapes remains unchanged. The key insight is that moving a shape is NOT the same as deleting and recreating it - the shape's position in the z-order list must be preserved.",
    "new_requirements": [
      "Move shapes by their unique ID to new (x,y) positions",
      "For rectangles: new position is the top-left corner",
      "For circles: new position is the center",
      "Z-order must be preserved (moving doesn't bring shape to front)",
      "O(1) lookup by shape ID for efficient movement"
    ],
    "new_constraints": [
      "Shape ID must exist for move to have effect",
      "Moving doesn't affect creation order or z-ordering",
      "Position update must be in-place (same object reference)"
    ],
    "key_insight": "Use a **HashMap<String, Shape>** alongside the List for dual access: List maintains z-order, HashMap enables O(1) lookups. Update position in-place on the SAME shape object - both data structures reference the same object, so one update reflects in both!"
  },
  "visual_explanation": {
    "before_after": "```\n=== DATA STRUCTURES ===\n\nList (z-order):     [rect_1] \u2192 [rect_2] \u2192 [circle_1]\n                       \u2191          \u2191           \u2191\nHashMap:            {\"rect_1\": \u2500\u2500\u2518  \"rect_2\": \u2518   \"circle_1\": \u2518}\n                     (Same object references!)\n\n=== BEFORE moveShape(\"rect_1\", 80, 80) ===\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                     \u2502  rect_1 at (10,10)\n\u2502    \u2502 rect_1  \u2502                     \u2502  rect_2 at (25,25) - ON TOP\n\u2502    \u2502    \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2510                \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2518    \u2502                \u2502\n\u2502         \u2502 rect_2  \u2502                \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nQuery (30,30) \u2192 rect_2 (topmost at that point)\n\n=== AFTER moveShape(\"rect_1\", 80, 80) ===\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502\n\u2502         \u2502 rect_2  \u2502                \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502\n\u2502                                    \u2502\n\u2502                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502  rect_1 MOVED to (80,80)\n\u2502                      \u2502 rect_1  \u2502   \u2502  Z-order: still BEHIND rect_2!\n\u2502                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nQuery (30,30) \u2192 rect_2 (still the only shape there)\n```",
    "algorithm_flow": "```\nmoveShape(\"rect_1\", 80, 80) Execution Flow:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Step 1: HashMap Lookup                          \u2502\n\u2502                                                 \u2502\n\u2502   shapeMap.get(\"rect_1\")  \u2500\u2500\u2500\u2500\u25ba  Rectangle obj  \u2502\n\u2502                                     \u2502           \u2502\n\u2502   Time: O(1)                        \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Step 2: Update Position In-Place                \u2502\n\u2502                                                 \u2502\n\u2502   rect.x = 80                                   \u2502\n\u2502   rect.y = 80                                   \u2502\n\u2502                                                 \u2502\n\u2502   Time: O(1)                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Step 3: No List Modification Needed!            \u2502\n\u2502                                                 \u2502\n\u2502   List still: [rect_1, rect_2, circle_1]        \u2502\n\u2502               (same references, updated data)   \u2502\n\u2502                                                 \u2502\n\u2502   Z-order PRESERVED automatically               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Approach: Linear Search",
      "description": "Iterate through the shapes list to find the shape by ID, then update its position.",
      "time_complexity": "O(n) for moveShape where n = number of shapes",
      "space_complexity": "O(n) for storing shapes",
      "why_not_optimal": "With potentially hundreds of shapes and frequent move operations (like drag-and-drop), O(n) lookup becomes a bottleneck. In a real drawing app, move is called on every mouse move event during dragging - this could be hundreds of calls per second!"
    },
    {
      "name": "Optimal Approach: HashMap + List Dual Storage",
      "description": "Maintain both a List for z-order and a HashMap for O(1) ID lookup. Both reference the SAME shape objects, so updating via HashMap automatically updates what the List sees.",
      "time_complexity": "O(1) for moveShape",
      "space_complexity": "O(n) for shapes (HashMap adds O(n) for references, but objects are shared)",
      "key_insight": "By storing object REFERENCES in both data structures, we get the best of both worlds: List preserves insertion order for z-ordering, HashMap provides instant lookup. One in-place update reflects everywhere because Java/Python use reference semantics for objects!"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Dual Data Structure Pattern\n\n### Core Insight\nThis problem demonstrates a classic pattern: when you need **both ordered traversal AND fast key lookup**, use two data structures that share the same object references.\n\n### Data Structure Design\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     CANVAS STATE                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502  shapes: List<Shape>     \u2192  For Z-order traversal          \u2502\n\u2502  [ref1, ref2, ref3]         (iterate back-to-front)        \u2502\n\u2502    \u2502     \u2502     \u2502                                            \u2502\n\u2502    \u2502     \u2502     \u2502                                            \u2502\n\u2502    \u25bc     \u25bc     \u25bc                                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510       \u2190  Actual Shape Objects           \u2502\n\u2502  \u2502 R \u2502 \u2502 R \u2502 \u2502 C \u2502          (stored in heap)               \u2502\n\u2502  \u2502 1 \u2502 \u2502 2 \u2502 \u2502 1 \u2502                                          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518                                          \u2502\n\u2502    \u25b2     \u25b2     \u25b2                                            \u2502\n\u2502    \u2502     \u2502     \u2502                                            \u2502\n\u2502  shapeMap: HashMap       \u2192  For O(1) ID lookup              \u2502\n\u2502  {rect_1\u2192ref1,                                              \u2502\n\u2502   rect_2\u2192ref2,                                              \u2502\n\u2502   circle_1\u2192ref3}                                            \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n### Why This Works\n\n1. **On Create**: Add shape to List (end = topmost), add to HashMap\n2. **On GetShapeAt**: Iterate List backwards (O(n) - unavoidable)\n3. **On MoveShape**: HashMap lookup O(1), update position O(1)\n\n### The Magic of References\n\n```python\n# In memory:\nrect = Rectangle(...)  # Object lives at memory address 0x1234\n\nshapes.append(rect)    # List stores reference to 0x1234\nshapeMap[id] = rect    # HashMap stores reference to 0x1234\n\n# Later:\nshapeMap[id].move_to(80, 80)  # Updates object at 0x1234\n\n# Now shapes[0] ALSO sees the update because it points to 0x1234!\n```\n\n### Key Implementation Details\n\n1. **Shape as Abstract Base**: Use polymorphism for `containsPoint()` and `moveTo()`\n2. **Mutable Position**: Store position as instance variables, not final/immutable\n3. **Silent Failure**: If shape ID doesn't exist, `moveShape` does nothing (no exception)",
    "data_structures": [
      {
        "structure": "List<Shape>",
        "purpose": "Maintains z-order - shapes added later are 'on top' when iterating from end"
      },
      {
        "structure": "HashMap<String, Shape>",
        "purpose": "O(1) lookup by shape ID for fast move operations"
      },
      {
        "structure": "Shape (Abstract)",
        "purpose": "Polymorphic base with containsPoint() and moveTo() methods"
      },
      {
        "structure": "Rectangle/Circle (Concrete)",
        "purpose": "Implement shape-specific geometry and position storage"
      }
    ],
    "algorithm_steps": [
      "Step 1: On Canvas creation, initialize empty List and empty HashMap",
      "Step 2: On createRectangle/createCircle, create shape object, append to List, add to HashMap, return ID",
      "Step 3: On getShapeAt(x,y), iterate List from end (topmost) to start, return first shape containing point",
      "Step 4: On moveShape(id, x, y), lookup shape in HashMap O(1), call shape.moveTo(x, y) to update position",
      "Step 5: Z-order automatically preserved because List order never changes and we update the same object"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, Dict, List",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"",
    "    Abstract base class for all canvas shapes.",
    "    Provides interface for hit testing and movement.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str):",
    "        self.shape_id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains_point(self, x: int, y: int) -> bool:",
    "        \"\"\"Check if the given point is inside this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move the shape to a new position.\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"",
    "    Rectangle defined by top-left corner (x, y), width, and height.",
    "    Point containment includes boundaries (closed interval).",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, x: int, y: int, width: int, height: int):",
    "        super().__init__(shape_id)",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "    ",
    "    def contains_point(self, px: int, py: int) -> bool:",
    "        \"\"\"",
    "        Check if point (px, py) is inside or on boundary of rectangle.",
    "        Uses closed interval: x <= px <= x + width AND y <= py <= y + height",
    "        \"\"\"",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move rectangle by setting new top-left corner position.\"\"\"",
    "        self.x = new_x",
    "        self.y = new_y",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Rectangle({self.shape_id}, x={self.x}, y={self.y}, w={self.width}, h={self.height})\"",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"",
    "    Circle defined by center point (center_x, center_y) and radius.",
    "    Point containment uses Euclidean distance (includes boundary).",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, center_x: int, center_y: int, radius: int):",
    "        super().__init__(shape_id)",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "    ",
    "    def contains_point(self, px: int, py: int) -> bool:",
    "        \"\"\"",
    "        Check if point (px, py) is inside or on boundary of circle.",
    "        Uses distance formula: (px-cx)\u00b2 + (py-cy)\u00b2 <= r\u00b2",
    "        Avoids sqrt for efficiency by comparing squared distances.",
    "        \"\"\"",
    "        dx = px - self.center_x",
    "        dy = py - self.center_y",
    "        distance_squared = dx * dx + dy * dy",
    "        return distance_squared <= self.radius * self.radius",
    "    ",
    "    def move_to(self, new_x: int, new_y: int) -> None:",
    "        \"\"\"Move circle by setting new center position.\"\"\"",
    "        self.center_x = new_x",
    "        self.center_y = new_y",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Circle({self.shape_id}, center=({self.center_x},{self.center_y}), r={self.radius})\"",
    "",
    "",
    "class Canvas:",
    "    \"\"\"",
    "    2D Canvas for managing drawable shapes.",
    "    ",
    "    Features:",
    "    - Create rectangles and circles with auto-generated IDs",
    "    - Hit testing: find topmost shape at any point",
    "    - Move shapes while preserving z-order",
    "    ",
    "    Implementation:",
    "    - List maintains z-order (later additions are 'on top')",
    "    - HashMap provides O(1) lookup by shape ID",
    "    - Both reference same Shape objects for consistency",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._shapes: List[Shape] = []           # Z-order: index 0 = bottom, last = top",
    "        self._shape_map: Dict[str, Shape] = {}   # O(1) lookup by ID",
    "        self._rect_counter: int = 0              # For generating rect_1, rect_2, ...",
    "        self._circle_counter: int = 0            # For generating circle_1, circle_2, ...",
    "    ",
    "    def create_rectangle(self, x: int, y: int, width: int, height: int) -> str:",
    "        \"\"\"",
    "        Create a rectangle and add it to the canvas.",
    "        ",
    "        Args:",
    "            x: X coordinate of top-left corner",
    "            y: Y coordinate of top-left corner",
    "            width: Width of rectangle",
    "            height: Height of rectangle",
    "        ",
    "        Returns:",
    "            Auto-generated shape ID (e.g., 'rect_1', 'rect_2')",
    "        \"\"\"",
    "        self._rect_counter += 1",
    "        shape_id = f\"rect_{self._rect_counter}\"",
    "        ",
    "        rect = Rectangle(shape_id, x, y, width, height)",
    "        self._shapes.append(rect)          # Add to end = topmost z-order",
    "        self._shape_map[shape_id] = rect   # Enable O(1) lookup",
    "        ",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, radius: int) -> str:",
    "        \"\"\"",
    "        Create a circle and add it to the canvas.",
    "        ",
    "        Args:",
    "            center_x: X coordinate of center",
    "            center_y: Y coordinate of center",
    "            radius: Radius of circle",
    "        ",
    "        Returns:",
    "            Auto-generated shape ID (e.g., 'circle_1', 'circle_2')",
    "        \"\"\"",
    "        self._circle_counter += 1",
    "        shape_id = f\"circle_{self._circle_counter}\"",
    "        ",
    "        circle = Circle(shape_id, center_x, center_y, radius)",
    "        self._shapes.append(circle)        # Add to end = topmost z-order",
    "        self._shape_map[shape_id] = circle # Enable O(1) lookup",
    "        ",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"",
    "        Find the topmost shape containing the given point.",
    "        ",
    "        Shapes are checked from top to bottom (reverse list order).",
    "        First shape that contains the point wins.",
    "        ",
    "        Args:",
    "            x: X coordinate to query",
    "            y: Y coordinate to query",
    "        ",
    "        Returns:",
    "            Shape ID of topmost shape at point, or None if no shape found",
    "        \"\"\"",
    "        # Iterate from end (topmost) to beginning (bottommost)",
    "        for shape in reversed(self._shapes):",
    "            if shape.contains_point(x, y):",
    "                return shape.shape_id",
    "        return None",
    "    ",
    "    def move_shape(self, shape_id: str, new_x: int, new_y: int) -> None:",
    "        \"\"\"",
    "        Move a shape to a new position.",
    "        ",
    "        Position semantics:",
    "        - Rectangle: (new_x, new_y) becomes new top-left corner",
    "        - Circle: (new_x, new_y) becomes new center",
    "        ",
    "        Z-order is preserved - moving does NOT bring shape to front.",
    "        If shape_id doesn't exist, this is a no-op.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to move",
    "            new_x: New X position",
    "            new_y: New Y position",
    "        \"\"\"",
    "        shape = self._shape_map.get(shape_id)",
    "        if shape is not None:",
    "            shape.move_to(new_x, new_y)",
    "",
    "",
    "# ============== DEMONSTRATION ==============",
    "",
    "def main():",
    "    \"\"\"Demonstrate canvas functionality with Part 2 features.\"\"\"",
    "    print(\"=\"*60)",
    "    print(\"2D Canvas Drawing Application - Part 2 Demo\")",
    "    print(\"=\"*60)",
    "    ",
    "    # Example 1: Basic move functionality",
    "    print(\"\\n--- Example 1: Basic Move ---\")",
    "    canvas = Canvas()",
    "    ",
    "    r1 = canvas.create_rectangle(0, 0, 50, 50)",
    "    print(f\"Created: {r1} at (0,0) size 50x50\")",
    "    ",
    "    r2 = canvas.create_rectangle(25, 25, 50, 50)",
    "    print(f\"Created: {r2} at (25,25) size 50x50 [ON TOP]\")",
    "    ",
    "    # Query overlapping region",
    "    result = canvas.get_shape_at(30, 30)",
    "    print(f\"\\nget_shape_at(30, 30) = {result}  [Expected: rect_2 - topmost]\")",
    "    ",
    "    # Move rect_1 away",
    "    print(f\"\\nMoving {r1} to (100, 100)...\")",
    "    canvas.move_shape(r1, 100, 100)",
    "    ",
    "    # Query again",
    "    result = canvas.get_shape_at(30, 30)",
    "    print(f\"get_shape_at(30, 30) = {result}  [Expected: rect_2 - only shape there now]\")",
    "    ",
    "    # Example 2: Z-order preservation",
    "    print(\"\\n--- Example 2: Z-Order Preservation ---\")",
    "    canvas2 = Canvas()",
    "    ",
    "    r1 = canvas2.create_rectangle(0, 0, 40, 40)",
    "    print(f\"Created: {r1} at (0,0) [BOTTOM]\")",
    "    ",
    "    c1 = canvas2.create_circle(100, 100, 20)",
    "    print(f\"Created: {c1} at center (100,100) [TOP]\")",
    "    ",
    "    # Move circle to overlap with rectangle",
    "    print(f\"\\nMoving {c1} to center (20, 20)...\")",
    "    canvas2.move_shape(c1, 20, 20)",
    "    ",
    "    # Query overlapping point",
    "    result = canvas2.get_shape_at(20, 20)",
    "    print(f\"get_shape_at(20, 20) = {result}  [Expected: circle_1 - still on top despite move]\")",
    "    ",
    "    # Example 3: Moving non-existent shape",
    "    print(\"\\n--- Example 3: Edge Case - Non-existent Shape ---\")",
    "    print(\"Attempting to move 'fake_shape'...\")",
    "    canvas2.move_shape(\"fake_shape\", 50, 50)  # Should do nothing",
    "    print(\"No error - silently ignored as expected\")",
    "    ",
    "    print(\"\\n\" + \"=\"*60)",
    "    print(\"All demonstrations completed successfully!\")",
    "    print(\"=\"*60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Abstract base class for all canvas shapes.",
    " * Provides interface for hit testing and position updates.",
    " */",
    "abstract class Shape {",
    "    protected String shapeId;",
    "    ",
    "    public Shape(String shapeId) {",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    public String getShapeId() {",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Check if the given point is inside this shape.",
    "     * @param x X coordinate of point",
    "     * @param y Y coordinate of point",
    "     * @return true if point is inside shape (including boundary)",
    "     */",
    "    public abstract boolean containsPoint(int x, int y);",
    "    ",
    "    /**",
    "     * Move the shape to a new position.",
    "     * @param newX New X coordinate",
    "     * @param newY New Y coordinate",
    "     */",
    "    public abstract void moveTo(int newX, int newY);",
    "}",
    "",
    "/**",
    " * Rectangle shape defined by top-left corner and dimensions.",
    " */",
    "class Rectangle extends Shape {",
    "    private int x, y, width, height;",
    "    ",
    "    public Rectangle(String shapeId, int x, int y, int width, int height) {",
    "        super(shapeId);",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(int px, int py) {",
    "        // Closed interval check: includes boundary",
    "        return px >= x && px <= x + width && py >= y && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        // Update top-left corner position",
    "        this.x = newX;",
    "        this.y = newY;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Rectangle(%s, x=%d, y=%d, w=%d, h=%d)\", ",
    "                            shapeId, x, y, width, height);",
    "    }",
    "}",
    "",
    "/**",
    " * Circle shape defined by center point and radius.",
    " */",
    "class Circle extends Shape {",
    "    private int centerX, centerY, radius;",
    "    ",
    "    public Circle(String shapeId, int centerX, int centerY, int radius) {",
    "        super(shapeId);",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(int px, int py) {",
    "        // Use squared distance to avoid sqrt computation",
    "        // Use long to prevent integer overflow for large coordinates",
    "        long dx = px - centerX;",
    "        long dy = py - centerY;",
    "        long distanceSquared = dx * dx + dy * dy;",
    "        long radiusSquared = (long) radius * radius;",
    "        return distanceSquared <= radiusSquared;",
    "    }",
    "    ",
    "    @Override",
    "    public void moveTo(int newX, int newY) {",
    "        // Update center position",
    "        this.centerX = newX;",
    "        this.centerY = newY;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Circle(%s, center=(%d,%d), r=%d)\", ",
    "                            shapeId, centerX, centerY, radius);",
    "    }",
    "}",
    "",
    "/**",
    " * 2D Canvas for managing drawable shapes.",
    " * ",
    " * Features:",
    " * - Create rectangles and circles with auto-generated IDs",
    " * - Hit testing: find topmost shape at any point",
    " * - Move shapes while preserving z-order",
    " * ",
    " * Implementation:",
    " * - List maintains z-order (later additions are 'on top')",
    " * - HashMap provides O(1) lookup by shape ID",
    " * - Both reference same Shape objects for consistency",
    " */",
    "public class Canvas {",
    "    private List<Shape> shapes;              // Z-order: index 0 = bottom, last = top",
    "    private Map<String, Shape> shapeMap;     // O(1) lookup by ID",
    "    private int rectCounter;                  // For generating rect_1, rect_2, ...",
    "    private int circleCounter;                // For generating circle_1, circle_2, ...",
    "    ",
    "    public Canvas() {",
    "        shapes = new ArrayList<>();",
    "        shapeMap = new HashMap<>();",
    "        rectCounter = 0;",
    "        circleCounter = 0;",
    "    }",
    "    ",
    "    /**",
    "     * Create a rectangle and add it to the canvas.",
    "     * @param x X coordinate of top-left corner",
    "     * @param y Y coordinate of top-left corner",
    "     * @param width Width of rectangle",
    "     * @param height Height of rectangle",
    "     * @return Auto-generated shape ID (e.g., \"rect_1\", \"rect_2\")",
    "     */",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        rectCounter++;",
    "        String shapeId = \"rect_\" + rectCounter;",
    "        ",
    "        Rectangle rect = new Rectangle(shapeId, x, y, width, height);",
    "        shapes.add(rect);           // Add to end = topmost z-order",
    "        shapeMap.put(shapeId, rect); // Enable O(1) lookup",
    "        ",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Create a circle and add it to the canvas.",
    "     * @param centerX X coordinate of center",
    "     * @param centerY Y coordinate of center",
    "     * @param radius Radius of circle",
    "     * @return Auto-generated shape ID (e.g., \"circle_1\", \"circle_2\")",
    "     */",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        circleCounter++;",
    "        String shapeId = \"circle_\" + circleCounter;",
    "        ",
    "        Circle circle = new Circle(shapeId, centerX, centerY, radius);",
    "        shapes.add(circle);           // Add to end = topmost z-order",
    "        shapeMap.put(shapeId, circle); // Enable O(1) lookup",
    "        ",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Find the topmost shape containing the given point.",
    "     * Shapes are checked from top to bottom (reverse list order).",
    "     * @param x X coordinate to query",
    "     * @param y Y coordinate to query",
    "     * @return Shape ID of topmost shape at point, or null if none found",
    "     */",
    "    public String getShapeAt(int x, int y) {",
    "        // Iterate from end (topmost) to beginning (bottommost)",
    "        for (int i = shapes.size() - 1; i >= 0; i--) {",
    "            Shape shape = shapes.get(i);",
    "            if (shape.containsPoint(x, y)) {",
    "                return shape.getShapeId();",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    /**",
    "     * Move a shape to a new position.",
    "     * ",
    "     * Position semantics:",
    "     * - Rectangle: (newX, newY) becomes new top-left corner",
    "     * - Circle: (newX, newY) becomes new center",
    "     * ",
    "     * Z-order is preserved - moving does NOT bring shape to front.",
    "     * If shapeId doesn't exist, this is a no-op.",
    "     * ",
    "     * @param shapeId ID of shape to move",
    "     * @param newX New X position",
    "     * @param newY New Y position",
    "     */",
    "    public void moveShape(String shapeId, int newX, int newY) {",
    "        Shape shape = shapeMap.get(shapeId);",
    "        if (shape != null) {",
    "            shape.moveTo(newX, newY);",
    "        }",
    "    }",
    "    ",
    "    // ============== DEMONSTRATION ==============",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"2D Canvas Drawing Application - Part 2 Demo\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Example 1: Basic move functionality",
    "        System.out.println(\"\\n--- Example 1: Basic Move ---\");",
    "        Canvas canvas = new Canvas();",
    "        ",
    "        String r1 = canvas.createRectangle(0, 0, 50, 50);",
    "        System.out.println(\"Created: \" + r1 + \" at (0,0) size 50x50\");",
    "        ",
    "        String r2 = canvas.createRectangle(25, 25, 50, 50);",
    "        System.out.println(\"Created: \" + r2 + \" at (25,25) size 50x50 [ON TOP]\");",
    "        ",
    "        // Query overlapping region",
    "        String result = canvas.getShapeAt(30, 30);",
    "        System.out.println(\"\\ngetShapeAt(30, 30) = \" + result + \"  [Expected: rect_2 - topmost]\");",
    "        ",
    "        // Move rect_1 away",
    "        System.out.println(\"\\nMoving \" + r1 + \" to (100, 100)...\");",
    "        canvas.moveShape(r1, 100, 100);",
    "        ",
    "        // Query again",
    "        result = canvas.getShapeAt(30, 30);",
    "        System.out.println(\"getShapeAt(30, 30) = \" + result + \"  [Expected: rect_2]\");",
    "        ",
    "        // Example 2: Z-order preservation",
    "        System.out.println(\"\\n--- Example 2: Z-Order Preservation ---\");",
    "        Canvas canvas2 = new Canvas();",
    "        ",
    "        r1 = canvas2.createRectangle(0, 0, 40, 40);",
    "        System.out.println(\"Created: \" + r1 + \" at (0,0) [BOTTOM]\");",
    "        ",
    "        String c1 = canvas2.createCircle(100, 100, 20);",
    "        System.out.println(\"Created: \" + c1 + \" at center (100,100) [TOP]\");",
    "        ",
    "        // Move circle to overlap with rectangle",
    "        System.out.println(\"\\nMoving \" + c1 + \" to center (20, 20)...\");",
    "        canvas2.moveShape(c1, 20, 20);",
    "        ",
    "        // Query overlapping point",
    "        result = canvas2.getShapeAt(20, 20);",
    "        System.out.println(\"getShapeAt(20, 20) = \" + result + \"  [Expected: circle_1 - on top]\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All demonstrations completed successfully!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-22",
      "explanation": "**Shape Abstract Base Class**: Defines the contract all shapes must follow. The `shape_id` is stored, and subclasses must implement `contains_point()` and `move_to()`. This enables polymorphic handling in Canvas."
    },
    {
      "lines": "24-52",
      "explanation": "**Rectangle Class**: Implements shape-specific logic. Position stored as mutable `x, y` fields. `contains_point()` uses closed interval check (inclusive boundaries). `move_to()` simply updates x and y - the key insight is this same object is referenced by both List and HashMap."
    },
    {
      "lines": "54-82",
      "explanation": "**Circle Class**: Uses center-based positioning. `contains_point()` computes squared distance to avoid expensive sqrt operation. Move updates center coordinates. Same reference-sharing pattern as Rectangle."
    },
    {
      "lines": "84-110",
      "explanation": "**Canvas Initialization**: Creates BOTH data structures - `_shapes` List for z-order and `_shape_map` HashMap for O(1) lookup. Separate counters for rect and circle IDs ensures unique, predictable naming."
    },
    {
      "lines": "112-145",
      "explanation": "**createRectangle/createCircle**: Generate ID, create shape object, add to BOTH data structures. Critical: same object reference goes to both List and HashMap. This is what enables efficient move operations."
    },
    {
      "lines": "147-162",
      "explanation": "**getShapeAt**: Iterates shapes in REVERSE order (using `reversed()`) to check topmost first. Returns immediately on first hit. O(n) complexity is unavoidable here as we must check containment."
    },
    {
      "lines": "164-182",
      "explanation": "**moveShape (THE NEW METHOD)**: HashMap lookup is O(1). If shape exists, call polymorphic `move_to()`. The shape object is updated IN PLACE - since List holds the same reference, z-order is automatically preserved without touching the List!"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "moveShape": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup O(1) + position update O(1) = O(1) total. This is the key improvement over naive O(n) linear search."
        }
      },
      "existing_methods": {
        "createRectangle": {
          "complexity": "O(1)",
          "explanation": "List append O(1) amortized + HashMap put O(1)"
        },
        "createCircle": {
          "complexity": "O(1)",
          "explanation": "Same as createRectangle"
        },
        "getShapeAt": {
          "complexity": "O(n)",
          "explanation": "Must check each shape in worst case. Cannot be improved without spatial indexing (e.g., quadtree)."
        }
      },
      "overall_change": "Part 2 adds O(1) moveShape capability without degrading any existing operations."
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "HashMap stores n references (one per shape). Note: these are REFERENCES to existing Shape objects, not copies. Total space is still O(n) for all shapes, with HashMap adding O(n) pointer overhead."
    }
  },
  "dry_run": {
    "example_input": "Example 2: createRectangle(0,0,40,40) \u2192 createCircle(100,100,20) \u2192 moveShape('circle_1',20,20) \u2192 getShapeAt(20,20)",
    "steps": [
      {
        "step": 1,
        "action": "Canvas()",
        "state": "shapes=[], shapeMap={}, rectCounter=0, circleCounter=0",
        "explanation": "Initialize empty canvas"
      },
      {
        "step": 2,
        "action": "createRectangle(0, 0, 40, 40)",
        "state": "shapes=[Rectangle@0x1], shapeMap={'rect_1':Rectangle@0x1}, rectCounter=1",
        "explanation": "Create rect_1 at (0,0) with size 40x40. Both List and HashMap point to SAME object."
      },
      {
        "step": 3,
        "action": "createCircle(100, 100, 20)",
        "state": "shapes=[Rectangle@0x1, Circle@0x2], shapeMap={'rect_1':Rectangle@0x1, 'circle_1':Circle@0x2}",
        "explanation": "Create circle_1 at center (100,100) with radius 20. Added to END of list = topmost z-order."
      },
      {
        "step": 4,
        "action": "moveShape('circle_1', 20, 20)",
        "state": "Circle@0x2 now has centerX=20, centerY=20 (was 100,100)",
        "explanation": "HashMap lookup finds Circle@0x2 in O(1). Call moveTo(20,20) updates center IN PLACE. List order UNCHANGED - still [rect, circle]."
      },
      {
        "step": 5,
        "action": "getShapeAt(20, 20)",
        "state": "Checking Circle@0x2 first (end of list)",
        "explanation": "Iterate from end. Circle contains (20,20)? Distance from (20,20) to center (20,20) = 0 \u2264 20. YES! Return 'circle_1' immediately."
      }
    ],
    "final_output": "'circle_1' - The circle is ON TOP (created after rect) and now contains point (20,20) after being moved."
  },
  "edge_cases": [
    {
      "case": "Move non-existent shape ID",
      "handling": "shapeMap.get() returns None/null, method returns without action",
      "gotcha": "Don't throw exception - silent no-op is expected behavior per problem spec"
    },
    {
      "case": "Move shape to same position",
      "handling": "Works fine - just sets position to same values",
      "gotcha": "No need to check if position changed - simple assignment is efficient"
    },
    {
      "case": "Move shape to negative coordinates",
      "handling": "Allowed - coordinates can be negative (shape partially off-canvas)",
      "gotcha": "Don't add bounds checking unless specified"
    },
    {
      "case": "Move shape that creates new overlap",
      "handling": "Z-order determined by creation order, not move order",
      "gotcha": "Moving rect_1 onto rect_2 doesn't bring rect_1 to front - rect_2 still on top if created later"
    },
    {
      "case": "Query point after shape moved away",
      "handling": "Point now returns different shape or null",
      "gotcha": "Hit testing always uses CURRENT position, not original"
    }
  ],
  "test_cases": [
    {
      "name": "Basic move - shape moves correctly",
      "input": "createRectangle(0,0,10,10) \u2192 moveShape('rect_1',50,50) \u2192 getShapeAt(5,5) \u2192 getShapeAt(55,55)",
      "expected": "[rect_1, null, null, rect_1]",
      "explanation": "After move, old position is empty, new position contains shape"
    },
    {
      "name": "Z-order preserved after move",
      "input": "createRectangle(0,0,50,50) \u2192 createRectangle(0,0,50,50) \u2192 moveShape('rect_1',0,0) \u2192 getShapeAt(25,25)",
      "expected": "[rect_1, rect_2, null, rect_2]",
      "explanation": "Even though rect_1 was moved (to same spot), rect_2 is still on top"
    },
    {
      "name": "Move circle preserves center semantics",
      "input": "createCircle(0,0,10) \u2192 moveShape('circle_1',50,50) \u2192 getShapeAt(55,55)",
      "expected": "[circle_1, null, circle_1]",
      "explanation": "(55,55) is within radius 10 of new center (50,50)"
    },
    {
      "name": "Move non-existent shape",
      "input": "createRectangle(0,0,10,10) \u2192 moveShape('fake_id',100,100) \u2192 getShapeAt(5,5)",
      "expected": "[rect_1, null, rect_1]",
      "explanation": "Moving fake_id has no effect, rect_1 unchanged"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using linear search instead of HashMap for moveShape",
      "why_wrong": "O(n) lookup on every move is too slow for real-time dragging scenarios",
      "correct_approach": "Store reference in HashMap at creation time, use HashMap.get() for O(1) lookup",
      "code_example_wrong": "def move_shape(self, shape_id, x, y):\n    for shape in self._shapes:\n        if shape.shape_id == shape_id:  # O(n) search!\n            shape.move_to(x, y)",
      "code_example_correct": "def move_shape(self, shape_id, x, y):\n    shape = self._shape_map.get(shape_id)  # O(1) lookup\n    if shape:\n        shape.move_to(x, y)"
    },
    {
      "mistake": "Recreating shape instead of updating position",
      "why_wrong": "Creating new shape loses z-order position, new shape goes to top",
      "correct_approach": "Update position IN PLACE on existing shape object",
      "code_example_wrong": "def move_shape(self, shape_id, x, y):\n    shape = self._shape_map[shape_id]\n    new_shape = Rectangle(shape_id, x, y, ...)  # WRONG: new object!\n    # Lost z-order, shape goes to end of list",
      "code_example_correct": "def move_shape(self, shape_id, x, y):\n    shape = self._shape_map.get(shape_id)\n    if shape:\n        shape.move_to(x, y)  # Same object, updated position"
    },
    {
      "mistake": "Changing list order on move (removing and re-adding)",
      "why_wrong": "Moving shape would incorrectly bring it to front",
      "correct_approach": "Never modify list on move - only update shape's position fields",
      "code_example_wrong": "def move_shape(self, shape_id, x, y):\n    shape = self._shape_map[shape_id]\n    self._shapes.remove(shape)  # WRONG!\n    shape.move_to(x, y)\n    self._shapes.append(shape)  # Now shape is on top!",
      "code_example_correct": "def move_shape(self, shape_id, x, y):\n    shape = self._shape_map.get(shape_id)\n    if shape:\n        shape.move_to(x, y)  # List unchanged, z-order preserved"
    },
    {
      "mistake": "Using separate HashMap for position tracking",
      "why_wrong": "Duplicates data, risks inconsistency between List and HashMap",
      "correct_approach": "Store object reference in HashMap - position lives in object itself",
      "code_example_wrong": "self._positions = {}  # {'rect_1': (10, 20), ...}\ndef move_shape(self, shape_id, x, y):\n    self._positions[shape_id] = (x, y)  # HashMap out of sync with Shape!",
      "code_example_correct": "# Position stored IN the Shape object\ndef move_shape(self, shape_id, x, y):\n    self._shape_map[shape_id].move_to(x, y)  # Single source of truth"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by acknowledging the new requirement: 'Part 2 adds moveShape, which needs O(1) lookup. I'll add a HashMap alongside the List to enable this.' Then explain the reference-sharing insight: 'Both data structures point to the SAME shape objects, so updating via HashMap automatically updates what the List sees - no synchronization needed!'",
    "what_to_mention": [
      "Explicitly state why you need HashMap: 'O(1) lookup by ID for efficient move operations'",
      "Explain reference semantics: 'Both List and HashMap store references to same objects'",
      "Highlight z-order preservation: 'Moving updates position, not list order'",
      "Note the polymorphism: 'moveTo() is abstract - Rectangle and Circle implement differently'",
      "Mention time complexity improvement: 'moveShape is now O(1) instead of O(n)'"
    ],
    "time_allocation": "5 minutes to explain HashMap addition, 5 minutes to implement moveShape, 5 minutes to test and discuss edge cases",
    "if_stuck": [
      "Think about what data structures support O(1) lookup by key",
      "Consider: if both List and HashMap point to same object, what happens when you modify the object?",
      "Remember: z-order comes from LIST position, not from anything else",
      "Ask yourself: what's the minimal change to Part 1 solution that enables efficient move?"
    ]
  },
  "connection_to_next_part": "Part 3 will likely add **deleteShape** or **bringToFront/sendToBack** operations. With HashMap already in place, deleteShape needs O(n) list removal (or use LinkedHashMap in Java / OrderedDict pattern). For z-order manipulation, consider storing explicit z-index values or using a data structure that supports efficient reordering. The dual HashMap + List pattern established here provides the foundation for these extensions.",
  "generated_at": "2026-01-14T15:24:49.856223",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}