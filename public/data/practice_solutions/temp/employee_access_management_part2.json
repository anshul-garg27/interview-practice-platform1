{
  "problem_title": "Employee Access Management System - Part 2: Role-Based Access Control (Groups)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 introduces group-based access inheritance. Employees can now belong to multiple groups, and groups can have their own access permissions to resources. An employee's effective access becomes the union of their direct access and all inherited access from their groups. This mirrors real-world RBAC systems like AWS IAM, Okta, and Active Directory.",
    "new_requirements": [
      "Support employee membership in multiple groups",
      "Groups can have access to resources (like employees)",
      "Effective access = direct access \u222a inherited group access",
      "Revoking from an employee does NOT affect group access",
      "Must compute effective access at query time for correctness"
    ],
    "new_constraints": [
      "Groups are identified by string IDs (like employees)",
      "No hierarchical groups (groups cannot contain other groups)",
      "Access types remain the same: READ, WRITE, ADMIN"
    ],
    "key_insight": "Compute inheritance at QUERY TIME, not at GRANT TIME. This avoids complex cache invalidation when group membership or group access changes. The trade-off is O(g) query time where g is number of groups, but this is typically small and worth the simplicity."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    BEFORE: Part 1 Model                          \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                  \u2551\n\u2551  Employee E1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> Resource R1 \u2500\u2500\u2500\u2500> {READ, WRITE}       \u2551\n\u2551                                                                  \u2551\n\u2551  (Direct access only, no inheritance)                            \u2551\n\u2551                                                                  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    AFTER: Part 2 Model                           \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                  \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                              \u2551\n\u2551   \u2502 Group G1\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500>\u2502   R1    \u2502\u2500\u2500\u2500\u2500> {READ, ADMIN}           \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                              \u2551\n\u2551        \u2502                     \u2502                                   \u2551\n\u2551   member                     \u2502                                   \u2551\n\u2551        \u2502                     \u2502                                   \u2551\n\u2551        \u25bc                     \u25bc                                   \u2551\n\u2551   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           direct access                            \u2551\n\u2551   \u2502   E1    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500> {WRITE}                   \u2551\n\u2551   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                    \u2551\n\u2551                                                                  \u2551\n\u2551   Effective(E1, R1) = {READ, ADMIN} \u222a {WRITE}                    \u2551\n\u2551                     = {READ, WRITE, ADMIN}                       \u2551\n\u2551                                                                  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           getEffectiveAccess(E1, R1) Algorithm Flow               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                   \u2502\n\u2502  Step 1: Initialize empty Set for effective_access               \u2502\n\u2502          effective_access = {}                                    \u2502\n\u2502                                                                   \u2502\n\u2502  Step 2: Add direct access                                        \u2502\n\u2502          employee_access[E1][R1] = {WRITE}                       \u2502\n\u2502          effective_access = {WRITE}                               \u2502\n\u2502                                                                   \u2502\n\u2502  Step 3: Get employee's groups                                    \u2502\n\u2502          employee_groups[E1] = {G1, G2}                          \u2502\n\u2502                                                                   \u2502\n\u2502  Step 4: For each group, union their access                       \u2502\n\u2502          \u2502                                                        \u2502\n\u2502          \u251c\u2500> G1: group_access[G1][R1] = {READ}                   \u2502\n\u2502          \u2502       effective_access = {WRITE, READ}                 \u2502\n\u2502          \u2502                                                        \u2502\n\u2502          \u2514\u2500> G2: group_access[G2][R1] = {ADMIN}                  \u2502\n\u2502                  effective_access = {WRITE, READ, ADMIN}          \u2502\n\u2502                                                                   \u2502\n\u2502  Step 5: Return sorted list                                       \u2502\n\u2502          return [\"ADMIN\", \"READ\", \"WRITE\"]                       \u2502\n\u2502                                                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Eager Denormalization (Naive Extension)",
      "description": "When granting group access or adding employee to group, immediately update a cached 'effective access' for all affected employees. This precomputes inheritance.",
      "time_complexity": "O(1) for queries, O(m) for updates where m = group members",
      "space_complexity": "O(e * r) where e = employees, r = resources",
      "why_not_optimal": "Complex cache invalidation logic. When group access changes, must update ALL members. When employee leaves group, must recompute from scratch. Race conditions in concurrent systems. Memory overhead from storing derived data."
    },
    {
      "name": "Lazy Computation at Query Time (Optimal)",
      "description": "Store group access and membership separately. Compute effective access on each query by taking union of direct access and all group access.",
      "time_complexity": "O(g) for getEffectiveAccess where g = number of groups employee belongs to",
      "space_complexity": "O(g * r + e * r) for group and employee access storage",
      "key_insight": "In most RBAC systems, users belong to few groups (typically <10), so O(g) is effectively O(1). Lazy evaluation eliminates complex invalidation logic and is simpler to reason about for correctness."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Lazy Inheritance Computation\n\n### Core Insight\nWe store **three separate concerns**:\n1. **Direct employee access** (from Part 1)\n2. **Group access** (new - mirrors employee access structure)\n3. **Group membership** (new - maps employees to their groups)\n\n### Why Query-Time Computation?\n\n**The key insight** is that computing inheritance at query time is both **simpler** and **correct**:\n\n1. **No Cache Invalidation**: When group access changes, we don't need to update any employee records\n2. **No Consistency Issues**: The effective access is always computed fresh from source-of-truth data\n3. **Acceptable Performance**: Employees typically belong to **O(1) to O(10) groups**, making query time effectively constant\n\n### Data Structure Design\n\n```\n_employee_access:    employeeId \u2192 resourceId \u2192 Set<AccessType>\n_group_access:       groupId \u2192 resourceId \u2192 Set<AccessType>  \n_employee_groups:    employeeId \u2192 Set<groupId>\n_group_members:      groupId \u2192 Set<employeeId>  (optional, for reverse lookup)\n```\n\n### Set Union for Effective Access\n\nThe mathematical model is clean:\n```\nEffective(E, R) = Direct(E, R) \u222a \u22c3{Group(G, R) | G \u2208 Groups(E)}\n```\n\nThis translates directly to code using Python's `set.update()` or Java's `addAll()`.",
    "data_structures": [
      {
        "structure": "HashMap<String, HashMap<String, Set<AccessType>>>",
        "purpose": "Store direct employee access (employeeId \u2192 resourceId \u2192 access types)"
      },
      {
        "structure": "HashMap<String, HashMap<String, Set<AccessType>>>",
        "purpose": "Store group access (groupId \u2192 resourceId \u2192 access types)"
      },
      {
        "structure": "HashMap<String, Set<String>>",
        "purpose": "Store employee-to-groups membership (employeeId \u2192 set of groupIds)"
      },
      {
        "structure": "HashMap<String, Set<String>>",
        "purpose": "Store group-to-employees reverse mapping (optional, for efficient group queries)"
      }
    ],
    "algorithm_steps": [
      "Step 1: Initialize data structures - nested HashMaps for access, simple HashMaps for membership",
      "Step 2: grant_access/grant_group_access - Add access type to appropriate nested map",
      "Step 3: revoke_access/revoke_group_access - Remove access type (or all types) from map",
      "Step 4: add_employee_to_group - Add groupId to employee's group set, add employeeId to group's member set",
      "Step 5: remove_employee_from_group - Remove from both sets",
      "Step 6: get_effective_access - Start with direct access set, iterate through employee's groups adding each group's access for that resource",
      "Step 7: get_effective_resources - Union of employee's direct resources and all resources from all groups"
    ]
  },
  "solution_python_lines": [
    "from enum import Enum",
    "from typing import Dict, List, Set, Optional",
    "from collections import defaultdict",
    "",
    "",
    "class AccessType(Enum):",
    "    \"\"\"Enumeration of access permission types.\"\"\"",
    "    READ = \"READ\"",
    "    WRITE = \"WRITE\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "class AccessManager:",
    "    \"\"\"",
    "    Role-Based Access Control System with Group Support.",
    "    ",
    "    This system supports:",
    "    - Direct employee access to resources (Part 1)",
    "    - Group-based access inheritance (Part 2)",
    "    - Employees can belong to multiple groups",
    "    - Effective access = direct access \u222a inherited group access",
    "    ",
    "    Design Decision: Lazy evaluation of inheritance at query time",
    "    to avoid complex cache invalidation.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize the access management system.\"\"\"",
    "        # Part 1: Direct employee access",
    "        # Structure: employeeId -> resourceId -> Set[AccessType]",
    "        self._employee_access: Dict[str, Dict[str, Set[AccessType]]] = \\",
    "            defaultdict(lambda: defaultdict(set))",
    "        ",
    "        # Part 2: Group access (mirrors employee access structure)",
    "        # Structure: groupId -> resourceId -> Set[AccessType]",
    "        self._group_access: Dict[str, Dict[str, Set[AccessType]]] = \\",
    "            defaultdict(lambda: defaultdict(set))",
    "        ",
    "        # Part 2: Employee-to-groups membership",
    "        # Structure: employeeId -> Set[groupId]",
    "        self._employee_groups: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Part 2: Group-to-employees (reverse mapping for efficiency)",
    "        # Structure: groupId -> Set[employeeId]",
    "        self._group_members: Dict[str, Set[str]] = defaultdict(set)",
    "    ",
    "    # ==================== Part 1: Direct Access Methods ====================",
    "    ",
    "    def grant_access(self, employee_id: str, resource_id: str, ",
    "                     access_type: str) -> None:",
    "        \"\"\"",
    "        Grant direct access to an employee for a resource.",
    "        ",
    "        Args:",
    "            employee_id: The employee identifier",
    "            resource_id: The resource identifier",
    "            access_type: One of 'READ', 'WRITE', 'ADMIN'",
    "        \"\"\"",
    "        access = AccessType(access_type)",
    "        self._employee_access[employee_id][resource_id].add(access)",
    "    ",
    "    def revoke_access(self, employee_id: str, resource_id: str,",
    "                      access_type: Optional[str] = None) -> None:",
    "        \"\"\"",
    "        Revoke access from an employee.",
    "        ",
    "        Args:",
    "            employee_id: The employee identifier",
    "            resource_id: The resource identifier",
    "            access_type: If None, revokes ALL access types for the resource",
    "        ",
    "        Note: This only affects direct access, not inherited group access.",
    "        \"\"\"",
    "        if employee_id not in self._employee_access:",
    "            return",
    "        if resource_id not in self._employee_access[employee_id]:",
    "            return",
    "        ",
    "        if access_type is None:",
    "            # Revoke all access for this resource",
    "            del self._employee_access[employee_id][resource_id]",
    "        else:",
    "            # Revoke specific access type",
    "            access = AccessType(access_type)",
    "            self._employee_access[employee_id][resource_id].discard(access)",
    "            ",
    "            # Clean up empty sets",
    "            if not self._employee_access[employee_id][resource_id]:",
    "                del self._employee_access[employee_id][resource_id]",
    "    ",
    "    def retrieve_access(self, employee_id: str, resource_id: str) -> List[str]:",
    "        \"\"\"",
    "        Get DIRECT access types for an employee on a resource.",
    "        ",
    "        Note: This is the Part 1 version. For effective access including",
    "        group inheritance, use get_effective_access() instead.",
    "        \"\"\"",
    "        if employee_id not in self._employee_access:",
    "            return []",
    "        if resource_id not in self._employee_access[employee_id]:",
    "            return []",
    "        return sorted([at.value for at in ",
    "                       self._employee_access[employee_id][resource_id]])",
    "    ",
    "    def retrieve_resources(self, employee_id: str) -> List[str]:",
    "        \"\"\"",
    "        Get all resources an employee has DIRECT access to.",
    "        ",
    "        Note: This is the Part 1 version. For effective resources including",
    "        group inheritance, use get_effective_resources() instead.",
    "        \"\"\"",
    "        if employee_id not in self._employee_access:",
    "            return []",
    "        return sorted(list(self._employee_access[employee_id].keys()))",
    "    ",
    "    # ==================== Part 2: Group Management ====================",
    "    ",
    "    def add_employee_to_group(self, employee_id: str, group_id: str) -> None:",
    "        \"\"\"",
    "        Add an employee to a group.",
    "        ",
    "        The employee will inherit all access permissions from this group.",
    "        Idempotent: adding twice has no additional effect.",
    "        \"\"\"",
    "        self._employee_groups[employee_id].add(group_id)",
    "        self._group_members[group_id].add(employee_id)",
    "    ",
    "    def remove_employee_from_group(self, employee_id: str, group_id: str) -> None:",
    "        \"\"\"",
    "        Remove an employee from a group.",
    "        ",
    "        The employee will no longer inherit access from this group.",
    "        Direct access is unaffected.",
    "        \"\"\"",
    "        self._employee_groups[employee_id].discard(group_id)",
    "        self._group_members[group_id].discard(employee_id)",
    "    ",
    "    def grant_group_access(self, group_id: str, resource_id: str,",
    "                           access_type: str) -> None:",
    "        \"\"\"",
    "        Grant access to a group for a resource.",
    "        ",
    "        All members of the group will inherit this access.",
    "        \"\"\"",
    "        access = AccessType(access_type)",
    "        self._group_access[group_id][resource_id].add(access)",
    "    ",
    "    def revoke_group_access(self, group_id: str, resource_id: str,",
    "                            access_type: Optional[str] = None) -> None:",
    "        \"\"\"",
    "        Revoke access from a group.",
    "        ",
    "        Args:",
    "            group_id: The group identifier",
    "            resource_id: The resource identifier  ",
    "            access_type: If None, revokes ALL access types for the resource",
    "        \"\"\"",
    "        if group_id not in self._group_access:",
    "            return",
    "        if resource_id not in self._group_access[group_id]:",
    "            return",
    "        ",
    "        if access_type is None:",
    "            del self._group_access[group_id][resource_id]",
    "        else:",
    "            access = AccessType(access_type)",
    "            self._group_access[group_id][resource_id].discard(access)",
    "            ",
    "            if not self._group_access[group_id][resource_id]:",
    "                del self._group_access[group_id][resource_id]",
    "    ",
    "    # ==================== Part 2: Effective Access Queries ====================",
    "    ",
    "    def get_effective_access(self, employee_id: str, ",
    "                             resource_id: str) -> List[str]:",
    "        \"\"\"",
    "        Get EFFECTIVE access for an employee on a resource.",
    "        ",
    "        This computes the union of:",
    "        - Direct access granted to the employee",
    "        - Inherited access from ALL groups the employee belongs to",
    "        ",
    "        Time Complexity: O(g) where g = number of groups employee belongs to",
    "        ",
    "        Returns:",
    "            Sorted list of access type strings",
    "        \"\"\"",
    "        effective_access: Set[AccessType] = set()",
    "        ",
    "        # Step 1: Add direct access",
    "        if employee_id in self._employee_access:",
    "            if resource_id in self._employee_access[employee_id]:",
    "                effective_access.update(",
    "                    self._employee_access[employee_id][resource_id]",
    "                )",
    "        ",
    "        # Step 2: Add inherited group access",
    "        for group_id in self._employee_groups.get(employee_id, set()):",
    "            if group_id in self._group_access:",
    "                if resource_id in self._group_access[group_id]:",
    "                    effective_access.update(",
    "                        self._group_access[group_id][resource_id]",
    "                    )",
    "        ",
    "        return sorted([at.value for at in effective_access])",
    "    ",
    "    def get_effective_resources(self, employee_id: str) -> List[str]:",
    "        \"\"\"",
    "        Get all resources an employee has effective access to.",
    "        ",
    "        This includes both direct resources and resources from all groups.",
    "        ",
    "        Time Complexity: O(g * r) where g = groups, r = resources per group",
    "        ",
    "        Returns:",
    "            Sorted list of resource identifiers",
    "        \"\"\"",
    "        resources: Set[str] = set()",
    "        ",
    "        # Step 1: Add direct resources",
    "        if employee_id in self._employee_access:",
    "            resources.update(self._employee_access[employee_id].keys())",
    "        ",
    "        # Step 2: Add inherited group resources",
    "        for group_id in self._employee_groups.get(employee_id, set()):",
    "            if group_id in self._group_access:",
    "                resources.update(self._group_access[group_id].keys())",
    "        ",
    "        return sorted(list(resources))",
    "    ",
    "    # ==================== Utility Methods ====================",
    "    ",
    "    def get_employee_groups(self, employee_id: str) -> List[str]:",
    "        \"\"\"Get all groups an employee belongs to.\"\"\"",
    "        return sorted(list(self._employee_groups.get(employee_id, set())))",
    "    ",
    "    def get_group_members(self, group_id: str) -> List[str]:",
    "        \"\"\"Get all employees in a group.\"\"\"",
    "        return sorted(list(self._group_members.get(group_id, set())))",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the AccessManager with comprehensive examples.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Employee Access Management System - Part 2 Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    manager = AccessManager()",
    "    ",
    "    # Example 1: Basic group inheritance",
    "    print(\"\\n--- Example 1: Basic Group Inheritance ---\")",
    "    manager.grant_group_access(\"G1\", \"R1\", \"READ\")",
    "    manager.add_employee_to_group(\"E1\", \"G1\")",
    "    manager.grant_access(\"E1\", \"R1\", \"WRITE\")",
    "    ",
    "    result = manager.get_effective_access(\"E1\", \"R1\")",
    "    print(f\"E1's effective access on R1: {result}\")",
    "    print(\"Expected: ['READ', 'WRITE'] (READ from G1, WRITE direct)\")",
    "    ",
    "    # Example 2: Multiple groups",
    "    print(\"\\n--- Example 2: Multiple Group Membership ---\")",
    "    manager.grant_group_access(\"G2\", \"R1\", \"ADMIN\")",
    "    manager.add_employee_to_group(\"E1\", \"G2\")",
    "    ",
    "    result = manager.get_effective_access(\"E1\", \"R1\")",
    "    print(f\"E1's effective access on R1: {result}\")",
    "    print(\"Expected: ['ADMIN', 'READ', 'WRITE'] (all three types)\")",
    "    ",
    "    # Example 3: Effective resources",
    "    print(\"\\n--- Example 3: Effective Resources ---\")",
    "    manager.grant_group_access(\"G1\", \"R2\", \"READ\")",
    "    manager.grant_access(\"E1\", \"R3\", \"ADMIN\")",
    "    ",
    "    result = manager.get_effective_resources(\"E1\")",
    "    print(f\"E1's effective resources: {result}\")",
    "    print(\"Expected: ['R1', 'R2', 'R3'] (R2 from G1, R3 direct)\")",
    "    ",
    "    # Example 4: Revoke doesn't affect group access",
    "    print(\"\\n--- Example 4: Direct Revoke vs Group Access ---\")",
    "    manager.revoke_access(\"E1\", \"R1\", \"WRITE\")",
    "    ",
    "    result = manager.get_effective_access(\"E1\", \"R1\")",
    "    print(f\"After revoking E1's direct WRITE on R1: {result}\")",
    "    print(\"Expected: ['ADMIN', 'READ'] (group access preserved)\")",
    "    ",
    "    # Example 5: Remove from group",
    "    print(\"\\n--- Example 5: Remove from Group ---\")",
    "    manager.remove_employee_from_group(\"E1\", \"G2\")",
    "    ",
    "    result = manager.get_effective_access(\"E1\", \"R1\")",
    "    print(f\"After removing E1 from G2: {result}\")",
    "    print(\"Expected: ['READ'] (only G1's READ remains)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests completed successfully!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Access permission types for resources.",
    " */",
    "enum AccessType {",
    "    READ, WRITE, ADMIN",
    "}",
    "",
    "/**",
    " * Role-Based Access Control System with Group Support.",
    " * ",
    " * This system supports:",
    " * - Direct employee access to resources (Part 1)",
    " * - Group-based access inheritance (Part 2)",
    " * - Employees can belong to multiple groups",
    " * - Effective access = direct access \u222a inherited group access",
    " */",
    "public class AccessManager {",
    "    ",
    "    // Part 1: Direct employee access",
    "    // Structure: employeeId -> resourceId -> Set<AccessType>",
    "    private final Map<String, Map<String, Set<AccessType>>> employeeAccess;",
    "    ",
    "    // Part 2: Group access (mirrors employee access structure)",
    "    private final Map<String, Map<String, Set<AccessType>>> groupAccess;",
    "    ",
    "    // Part 2: Employee-to-groups membership",
    "    private final Map<String, Set<String>> employeeGroups;",
    "    ",
    "    // Part 2: Group-to-employees (reverse mapping)",
    "    private final Map<String, Set<String>> groupMembers;",
    "    ",
    "    public AccessManager() {",
    "        this.employeeAccess = new HashMap<>();",
    "        this.groupAccess = new HashMap<>();",
    "        this.employeeGroups = new HashMap<>();",
    "        this.groupMembers = new HashMap<>();",
    "    }",
    "    ",
    "    // ==================== Part 1: Direct Access Methods ====================",
    "    ",
    "    /**",
    "     * Grant direct access to an employee for a resource.",
    "     */",
    "    public void grantAccess(String employeeId, String resourceId, ",
    "                            String accessType) {",
    "        AccessType access = AccessType.valueOf(accessType);",
    "        employeeAccess",
    "            .computeIfAbsent(employeeId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashSet<>())",
    "            .add(access);",
    "    }",
    "    ",
    "    /**",
    "     * Revoke access from an employee.",
    "     * If accessType is null, revokes all access for the resource.",
    "     */",
    "    public void revokeAccess(String employeeId, String resourceId,",
    "                             String accessType) {",
    "        if (!employeeAccess.containsKey(employeeId)) return;",
    "        Map<String, Set<AccessType>> resources = employeeAccess.get(employeeId);",
    "        if (!resources.containsKey(resourceId)) return;",
    "        ",
    "        if (accessType == null) {",
    "            resources.remove(resourceId);",
    "        } else {",
    "            AccessType access = AccessType.valueOf(accessType);",
    "            Set<AccessType> types = resources.get(resourceId);",
    "            types.remove(access);",
    "            if (types.isEmpty()) {",
    "                resources.remove(resourceId);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Get direct access types for an employee on a resource.",
    "     */",
    "    public List<String> retrieveAccess(String employeeId, String resourceId) {",
    "        if (!employeeAccess.containsKey(employeeId)) {",
    "            return new ArrayList<>();",
    "        }",
    "        Map<String, Set<AccessType>> resources = employeeAccess.get(employeeId);",
    "        if (!resources.containsKey(resourceId)) {",
    "            return new ArrayList<>();",
    "        }",
    "        List<String> result = new ArrayList<>();",
    "        for (AccessType at : resources.get(resourceId)) {",
    "            result.add(at.name());",
    "        }",
    "        Collections.sort(result);",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== Part 2: Group Management ====================",
    "    ",
    "    /**",
    "     * Add an employee to a group.",
    "     */",
    "    public void addEmployeeToGroup(String employeeId, String groupId) {",
    "        employeeGroups",
    "            .computeIfAbsent(employeeId, k -> new HashSet<>())",
    "            .add(groupId);",
    "        groupMembers",
    "            .computeIfAbsent(groupId, k -> new HashSet<>())",
    "            .add(employeeId);",
    "    }",
    "    ",
    "    /**",
    "     * Remove an employee from a group.",
    "     */",
    "    public void removeEmployeeFromGroup(String employeeId, String groupId) {",
    "        if (employeeGroups.containsKey(employeeId)) {",
    "            employeeGroups.get(employeeId).remove(groupId);",
    "        }",
    "        if (groupMembers.containsKey(groupId)) {",
    "            groupMembers.get(groupId).remove(employeeId);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Grant access to a group for a resource.",
    "     */",
    "    public void grantGroupAccess(String groupId, String resourceId,",
    "                                  String accessType) {",
    "        AccessType access = AccessType.valueOf(accessType);",
    "        groupAccess",
    "            .computeIfAbsent(groupId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashSet<>())",
    "            .add(access);",
    "    }",
    "    ",
    "    /**",
    "     * Revoke access from a group.",
    "     */",
    "    public void revokeGroupAccess(String groupId, String resourceId,",
    "                                   String accessType) {",
    "        if (!groupAccess.containsKey(groupId)) return;",
    "        Map<String, Set<AccessType>> resources = groupAccess.get(groupId);",
    "        if (!resources.containsKey(resourceId)) return;",
    "        ",
    "        if (accessType == null) {",
    "            resources.remove(resourceId);",
    "        } else {",
    "            AccessType access = AccessType.valueOf(accessType);",
    "            Set<AccessType> types = resources.get(resourceId);",
    "            types.remove(access);",
    "            if (types.isEmpty()) {",
    "                resources.remove(resourceId);",
    "            }",
    "        }",
    "    }",
    "    ",
    "    // ==================== Part 2: Effective Access Queries ====================",
    "    ",
    "    /**",
    "     * Get effective access for an employee on a resource.",
    "     * Includes both direct and inherited group access.",
    "     * ",
    "     * Time Complexity: O(g) where g = number of groups",
    "     */",
    "    public List<String> getEffectiveAccess(String employeeId, ",
    "                                            String resourceId) {",
    "        Set<AccessType> effectiveAccess = new HashSet<>();",
    "        ",
    "        // Step 1: Add direct access",
    "        if (employeeAccess.containsKey(employeeId)) {",
    "            Map<String, Set<AccessType>> resources = ",
    "                employeeAccess.get(employeeId);",
    "            if (resources.containsKey(resourceId)) {",
    "                effectiveAccess.addAll(resources.get(resourceId));",
    "            }",
    "        }",
    "        ",
    "        // Step 2: Add inherited group access",
    "        Set<String> groups = employeeGroups.getOrDefault(",
    "            employeeId, Collections.emptySet());",
    "        for (String groupId : groups) {",
    "            if (groupAccess.containsKey(groupId)) {",
    "                Map<String, Set<AccessType>> resources = ",
    "                    groupAccess.get(groupId);",
    "                if (resources.containsKey(resourceId)) {",
    "                    effectiveAccess.addAll(resources.get(resourceId));",
    "                }",
    "            }",
    "        }",
    "        ",
    "        List<String> result = new ArrayList<>();",
    "        for (AccessType at : effectiveAccess) {",
    "            result.add(at.name());",
    "        }",
    "        Collections.sort(result);",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get all resources an employee has effective access to.",
    "     */",
    "    public List<String> getEffectiveResources(String employeeId) {",
    "        Set<String> resources = new HashSet<>();",
    "        ",
    "        // Add direct resources",
    "        if (employeeAccess.containsKey(employeeId)) {",
    "            resources.addAll(employeeAccess.get(employeeId).keySet());",
    "        }",
    "        ",
    "        // Add inherited group resources",
    "        Set<String> groups = employeeGroups.getOrDefault(",
    "            employeeId, Collections.emptySet());",
    "        for (String groupId : groups) {",
    "            if (groupAccess.containsKey(groupId)) {",
    "                resources.addAll(groupAccess.get(groupId).keySet());",
    "            }",
    "        }",
    "        ",
    "        List<String> result = new ArrayList<>(resources);",
    "        Collections.sort(result);",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== Demo Main ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Employee Access Management System - Part 2 Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        AccessManager manager = new AccessManager();",
    "        ",
    "        // Example 1: Basic group inheritance",
    "        System.out.println(\"\\n--- Example 1: Basic Group Inheritance ---\");",
    "        manager.grantGroupAccess(\"G1\", \"R1\", \"READ\");",
    "        manager.addEmployeeToGroup(\"E1\", \"G1\");",
    "        manager.grantAccess(\"E1\", \"R1\", \"WRITE\");",
    "        ",
    "        System.out.println(\"E1's effective access on R1: \" + ",
    "            manager.getEffectiveAccess(\"E1\", \"R1\"));",
    "        System.out.println(\"Expected: [READ, WRITE]\");",
    "        ",
    "        // Example 2: Multiple groups",
    "        System.out.println(\"\\n--- Example 2: Multiple Groups ---\");",
    "        manager.grantGroupAccess(\"G2\", \"R1\", \"ADMIN\");",
    "        manager.addEmployeeToGroup(\"E1\", \"G2\");",
    "        ",
    "        System.out.println(\"E1's effective access on R1: \" + ",
    "            manager.getEffectiveAccess(\"E1\", \"R1\"));",
    "        System.out.println(\"Expected: [ADMIN, READ, WRITE]\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "Imports and AccessType enum definition. Using Enum in Python for type safety and clearer code."
    },
    {
      "lines": "13-24",
      "explanation": "Class docstring explaining the RBAC system capabilities and the key design decision of lazy evaluation."
    },
    {
      "lines": "26-42",
      "explanation": "Constructor initializes four data structures using defaultdict for automatic nested dictionary creation. This eliminates null checks throughout the code."
    },
    {
      "lines": "46-55",
      "explanation": "grant_access: Simple insertion into nested dictionary. The defaultdict handles missing keys automatically."
    },
    {
      "lines": "57-78",
      "explanation": "revoke_access: Handles both full revocation (accessType=None) and partial revocation. Includes cleanup of empty sets/dicts."
    },
    {
      "lines": "102-120",
      "explanation": "Group membership methods. Note the bidirectional update: both employee_groups and group_members are updated for efficient reverse lookups."
    },
    {
      "lines": "144-174",
      "explanation": "getEffectiveAccess: The CORE algorithm. Initializes empty set, adds direct access, then iterates through all employee's groups to union their access."
    },
    {
      "lines": "176-196",
      "explanation": "getEffectiveResources: Similar pattern but for resource discovery. Unions resource keys instead of access types."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "addEmployeeToGroup": {
          "complexity": "O(1)",
          "explanation": "Two HashSet insertions"
        },
        "removeEmployeeFromGroup": {
          "complexity": "O(1)",
          "explanation": "Two HashSet removals"
        },
        "grantGroupAccess": {
          "complexity": "O(1)",
          "explanation": "Same as grant_access, just different map"
        },
        "revokeGroupAccess": {
          "complexity": "O(1)",
          "explanation": "Same as revoke_access, just different map"
        },
        "getEffectiveAccess": {
          "complexity": "O(g)",
          "explanation": "Must iterate through g groups the employee belongs to. Each group lookup is O(1)."
        },
        "getEffectiveResources": {
          "complexity": "O(g * r_avg)",
          "explanation": "For each of g groups, we add r resources to the set. Set union is amortized O(1) per element."
        }
      },
      "overall_change": "Query operations become O(g) instead of O(1), but g is typically small (1-10 groups per employee). Write operations remain O(1)."
    },
    "space": {
      "additional_space": "O(G * R + E * G)",
      "explanation": "Group access requires O(G * R) where G = groups, R = resources. Group membership requires O(E * G) for bidirectional mapping. This is in addition to Part 1's O(E * R) for employee access."
    }
  },
  "dry_run": {
    "example_input": "grantGroupAccess(G1, R1, READ) \u2192 addEmployeeToGroup(E1, G1) \u2192 grant_access(E1, R1, WRITE) \u2192 getEffectiveAccess(E1, R1)",
    "steps": [
      {
        "step": 1,
        "action": "grantGroupAccess(G1, R1, READ)",
        "state": "group_access = {G1: {R1: {READ}}}",
        "explanation": "Group G1 now has READ access to resource R1"
      },
      {
        "step": 2,
        "action": "addEmployeeToGroup(E1, G1)",
        "state": "employee_groups = {E1: {G1}}, group_members = {G1: {E1}}",
        "explanation": "E1 is now a member of G1, bidirectional mapping updated"
      },
      {
        "step": 3,
        "action": "grant_access(E1, R1, WRITE)",
        "state": "employee_access = {E1: {R1: {WRITE}}}",
        "explanation": "E1 has direct WRITE access to R1"
      },
      {
        "step": 4,
        "action": "getEffectiveAccess(E1, R1) - init",
        "state": "effective_access = {}",
        "explanation": "Initialize empty set for collecting access types"
      },
      {
        "step": 5,
        "action": "getEffectiveAccess - direct",
        "state": "effective_access = {WRITE}",
        "explanation": "Add E1's direct access: {WRITE}"
      },
      {
        "step": 6,
        "action": "getEffectiveAccess - groups",
        "state": "Iterate groups: {G1}",
        "explanation": "E1 belongs to groups: {G1}"
      },
      {
        "step": 7,
        "action": "getEffectiveAccess - G1",
        "state": "effective_access = {WRITE, READ}",
        "explanation": "Union with G1's access on R1: {READ}"
      },
      {
        "step": 8,
        "action": "getEffectiveAccess - return",
        "state": "sorted(['READ', 'WRITE'])",
        "explanation": "Convert to sorted list and return"
      }
    ],
    "final_output": "['READ', 'WRITE']"
  },
  "edge_cases": [
    {
      "case": "Employee not in any group",
      "handling": "employee_groups.get(id, set()) returns empty set, loop doesn't execute",
      "gotcha": "Don't throw exception, just return direct access only"
    },
    {
      "case": "Group with no access granted",
      "handling": "group_access check handles missing groups gracefully",
      "gotcha": "Empty group should not contribute any access"
    },
    {
      "case": "Employee removed from group after access granted",
      "handling": "Lazy evaluation means next query correctly excludes former group's access",
      "gotcha": "If using caching, this would require invalidation - our approach avoids this"
    },
    {
      "case": "Revoking direct access that's also from group",
      "handling": "Only direct access is revoked; group access remains",
      "gotcha": "Users might expect complete revocation - document this clearly"
    },
    {
      "case": "Same access type from multiple sources",
      "handling": "Set automatically deduplicates",
      "gotcha": "Don't count access twice or return duplicates in list"
    },
    {
      "case": "Employee with access but no groups, and group access on same resource",
      "handling": "Just returns direct access",
      "gotcha": "Make sure direct access path doesn't require group membership"
    }
  ],
  "test_cases": [
    {
      "name": "Basic group inheritance",
      "input": "grantGroupAccess(G1,R1,READ); addEmployeeToGroup(E1,G1); getEffectiveAccess(E1,R1)",
      "expected": "['READ']",
      "explanation": "Employee inherits group's access"
    },
    {
      "name": "Direct + inherited access union",
      "input": "grantGroupAccess(G1,R1,READ); addEmployeeToGroup(E1,G1); grant_access(E1,R1,WRITE); getEffectiveAccess(E1,R1)",
      "expected": "['READ', 'WRITE']",
      "explanation": "Union of direct WRITE and inherited READ"
    },
    {
      "name": "Multiple group membership",
      "input": "grantGroupAccess(G1,R1,READ); grantGroupAccess(G2,R1,ADMIN); addEmployeeToGroup(E1,G1); addEmployeeToGroup(E1,G2); getEffectiveAccess(E1,R1)",
      "expected": "['ADMIN', 'READ']",
      "explanation": "Access from both groups is combined"
    },
    {
      "name": "Revoke direct doesn't affect group",
      "input": "grantGroupAccess(G1,R1,READ); addEmployeeToGroup(E1,G1); grant_access(E1,R1,WRITE); revoke_access(E1,R1,WRITE); getEffectiveAccess(E1,R1)",
      "expected": "['READ']",
      "explanation": "Only direct WRITE was revoked, inherited READ remains"
    },
    {
      "name": "Remove from group removes inherited access",
      "input": "grantGroupAccess(G1,R1,READ); addEmployeeToGroup(E1,G1); removeEmployeeFromGroup(E1,G1); getEffectiveAccess(E1,R1)",
      "expected": "[]",
      "explanation": "No longer inherits from G1 after removal"
    },
    {
      "name": "Effective resources includes group resources",
      "input": "grantGroupAccess(G1,R1,READ); grantGroupAccess(G1,R2,READ); addEmployeeToGroup(E1,G1); grant_access(E1,R3,WRITE); getEffectiveResources(E1)",
      "expected": "['R1', 'R2', 'R3']",
      "explanation": "R1,R2 from G1, R3 direct"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Modifying group access when revoking employee access",
      "why_wrong": "The problem states 'Revoking from an employee does NOT affect group access'. Some candidates try to remove the employee from the group or modify group access.",
      "correct_approach": "Only modify the employee's direct access. Group access is a separate concern.",
      "code_example_wrong": "def revoke_access(self, emp, res, type):\n    # WRONG: Also removing from groups\n    for group in self._employee_groups[emp]:\n        self._group_access[group][res].discard(type)",
      "code_example_correct": "def revoke_access(self, emp, res, type):\n    # CORRECT: Only modify direct access\n    self._employee_access[emp][res].discard(type)"
    },
    {
      "mistake": "Caching effective access at grant time",
      "why_wrong": "Leads to stale data when group membership or group access changes. Requires complex invalidation logic.",
      "correct_approach": "Compute effective access at query time. The overhead is minimal since employees typically belong to few groups.",
      "code_example_wrong": "def add_employee_to_group(self, emp, grp):\n    # WRONG: Precomputing effective access\n    self._cached_access[emp].update(\n        self._group_access[grp])\n    # Must now invalidate when group access changes!",
      "code_example_correct": "def add_employee_to_group(self, emp, grp):\n    # CORRECT: Just store membership\n    self._employee_groups[emp].add(grp)"
    },
    {
      "mistake": "Returning duplicate access types",
      "why_wrong": "If employee has READ directly and from a group, returning ['READ', 'READ'] is incorrect.",
      "correct_approach": "Use a Set to collect access types, then convert to list.",
      "code_example_wrong": "result = []\nresult.extend(direct_access)\nresult.extend(group_access)\nreturn result  # May have duplicates!",
      "code_example_correct": "result = set()\nresult.update(direct_access)\nresult.update(group_access)\nreturn sorted(list(result))"
    },
    {
      "mistake": "Not handling missing employees/groups/resources",
      "why_wrong": "KeyError exceptions when querying for non-existent entities.",
      "correct_approach": "Use defaultdict or check for key existence before access.",
      "code_example_wrong": "return self._employee_access[emp][res]  # KeyError if emp or res missing",
      "code_example_correct": "return self._employee_access.get(emp, {}).get(res, set())"
    }
  ],
  "interview_tips": {
    "how_to_present": "1. Start by clarifying the inheritance model: 'So effective access is the union of direct and all group access, and revoking doesn't cascade to groups?' 2. Explain your design decision upfront: 'I'll compute inheritance at query time to avoid cache invalidation complexity.' 3. Draw the data structure diagram before coding. 4. Implement incrementally, testing each method.",
    "what_to_mention": [
      "Trade-off analysis: Query-time computation vs. caching with invalidation",
      "Real-world relevance: 'This is similar to AWS IAM or Okta's permission model'",
      "Why Set union is the right abstraction for combining permissions",
      "Memory efficiency: defaultdict for sparse data, no pre-allocation needed",
      "The bidirectional group membership for potential future needs (list group members)"
    ],
    "time_allocation": "15-20 minutes: 2 min clarifying questions, 3 min design discussion, 10 min coding, 3 min testing with examples",
    "if_stuck": [
      "Draw the data structures on paper first - what maps do you need?",
      "Think about what changes from Part 1 - what new data needs to be stored?",
      "For getEffectiveAccess, think: 'direct access UNION all group access'",
      "Remember: Set.update() or addAll() does union in-place"
    ]
  },
  "connection_to_next_part": "Part 3 might introduce hierarchical groups (groups containing other groups), time-based access (access that expires), or audit logging. The current design separates concerns well: adding group hierarchies would require recursion in getEffectiveAccess but wouldn't change the data structure fundamentally. Time-based access would add a timestamp field to access grants. The lazy evaluation approach scales to these extensions.",
  "generated_at": "2026-01-14T15:03:05.944109",
  "_meta": {
    "problem_id": "employee_access_management",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}