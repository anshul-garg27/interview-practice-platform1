{
  "problem_title": "Song Play Analytics System - Part 3: Recent Unique Plays",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 returned recent plays WITH duplicates. Part 3 requires returning recent plays WITHOUT duplicates - each song appears only once at its most recent position. This requires traversing backwards and tracking 'seen' songs to skip duplicates.",
    "new_requirements": [
      "Return unique songs only (no duplicates in result)",
      "Each song's position is determined by its MOST RECENT play",
      "Still ordered by recency (most recent first)",
      "Return min(count, total_unique_songs) songs"
    ],
    "new_constraints": [
      "Cannot simply filter Part 2 results - order matters",
      "Must track 'seen' state during iteration",
      "May return fewer than 'count' if insufficient unique songs exist"
    ],
    "key_insight": "Iterate BACKWARDS through play history. Use a Set to track songs already added. Skip songs already seen. This naturally gives us each song at its most recent position only."
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          PLAY HISTORY (stored in Part 2)                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  Index:    [0]  [1]  [2]  [3]  [4]  [5]                     \u2502\n\u2502  Songs:     A    B    A    C    A    B                      \u2502\n\u2502                                   \u2191    \u2191                    \u2502\n\u2502                              A's last B's last              \u2502\n\u2502                                                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  PART 2: getRecentPlays(4)                                  \u2502\n\u2502  Simply take last 4, reverse: [B, A, C, A]                  \u2502\n\u2502  Duplicates? \u2713 Allowed                                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  PART 3: getRecentUniquePlays(4)                            \u2502\n\u2502  Iterate backwards, skip seen: [B, A, C]                    \u2502\n\u2502  Duplicates? \u2717 Not allowed                                  \u2502\n\u2502  Only 3 unique songs exist, so return 3                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           BACKWARD ITERATION ALGORITHM                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502  Play History: [A] [B] [A] [C] [A] [B]                      \u2502\n\u2502                 0   1   2   3   4   5                       \u2502\n\u2502                                                              \u2502\n\u2502  Start i=5, result=[], seen={}                              \u2502\n\u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                       \u2502\n\u2502                                                              \u2502\n\u2502  Step 1: i=5, song='B'                                      \u2502\n\u2502          B not in seen \u2713                                    \u2502\n\u2502          seen={B}, result=[B]                               \u2502\n\u2502                                                              \u2502\n\u2502  Step 2: i=4, song='A'                                      \u2502\n\u2502          A not in seen \u2713                                    \u2502\n\u2502          seen={B,A}, result=[B,A]                           \u2502\n\u2502                                                              \u2502\n\u2502  Step 3: i=3, song='C'                                      \u2502\n\u2502          C not in seen \u2713                                    \u2502\n\u2502          seen={B,A,C}, result=[B,A,C]                       \u2502\n\u2502          len(result)==count? \u2713 DONE!                        \u2502\n\u2502                                                              \u2502\n\u2502  (Would skip i=2 'A' - already seen)                        \u2502\n\u2502  (Would skip i=1 'B' - already seen)                        \u2502\n\u2502                                                              \u2502\n\u2502  FINAL: [B, A, C]                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive: Filter Part 2 Results",
      "description": "Call getRecentPlays(count), then remove duplicates keeping first occurrence",
      "time_complexity": "O(count)",
      "space_complexity": "O(count)",
      "why_not_optimal": "This FAILS because getRecentPlays(count) only returns 'count' items. If we have [A,A,A,B,C] and call getRecentPlays(3), we get [C,B,A]. But if count=5 and we call getRecentPlays(5) then filter, we might miss unique songs that appeared before our window. Also, we may not get enough unique songs."
    },
    {
      "name": "Naive: Use LinkedHashSet / OrderedDict",
      "description": "Maintain a LinkedHashSet of plays, removing old entries on re-play",
      "time_complexity": "O(1) per play, O(count) for query",
      "space_complexity": "O(unique_songs)",
      "why_not_optimal": "This works but adds complexity to play_song() method. We'd need to remove and re-add on each play to update order. Complicates the simple list-based history from Part 2."
    },
    {
      "name": "Optimal: Backward Iteration with Seen Set",
      "description": "Iterate backwards through existing play_history list, use HashSet to track seen songs, collect unique songs until we have enough or exhaust history",
      "time_complexity": "O(n) worst case, where n = total plays",
      "space_complexity": "O(min(count, unique_songs)) for result + O(min(count, unique_songs)) for seen set",
      "key_insight": "The play_history list from Part 2 already has all the information we need. By iterating backwards, the FIRST time we see each song is its most recent play. No data structure changes needed - just smart iteration!"
    }
  ],
  "optimal_solution": {
    "explanation_md": "The **key insight** is that we don't need any new data structures! The `play_history` list from Part 2 contains everything.\n\n**Why Backward Iteration Works:**\n- The list stores plays in chronological order (oldest \u2192 newest)\n- Iterating backwards means we see the **most recent play first**\n- The first time we encounter each song is its most recent occurrence\n- A **HashSet** efficiently tracks which songs we've already added\n\n**Algorithm:**\n1. Initialize empty `result` list and empty `seen` set\n2. Loop from `len(history)-1` down to `0`\n3. For each song: if **not in seen**, add to both `seen` and `result`\n4. **Early termination**: Stop when `len(result) >= count`\n5. Return `result`\n\n**Why This Is Optimal:**\n- **No extra storage** on play_song() - we reuse existing history\n- **Lazy computation** - only computed when needed\n- **Early termination** - stops as soon as we have enough unique songs\n- **Simple logic** - easy to understand and debug",
    "data_structures": [
      {
        "structure": "List (play_history)",
        "purpose": "Existing from Part 2 - stores all plays in chronological order"
      },
      {
        "structure": "HashSet (seen)",
        "purpose": "Temporary during query - O(1) lookup to check if song already added"
      },
      {
        "structure": "List (result)",
        "purpose": "Temporary during query - accumulates unique songs in recency order"
      }
    ],
    "algorithm_steps": [
      "Step 1: Handle edge case - if count <= 0, return empty list",
      "Step 2: Initialize result = [] and seen = set()",
      "Step 3: Loop i from len(play_history)-1 down to 0",
      "Step 4: Get song_name = play_history[i]",
      "Step 5: If song_name NOT in seen: add to seen, append to result",
      "Step 6: If len(result) >= count: break early",
      "Step 7: Return result"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Dict, Set",
    "from collections import defaultdict",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Music streaming analytics system that tracks song plays and unique listeners.",
    "    ",
    "    Part 1: Basic song management and sorted reports by unique listeners",
    "    Part 2: Recent plays with duplicates",
    "    Part 3: Recent unique plays (no duplicates) - THIS PART",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize the analytics system with empty collections.\"\"\"",
    "        self._next_id: int = 1",
    "        self._songs: Dict[int, str] = {}  # song_id -> song_name",
    "        self._unique_listeners: Dict[int, Set[int]] = defaultdict(set)  # song_id -> user_ids",
    "        self._play_history: List[str] = []  # Chronological play history (song names)",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"",
    "        Add a song to the library with auto-assigned ID.",
    "        ",
    "        Args:",
    "            name: The name of the song to add",
    "            ",
    "        Returns:",
    "            The auto-assigned song ID (1, 2, 3, ...)",
    "        \"\"\"",
    "        song_id = self._next_id",
    "        self._songs[song_id] = name",
    "        self._next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"",
    "        Record that a user played a song.",
    "        ",
    "        Args:",
    "            song_id: The ID of the song being played",
    "            user_id: The ID of the user playing the song",
    "        \"\"\"",
    "        if song_id not in self._songs:",
    "            return  # Silently ignore invalid song IDs",
    "        ",
    "        # Track unique listener",
    "        self._unique_listeners[song_id].add(user_id)",
    "        ",
    "        # Record in play history (from Part 2)",
    "        self._play_history.append(self._songs[song_id])",
    "    ",
    "    def get_sorted_report(self) -> List[str]:",
    "        \"\"\"",
    "        Get songs sorted by unique listener count (desc), then song ID (asc).",
    "        ",
    "        Returns:",
    "            List of song names in sorted order",
    "        \"\"\"",
    "        song_data = []",
    "        for song_id, song_name in self._songs.items():",
    "            unique_count = len(self._unique_listeners.get(song_id, set()))",
    "            song_data.append((song_id, song_name, unique_count))",
    "        ",
    "        # Sort: primary by -unique_count (desc), secondary by song_id (asc)",
    "        song_data.sort(key=lambda x: (-x[2], x[0]))",
    "        ",
    "        return [name for _, name, _ in song_data]",
    "    ",
    "    def get_recent_plays(self, count: int) -> List[str]:",
    "        \"\"\"",
    "        Get the most recent plays (may include duplicates). [Part 2]",
    "        ",
    "        Args:",
    "            count: Number of recent plays to return",
    "            ",
    "        Returns:",
    "            List of song names, most recent first",
    "        \"\"\"",
    "        if count <= 0:",
    "            return []",
    "        ",
    "        # Slice last 'count' items and reverse",
    "        actual_count = min(count, len(self._play_history))",
    "        return list(reversed(self._play_history[-actual_count:]))",
    "    ",
    "    def get_recent_unique_plays(self, count: int) -> List[str]:",
    "        \"\"\"",
    "        Get the most recently played UNIQUE songs (no duplicates). [Part 3]",
    "        ",
    "        Each song appears only once, at its most recent position.",
    "        Uses backward iteration with a seen-set for O(n) performance.",
    "        ",
    "        Args:",
    "            count: Maximum number of unique recent songs to return",
    "            ",
    "        Returns:",
    "            List of unique song names, most recent first.",
    "            May return fewer than 'count' if fewer unique songs exist.",
    "        ",
    "        Example:",
    "            History: [A, B, A, C, A, B]",
    "            get_recent_unique_plays(3) -> [B, A, C]",
    "        \"\"\"",
    "        if count <= 0:",
    "            return []",
    "        ",
    "        result: List[str] = []",
    "        seen: Set[str] = set()",
    "        ",
    "        # Iterate backwards: most recent to oldest",
    "        for i in range(len(self._play_history) - 1, -1, -1):",
    "            song_name = self._play_history[i]",
    "            ",
    "            # Only add if not seen before",
    "            if song_name not in seen:",
    "                seen.add(song_name)",
    "                result.append(song_name)",
    "                ",
    "                # Early termination when we have enough",
    "                if len(result) >= count:",
    "                    break",
    "        ",
    "        return result",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the SongAnalytics system with Part 3 functionality.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"SONG ANALYTICS SYSTEM - Part 3: Recent Unique Plays Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    ",
    "    # Add songs",
    "    id_a = analytics.add_song(\"A\")",
    "    id_b = analytics.add_song(\"B\")",
    "    id_c = analytics.add_song(\"C\")",
    "    print(f\"\\nAdded songs: A(id={id_a}), B(id={id_b}), C(id={id_c})\")",
    "    ",
    "    # Play sequence: A -> B -> A -> C -> A -> B",
    "    plays = [(id_a, 1), (id_b, 1), (id_a, 2), (id_c, 1), (id_a, 3), (id_b, 2)]",
    "    print(\"\\nPlay sequence:\")",
    "    for song_id, user_id in plays:",
    "        song_name = {id_a: 'A', id_b: 'B', id_c: 'C'}[song_id]",
    "        print(f\"  User {user_id} plays '{song_name}'\")",
    "        analytics.play_song(song_id, user_id)",
    "    ",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"COMPARISON: Recent Plays vs Recent UNIQUE Plays\")",
    "    print(\"-\" * 60)",
    "    ",
    "    # Part 2: Recent plays (with duplicates)",
    "    recent = analytics.get_recent_plays(4)",
    "    print(f\"\\nget_recent_plays(4):       {recent}\")",
    "    print(\"  (duplicates allowed - raw last 4 plays)\")",
    "    ",
    "    # Part 3: Recent unique plays (no duplicates)",
    "    unique = analytics.get_recent_unique_plays(4)",
    "    print(f\"\\nget_recent_unique_plays(4): {unique}\")",
    "    print(\"  (unique only - only 3 distinct songs exist!)\")",
    "    ",
    "    # Edge case: More requested than unique",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"EDGE CASE: Single song played multiple times\")",
    "    print(\"-\" * 60)",
    "    ",
    "    analytics2 = SongAnalytics()",
    "    only_id = analytics2.add_song(\"Only\")",
    "    for i in range(5):",
    "        analytics2.play_song(only_id, i + 1)",
    "    ",
    "    print(f\"\\nSong 'Only' played 5 times by 5 different users\")",
    "    print(f\"get_recent_unique_plays(5): {analytics2.get_recent_unique_plays(5)}\")",
    "    print(\"  (only 1 unique song exists, so returns list with 1 item)\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Music streaming analytics system that tracks song plays and unique listeners.",
    " * ",
    " * Part 1: Basic song management and sorted reports by unique listeners",
    " * Part 2: Recent plays with duplicates",
    " * Part 3: Recent unique plays (no duplicates) - THIS PART",
    " */",
    "public class SongAnalytics {",
    "    ",
    "    private int nextId;",
    "    private Map<Integer, String> songs;           // song_id -> song_name",
    "    private Map<Integer, Set<Integer>> uniqueListeners;  // song_id -> user_ids",
    "    private List<String> playHistory;             // chronological play history",
    "    ",
    "    /**",
    "     * Initialize the analytics system with empty collections.",
    "     */",
    "    public SongAnalytics() {",
    "        this.nextId = 1;",
    "        this.songs = new HashMap<>();",
    "        this.uniqueListeners = new HashMap<>();",
    "        this.playHistory = new ArrayList<>();",
    "    }",
    "    ",
    "    /**",
    "     * Add a song to the library with auto-assigned ID.",
    "     * @param name The name of the song to add",
    "     * @return The auto-assigned song ID (1, 2, 3, ...)",
    "     */",
    "    public int addSong(String name) {",
    "        int songId = nextId++;",
    "        songs.put(songId, name);",
    "        return songId;",
    "    }",
    "    ",
    "    /**",
    "     * Record that a user played a song.",
    "     * @param songId The ID of the song being played",
    "     * @param userId The ID of the user playing the song",
    "     */",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            return;  // Silently ignore invalid song IDs",
    "        }",
    "        ",
    "        // Track unique listener",
    "        uniqueListeners.computeIfAbsent(songId, k -> new HashSet<>()).add(userId);",
    "        ",
    "        // Record in play history (from Part 2)",
    "        playHistory.add(songs.get(songId));",
    "    }",
    "    ",
    "    /**",
    "     * Get songs sorted by unique listener count (desc), then song ID (asc).",
    "     * @return List of song names in sorted order",
    "     */",
    "    public List<String> getSortedReport() {",
    "        List<int[]> songData = new ArrayList<>();  // [songId, uniqueCount]",
    "        ",
    "        for (int songId : songs.keySet()) {",
    "            int uniqueCount = uniqueListeners.getOrDefault(songId, new HashSet<>()).size();",
    "            songData.add(new int[]{songId, uniqueCount});",
    "        }",
    "        ",
    "        // Sort: primary by -uniqueCount (desc), secondary by songId (asc)",
    "        songData.sort((a, b) -> {",
    "            if (a[1] != b[1]) return b[1] - a[1];  // desc by unique count",
    "            return a[0] - b[0];  // asc by song ID",
    "        });",
    "        ",
    "        List<String> result = new ArrayList<>();",
    "        for (int[] data : songData) {",
    "            result.add(songs.get(data[0]));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get the most recent plays (may include duplicates). [Part 2]",
    "     * @param count Number of recent plays to return",
    "     * @return List of song names, most recent first",
    "     */",
    "    public List<String> getRecentPlays(int count) {",
    "        if (count <= 0) {",
    "            return new ArrayList<>();",
    "        }",
    "        ",
    "        List<String> result = new ArrayList<>();",
    "        int start = Math.max(0, playHistory.size() - count);",
    "        ",
    "        // Collect from end, then reverse",
    "        for (int i = playHistory.size() - 1; i >= start; i--) {",
    "            result.add(playHistory.get(i));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get the most recently played UNIQUE songs (no duplicates). [Part 3]",
    "     * ",
    "     * Each song appears only once, at its most recent position.",
    "     * Uses backward iteration with a seen-set for O(n) performance.",
    "     * ",
    "     * @param count Maximum number of unique recent songs to return",
    "     * @return List of unique song names, most recent first.",
    "     *         May return fewer than 'count' if fewer unique songs exist.",
    "     */",
    "    public List<String> getRecentUniquePlays(int count) {",
    "        if (count <= 0) {",
    "            return new ArrayList<>();",
    "        }",
    "        ",
    "        List<String> result = new ArrayList<>();",
    "        Set<String> seen = new HashSet<>();",
    "        ",
    "        // Iterate backwards: most recent to oldest",
    "        for (int i = playHistory.size() - 1; i >= 0; i--) {",
    "            String songName = playHistory.get(i);",
    "            ",
    "            // Only add if not seen before",
    "            if (!seen.contains(songName)) {",
    "                seen.add(songName);",
    "                result.add(songName);",
    "                ",
    "                // Early termination when we have enough",
    "                if (result.size() >= count) {",
    "                    break;",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Main method to demonstrate the SongAnalytics system.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"SONG ANALYTICS SYSTEM - Part 3: Recent Unique Plays Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        ",
    "        // Add songs",
    "        int idA = analytics.addSong(\"A\");",
    "        int idB = analytics.addSong(\"B\");",
    "        int idC = analytics.addSong(\"C\");",
    "        System.out.printf(\"%nAdded songs: A(id=%d), B(id=%d), C(id=%d)%n\", idA, idB, idC);",
    "        ",
    "        // Play sequence: A -> B -> A -> C -> A -> B",
    "        System.out.println(\"\\nPlay sequence:\");",
    "        analytics.playSong(idA, 1); System.out.println(\"  User 1 plays 'A'\");",
    "        analytics.playSong(idB, 1); System.out.println(\"  User 1 plays 'B'\");",
    "        analytics.playSong(idA, 2); System.out.println(\"  User 2 plays 'A'\");",
    "        analytics.playSong(idC, 1); System.out.println(\"  User 1 plays 'C'\");",
    "        analytics.playSong(idA, 3); System.out.println(\"  User 3 plays 'A'\");",
    "        analytics.playSong(idB, 2); System.out.println(\"  User 2 plays 'B'\");",
    "        ",
    "        System.out.println(\"\\n\" + \"-\".repeat(60));",
    "        System.out.println(\"COMPARISON: Recent Plays vs Recent UNIQUE Plays\");",
    "        System.out.println(\"-\".repeat(60));",
    "        ",
    "        // Part 2: Recent plays (with duplicates)",
    "        List<String> recent = analytics.getRecentPlays(4);",
    "        System.out.printf(\"%ngetRecentPlays(4):       %s%n\", recent);",
    "        System.out.println(\"  (duplicates allowed - raw last 4 plays)\");",
    "        ",
    "        // Part 3: Recent unique plays (no duplicates)",
    "        List<String> unique = analytics.getRecentUniquePlays(4);",
    "        System.out.printf(\"%ngetRecentUniquePlays(4): %s%n\", unique);",
    "        System.out.println(\"  (unique only - only 3 distinct songs exist!)\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-4 (Python)",
      "explanation": "Import required types: List, Dict, Set for type hints, and defaultdict for automatic set creation"
    },
    {
      "lines": "14-18 (Python)",
      "explanation": "Constructor initializes all data structures. play_history is the key structure from Part 2 that we'll iterate over"
    },
    {
      "lines": "82-110 (Python)",
      "explanation": "The NEW get_recent_unique_plays method. Core logic: backward iteration with seen-set tracking"
    },
    {
      "lines": "92-93 (Python)",
      "explanation": "Initialize empty result list and seen set - these are temporary for the query only"
    },
    {
      "lines": "96-106 (Python)",
      "explanation": "Backward iteration loop: range(len-1, -1, -1) gives us indices from last to first"
    },
    {
      "lines": "100-106 (Python)",
      "explanation": "Core dedup logic: check if song in seen, if not add to both seen and result, early exit when count reached"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_recent_unique_plays": {
          "complexity": "O(n)",
          "explanation": "Worst case iterates through all n plays in history. Best case is O(count) if last 'count' plays are all unique. HashSet operations are O(1). Early termination helps average case."
        }
      },
      "existing_methods_unchanged": {
        "add_song": "O(1) - unchanged",
        "play_song": "O(1) - unchanged, still just appends to history",
        "get_sorted_report": "O(s log s) - unchanged, where s = number of songs",
        "get_recent_plays": "O(count) - unchanged"
      },
      "overall_change": "No change to existing methods. New method is O(n) worst case."
    },
    "space": {
      "additional_space": "O(min(count, unique_songs))",
      "explanation": "The 'seen' set and 'result' list are both bounded by the smaller of: requested count, or total unique songs in history. These are temporary - no persistent storage added beyond Part 2."
    }
  },
  "dry_run": {
    "example_input": "Songs: A(1), B(2), C(3). Plays: A\u2192B\u2192A\u2192C\u2192A\u2192B. Query: getRecentUniquePlays(3)",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "result=[], seen={}, i=5",
        "explanation": "Start at the end of play_history which is [A,B,A,C,A,B]"
      },
      {
        "step": 2,
        "action": "Check playHistory[5]='B'",
        "state": "'B' not in seen \u2192 Add to seen and result",
        "explanation": "First unique song found: B (most recent)"
      },
      {
        "step": 3,
        "action": "After processing i=5",
        "state": "result=['B'], seen={'B'}, i\u21924",
        "explanation": "len(result)=1 < count=3, continue"
      },
      {
        "step": 4,
        "action": "Check playHistory[4]='A'",
        "state": "'A' not in seen \u2192 Add to seen and result",
        "explanation": "Second unique song found: A (its most recent position)"
      },
      {
        "step": 5,
        "action": "After processing i=4",
        "state": "result=['B','A'], seen={'B','A'}, i\u21923",
        "explanation": "len(result)=2 < count=3, continue"
      },
      {
        "step": 6,
        "action": "Check playHistory[3]='C'",
        "state": "'C' not in seen \u2192 Add to seen and result",
        "explanation": "Third unique song found: C"
      },
      {
        "step": 7,
        "action": "After processing i=3",
        "state": "result=['B','A','C'], seen={'B','A','C'}",
        "explanation": "len(result)=3 == count=3 \u2192 BREAK!"
      }
    ],
    "final_output": "['B', 'A', 'C']"
  },
  "edge_cases": [
    {
      "case": "count = 0",
      "handling": "Return empty list immediately",
      "gotcha": "Don't iterate at all if count is 0 or negative"
    },
    {
      "case": "count > unique songs in history",
      "handling": "Return all unique songs (fewer than requested)",
      "gotcha": "The loop naturally terminates when reaching beginning of history"
    },
    {
      "case": "Empty play history",
      "handling": "Loop doesn't execute, return empty list",
      "gotcha": "range(len-1, -1, -1) with len=0 gives range(-1, -1, -1) which is empty"
    },
    {
      "case": "Same song played many times",
      "handling": "Only first encounter (most recent) is added, rest skipped",
      "gotcha": "History [A,A,A,A,A] with count=5 returns ['A'] - only 1 unique!"
    },
    {
      "case": "All unique songs (no duplicates in history)",
      "handling": "Same as getRecentPlays but with early termination",
      "gotcha": "Performs same as Part 2 in this case"
    }
  ],
  "test_cases": [
    {
      "name": "Basic functionality with duplicates",
      "input": "Plays: A\u2192B\u2192A\u2192C\u2192A\u2192B, getRecentUniquePlays(3)",
      "expected": "['B', 'A', 'C']",
      "explanation": "B is most recent, A second (skipping older A's), C third"
    },
    {
      "name": "Request more than unique songs exist",
      "input": "Plays: A\u2192B\u2192A, getRecentUniquePlays(5)",
      "expected": "['A', 'B']",
      "explanation": "Only 2 unique songs, return both even though 5 requested"
    },
    {
      "name": "Single song repeated",
      "input": "Plays: X\u2192X\u2192X\u2192X\u2192X, getRecentUniquePlays(3)",
      "expected": "['X']",
      "explanation": "Only 1 unique song despite 5 plays"
    },
    {
      "name": "All unique plays",
      "input": "Plays: A\u2192B\u2192C\u2192D\u2192E, getRecentUniquePlays(3)",
      "expected": "['E', 'D', 'C']",
      "explanation": "No duplicates, just take last 3 reversed"
    },
    {
      "name": "Zero count",
      "input": "Plays: A\u2192B\u2192C, getRecentUniquePlays(0)",
      "expected": "[]",
      "explanation": "Edge case: requesting 0 returns empty"
    },
    {
      "name": "Empty history",
      "input": "No plays, getRecentUniquePlays(5)",
      "expected": "[]",
      "explanation": "No plays recorded, nothing to return"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Filtering getRecentPlays result instead of full history",
      "why_wrong": "getRecentPlays(count) only returns 'count' items. If those have duplicates, you'll get fewer unique songs than potentially exist in the full history window.",
      "correct_approach": "Always iterate through the full play_history backwards, stopping only when you have enough unique songs.",
      "code_example_wrong": "# WRONG: May miss unique songs\nunique = []\nfor song in self.get_recent_plays(count):\n    if song not in unique:\n        unique.append(song)\nreturn unique[:count]",
      "code_example_correct": "# CORRECT: Iterate full history backwards\nresult, seen = [], set()\nfor i in range(len(self._play_history) - 1, -1, -1):\n    song = self._play_history[i]\n    if song not in seen:\n        seen.add(song)\n        result.append(song)\n        if len(result) >= count:\n            break\nreturn result"
    },
    {
      "mistake": "Using a list instead of set for 'seen' tracking",
      "why_wrong": "Checking 'if song in list' is O(n), making overall complexity O(n\u00b2)",
      "correct_approach": "Use a HashSet for O(1) lookup when checking if song was already seen",
      "code_example_wrong": "seen = []  # WRONG: O(n) lookup\nif song not in seen:  # O(n) each time",
      "code_example_correct": "seen = set()  # CORRECT: O(1) lookup\nif song not in seen:  # O(1) each time"
    },
    {
      "mistake": "Forgetting early termination",
      "why_wrong": "Without early break, you iterate through entire history even when you already have enough unique songs",
      "correct_approach": "Check len(result) >= count after each addition and break",
      "code_example_wrong": "for i in range(len(history) - 1, -1, -1):\n    if song not in seen:\n        result.append(song)\n# WRONG: No break, always iterates everything",
      "code_example_correct": "for i in range(len(history) - 1, -1, -1):\n    if song not in seen:\n        result.append(song)\n        if len(result) >= count:\n            break  # CORRECT: Early termination"
    },
    {
      "mistake": "Iterating forward then reversing",
      "why_wrong": "This would give oldest unique plays, not most recent. Order matters!",
      "correct_approach": "Always iterate backwards so first encounter = most recent play",
      "code_example_wrong": "# WRONG: Gives oldest unique plays\nfor song in self._play_history:\n    if song not in seen:\n        result.append(song)\nreturn result[:count][::-1]  # Reversal won't fix semantic issue",
      "code_example_correct": "# CORRECT: Iterate backwards\nfor i in range(len(self._play_history) - 1, -1, -1):\n    ..."
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the difference from Part 2: 'Now we need unique songs, where each song's position is its MOST RECENT play.' Then explain the backward iteration insight: 'By iterating backwards, the first time I see a song IS its most recent occurrence.' Draw a quick example on the whiteboard.",
    "what_to_mention": [
      "Key insight: backward iteration makes 'first seen = most recent' naturally true",
      "No new persistent data structures needed - reuse play_history from Part 2",
      "HashSet for O(1) seen-checking is crucial for O(n) overall",
      "Early termination optimization when we have enough unique songs",
      "Graceful handling when fewer unique songs exist than requested"
    ],
    "time_allocation": "2 min to understand and clarify, 3 min to explain approach with example, 5 min to code, 2 min to trace through example, 2 min for edge cases",
    "if_stuck": [
      "Think about what 'most recent unique' means - which occurrence of a repeated song should count?",
      "What if you read the history backwards instead of forwards?",
      "How do you efficiently check 'have I seen this before'?",
      "When can you stop early to avoid unnecessary work?"
    ]
  },
  "connection_to_next_part": "Part 3's backward iteration pattern and seen-set tracking could be extended in Part 4 for more complex queries like 'recent unique plays by a specific user' or 'unique songs in a time window'. The play_history might need to store (song_name, user_id, timestamp) tuples for richer analytics.",
  "generated_at": "2026-01-14T15:34:45.970420",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}