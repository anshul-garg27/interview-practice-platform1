{
  "problem_title": "Task Scheduling with Dependencies",
  "difficulty": "medium",
  "category": "DSA/Graphs",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **graph problem** combining topological sorting with critical path analysis. The dependency structure naturally forms a Directed Acyclic Graph (DAG), and we need to find both a valid execution order and the minimum completion time with unlimited parallelism.",
    "pattern_recognition": "**Topological Sort (Kahn's Algorithm)** + **Critical Path Method (CPM)** + **BFS** + **Cycle Detection**. This combines multiple fundamental graph algorithms into one practical scheduling problem.",
    "key_constraints": [
      "Task IDs are non-consecutive (1 to 10\u2075) - must use HashMap, not array",
      "Up to 10\u2074 tasks and 10\u2075 dependencies - need O(V+E) algorithm",
      "Cycle detection required - topological sort handles this naturally",
      "Unlimited workers - total time = critical path length, not sum of durations"
    ],
    "clarifying_questions": [
      "**Are task IDs guaranteed to be consecutive?** No - this means we need HashMaps, not arrays. Critical for implementation.",
      "**What does 'unlimited workers' mean exactly?** Tasks without dependencies on each other run in parallel - total time is the critical path.",
      "**Can there be duplicate dependencies?** Good to clarify - we should handle gracefully.",
      "**What if a dependency references a non-existent task?** Should we validate or assume valid input?",
      "**For multiple valid orders, any preference?** Confirms any topological order is acceptable.",
      "**Are self-loops (task depends on itself) considered cycles?** Yes, they should return [-1, []]."
    ],
    "edge_cases_to_consider": [
      "Single task with no dependencies",
      "All tasks independent (no dependencies) - fully parallel",
      "Linear chain - fully sequential, no parallelism",
      "Cycle detection - simple cycle, self-loop",
      "Multiple disconnected components",
      "Diamond dependency pattern",
      "Task with many prerequisites converging"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    TASK SCHEDULING OVERVIEW                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  INPUT:                           PROCESS:                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502  \u2502 Tasks:           \u2502             \u2502 1. Build Graph      \u2502               \u2502\n\u2502  \u2502 [1,3] [2,2]      \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 2. Topological Sort \u2502               \u2502\n\u2502  \u2502 [3,5] [4,3]      \u2502             \u2502 3. Critical Path    \u2502               \u2502\n\u2502  \u2502                  \u2502             \u2502 4. Cycle Detection  \u2502               \u2502\n\u2502  \u2502 Dependencies:    \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502  \u2502 1\u21922, 1\u21923        \u2502                        \u2502                          \u2502\n\u2502  \u2502 2\u21924, 3\u21924        \u2502                        \u25bc                          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n\u2502                                   \u2502 OUTPUT:             \u2502               \u2502\n\u2502  GRAPH:                           \u2502 Order: [1,2,3,4]    \u2502               \u2502\n\u2502       \u250c\u2500\u25001(3)\u2500\u2500\u2510                  \u2502 Time: 11            \u2502               \u2502\n\u2502       \u2502        \u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502       \u25bc        \u25bc                                                        \u2502\n\u2502     2(2)     3(5)                 TIMELINE (Parallel):                  \u2502\n\u2502       \u2502        \u2502                  t=0   t=3   t=5   t=8   t=11          \u2502\n\u2502       \u25bc        \u25bc                  \u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2502             \u2502\n\u2502       \u2514\u2500\u25004(3)\u2500\u2500\u2518                  \u2588\u2588\u2588\u25881\u2588\u2588\u2588\u2588                             \u2502\n\u2502                                        \u2588\u2588\u25882\u2588\u2588\u2588                          \u2502\n\u2502  In-degrees:                           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u25883\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588                \u2502\n\u2502  1:0, 2:1, 3:1, 4:2                                 \u2588\u2588\u2588\u25884\u2588\u2588\u2588\u2588           \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DATA STRUCTURES EVOLUTION                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                         \u2502\n\u2502  1. GRAPH (adjacency list):           2. REVERSE GRAPH (for prereqs):  \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502     \u2502 Key \u2502 Dependents   \u2502               \u2502 Key \u2502 Prerequisites\u2502        \u2502\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u2502\n\u2502     \u2502  1  \u2502  [2, 3]      \u2502               \u2502  1  \u2502  []          \u2502        \u2502\n\u2502     \u2502  2  \u2502  [4]         \u2502               \u2502  2  \u2502  [1]         \u2502        \u2502\n\u2502     \u2502  3  \u2502  [4]         \u2502               \u2502  3  \u2502  [1]         \u2502        \u2502\n\u2502     \u2502  4  \u2502  []          \u2502               \u2502  4  \u2502  [2, 3]      \u2502        \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502                                                                         \u2502\n\u2502  3. IN-DEGREE MAP:                    4. DURATION MAP:                  \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502     \u2502Task \u2502 In-degree \u2502                  \u2502Task \u2502 Duration  \u2502           \u2502\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524           \u2502\n\u2502     \u2502  1  \u2502     0     \u2502\u25c0\u2500\u2500 Start here    \u2502  1  \u2502     3     \u2502           \u2502\n\u2502     \u2502  2  \u2502     1     \u2502                  \u2502  2  \u2502     2     \u2502           \u2502\n\u2502     \u2502  3  \u2502     1     \u2502                  \u2502  3  \u2502     5     \u2502           \u2502\n\u2502     \u2502  4  \u2502     2     \u2502                  \u2502  4  \u2502     3     \u2502           \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502                                                                         \u2502\n\u2502  5. START_TIME MAP (computed during BFS):                               \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502     \u2502Task \u2502Start Time \u2502 Formula                               \u2502        \u2502\n\u2502     \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u2502\n\u2502     \u2502  1  \u2502     0     \u2502 No prereqs                            \u2502        \u2502\n\u2502     \u2502  2  \u2502     3     \u2502 max(end[1]) = 0+3 = 3                 \u2502        \u2502\n\u2502     \u2502  3  \u2502     3     \u2502 max(end[1]) = 0+3 = 3                 \u2502        \u2502\n\u2502     \u2502  4  \u2502     8     \u2502 max(end[2],end[3]) = max(5,8) = 8     \u2502        \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502                                                                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**Build Graph** - Create adjacency list and compute in-degrees",
        "visualization": "```\nInput: deps = [[1,2],[1,3],[2,4],[3,4]]\n\nProcess each dependency [a,b]: \"a must complete before b\"\n\ngraph[1].append(2)  \u2192  1 \u2500\u2500\u25b6 2\ngraph[1].append(3)  \u2192  1 \u2500\u2500\u25b6 3  \ngraph[2].append(4)  \u2192  2 \u2500\u2500\u25b6 4\ngraph[3].append(4)  \u2192  3 \u2500\u2500\u25b6 4\n\nin_degree[2]++, in_degree[3]++, in_degree[4] += 2\n\nResult: in_degree = {1:0, 2:1, 3:1, 4:2}\n```",
        "key_point": "Graph represents \"who depends on me\", in_degree represents \"how many I depend on\""
      },
      {
        "step": 2,
        "description": "**Initialize Queue** - Start with tasks having in_degree = 0",
        "visualization": "```\nFind all tasks with in_degree = 0:\n  Task 1: in_degree[1] = 0 \u2713\n\nqueue = [1]\nstart_time = {1: 0}  // Task 1 can start immediately\norder = []\n```",
        "key_point": "Tasks with no prerequisites can start immediately at time 0"
      },
      {
        "step": 3,
        "description": "**Process Task 1** - Dequeue, add to order, update dependents",
        "visualization": "```\nDequeue: task = 1\norder = [1]\ncompletion_time[1] = start_time[1] + duration[1] = 0 + 3 = 3\n\nUpdate dependents of 1: [2, 3]\n  Task 2: in_degree[2] = 1-1 = 0 \u2192 add to queue\n          start_time[2] = max(-, 3) = 3\n  Task 3: in_degree[3] = 1-1 = 0 \u2192 add to queue\n          start_time[3] = max(-, 3) = 3\n\nqueue = [2, 3]\n```",
        "key_point": "When task completes, its dependents can potentially start"
      },
      {
        "step": 4,
        "description": "**Process Tasks 2 and 3** - Both available, process in queue order",
        "visualization": "```\n--- Process Task 2 ---\nDequeue: task = 2\norder = [1, 2]\ncompletion_time[2] = start_time[2] + duration[2] = 3 + 2 = 5\n\nUpdate dependents: [4]\n  Task 4: in_degree[4] = 2-1 = 1 (not ready yet!)\n          start_time[4] = max(-, 5) = 5\n\n--- Process Task 3 ---\nDequeue: task = 3\norder = [1, 2, 3]\ncompletion_time[3] = start_time[3] + duration[3] = 3 + 5 = 8\n\nUpdate dependents: [4]\n  Task 4: in_degree[4] = 1-1 = 0 \u2192 add to queue!\n          start_time[4] = max(5, 8) = 8  \u2190 CRITICAL!\n\nqueue = [4]\n```",
        "key_point": "Task 4 waits for BOTH 2 and 3 - start time is MAX of completions"
      },
      {
        "step": 5,
        "description": "**Process Task 4** - Final task in critical path",
        "visualization": "```\nDequeue: task = 4\norder = [1, 2, 3, 4]\ncompletion_time[4] = start_time[4] + duration[4] = 8 + 3 = 11\n\nNo dependents to update.\nqueue = []\n\nAll tasks processed: len(order) = 4 = len(tasks) \u2713 (no cycle)\n\nmax_completion = max(3, 5, 8, 11) = 11\n\nRETURN: (11, [1, 2, 3, 4])\n```",
        "key_point": "Total time is the maximum completion time across all tasks"
      }
    ],
    "dry_run_table": "| Step | Queue | Dequeue | Order | Task Completion | Updates | Start Times |\n|------|-------|---------|-------|-----------------|---------|-------------|\n| Init | [1] | - | [] | - | - | {1:0} |\n| 1 | [2,3] | 1 | [1] | end[1]=3 | 2,3 ready | {1:0, 2:3, 3:3} |\n| 2 | [3] | 2 | [1,2] | end[2]=5 | 4 partial | {1:0, 2:3, 3:3, 4:5} |\n| 3 | [4] | 3 | [1,2,3] | end[3]=8 | 4 ready! | {1:0, 2:3, 3:3, 4:8} |\n| 4 | [] | 4 | [1,2,3,4] | end[4]=11 | done | {1:0, 2:3, 3:3, 4:8} |\n| **Result** | - | - | **[1,2,3,4]** | **max=11** | - | - |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'dependencies' between tasks**, I immediately think of a **directed graph** where edges represent 'must complete before' relationships",
      "**When I see 'valid execution order'**, I think of **topological sort** - the classic algorithm for ordering nodes respecting dependencies",
      "**When I see 'cycle detection'**, I know Kahn's algorithm handles this naturally - if we can't process all nodes, there's a cycle",
      "**When I see 'minimum time with unlimited workers'**, I realize this is the **Critical Path Method** - tasks can run in parallel, so total time is the longest dependency chain",
      "**The key insight**: These two requirements (order + time) can be computed **simultaneously** during one topological sort pass",
      "**For non-consecutive task IDs**, I must use **HashMaps** instead of arrays - this is a common interview gotcha"
    ],
    "key_insight": "The **minimum completion time equals the critical path length**, not the sum of all durations. With unlimited parallelism, independent tasks run simultaneously. We track the **earliest possible start time** for each task, which equals the **maximum completion time** of all its prerequisites.",
    "why_this_works": "Kahn's algorithm processes tasks in topological order using in-degrees. A task is processed only when all its prerequisites are done (in_degree = 0). By maintaining `start_time[task] = max(completion_time[prereq])` for all prerequisites, we correctly model parallel execution. The algorithm also naturally detects cycles - if any tasks remain unprocessed after BFS completes, they must be part of a cycle."
  },
  "approaches": [
    {
      "name": "Brute Force: DFS with Memoization",
      "description": "For each task, recursively compute completion time by checking all paths through dependencies",
      "pseudocode": "def get_completion_time(task):\n    if task in memo:\n        return memo[task]\n    \n    max_prereq = 0\n    for prereq in prerequisites[task]:\n        max_prereq = max(max_prereq, get_completion_time(prereq))\n    \n    memo[task] = max_prereq + duration[task]\n    return memo[task]\n\n# For each task, call get_completion_time\n# Total = max(all completion times)",
      "time_complexity": "O(V + E) with memoization",
      "space_complexity": "O(V) for memo + O(V) recursion stack",
      "pros": [
        "Intuitive recursive thinking",
        "Works well for single queries"
      ],
      "cons": [
        "Recursion stack can overflow for deep graphs",
        "Harder to detect cycles cleanly",
        "Doesn't naturally produce topological order"
      ],
      "when_to_use": "Quick prototyping or when only critical path is needed (not order)"
    },
    {
      "name": "Optimal: Kahn's Algorithm with Critical Path",
      "description": "BFS-based topological sort that simultaneously computes the critical path by tracking start times",
      "pseudocode": "1. Build graph and in-degree map\n2. Initialize queue with in_degree=0 tasks, start_time=0\n3. While queue not empty:\n   a. Dequeue task, add to order\n   b. Calculate completion = start_time + duration\n   c. For each dependent:\n      - Decrement in_degree\n      - Update start_time = max(current, completion)\n      - If in_degree=0, enqueue\n4. If len(order) < len(tasks): CYCLE!\n5. Return (max_completion, order)",
      "time_complexity": "O(V + E) where V = tasks, E = dependencies",
      "space_complexity": "O(V + E) for graph storage",
      "pros": [
        "Single pass computes both order and time",
        "Natural cycle detection",
        "No recursion (no stack overflow)",
        "Industry standard approach"
      ],
      "cons": [
        "Slightly more complex than pure DFS"
      ],
      "key_insight": "Process tasks in dependency order, tracking when each can START based on when prerequisites END"
    }
  ],
  "optimal_solution": {
    "name": "Kahn's Algorithm with Integrated Critical Path Calculation",
    "explanation_md": "## Approach\n\nWe solve both requirements (topological order and minimum time) in a **single BFS pass** using Kahn's algorithm enhanced with start time tracking.\n\n### Core Idea\n\n1. **Build the dependency graph** as an adjacency list\n2. **Track in-degrees** to know when a task's prerequisites are satisfied\n3. **Track start times** to compute critical path\n\n### Why Kahn's Algorithm?\n\n- **BFS-based**: Processes tasks level by level, naturally respecting dependencies\n- **Cycle detection**: If we can't process all tasks, remaining tasks form a cycle\n- **No recursion**: Avoids stack overflow on large inputs\n\n### Critical Path Calculation\n\n```\nstart_time[task] = max(completion_time[prereq]) for all prerequisites\ncompletion_time[task] = start_time[task] + duration[task]\ntotal_time = max(completion_time[task]) for all tasks\n```\n\n### Why This is Optimal\n\n- **Time: O(V + E)** - Each task and dependency processed exactly once\n- **Space: O(V + E)** - Graph storage is necessary\n- **Single Pass** - Order and time computed together",
    "data_structures": [
      {
        "structure": "HashMap<taskId, List<dependentIds>>",
        "purpose": "Adjacency list - O(1) lookup of who depends on each task"
      },
      {
        "structure": "HashMap<taskId, List<prereqIds>>",
        "purpose": "Reverse graph - O(1) lookup of prerequisites (for path reconstruction)"
      },
      {
        "structure": "HashMap<taskId, int>",
        "purpose": "Duration map - O(1) lookup of task duration"
      },
      {
        "structure": "HashMap<taskId, int>",
        "purpose": "In-degree map - Tracks remaining prerequisites for each task"
      },
      {
        "structure": "HashMap<taskId, int>",
        "purpose": "Start time map - Earliest possible start time for each task"
      },
      {
        "structure": "Deque<taskId>",
        "purpose": "BFS queue - Tasks ready to be processed (in_degree = 0)"
      }
    ],
    "algorithm_steps": [
      "1. **Parse Input**: Build duration map from task_list",
      "2. **Build Graph**: For each dependency [a,b], add b to graph[a], increment in_degree[b]",
      "3. **Initialize BFS**: Add all tasks with in_degree=0 to queue, set their start_time=0",
      "4. **Process Queue**: For each task, calculate completion time, update dependent start times",
      "5. **Cycle Check**: If processed count < total tasks, return (-1, [])",
      "6. **Return Results**: (max_completion_time, topological_order)"
    ],
    "why_decimal": "Not applicable for this problem - durations are integers"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Task Scheduling with Dependencies",
    "",
    "This module implements a task scheduler that:",
    "1. Finds a valid execution order (topological sort)",
    "2. Calculates minimum completion time (critical path)",
    "3. Detects cycles in dependencies",
    "",
    "Algorithm: Kahn's Algorithm (BFS-based topological sort)",
    "Time Complexity: O(V + E) where V = tasks, E = dependencies",
    "Space Complexity: O(V + E) for graph storage",
    "\"\"\"",
    "",
    "from collections import defaultdict, deque",
    "from typing import List, Tuple, Dict, Set",
    "",
    "",
    "class TaskScheduler:",
    "    \"\"\"",
    "    A task scheduler that handles dependencies using topological sort",
    "    and calculates critical path for minimum completion time.",
    "    ",
    "    Attributes:",
    "        graph: Adjacency list mapping task -> list of dependent tasks",
    "        duration: Mapping of task_id -> task duration",
    "        in_degree: Mapping of task_id -> number of prerequisites",
    "        tasks: Set of all task IDs",
    "    ",
    "    Example:",
    "        >>> scheduler = TaskScheduler()",
    "        >>> tasks = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "        >>> deps = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "        >>> scheduler.schedule_tasks(tasks, deps)",
    "        (11, [1, 2, 3, 4])",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize empty data structures.\"\"\"",
    "        self.graph: Dict[int, List[int]] = defaultdict(list)",
    "        self.duration: Dict[int, int] = {}",
    "        self.in_degree: Dict[int, int] = defaultdict(int)",
    "        self.tasks: Set[int] = set()",
    "    ",
    "    def _reset(self) -> None:",
    "        \"\"\"Reset all data structures for a new scheduling request.\"\"\"",
    "        self.graph = defaultdict(list)",
    "        self.duration = {}",
    "        self.in_degree = defaultdict(int)",
    "        self.tasks = set()",
    "    ",
    "    def _build_graph(self, task_list: List[List[int]], ",
    "                     dependency_list: List[List[int]]) -> bool:",
    "        \"\"\"",
    "        Build adjacency list and compute in-degrees.",
    "        ",
    "        Args:",
    "            task_list: List of [task_id, duration] pairs",
    "            dependency_list: List of [prereq, dependent] pairs",
    "        ",
    "        Returns:",
    "            True if graph built successfully, False if invalid input",
    "        \"\"\"",
    "        # Register all tasks with their durations",
    "        for task_id, task_duration in task_list:",
    "            self.tasks.add(task_id)",
    "            self.duration[task_id] = task_duration",
    "            self.in_degree[task_id] = 0  # Initialize to 0",
    "        ",
    "        # Build dependency graph",
    "        for prereq, dependent in dependency_list:",
    "            # Validate that both tasks exist",
    "            if prereq not in self.tasks or dependent not in self.tasks:",
    "                continue  # Skip invalid dependencies",
    "            ",
    "            # Skip self-loops (would cause cycle)",
    "            if prereq == dependent:",
    "                return False",
    "            ",
    "            self.graph[prereq].append(dependent)",
    "            self.in_degree[dependent] += 1",
    "        ",
    "        return True",
    "    ",
    "    def _topological_sort_with_critical_path(self) -> Tuple[int, List[int]]:",
    "        \"\"\"",
    "        Perform topological sort while calculating critical path.",
    "        ",
    "        Uses Kahn's algorithm (BFS-based) for topological sorting.",
    "        Simultaneously tracks start times to compute critical path.",
    "        ",
    "        Returns:",
    "            Tuple of (total_duration, execution_order)",
    "            Returns (-1, []) if a cycle is detected",
    "        \"\"\"",
    "        # Initialize queue with tasks having no prerequisites",
    "        queue: deque = deque()",
    "        start_time: Dict[int, int] = {}",
    "        ",
    "        for task in self.tasks:",
    "            if self.in_degree[task] == 0:",
    "                queue.append(task)",
    "                start_time[task] = 0  # Can start immediately",
    "        ",
    "        order: List[int] = []",
    "        max_completion: int = 0",
    "        ",
    "        while queue:",
    "            # Process next available task",
    "            task = queue.popleft()",
    "            order.append(task)",
    "            ",
    "            # Calculate when this task completes",
    "            task_completion = start_time[task] + self.duration[task]",
    "            max_completion = max(max_completion, task_completion)",
    "            ",
    "            # Update all tasks that depend on this one",
    "            for dependent in self.graph[task]:",
    "                # Decrease in-degree (one less prerequisite to wait for)",
    "                self.in_degree[dependent] -= 1",
    "                ",
    "                # Update earliest start time for dependent",
    "                # Dependent can start only after this task completes",
    "                if dependent not in start_time:",
    "                    start_time[dependent] = task_completion",
    "                else:",
    "                    # Take max if multiple prerequisites",
    "                    start_time[dependent] = max(",
    "                        start_time[dependent], ",
    "                        task_completion",
    "                    )",
    "                ",
    "                # If all prerequisites done, task is ready",
    "                if self.in_degree[dependent] == 0:",
    "                    queue.append(dependent)",
    "        ",
    "        # Cycle detection: if we couldn't process all tasks, there's a cycle",
    "        if len(order) != len(self.tasks):",
    "            return (-1, [])",
    "        ",
    "        return (max_completion, order)",
    "    ",
    "    def schedule_tasks(self, task_list: List[List[int]], ",
    "                       dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "        \"\"\"",
    "        Schedule tasks respecting dependencies and calculate minimum time.",
    "        ",
    "        Args:",
    "            task_list: List of [task_id, duration] pairs.",
    "                       Task IDs are unique integers (not necessarily consecutive).",
    "            dependency_list: List of [prereq, dependent] pairs.",
    "                            Means prereq must complete before dependent starts.",
    "        ",
    "        Returns:",
    "            Tuple of (minimum_total_duration, valid_execution_order).",
    "            Returns (-1, []) if dependencies contain a cycle.",
    "        ",
    "        Example:",
    "            >>> scheduler = TaskScheduler()",
    "            >>> scheduler.schedule_tasks([[1,3],[2,2],[3,5],[4,3]], ",
    "            ...                          [[1,2],[1,3],[2,4],[3,4]])",
    "            (11, [1, 2, 3, 4])",
    "        \"\"\"",
    "        # Handle edge cases",
    "        if not task_list:",
    "            return (0, [])",
    "        ",
    "        # Reset state for new request",
    "        self._reset()",
    "        ",
    "        # Build the dependency graph",
    "        if not self._build_graph(task_list, dependency_list):",
    "            return (-1, [])  # Self-loop detected",
    "        ",
    "        # Perform topological sort with critical path calculation",
    "        return self._topological_sort_with_critical_path()",
    "",
    "",
    "# Standalone function for direct usage (matches problem signature)",
    "def schedule_tasks(task_list: List[List[int]], ",
    "                   dependency_list: List[List[int]]) -> Tuple[int, List[int]]:",
    "    \"\"\"",
    "    Wrapper function for task scheduling.",
    "    ",
    "    Args:",
    "        task_list: List of [task_id, duration] pairs",
    "        dependency_list: List of [prereq, dependent] pairs",
    "    ",
    "    Returns:",
    "        Tuple of (minimum_duration, execution_order) or (-1, []) if cycle",
    "    \"\"\"",
    "    scheduler = TaskScheduler()",
    "    return scheduler.schedule_tasks(task_list, dependency_list)",
    "",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('TASK SCHEDULING WITH DEPENDENCIES - Demo')",
    "    print('=' * 60)",
    "    ",
    "    # Example 1: Diamond pattern",
    "    print('\\n--- Example 1: Diamond Pattern ---')",
    "    tasks1 = [[1, 3], [2, 2], [3, 5], [4, 3]]",
    "    deps1 = [[1, 2], [1, 3], [2, 4], [3, 4]]",
    "    result1 = schedule_tasks(tasks1, deps1)",
    "    print(f'Tasks: {tasks1}')",
    "    print(f'Dependencies: {deps1}')",
    "    print(f'Result: duration={result1[0]}, order={result1[1]}')",
    "    print('Expected: (11, [1, 2, 3, 4]) or similar valid order')",
    "    ",
    "    # Example 2: Independent tasks",
    "    print('\\n--- Example 2: Independent Tasks ---')",
    "    tasks2 = [[1, 5], [2, 3], [3, 4]]",
    "    deps2 = []",
    "    result2 = schedule_tasks(tasks2, deps2)",
    "    print(f'Tasks: {tasks2}')",
    "    print(f'Dependencies: {deps2}')",
    "    print(f'Result: duration={result2[0]}, order={result2[1]}')",
    "    print('Expected: (5, any permutation) - all run in parallel')",
    "    ",
    "    # Example 3: Linear chain",
    "    print('\\n--- Example 3: Linear Chain ---')",
    "    tasks3 = [[1, 2], [2, 3], [3, 1]]",
    "    deps3 = [[1, 2], [2, 3]]",
    "    result3 = schedule_tasks(tasks3, deps3)",
    "    print(f'Tasks: {tasks3}')",
    "    print(f'Dependencies: {deps3}')",
    "    print(f'Result: duration={result3[0]}, order={result3[1]}')",
    "    print('Expected: (6, [1, 2, 3]) - sequential execution')",
    "    ",
    "    # Example 4: Cycle detection",
    "    print('\\n--- Example 4: Cycle Detection ---')",
    "    tasks4 = [[1, 2], [2, 3], [3, 1]]",
    "    deps4 = [[1, 2], [2, 3], [3, 1]]",
    "    result4 = schedule_tasks(tasks4, deps4)",
    "    print(f'Tasks: {tasks4}')",
    "    print(f'Dependencies: {deps4}')",
    "    print(f'Result: duration={result4[0]}, order={result4[1]}')",
    "    print('Expected: (-1, []) - cycle detected')",
    "    ",
    "    # Example 5: Non-consecutive IDs",
    "    print('\\n--- Example 5: Non-consecutive Task IDs ---')",
    "    tasks5 = [[1, 2], [10, 3], [100, 4]]",
    "    deps5 = [[1, 10], [10, 100]]",
    "    result5 = schedule_tasks(tasks5, deps5)",
    "    print(f'Tasks: {tasks5}')",
    "    print(f'Dependencies: {deps5}')",
    "    print(f'Result: duration={result5[0]}, order={result5[1]}')",
    "    print('Expected: (9, [1, 10, 100])')",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('All demos completed successfully!')",
    "    print('=' * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Task Scheduling with Dependencies",
    " * ",
    " * Implements a task scheduler using Kahn's algorithm for topological sort",
    " * with integrated critical path calculation.",
    " * ",
    " * Time Complexity: O(V + E) where V = tasks, E = dependencies",
    " * Space Complexity: O(V + E) for graph storage",
    " */",
    "public class TaskScheduler {",
    "    ",
    "    // Adjacency list: task -> list of dependent tasks",
    "    private Map<Integer, List<Integer>> graph;",
    "    ",
    "    // Task durations",
    "    private Map<Integer, Integer> duration;",
    "    ",
    "    // Number of prerequisites for each task",
    "    private Map<Integer, Integer> inDegree;",
    "    ",
    "    // Set of all task IDs",
    "    private Set<Integer> tasks;",
    "    ",
    "    public TaskScheduler() {",
    "        reset();",
    "    }",
    "    ",
    "    /**",
    "     * Reset all data structures for a new scheduling request.",
    "     */",
    "    private void reset() {",
    "        graph = new HashMap<>();",
    "        duration = new HashMap<>();",
    "        inDegree = new HashMap<>();",
    "        tasks = new HashSet<>();",
    "    }",
    "    ",
    "    /**",
    "     * Build adjacency list and compute in-degrees.",
    "     * ",
    "     * @param taskList List of [task_id, duration] pairs",
    "     * @param dependencyList List of [prereq, dependent] pairs",
    "     * @return true if graph built successfully, false if self-loop detected",
    "     */",
    "    private boolean buildGraph(int[][] taskList, int[][] dependencyList) {",
    "        // Register all tasks",
    "        for (int[] task : taskList) {",
    "            int taskId = task[0];",
    "            int taskDuration = task[1];",
    "            tasks.add(taskId);",
    "            duration.put(taskId, taskDuration);",
    "            inDegree.put(taskId, 0);",
    "            graph.put(taskId, new ArrayList<>());",
    "        }",
    "        ",
    "        // Build dependency graph",
    "        for (int[] dep : dependencyList) {",
    "            int prereq = dep[0];",
    "            int dependent = dep[1];",
    "            ",
    "            // Skip invalid dependencies",
    "            if (!tasks.contains(prereq) || !tasks.contains(dependent)) {",
    "                continue;",
    "            }",
    "            ",
    "            // Self-loop is a cycle",
    "            if (prereq == dependent) {",
    "                return false;",
    "            }",
    "            ",
    "            graph.get(prereq).add(dependent);",
    "            inDegree.put(dependent, inDegree.get(dependent) + 1);",
    "        }",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Perform topological sort with critical path calculation.",
    "     * ",
    "     * @return [totalDuration, ...executionOrder] or [-1] if cycle detected",
    "     */",
    "    private int[] topologicalSortWithCriticalPath() {",
    "        Queue<Integer> queue = new LinkedList<>();",
    "        Map<Integer, Integer> startTime = new HashMap<>();",
    "        ",
    "        // Initialize with tasks having no prerequisites",
    "        for (int task : tasks) {",
    "            if (inDegree.get(task) == 0) {",
    "                queue.offer(task);",
    "                startTime.put(task, 0);",
    "            }",
    "        }",
    "        ",
    "        List<Integer> order = new ArrayList<>();",
    "        int maxCompletion = 0;",
    "        ",
    "        while (!queue.isEmpty()) {",
    "            int task = queue.poll();",
    "            order.add(task);",
    "            ",
    "            // Calculate completion time",
    "            int taskCompletion = startTime.get(task) + duration.get(task);",
    "            maxCompletion = Math.max(maxCompletion, taskCompletion);",
    "            ",
    "            // Update dependents",
    "            for (int dependent : graph.get(task)) {",
    "                inDegree.put(dependent, inDegree.get(dependent) - 1);",
    "                ",
    "                // Update start time",
    "                int currentStart = startTime.getOrDefault(dependent, 0);",
    "                startTime.put(dependent, Math.max(currentStart, taskCompletion));",
    "                ",
    "                if (inDegree.get(dependent) == 0) {",
    "                    queue.offer(dependent);",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Cycle detection",
    "        if (order.size() != tasks.size()) {",
    "            return new int[]{-1};",
    "        }",
    "        ",
    "        // Build result array: [duration, order...]",
    "        int[] result = new int[order.size() + 1];",
    "        result[0] = maxCompletion;",
    "        for (int i = 0; i < order.size(); i++) {",
    "            result[i + 1] = order.get(i);",
    "        }",
    "        ",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Schedule tasks respecting dependencies and calculate minimum time.",
    "     * ",
    "     * @param taskList Array of [task_id, duration] pairs",
    "     * @param dependencyList Array of [prereq, dependent] pairs",
    "     * @return Array where first element is duration, rest is order. [-1] if cycle.",
    "     */",
    "    public int[] scheduleTasks(int[][] taskList, int[][] dependencyList) {",
    "        if (taskList == null || taskList.length == 0) {",
    "            return new int[]{0};",
    "        }",
    "        ",
    "        reset();",
    "        ",
    "        if (!buildGraph(taskList, dependencyList)) {",
    "            return new int[]{-1};  // Self-loop detected",
    "        }",
    "        ",
    "        return topologicalSortWithCriticalPath();",
    "    }",
    "    ",
    "    /**",
    "     * Demo and test cases.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"TASK SCHEDULING WITH DEPENDENCIES - Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        TaskScheduler scheduler = new TaskScheduler();",
    "        ",
    "        // Example 1: Diamond pattern",
    "        System.out.println(\"\\n--- Example 1: Diamond Pattern ---\");",
    "        int[][] tasks1 = {{1, 3}, {2, 2}, {3, 5}, {4, 3}};",
    "        int[][] deps1 = {{1, 2}, {1, 3}, {2, 4}, {3, 4}};",
    "        int[] result1 = scheduler.scheduleTasks(tasks1, deps1);",
    "        System.out.println(\"Result: \" + Arrays.toString(result1));",
    "        System.out.println(\"Expected: [11, 1, 2, 3, 4] or similar valid order\");",
    "        ",
    "        // Example 2: Independent tasks",
    "        System.out.println(\"\\n--- Example 2: Independent Tasks ---\");",
    "        int[][] tasks2 = {{1, 5}, {2, 3}, {3, 4}};",
    "        int[][] deps2 = {};",
    "        int[] result2 = scheduler.scheduleTasks(tasks2, deps2);",
    "        System.out.println(\"Result: \" + Arrays.toString(result2));",
    "        System.out.println(\"Expected: [5, ...] - all run in parallel\");",
    "        ",
    "        // Example 3: Cycle detection",
    "        System.out.println(\"\\n--- Example 3: Cycle Detection ---\");",
    "        int[][] tasks3 = {{1, 2}, {2, 3}, {3, 1}};",
    "        int[][] deps3 = {{1, 2}, {2, 3}, {3, 1}};",
    "        int[] result3 = scheduler.scheduleTasks(tasks3, deps3);",
    "        System.out.println(\"Result: \" + Arrays.toString(result3));",
    "        System.out.println(\"Expected: [-1] - cycle detected\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All demos completed!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "section": "Module Documentation & Imports",
      "explanation": "The module docstring explains the problem and algorithm. We import `defaultdict` for automatic list initialization, `deque` for O(1) queue operations, and typing hints for clean interfaces."
    },
    {
      "lines": "18-36",
      "section": "Class Definition & __init__",
      "explanation": "The `TaskScheduler` class encapsulates all scheduling logic. We use **four main data structures**: `graph` (adjacency list for dependents), `duration` (task durations), `in_degree` (prerequisite counts), and `tasks` (set of all task IDs). The docstring shows expected usage."
    },
    {
      "lines": "38-43",
      "section": "_reset Method",
      "explanation": "Resets all data structures to allow reusing the same scheduler instance. This is important for handling multiple scheduling requests without creating new objects."
    },
    {
      "lines": "45-72",
      "section": "_build_graph Method",
      "explanation": "**Critical step**: Builds the dependency graph. First registers all tasks with duration and in_degree=0. Then processes each dependency `[prereq, dependent]` by adding an edge and incrementing in_degree. **Self-loops are detected here** and cause immediate failure (return False)."
    },
    {
      "lines": "74-118",
      "section": "_topological_sort_with_critical_path Method",
      "explanation": "**The heart of the algorithm**: Implements Kahn's BFS with critical path calculation. **Key insight**: Tasks with in_degree=0 start immediately (start_time=0). When processing a task, we calculate its completion time and update all dependents' start times using `max()`. A dependent is enqueued only when all prerequisites are processed (in_degree becomes 0). **Cycle detection**: If we process fewer tasks than exist, remaining tasks are in a cycle."
    },
    {
      "lines": "120-149",
      "section": "schedule_tasks Method (Main Entry Point)",
      "explanation": "Public API that orchestrates the scheduling. Handles edge cases (empty input), resets state, builds graph, and runs the algorithm. Returns tuple of (duration, order) or (-1, []) for cycles."
    },
    {
      "lines": "152-162",
      "section": "Standalone Function Wrapper",
      "explanation": "Provides a functional interface matching the problem signature. Creates a scheduler internally for stateless calls."
    },
    {
      "lines": "165-220",
      "section": "Main Demo Section",
      "explanation": "Comprehensive test cases demonstrating: (1) Diamond pattern with critical path, (2) Independent tasks running in parallel, (3) Linear chain with sequential execution, (4) Cycle detection, (5) Non-consecutive task IDs. Each test shows input, result, and expected output."
    }
  ],
  "complexity_analysis": {
    "time": {
      "build_graph": {
        "complexity": "O(V + E)",
        "explanation": "Process each task once (V) and each dependency once (E)"
      },
      "topological_sort": {
        "complexity": "O(V + E)",
        "explanation": "Each task dequeued once, each edge processed once when updating dependents"
      },
      "schedule_tasks": {
        "complexity": "O(V + E)",
        "explanation": "Sum of build_graph + topological_sort"
      },
      "overall": "**O(V + E)** where V = number of tasks, E = number of dependencies"
    },
    "space": {
      "complexity": "O(V + E)",
      "breakdown": "- **Graph (adjacency list)**: O(V + E) - V keys, E total edges\n- **Duration map**: O(V)\n- **In-degree map**: O(V)\n- **Start time map**: O(V)\n- **Queue**: O(V) worst case\n- **Order list**: O(V)",
      "note": "Cannot do better - we must store the entire graph to process dependencies"
    },
    "can_we_do_better": "**No** - O(V + E) is optimal because we must examine every task and every dependency at least once to determine the schedule and detect cycles."
  },
  "dry_run": {
    "example": "tasks=[[1,3],[2,2],[3,5],[4,3]], deps=[[1,2],[1,3],[2,4],[3,4]]",
    "trace_table": "| Step | Queue | Process | Order | Start Times | In-Degrees | Max Completion |\n|------|-------|---------|-------|-------------|------------|----------------|\n| Init | - | - | [] | {} | {1:0,2:1,3:1,4:2} | 0 |\n| 0 | [1] | - | [] | {1:0} | - | 0 |\n| 1 | [] | 1 | [1] | {1:0,2:3,3:3} | {1:-,2:0,3:0,4:2} | 3 |\n| 2 | [2,3] | 2 | [1,2] | {...,4:5} | {4:1} | 5 |\n| 3 | [3] | 3 | [1,2,3] | {4:max(5,8)=8} | {4:0} | 8 |\n| 4 | [4] | 4 | [1,2,3,4] | - | - | 11 |\n| Done | [] | - | [1,2,3,4] | - | - | **11** |",
    "final_answer": "(11, [1, 2, 3, 4])"
  },
  "test_cases": [
    {
      "name": "Diamond Pattern - Critical Path",
      "category": "Core Algorithm",
      "input": "tasks=[[1,3],[2,2],[3,5],[4,3]], deps=[[1,2],[1,3],[2,4],[3,4]]",
      "expected": "(11, [1,2,3,4]) or (11, [1,3,2,4])",
      "explanation": "Critical path is 1\u21923\u21924 = 3+5+3=11. Path 1\u21922\u21924 = 3+2+3=8 finishes earlier."
    },
    {
      "name": "All Independent - Maximum Parallelism",
      "category": "Edge Case",
      "input": "tasks=[[1,5],[2,3],[3,4]], deps=[]",
      "expected": "(5, any permutation)",
      "explanation": "All tasks run in parallel, total = max(5,3,4) = 5"
    },
    {
      "name": "Linear Chain - Zero Parallelism",
      "category": "Edge Case",
      "input": "tasks=[[1,2],[2,3],[3,1]], deps=[[1,2],[2,3]]",
      "expected": "(6, [1,2,3])",
      "explanation": "Sequential execution: 2+3+1=6. Only one valid order."
    },
    {
      "name": "Cycle Detection - Simple Cycle",
      "category": "Error Handling",
      "input": "tasks=[[1,2],[2,3],[3,1]], deps=[[1,2],[2,3],[3,1]]",
      "expected": "(-1, [])",
      "explanation": "Circular dependency 1\u21922\u21923\u21921 makes scheduling impossible"
    },
    {
      "name": "Self-Loop",
      "category": "Error Handling",
      "input": "tasks=[[1,5]], deps=[[1,1]]",
      "expected": "(-1, [])",
      "explanation": "Task depending on itself is a cycle"
    },
    {
      "name": "Single Task",
      "category": "Edge Case",
      "input": "tasks=[[42,7]], deps=[]",
      "expected": "(7, [42])",
      "explanation": "Single task runs alone"
    },
    {
      "name": "Non-Consecutive IDs",
      "category": "Implementation Detail",
      "input": "tasks=[[1,2],[10,3],[100,4]], deps=[[1,10],[10,100]]",
      "expected": "(9, [1,10,100])",
      "explanation": "Task IDs 1, 10, 100 - must use HashMap not array"
    },
    {
      "name": "Multiple Roots and Sinks",
      "category": "Complex Graph",
      "input": "tasks=[[1,1],[2,2],[3,3],[4,4]], deps=[[1,3],[2,3]]",
      "expected": "(7, [1,2,3,4] or [2,1,3,4])",
      "explanation": "Tasks 1,2 are roots, 3,4 are sinks. Critical path: 2\u21923\u21924? No, 4 is independent!"
    },
    {
      "name": "Wide Graph - Many Parallel Paths",
      "category": "Performance",
      "input": "tasks=[[0,1]]+[[i,1] for i in 1..100]+[[101,1]], deps=[[0,i] for i in 1..100]+[[i,101] for i in 1..100]",
      "expected": "(3, [0, any order of 1-100, 101])",
      "explanation": "Fan-out/fan-in pattern: 100 parallel tasks"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using array index for non-consecutive task IDs",
      "why_wrong": "Task IDs like 1, 10, 100 would require array size 101, wasting space and causing index errors",
      "correct_approach": "Use HashMap<taskId, value> for all task-related data",
      "code_wrong": "duration = [0] * (max_task_id + 1)  # Wastes space, may crash",
      "code_correct": "duration = {}  # HashMap handles any task ID"
    },
    {
      "mistake": "Calculating total time as sum of all durations",
      "why_wrong": "Ignores parallelism - independent tasks run simultaneously",
      "correct_approach": "Total time = critical path = max(completion_time[task]) for all tasks",
      "code_wrong": "total = sum(duration.values())  # Wrong!",
      "code_correct": "total = max(completion_time.values())  # Critical path"
    },
    {
      "mistake": "Not handling cycles properly",
      "why_wrong": "Infinite loop or incorrect results if cycle exists",
      "correct_approach": "Check if processed count equals task count after BFS",
      "code_wrong": "# No cycle check - algorithm hangs or gives wrong answer",
      "code_correct": "if len(order) != len(tasks): return (-1, [])  # Cycle detected"
    },
    {
      "mistake": "Using start_time = completion_time of last processed prereq",
      "why_wrong": "A task with multiple prerequisites must wait for ALL of them",
      "correct_approach": "start_time[task] = max(completion_time[prereq]) for all prereqs",
      "code_wrong": "start_time[dependent] = task_completion  # Only considers current prereq",
      "code_correct": "start_time[dependent] = max(start_time.get(dependent, 0), task_completion)"
    },
    {
      "mistake": "Using DFS for topological sort without memoization",
      "why_wrong": "Revisits nodes multiple times, giving O(2^n) worst case",
      "correct_approach": "Use Kahn's BFS algorithm or DFS with visited set",
      "code_wrong": "def dfs(task):\n    for dep in graph[task]:\n        dfs(dep)  # No memoization",
      "code_correct": "Use BFS with in_degree tracking (Kahn's algorithm)"
    },
    {
      "mistake": "Not initializing in_degree for all tasks",
      "why_wrong": "Tasks with no incoming edges might not be found",
      "correct_approach": "Initialize in_degree=0 for all tasks, then increment for dependencies",
      "code_wrong": "for prereq, dep in deps:\n    in_degree[dep] += 1  # Misses tasks with no deps",
      "code_correct": "for task in tasks: in_degree[task] = 0  # Initialize first\nfor prereq, dep in deps: in_degree[dep] += 1"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, let me make sure I understand correctly. We need to find both a valid execution order and the minimum completion time, assuming unlimited parallel workers. The minimum time would be the critical path - the longest chain of dependent tasks. Should I also handle cycle detection?",
    "clarifying_questions_to_ask": [
      "Are task IDs guaranteed to be consecutive? (No \u2192 use HashMap)",
      "What's the expected input size? (10^4 tasks, 10^5 deps \u2192 need O(V+E))",
      "Can there be duplicate dependencies? (Handle gracefully)",
      "For multiple valid orders, any preference? (Any is fine)",
      "How should I handle invalid input like non-existent task references?"
    ],
    "what_to_mention_proactively": [
      "I'll use Kahn's algorithm (BFS-based topological sort) - it handles cycle detection naturally",
      "For minimum time, I'll track start times using the critical path method",
      "I'll use HashMaps for task IDs since they may not be consecutive",
      "The key insight: a task's start time is the MAX of all its prerequisites' completion times"
    ],
    "communication_during_coding": [
      "First, I'll build the dependency graph as an adjacency list...",
      "I'm tracking in-degrees to know when a task is ready to execute...",
      "This line updates the start time using max() because a task must wait for ALL prerequisites...",
      "The cycle detection happens here - if we didn't process all tasks, there's a cycle..."
    ],
    "if_stuck": [
      "Step back: What are the two main parts? (1) Valid order (2) Minimum time",
      "For ordering: What algorithm handles dependencies? \u2192 Topological sort",
      "For timing: With unlimited workers, what determines total time? \u2192 Critical path",
      "Draw a small example and trace through manually"
    ],
    "time_management": "**0-5 min**: Clarify requirements, discuss approach\n**5-10 min**: Explain algorithm, draw example\n**10-30 min**: Code solution\n**30-40 min**: Test with examples, handle edge cases\n**40-45 min**: Discuss complexity, follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Topological Sort + Critical Path Method",
    "indicators": [
      "Tasks/courses with prerequisites/dependencies",
      "Find valid ordering respecting dependencies",
      "Minimum time with parallel execution",
      "Cycle detection in directed graph"
    ],
    "similar_problems": [
      "**LC 207 - Course Schedule**: Pure cycle detection \u2192 just return true/false",
      "**LC 210 - Course Schedule II**: Return topological order \u2192 this problem without timing",
      "**LC 1136 - Parallel Courses**: Minimum semesters \u2192 same as our critical path",
      "**LC 269 - Alien Dictionary**: Build graph from constraints \u2192 harder graph construction",
      "**LC 329 - Longest Increasing Path in Matrix**: Critical path in implicit graph"
    ],
    "template": "```python\n# Kahn's Algorithm Template\ndef topological_sort_bfs(nodes, edges):\n    graph = defaultdict(list)\n    in_degree = {node: 0 for node in nodes}\n    \n    for a, b in edges:\n        graph[a].append(b)\n        in_degree[b] += 1\n    \n    queue = deque([n for n in nodes if in_degree[n] == 0])\n    order = []\n    \n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return order if len(order) == len(nodes) else None  # None = cycle\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Limited Workers** - With k workers, tasks compete for resources. Use a priority queue (min-heap) sorted by end time to track when workers become free. Similar to LC 1834 - Single-Threaded CPU.",
    "part_3_hint": "**Part 3: Find Critical Path** - Return the actual tasks on the critical path. During BFS, track which prerequisite determined each task's start time. Then backtrack from the task with max completion time.",
    "part_4_hint": "**Part 4: Dynamic Task Addition** - Add new tasks and dependencies dynamically. Maintain the graph incrementally, detect if new dependency creates a cycle (check if path already exists from dependent to prereq).",
    "data_structure_evolution": "**Part 1**: HashMap + BFS queue\n**Part 2**: Add min-heap for worker scheduling\n**Part 3**: Add parent tracking for path reconstruction\n**Part 4**: Add incremental cycle detection with DFS/BFS"
  },
  "generated_at": "2026-01-14T15:17:10.158511",
  "_meta": {
    "problem_id": "task_scheduling_dependencies",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}