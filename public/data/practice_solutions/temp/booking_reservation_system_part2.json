{
  "problem_title": "Design a Hotel Booking/Reservation System - Part 2: Handling Concurrent Bookings",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 1 established the basic booking flow. Part 2 addresses the **critical challenge** of handling concurrent booking attempts. When thousands of users try to book the same room simultaneously, we must ensure exactly one succeeds while providing a good user experience for others. This requires implementing locking mechanisms, handling distributed systems, and gracefully managing failures.",
    "new_requirements": [
      "Never allow double-booking of the same room for overlapping dates",
      "Handle concurrent requests across multiple application servers",
      "Provide fair access to inventory during high demand",
      "Minimize user frustration from failed booking attempts",
      "Support multiple locking strategies based on use case"
    ],
    "new_constraints": [
      "System must be distributed (multiple app servers)",
      "Database must handle high concurrent write load",
      "Lock acquisition timeout must be reasonable (1-5 seconds)",
      "Failed bookings should fail fast with clear error messages",
      "Must handle network partitions gracefully"
    ],
    "key_insight": "Use **database constraints as the source of truth** for preventing double-bookings, with **distributed locks as an optimization** to fail fast. The database constraint is your safety net - even if distributed locks fail, the constraint will catch duplicates. This layered approach provides both performance and correctness."
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BEFORE: NAIVE APPROACH (RACE CONDITION)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Time \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n    \n    User A: \u2500\u2500\u2500[check availability]\u2500\u2500\u2500\u2713\u2500\u2500\u2500[book room]\u2500\u2500\u2500\u2713 CONFIRMED\n                        \u2502\n    User B: \u2500\u2500\u2500[check availability]\u2500\u2500\u2500\u2713\u2500\u2500\u2500[book room]\u2500\u2500\u2500\u2713 CONFIRMED \u26a0\ufe0f\n                        \u2502\n                        \u2514\u2500\u2500 Both see room as available!\n                            DOUBLE-BOOKING OCCURS!\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    AFTER: WITH PROPER LOCKING                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Time \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n    \n    User A: \u2500\u2500\u2500[acquire lock]\u2500\u2500\u2500\u2713\u2500\u2500\u2500[check]\u2500\u2500\u2500[book]\u2500\u2500\u2500[release]\u2500\u2500\u2713 CONFIRMED\n                    \u2502\n    User B: \u2500\u2500\u2500[acquire lock]\u2500\u2500\u2500WAIT...\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[retry/fail] \u274c\n                    \u2502\n                    \u2514\u2500\u2500 Lock ensures serialization!\n                        NO DOUBLE-BOOKING!\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502               CONCURRENT BOOKING HANDLING FLOW                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Booking Request \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                             \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502 1. Try Distributed Lock      \u2502\n              \u2502    (Redis SETNX)             \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502                             \u2502\n         Lock Acquired              Lock Failed (contention)\n              \u2502                             \u2502\n              \u25bc                             \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 2. Check Avail  \u2502           \u2502 Return: RETRY   \u2502\n    \u2502    in Database  \u2502           \u2502 (with backoff)  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                 \u2502\n Available        Not Available\n    \u2502                 \u2502\n    \u25bc                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3. INSERT   \u2502   \u2502 Return:     \u2502\n\u2502    Booking  \u2502   \u2502 UNAVAILABLE \u2502\n\u2502 (w/constr.) \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             \u2502\nSuccess   Constraint Violation\n\u2502             \u2502\n\u25bc             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502CONFIRMED\u2502  \u2502 RACE: Other \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502 user won    \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (Check-Then-Insert)",
      "description": "Simply check availability in the database, then insert if available. This was essentially the Part 1 approach.",
      "time_complexity": "O(d) where d = number of days",
      "space_complexity": "O(1)",
      "why_not_optimal": "Contains a TOCTOU (Time-Of-Check-To-Time-Of-Use) race condition. Between checking availability and inserting the booking, another transaction can complete the same booking. This leads to double-bookings under concurrent load."
    },
    {
      "name": "Pessimistic Locking (SELECT FOR UPDATE)",
      "description": "Lock the room records in the database before checking and updating. Other transactions must wait for the lock to be released.",
      "time_complexity": "O(d) for date range check",
      "space_complexity": "O(1)",
      "why_not_optimal": "Works but doesn't scale well. Locks block other transactions, creating a bottleneck for popular rooms. Can lead to deadlocks if not careful. Better for low-contention scenarios."
    },
    {
      "name": "Optimistic Locking (Version Check)",
      "description": "Read data with a version number, perform logic, then update only if version hasn't changed. If version mismatch, retry or fail.",
      "time_complexity": "O(d) per attempt, may need retries",
      "space_complexity": "O(1)",
      "why_not_optimal": "Works well when conflicts are rare. For hot inventory (popular rooms during peak times), many users waste work due to conflicts, leading to poor user experience."
    },
    {
      "name": "Optimal: Database Constraints + Distributed Locks",
      "description": "Use Redis distributed lock for fast-fail under contention, plus database UNIQUE/EXCLUDE constraint as safety net. The distributed lock reduces database pressure, while the constraint guarantees correctness even if locks fail.",
      "time_complexity": "O(1) for lock, O(d) for constraint check",
      "space_complexity": "O(d) for date records",
      "key_insight": "Layered defense: distributed lock is an optimization for performance, database constraint is the guarantee for correctness. This provides both speed and safety."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Optimal Concurrent Booking Solution\n\n### Architecture Overview\n\nWe implement a **three-layer defense** against double-bookings:\n\n1. **Layer 1: Distributed Lock (Redis)** - Fast-fail optimization\n   - Uses `SETNX` with TTL for atomic lock acquisition\n   - Reduces database contention by serializing at application layer\n   - If Redis is unavailable, we proceed without it (graceful degradation)\n\n2. **Layer 2: Application Logic** - Business rule validation\n   - Validates dates, checks user limits, applies business rules\n   - Can be bypassed by bugs, so we need Layer 3\n\n3. **Layer 3: Database Constraint** - Ultimate safety net\n   - `UNIQUE` constraint on `(room_id, date)` prevents duplicates\n   - PostgreSQL `EXCLUDE` constraint can handle date ranges\n   - This is the **source of truth** - if everything else fails, this catches it\n\n### Why This Works\n\n**For High Contention (Same Room):**\n- Redis lock serializes requests, most fail-fast without hitting DB\n- Only one request at a time proceeds to database\n- Even if two sneak through (Redis failure), constraint catches it\n\n**For Low Contention (Different Rooms):**\n- Different lock keys, no blocking\n- Parallel processing of different rooms\n- System scales horizontally\n\n**For Distributed Systems:**\n- Redis provides coordination across servers\n- Database constraint works regardless of application server\n- No single point of failure for correctness",
    "data_structures": [
      {
        "structure": "Redis String with SETNX",
        "purpose": "Distributed lock with automatic expiration for room+date combinations"
      },
      {
        "structure": "room_date_inventory table",
        "purpose": "One row per room per date, UNIQUE constraint prevents double-booking"
      },
      {
        "structure": "bookings table",
        "purpose": "Stores booking metadata, references inventory records"
      },
      {
        "structure": "Retry Queue (optional)",
        "purpose": "For handling temporary failures, allows async retry"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate request (dates, user, room exists)",
      "Step 2: Generate lock key: `booking_lock:{room_id}:{date_range_hash}`",
      "Step 3: Try to acquire distributed lock with SETNX and TTL (5 seconds)",
      "Step 4: If lock failed, return RETRY response with suggested backoff",
      "Step 5: If lock acquired, BEGIN database transaction",
      "Step 6: Check availability with SELECT (optional with pessimistic lock)",
      "Step 7: If not available, ROLLBACK, release lock, return UNAVAILABLE",
      "Step 8: INSERT booking records (one per date)",
      "Step 9: If constraint violation, ROLLBACK, release lock, return CONFLICT",
      "Step 10: COMMIT transaction, release distributed lock",
      "Step 11: Return CONFIRMED with booking details"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Hotel Booking System - Part 2: Concurrent Booking Handler",
    "Production-quality implementation with multiple locking strategies.",
    "\"\"\"",
    "",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "from datetime import date, datetime, timedelta",
    "from typing import Dict, List, Optional, Set, Tuple",
    "from abc import ABC, abstractmethod",
    "import threading",
    "import time",
    "import uuid",
    "import hashlib",
    "from contextlib import contextmanager",
    "",
    "",
    "# ==================== ENUMS AND DATA CLASSES ====================",
    "",
    "class LockStrategy(Enum):",
    "    PESSIMISTIC = \"pessimistic\"",
    "    OPTIMISTIC = \"optimistic\"",
    "    CONSTRAINT = \"constraint\"",
    "    DISTRIBUTED = \"distributed\"",
    "",
    "",
    "class BookingStatus(Enum):",
    "    CONFIRMED = \"CONFIRMED\"",
    "    FAILED = \"FAILED\"",
    "    PENDING = \"PENDING\"",
    "    CANCELLED = \"CANCELLED\"",
    "",
    "",
    "class ErrorCode(Enum):",
    "    LOCK_TIMEOUT = \"LOCK_TIMEOUT\"",
    "    VERSION_CONFLICT = \"VERSION_CONFLICT\"",
    "    CONSTRAINT_VIOLATION = \"CONSTRAINT_VIOLATION\"",
    "    ROOM_UNAVAILABLE = \"ROOM_UNAVAILABLE\"",
    "    INVALID_DATES = \"INVALID_DATES\"",
    "    SYSTEM_ERROR = \"SYSTEM_ERROR\"",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    user_id: str",
    "    room_id: str",
    "    check_in: date",
    "    check_out: date",
    "    strategy: LockStrategy = LockStrategy.DISTRIBUTED",
    "    ",
    "    @property",
    "    def dates(self) -> List[date]:",
    "        \"\"\"Generate list of all dates in the booking.\"\"\"",
    "        result = []",
    "        current = self.check_in",
    "        while current < self.check_out:",
    "            result.append(current)",
    "            current += timedelta(days=1)",
    "        return result",
    "    ",
    "    @property",
    "    def lock_key(self) -> str:",
    "        \"\"\"Generate unique lock key for this room+date combination.\"\"\"",
    "        date_hash = hashlib.md5(",
    "            f\"{self.check_in}:{self.check_out}\".encode()",
    "        ).hexdigest()[:8]",
    "        return f\"booking_lock:{self.room_id}:{date_hash}\"",
    "",
    "",
    "@dataclass",
    "class BookingResponse:",
    "    status: BookingStatus",
    "    booking_id: Optional[str] = None",
    "    error_code: Optional[ErrorCode] = None",
    "    message: Optional[str] = None",
    "    retry_after_ms: Optional[int] = None",
    "",
    "",
    "@dataclass",
    "class RoomInventory:",
    "    room_id: str",
    "    date: date",
    "    is_available: bool = True",
    "    version: int = 1",
    "    booking_id: Optional[str] = None",
    "",
    "",
    "# ==================== DISTRIBUTED LOCK ====================",
    "",
    "class DistributedLock:",
    "    \"\"\"",
    "    Simulated Redis-like distributed lock.",
    "    In production, use Redis with SETNX + EXPIRE.",
    "    \"\"\"",
    "    ",
    "    _locks: Dict[str, Tuple[str, float]] = {}",
    "    _global_lock = threading.Lock()",
    "    ",
    "    def __init__(self, ttl_seconds: float = 5.0):",
    "        self.ttl = ttl_seconds",
    "    ",
    "    def acquire(self, key: str, owner_id: str, timeout: float = 2.0) -> bool:",
    "        \"\"\"",
    "        Try to acquire lock. Returns True if successful.",
    "        Simulates: SET key owner_id NX EX ttl",
    "        \"\"\"",
    "        deadline = time.time() + timeout",
    "        ",
    "        while time.time() < deadline:",
    "            with self._global_lock:",
    "                now = time.time()",
    "                ",
    "                # Clean expired lock",
    "                if key in self._locks:",
    "                    _, expires_at = self._locks[key]",
    "                    if now > expires_at:",
    "                        del self._locks[key]",
    "                ",
    "                # Try to acquire",
    "                if key not in self._locks:",
    "                    self._locks[key] = (owner_id, now + self.ttl)",
    "                    return True",
    "            ",
    "            # Brief sleep before retry",
    "            time.sleep(0.05)",
    "        ",
    "        return False",
    "    ",
    "    def release(self, key: str, owner_id: str) -> bool:",
    "        \"\"\"",
    "        Release lock only if we own it.",
    "        Simulates: Lua script for atomic check-and-delete",
    "        \"\"\"",
    "        with self._global_lock:",
    "            if key in self._locks:",
    "                current_owner, _ = self._locks[key]",
    "                if current_owner == owner_id:",
    "                    del self._locks[key]",
    "                    return True",
    "        return False",
    "    ",
    "    @contextmanager",
    "    def lock(self, key: str, owner_id: str, timeout: float = 2.0):",
    "        \"\"\"Context manager for automatic lock release.\"\"\"",
    "        acquired = self.acquire(key, owner_id, timeout)",
    "        try:",
    "            yield acquired",
    "        finally:",
    "            if acquired:",
    "                self.release(key, owner_id)",
    "",
    "",
    "# ==================== IN-MEMORY DATABASE ====================",
    "",
    "class InMemoryDatabase:",
    "    \"\"\"",
    "    Simulated database with constraint support.",
    "    Models PostgreSQL behavior for testing.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # room_id -> date -> RoomInventory",
    "        self._inventory: Dict[str, Dict[date, RoomInventory]] = {}",
    "        self._bookings: Dict[str, Dict] = {}",
    "        self._lock = threading.RLock()",
    "        self._row_locks: Dict[str, threading.Lock] = {}",
    "    ",
    "    def initialize_room(self, room_id: str, start_date: date, days: int = 365):",
    "        \"\"\"Pre-populate room inventory.\"\"\"",
    "        with self._lock:",
    "            if room_id not in self._inventory:",
    "                self._inventory[room_id] = {}",
    "            ",
    "            current = start_date",
    "            for _ in range(days):",
    "                if current not in self._inventory[room_id]:",
    "                    self._inventory[room_id][current] = RoomInventory(",
    "                        room_id=room_id,",
    "                        date=current",
    "                    )",
    "                current += timedelta(days=1)",
    "    ",
    "    def check_availability(",
    "        self,",
    "        room_id: str,",
    "        dates: List[date],",
    "        for_update: bool = False",
    "    ) -> Tuple[bool, List[RoomInventory]]:",
    "        \"\"\"",
    "        Check if room is available for all dates.",
    "        for_update: If True, simulates SELECT ... FOR UPDATE",
    "        \"\"\"",
    "        with self._lock:",
    "            if room_id not in self._inventory:",
    "                return False, []",
    "            ",
    "            records = []",
    "            for d in dates:",
    "                if d not in self._inventory[room_id]:",
    "                    return False, []",
    "                records.append(self._inventory[room_id][d])",
    "            ",
    "            all_available = all(r.is_available for r in records)",
    "            return all_available, records",
    "    ",
    "    def insert_booking_with_constraint(",
    "        self,",
    "        booking_id: str,",
    "        room_id: str,",
    "        dates: List[date],",
    "        user_id: str",
    "    ) -> Tuple[bool, Optional[str]]:",
    "        \"\"\"",
    "        Insert booking with constraint check.",
    "        Returns (success, error_message).",
    "        Simulates: UNIQUE constraint on (room_id, date, is_booked=true)",
    "        \"\"\"",
    "        with self._lock:",
    "            # Check constraint - any date already booked?",
    "            for d in dates:",
    "                if room_id in self._inventory and d in self._inventory[room_id]:",
    "                    if not self._inventory[room_id][d].is_available:",
    "                        return False, f\"Constraint violation: {room_id} on {d}\"",
    "            ",
    "            # All good, mark as booked",
    "            for d in dates:",
    "                self._inventory[room_id][d].is_available = False",
    "                self._inventory[room_id][d].booking_id = booking_id",
    "                self._inventory[room_id][d].version += 1",
    "            ",
    "            # Store booking",
    "            self._bookings[booking_id] = {",
    "                'booking_id': booking_id,",
    "                'room_id': room_id,",
    "                'user_id': user_id,",
    "                'dates': dates,",
    "                'status': BookingStatus.CONFIRMED,",
    "                'created_at': datetime.now()",
    "            }",
    "            ",
    "            return True, None",
    "    ",
    "    def update_with_version_check(",
    "        self,",
    "        room_id: str,",
    "        date: date,",
    "        expected_version: int,",
    "        booking_id: str",
    "    ) -> bool:",
    "        \"\"\"",
    "        Optimistic locking: Update only if version matches.",
    "        Returns True if update succeeded.",
    "        \"\"\"",
    "        with self._lock:",
    "            if room_id not in self._inventory:",
    "                return False",
    "            if date not in self._inventory[room_id]:",
    "                return False",
    "            ",
    "            record = self._inventory[room_id][date]",
    "            if record.version != expected_version:",
    "                return False",
    "            if not record.is_available:",
    "                return False",
    "            ",
    "            record.is_available = False",
    "            record.booking_id = booking_id",
    "            record.version += 1",
    "            return True",
    "",
    "",
    "# ==================== BOOKING SERVICE ====================",
    "",
    "class BookingService:",
    "    \"\"\"",
    "    Main booking service with support for multiple locking strategies.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, db: InMemoryDatabase, distributed_lock: DistributedLock):",
    "        self.db = db",
    "        self.distributed_lock = distributed_lock",
    "        self._local_lock = threading.Lock()  # For pessimistic simulation",
    "    ",
    "    def create_booking_with_lock(",
    "        self,",
    "        request: BookingRequest,",
    "        strategy: Optional[LockStrategy] = None",
    "    ) -> BookingResponse:",
    "        \"\"\"",
    "        Create booking using specified locking strategy.",
    "        ",
    "        Args:",
    "            request: Booking request details",
    "            strategy: Override strategy (or use request's strategy)",
    "            ",
    "        Returns:",
    "            BookingResponse with status and details",
    "        \"\"\"",
    "        strategy = strategy or request.strategy",
    "        ",
    "        # Input validation",
    "        validation_error = self._validate_request(request)",
    "        if validation_error:",
    "            return validation_error",
    "        ",
    "        # Route to appropriate strategy",
    "        if strategy == LockStrategy.PESSIMISTIC:",
    "            return self._book_with_pessimistic_lock(request)",
    "        elif strategy == LockStrategy.OPTIMISTIC:",
    "            return self._book_with_optimistic_lock(request)",
    "        elif strategy == LockStrategy.CONSTRAINT:",
    "            return self._book_with_constraint_only(request)",
    "        elif strategy == LockStrategy.DISTRIBUTED:",
    "            return self._book_with_distributed_lock(request)",
    "        else:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error_code=ErrorCode.SYSTEM_ERROR,",
    "                message=f\"Unknown strategy: {strategy}\"",
    "            )",
    "    ",
    "    def _validate_request(self, request: BookingRequest) -> Optional[BookingResponse]:",
    "        \"\"\"Validate booking request.\"\"\"",
    "        if request.check_in >= request.check_out:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error_code=ErrorCode.INVALID_DATES,",
    "                message=\"Check-out must be after check-in\"",
    "            )",
    "        ",
    "        if request.check_in < date.today():",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error_code=ErrorCode.INVALID_DATES,",
    "                message=\"Cannot book dates in the past\"",
    "            )",
    "        ",
    "        return None",
    "    ",
    "    def _book_with_pessimistic_lock(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Pessimistic locking strategy.",
    "        Simulates: BEGIN; SELECT ... FOR UPDATE; INSERT; COMMIT;",
    "        \"\"\"",
    "        lock_acquired = self._local_lock.acquire(timeout=3.0)",
    "        ",
    "        if not lock_acquired:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error_code=ErrorCode.LOCK_TIMEOUT,",
    "                message=\"Could not acquire lock within timeout\",",
    "                retry_after_ms=1000",
    "            )",
    "        ",
    "        try:",
    "            # Check availability with lock held",
    "            available, _ = self.db.check_availability(",
    "                request.room_id,",
    "                request.dates,",
    "                for_update=True",
    "            )",
    "            ",
    "            if not available:",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.ROOM_UNAVAILABLE,",
    "                    message=\"Room is not available for selected dates\"",
    "                )",
    "            ",
    "            # Insert booking",
    "            booking_id = f\"BK_{uuid.uuid4().hex[:8].upper()}\"",
    "            success, error = self.db.insert_booking_with_constraint(",
    "                booking_id,",
    "                request.room_id,",
    "                request.dates,",
    "                request.user_id",
    "            )",
    "            ",
    "            if success:",
    "                return BookingResponse(",
    "                    status=BookingStatus.CONFIRMED,",
    "                    booking_id=booking_id,",
    "                    message=\"Booking confirmed successfully\"",
    "                )",
    "            else:",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.CONSTRAINT_VIOLATION,",
    "                    message=error",
    "                )",
    "        finally:",
    "            self._local_lock.release()",
    "    ",
    "    def _book_with_optimistic_lock(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Optimistic locking strategy.",
    "        Read version, process, update only if version unchanged.",
    "        \"\"\"",
    "        max_retries = 3",
    "        ",
    "        for attempt in range(max_retries):",
    "            # Read current state with versions",
    "            available, records = self.db.check_availability(",
    "                request.room_id,",
    "                request.dates",
    "            )",
    "            ",
    "            if not available:",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.ROOM_UNAVAILABLE,",
    "                    message=\"Room is not available for selected dates\"",
    "                )",
    "            ",
    "            # Store versions for optimistic check",
    "            versions = {r.date: r.version for r in records}",
    "            ",
    "            # Try to update with version check",
    "            booking_id = f\"BK_{uuid.uuid4().hex[:8].upper()}\"",
    "            all_updated = True",
    "            ",
    "            for d in request.dates:",
    "                success = self.db.update_with_version_check(",
    "                    request.room_id,",
    "                    d,",
    "                    versions[d],",
    "                    booking_id",
    "                )",
    "                if not success:",
    "                    all_updated = False",
    "                    break",
    "            ",
    "            if all_updated:",
    "                return BookingResponse(",
    "                    status=BookingStatus.CONFIRMED,",
    "                    booking_id=booking_id,",
    "                    message=\"Booking confirmed successfully\"",
    "                )",
    "            ",
    "            # Version conflict - retry with backoff",
    "            time.sleep(0.1 * (attempt + 1))",
    "        ",
    "        return BookingResponse(",
    "            status=BookingStatus.FAILED,",
    "            error_code=ErrorCode.VERSION_CONFLICT,",
    "            message=\"Resource was modified by another transaction, please retry\",",
    "            retry_after_ms=500",
    "        )",
    "    ",
    "    def _book_with_constraint_only(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        Rely solely on database constraint for safety.",
    "        Simplest approach - let the database handle it.",
    "        \"\"\"",
    "        booking_id = f\"BK_{uuid.uuid4().hex[:8].upper()}\"",
    "        ",
    "        success, error = self.db.insert_booking_with_constraint(",
    "            booking_id,",
    "            request.room_id,",
    "            request.dates,",
    "            request.user_id",
    "        )",
    "        ",
    "        if success:",
    "            return BookingResponse(",
    "                status=BookingStatus.CONFIRMED,",
    "                booking_id=booking_id,",
    "                message=\"Booking confirmed successfully\"",
    "            )",
    "        else:",
    "            return BookingResponse(",
    "                status=BookingStatus.FAILED,",
    "                error_code=ErrorCode.CONSTRAINT_VIOLATION,",
    "                message=error or \"Room already booked for selected dates\"",
    "            )",
    "    ",
    "    def _book_with_distributed_lock(self, request: BookingRequest) -> BookingResponse:",
    "        \"\"\"",
    "        RECOMMENDED: Distributed lock + database constraint.",
    "        Best of both worlds - performance AND safety.",
    "        \"\"\"",
    "        owner_id = f\"{request.user_id}_{uuid.uuid4().hex[:8]}\"",
    "        lock_key = request.lock_key",
    "        ",
    "        # Try distributed lock first (optimization layer)",
    "        with self.distributed_lock.lock(lock_key, owner_id, timeout=2.0) as acquired:",
    "            if not acquired:",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.LOCK_TIMEOUT,",
    "                    message=\"High demand - please try again\",",
    "                    retry_after_ms=2000",
    "                )",
    "            ",
    "            # Quick availability check (optional optimization)",
    "            available, _ = self.db.check_availability(",
    "                request.room_id,",
    "                request.dates",
    "            )",
    "            ",
    "            if not available:",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.ROOM_UNAVAILABLE,",
    "                    message=\"Room is not available for selected dates\"",
    "                )",
    "            ",
    "            # Insert with constraint (safety layer)",
    "            booking_id = f\"BK_{uuid.uuid4().hex[:8].upper()}\"",
    "            success, error = self.db.insert_booking_with_constraint(",
    "                booking_id,",
    "                request.room_id,",
    "                request.dates,",
    "                request.user_id",
    "            )",
    "            ",
    "            if success:",
    "                return BookingResponse(",
    "                    status=BookingStatus.CONFIRMED,",
    "                    booking_id=booking_id,",
    "                    message=\"Booking confirmed successfully\"",
    "                )",
    "            else:",
    "                # Constraint caught a race condition (rare but possible)",
    "                return BookingResponse(",
    "                    status=BookingStatus.FAILED,",
    "                    error_code=ErrorCode.CONSTRAINT_VIOLATION,",
    "                    message=\"Room was just booked by another user\"",
    "                )",
    "",
    "",
    "# ==================== CONCURRENT TEST HARNESS ====================",
    "",
    "class ConcurrencyTester:",
    "    \"\"\"Test harness for concurrent booking scenarios.\"\"\"",
    "    ",
    "    def __init__(self, service: BookingService):",
    "        self.service = service",
    "        self.results: List[Tuple[str, BookingResponse]] = []",
    "        self._results_lock = threading.Lock()",
    "    ",
    "    def run_concurrent_bookings(",
    "        self,",
    "        requests: List[BookingRequest],",
    "        strategy: LockStrategy",
    "    ) -> List[Tuple[str, BookingResponse]]:",
    "        \"\"\"Run multiple booking requests concurrently.\"\"\"",
    "        self.results = []",
    "        threads = []",
    "        ",
    "        for request in requests:",
    "            thread = threading.Thread(",
    "                target=self._execute_booking,",
    "                args=(request, strategy)",
    "            )",
    "            threads.append(thread)",
    "        ",
    "        # Start all threads simultaneously",
    "        for thread in threads:",
    "            thread.start()",
    "        ",
    "        # Wait for completion",
    "        for thread in threads:",
    "            thread.join()",
    "        ",
    "        return self.results",
    "    ",
    "    def _execute_booking(self, request: BookingRequest, strategy: LockStrategy):",
    "        \"\"\"Execute a single booking and store result.\"\"\"",
    "        response = self.service.create_booking_with_lock(request, strategy)",
    "        ",
    "        with self._results_lock:",
    "            self.results.append((request.user_id, response))",
    "",
    "",
    "# ==================== DEMONSTRATION ====================",
    "",
    "def demonstrate_concurrent_booking():",
    "    \"\"\"Demonstrate concurrent booking handling with different strategies.\"\"\"",
    "    print(\"=\"*70)",
    "    print(\"HOTEL BOOKING SYSTEM - CONCURRENT BOOKING DEMONSTRATION\")",
    "    print(\"=\"*70)",
    "    ",
    "    # Setup",
    "    db = InMemoryDatabase()",
    "    dist_lock = DistributedLock(ttl_seconds=5.0)",
    "    service = BookingService(db, dist_lock)",
    "    tester = ConcurrencyTester(service)",
    "    ",
    "    # Initialize test room",
    "    test_date = date.today() + timedelta(days=30)",
    "    db.initialize_room(\"R101\", test_date, days=30)",
    "    ",
    "    strategies = [",
    "        (LockStrategy.PESSIMISTIC, \"Pessimistic Locking (SELECT FOR UPDATE)\"),",
    "        (LockStrategy.OPTIMISTIC, \"Optimistic Locking (Version Check)\"),",
    "        (LockStrategy.CONSTRAINT, \"Database Constraint Only\"),",
    "        (LockStrategy.DISTRIBUTED, \"Distributed Lock + Constraint\"),",
    "    ]",
    "    ",
    "    for strategy, description in strategies:",
    "        print(f\"\\n{'\u2500'*70}\")",
    "        print(f\"Strategy: {description}\")",
    "        print(f\"{'\u2500'*70}\")",
    "        ",
    "        # Reset database for fair comparison",
    "        db = InMemoryDatabase()",
    "        db.initialize_room(\"R101\", test_date, days=30)",
    "        service = BookingService(db, dist_lock)",
    "        tester = ConcurrencyTester(service)",
    "        ",
    "        # Create concurrent requests for same room",
    "        requests = [",
    "            BookingRequest(",
    "                user_id=f\"User_{i}\",",
    "                room_id=\"R101\",",
    "                check_in=test_date,",
    "                check_out=test_date + timedelta(days=2),",
    "                strategy=strategy",
    "            )",
    "            for i in range(5)",
    "        ]",
    "        ",
    "        # Run concurrent test",
    "        start = time.time()",
    "        results = tester.run_concurrent_bookings(requests, strategy)",
    "        elapsed = time.time() - start",
    "        ",
    "        # Analyze results",
    "        confirmed = [r for r in results if r[1].status == BookingStatus.CONFIRMED]",
    "        failed = [r for r in results if r[1].status == BookingStatus.FAILED]",
    "        ",
    "        print(f\"\\nResults ({elapsed:.3f}s):\")",
    "        print(f\"  \u2705 Confirmed: {len(confirmed)}\")",
    "        print(f\"  \u274c Failed: {len(failed)}\")",
    "        ",
    "        for user_id, response in results:",
    "            status_icon = \"\u2705\" if response.status == BookingStatus.CONFIRMED else \"\u274c\"",
    "            details = response.booking_id if response.booking_id else response.message",
    "            print(f\"    {status_icon} {user_id}: {response.status.value} - {details}\")",
    "        ",
    "        # Verify no double-booking",
    "        if len(confirmed) > 1:",
    "            print(f\"  \u26a0\ufe0f  WARNING: Double-booking detected!\")",
    "        else:",
    "            print(f\"  \u2713  No double-booking - system working correctly\")",
    "    ",
    "    print(f\"\\n{'='*70}\")",
    "    print(\"DEMONSTRATION COMPLETE\")",
    "    print(f\"{'='*70}\")",
    "",
    "",
    "def demonstrate_overlapping_dates():",
    "    \"\"\"Demonstrate handling of overlapping date scenarios.\"\"\"",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"OVERLAPPING DATES SCENARIO\")",
    "    print(\"=\"*70)",
    "    ",
    "    db = InMemoryDatabase()",
    "    dist_lock = DistributedLock()",
    "    service = BookingService(db, dist_lock)",
    "    ",
    "    test_date = date.today() + timedelta(days=60)",
    "    db.initialize_room(\"SUITE_1\", test_date, days=30)",
    "    ",
    "    # User A books Jan 1-5",
    "    request_a = BookingRequest(",
    "        user_id=\"User_A\",",
    "        room_id=\"SUITE_1\",",
    "        check_in=test_date,",
    "        check_out=test_date + timedelta(days=5)",
    "    )",
    "    ",
    "    # User B tries to book Jan 3-7 (overlaps Jan 3-5)",
    "    request_b = BookingRequest(",
    "        user_id=\"User_B\",",
    "        room_id=\"SUITE_1\",",
    "        check_in=test_date + timedelta(days=2),",
    "        check_out=test_date + timedelta(days=7)",
    "    )",
    "    ",
    "    print(f\"\\nUser A requests: {request_a.check_in} to {request_a.check_out}\")",
    "    response_a = service.create_booking_with_lock(request_a)",
    "    print(f\"User A result: {response_a.status.value} - {response_a.booking_id or response_a.message}\")",
    "    ",
    "    print(f\"\\nUser B requests: {request_b.check_in} to {request_b.check_out}\")",
    "    response_b = service.create_booking_with_lock(request_b)",
    "    print(f\"User B result: {response_b.status.value} - {response_b.message}\")",
    "    ",
    "    print(f\"\\nExpected: User A succeeds, User B fails due to overlap on dates 3-5\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    demonstrate_concurrent_booking()",
    "    demonstrate_overlapping_dates()"
  ],
  "solution_java_lines": [
    "import java.time.LocalDate;",
    "import java.time.temporal.ChronoUnit;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.atomic.AtomicInteger;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Hotel Booking System - Part 2: Concurrent Booking Handler",
    " * Production-quality implementation with multiple locking strategies.",
    " */",
    "public class HotelBookingConcurrency {",
    "",
    "    // ==================== ENUMS ====================",
    "    ",
    "    public enum LockStrategy {",
    "        PESSIMISTIC, OPTIMISTIC, CONSTRAINT, DISTRIBUTED",
    "    }",
    "    ",
    "    public enum BookingStatus {",
    "        CONFIRMED, FAILED, PENDING, CANCELLED",
    "    }",
    "    ",
    "    public enum ErrorCode {",
    "        LOCK_TIMEOUT, VERSION_CONFLICT, CONSTRAINT_VIOLATION,",
    "        ROOM_UNAVAILABLE, INVALID_DATES, SYSTEM_ERROR",
    "    }",
    "",
    "    // ==================== DATA CLASSES ====================",
    "    ",
    "    public static class BookingRequest {",
    "        public final String userId;",
    "        public final String roomId;",
    "        public final LocalDate checkIn;",
    "        public final LocalDate checkOut;",
    "        public final LockStrategy strategy;",
    "        ",
    "        public BookingRequest(String userId, String roomId,",
    "                             LocalDate checkIn, LocalDate checkOut,",
    "                             LockStrategy strategy) {",
    "            this.userId = userId;",
    "            this.roomId = roomId;",
    "            this.checkIn = checkIn;",
    "            this.checkOut = checkOut;",
    "            this.strategy = strategy;",
    "        }",
    "        ",
    "        public List<LocalDate> getDates() {",
    "            List<LocalDate> dates = new ArrayList<>();",
    "            LocalDate current = checkIn;",
    "            while (current.isBefore(checkOut)) {",
    "                dates.add(current);",
    "                current = current.plusDays(1);",
    "            }",
    "            return dates;",
    "        }",
    "        ",
    "        public String getLockKey() {",
    "            return String.format(\"booking_lock:%s:%s_%s\",",
    "                roomId, checkIn, checkOut);",
    "        }",
    "    }",
    "    ",
    "    public static class BookingResponse {",
    "        public final BookingStatus status;",
    "        public final String bookingId;",
    "        public final ErrorCode errorCode;",
    "        public final String message;",
    "        public final Integer retryAfterMs;",
    "        ",
    "        private BookingResponse(BookingStatus status, String bookingId,",
    "                              ErrorCode errorCode, String message,",
    "                              Integer retryAfterMs) {",
    "            this.status = status;",
    "            this.bookingId = bookingId;",
    "            this.errorCode = errorCode;",
    "            this.message = message;",
    "            this.retryAfterMs = retryAfterMs;",
    "        }",
    "        ",
    "        public static BookingResponse confirmed(String bookingId) {",
    "            return new BookingResponse(BookingStatus.CONFIRMED, bookingId,",
    "                null, \"Booking confirmed successfully\", null);",
    "        }",
    "        ",
    "        public static BookingResponse failed(ErrorCode code, String message) {",
    "            return new BookingResponse(BookingStatus.FAILED, null,",
    "                code, message, null);",
    "        }",
    "        ",
    "        public static BookingResponse retry(ErrorCode code, String message, int ms) {",
    "            return new BookingResponse(BookingStatus.FAILED, null,",
    "                code, message, ms);",
    "        }",
    "    }",
    "    ",
    "    public static class RoomInventory {",
    "        public final String roomId;",
    "        public final LocalDate date;",
    "        public volatile boolean isAvailable;",
    "        public volatile int version;",
    "        public volatile String bookingId;",
    "        ",
    "        public RoomInventory(String roomId, LocalDate date) {",
    "            this.roomId = roomId;",
    "            this.date = date;",
    "            this.isAvailable = true;",
    "            this.version = 1;",
    "            this.bookingId = null;",
    "        }",
    "    }",
    "",
    "    // ==================== DISTRIBUTED LOCK ====================",
    "    ",
    "    public static class DistributedLock {",
    "        private final ConcurrentHashMap<String, LockEntry> locks;",
    "        private final long ttlMs;",
    "        ",
    "        private static class LockEntry {",
    "            final String ownerId;",
    "            final long expiresAt;",
    "            ",
    "            LockEntry(String ownerId, long expiresAt) {",
    "                this.ownerId = ownerId;",
    "                this.expiresAt = expiresAt;",
    "            }",
    "        }",
    "        ",
    "        public DistributedLock(long ttlMs) {",
    "            this.locks = new ConcurrentHashMap<>();",
    "            this.ttlMs = ttlMs;",
    "        }",
    "        ",
    "        public boolean acquire(String key, String ownerId, long timeoutMs) {",
    "            long deadline = System.currentTimeMillis() + timeoutMs;",
    "            ",
    "            while (System.currentTimeMillis() < deadline) {",
    "                long now = System.currentTimeMillis();",
    "                ",
    "                // Clean expired",
    "                locks.computeIfPresent(key, (k, entry) -> ",
    "                    entry.expiresAt < now ? null : entry);",
    "                ",
    "                // Try acquire",
    "                LockEntry newEntry = new LockEntry(ownerId, now + ttlMs);",
    "                LockEntry existing = locks.putIfAbsent(key, newEntry);",
    "                ",
    "                if (existing == null) {",
    "                    return true;",
    "                }",
    "                ",
    "                try {",
    "                    Thread.sleep(50);",
    "                } catch (InterruptedException e) {",
    "                    Thread.currentThread().interrupt();",
    "                    return false;",
    "                }",
    "            }",
    "            return false;",
    "        }",
    "        ",
    "        public void release(String key, String ownerId) {",
    "            locks.computeIfPresent(key, (k, entry) -> ",
    "                entry.ownerId.equals(ownerId) ? null : entry);",
    "        }",
    "    }",
    "",
    "    // ==================== DATABASE ====================",
    "    ",
    "    public static class InMemoryDatabase {",
    "        private final ConcurrentHashMap<String, ConcurrentHashMap<LocalDate, RoomInventory>> inventory;",
    "        private final ConcurrentHashMap<String, Map<String, Object>> bookings;",
    "        private final ReentrantLock globalLock;",
    "        ",
    "        public InMemoryDatabase() {",
    "            this.inventory = new ConcurrentHashMap<>();",
    "            this.bookings = new ConcurrentHashMap<>();",
    "            this.globalLock = new ReentrantLock();",
    "        }",
    "        ",
    "        public void initializeRoom(String roomId, LocalDate start, int days) {",
    "            inventory.putIfAbsent(roomId, new ConcurrentHashMap<>());",
    "            LocalDate current = start;",
    "            for (int i = 0; i < days; i++) {",
    "                LocalDate d = current;",
    "                inventory.get(roomId).putIfAbsent(d, new RoomInventory(roomId, d));",
    "                current = current.plusDays(1);",
    "            }",
    "        }",
    "        ",
    "        public boolean checkAvailability(String roomId, List<LocalDate> dates) {",
    "            Map<LocalDate, RoomInventory> roomInv = inventory.get(roomId);",
    "            if (roomInv == null) return false;",
    "            ",
    "            for (LocalDate d : dates) {",
    "                RoomInventory inv = roomInv.get(d);",
    "                if (inv == null || !inv.isAvailable) {",
    "                    return false;",
    "                }",
    "            }",
    "            return true;",
    "        }",
    "        ",
    "        public synchronized boolean insertWithConstraint(",
    "                String bookingId, String roomId,",
    "                List<LocalDate> dates, String userId) {",
    "            Map<LocalDate, RoomInventory> roomInv = inventory.get(roomId);",
    "            if (roomInv == null) return false;",
    "            ",
    "            // Check constraint",
    "            for (LocalDate d : dates) {",
    "                RoomInventory inv = roomInv.get(d);",
    "                if (inv == null || !inv.isAvailable) {",
    "                    return false;",
    "                }",
    "            }",
    "            ",
    "            // Mark as booked",
    "            for (LocalDate d : dates) {",
    "                RoomInventory inv = roomInv.get(d);",
    "                inv.isAvailable = false;",
    "                inv.bookingId = bookingId;",
    "                inv.version++;",
    "            }",
    "            ",
    "            // Store booking",
    "            Map<String, Object> booking = new HashMap<>();",
    "            booking.put(\"bookingId\", bookingId);",
    "            booking.put(\"roomId\", roomId);",
    "            booking.put(\"userId\", userId);",
    "            booking.put(\"dates\", dates);",
    "            bookings.put(bookingId, booking);",
    "            ",
    "            return true;",
    "        }",
    "    }",
    "",
    "    // ==================== BOOKING SERVICE ====================",
    "    ",
    "    public static class BookingService {",
    "        private final InMemoryDatabase db;",
    "        private final DistributedLock distributedLock;",
    "        private final ReentrantLock pessimisticLock;",
    "        private final AtomicInteger bookingCounter;",
    "        ",
    "        public BookingService(InMemoryDatabase db, DistributedLock distLock) {",
    "            this.db = db;",
    "            this.distributedLock = distLock;",
    "            this.pessimisticLock = new ReentrantLock();",
    "            this.bookingCounter = new AtomicInteger(0);",
    "        }",
    "        ",
    "        public BookingResponse createBookingWithLock(",
    "                BookingRequest request, LockStrategy strategy) {",
    "            ",
    "            // Validate",
    "            if (!request.checkIn.isBefore(request.checkOut)) {",
    "                return BookingResponse.failed(ErrorCode.INVALID_DATES,",
    "                    \"Check-out must be after check-in\");",
    "            }",
    "            ",
    "            switch (strategy) {",
    "                case PESSIMISTIC:",
    "                    return bookWithPessimisticLock(request);",
    "                case OPTIMISTIC:",
    "                    return bookWithOptimisticLock(request);",
    "                case CONSTRAINT:",
    "                    return bookWithConstraintOnly(request);",
    "                case DISTRIBUTED:",
    "                    return bookWithDistributedLock(request);",
    "                default:",
    "                    return BookingResponse.failed(ErrorCode.SYSTEM_ERROR,",
    "                        \"Unknown strategy\");",
    "            }",
    "        }",
    "        ",
    "        private String generateBookingId() {",
    "            return String.format(\"BK_%08X\", bookingCounter.incrementAndGet());",
    "        }",
    "        ",
    "        private BookingResponse bookWithPessimisticLock(BookingRequest req) {",
    "            boolean acquired = false;",
    "            try {",
    "                acquired = pessimisticLock.tryLock(3, TimeUnit.SECONDS);",
    "                if (!acquired) {",
    "                    return BookingResponse.retry(ErrorCode.LOCK_TIMEOUT,",
    "                        \"Could not acquire lock\", 1000);",
    "                }",
    "                ",
    "                if (!db.checkAvailability(req.roomId, req.getDates())) {",
    "                    return BookingResponse.failed(ErrorCode.ROOM_UNAVAILABLE,",
    "                        \"Room not available\");",
    "                }",
    "                ",
    "                String bookingId = generateBookingId();",
    "                if (db.insertWithConstraint(bookingId, req.roomId,",
    "                        req.getDates(), req.userId)) {",
    "                    return BookingResponse.confirmed(bookingId);",
    "                }",
    "                return BookingResponse.failed(ErrorCode.CONSTRAINT_VIOLATION,",
    "                    \"Booking failed\");",
    "            } catch (InterruptedException e) {",
    "                Thread.currentThread().interrupt();",
    "                return BookingResponse.failed(ErrorCode.SYSTEM_ERROR,",
    "                    \"Interrupted\");",
    "            } finally {",
    "                if (acquired) pessimisticLock.unlock();",
    "            }",
    "        }",
    "        ",
    "        private BookingResponse bookWithOptimisticLock(BookingRequest req) {",
    "            for (int attempt = 0; attempt < 3; attempt++) {",
    "                if (!db.checkAvailability(req.roomId, req.getDates())) {",
    "                    return BookingResponse.failed(ErrorCode.ROOM_UNAVAILABLE,",
    "                        \"Room not available\");",
    "                }",
    "                ",
    "                String bookingId = generateBookingId();",
    "                if (db.insertWithConstraint(bookingId, req.roomId,",
    "                        req.getDates(), req.userId)) {",
    "                    return BookingResponse.confirmed(bookingId);",
    "                }",
    "                ",
    "                try {",
    "                    Thread.sleep(100 * (attempt + 1));",
    "                } catch (InterruptedException e) {",
    "                    Thread.currentThread().interrupt();",
    "                    break;",
    "                }",
    "            }",
    "            return BookingResponse.retry(ErrorCode.VERSION_CONFLICT,",
    "                \"Please retry\", 500);",
    "        }",
    "        ",
    "        private BookingResponse bookWithConstraintOnly(BookingRequest req) {",
    "            String bookingId = generateBookingId();",
    "            if (db.insertWithConstraint(bookingId, req.roomId,",
    "                    req.getDates(), req.userId)) {",
    "                return BookingResponse.confirmed(bookingId);",
    "            }",
    "            return BookingResponse.failed(ErrorCode.CONSTRAINT_VIOLATION,",
    "                \"Room already booked\");",
    "        }",
    "        ",
    "        private BookingResponse bookWithDistributedLock(BookingRequest req) {",
    "            String ownerId = req.userId + \"_\" + System.nanoTime();",
    "            String lockKey = req.getLockKey();",
    "            ",
    "            boolean acquired = distributedLock.acquire(lockKey, ownerId, 2000);",
    "            if (!acquired) {",
    "                return BookingResponse.retry(ErrorCode.LOCK_TIMEOUT,",
    "                    \"High demand - please try again\", 2000);",
    "            }",
    "            ",
    "            try {",
    "                if (!db.checkAvailability(req.roomId, req.getDates())) {",
    "                    return BookingResponse.failed(ErrorCode.ROOM_UNAVAILABLE,",
    "                        \"Room not available\");",
    "                }",
    "                ",
    "                String bookingId = generateBookingId();",
    "                if (db.insertWithConstraint(bookingId, req.roomId,",
    "                        req.getDates(), req.userId)) {",
    "                    return BookingResponse.confirmed(bookingId);",
    "                }",
    "                return BookingResponse.failed(ErrorCode.CONSTRAINT_VIOLATION,",
    "                    \"Room was just booked\");",
    "            } finally {",
    "                distributedLock.release(lockKey, ownerId);",
    "            }",
    "        }",
    "    }",
    "",
    "    // ==================== MAIN ====================",
    "    ",
    "    public static void main(String[] args) throws Exception {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"HOTEL BOOKING - CONCURRENT BOOKING TEST\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        ExecutorService executor = Executors.newFixedThreadPool(10);",
    "        ",
    "        for (LockStrategy strategy : LockStrategy.values()) {",
    "            System.out.println(\"\\nStrategy: \" + strategy);",
    "            System.out.println(\"-\".repeat(50));",
    "            ",
    "            InMemoryDatabase db = new InMemoryDatabase();",
    "            DistributedLock distLock = new DistributedLock(5000);",
    "            BookingService service = new BookingService(db, distLock);",
    "            ",
    "            LocalDate testDate = LocalDate.now().plusDays(30);",
    "            db.initializeRoom(\"R101\", testDate, 30);",
    "            ",
    "            List<Future<BookingResponse>> futures = new ArrayList<>();",
    "            ",
    "            for (int i = 0; i < 5; i++) {",
    "                final int userId = i;",
    "                futures.add(executor.submit(() -> {",
    "                    BookingRequest req = new BookingRequest(",
    "                        \"User_\" + userId, \"R101\",",
    "                        testDate, testDate.plusDays(2), strategy);",
    "                    return service.createBookingWithLock(req, strategy);",
    "                }));",
    "            }",
    "            ",
    "            int confirmed = 0;",
    "            for (int i = 0; i < futures.size(); i++) {",
    "                BookingResponse resp = futures.get(i).get();",
    "                String icon = resp.status == BookingStatus.CONFIRMED ? \"\u2713\" : \"\u2717\";",
    "                String detail = resp.bookingId != null ? resp.bookingId : resp.message;",
    "                System.out.printf(\"  %s User_%d: %s - %s%n\",",
    "                    icon, i, resp.status, detail);",
    "                if (resp.status == BookingStatus.CONFIRMED) confirmed++;",
    "            }",
    "            ",
    "            System.out.println(\"  Result: \" + confirmed + \" confirmed, \" +",
    "                (5-confirmed) + \" failed\");",
    "            System.out.println(confirmed == 1 ? \"  \u2713 No double-booking!\" :",
    "                \"  \u26a0 Issue detected!\");",
    "        }",
    "        ",
    "        executor.shutdown();",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"TEST COMPLETE\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and module docstring. We use threading for concurrency simulation, uuid for booking IDs, and contextmanager for clean lock handling."
    },
    {
      "lines": "17-45",
      "explanation": "Enums for LockStrategy, BookingStatus, and ErrorCode. These provide type-safe constants for all possible states and error conditions."
    },
    {
      "lines": "47-75",
      "explanation": "BookingRequest dataclass with computed properties for dates (list of all dates in range) and lock_key (unique key for distributed locking)."
    },
    {
      "lines": "77-95",
      "explanation": "BookingResponse dataclass containing status, booking ID on success, error details on failure, and optional retry timing."
    },
    {
      "lines": "97-145",
      "explanation": "DistributedLock class simulating Redis SETNX behavior. The acquire() method uses a timeout loop with atomic operations to prevent race conditions."
    },
    {
      "lines": "147-230",
      "explanation": "InMemoryDatabase simulating PostgreSQL. Key methods: check_availability (with optional FOR UPDATE), insert_booking_with_constraint (atomic constraint check + insert)."
    },
    {
      "lines": "232-350",
      "explanation": "BookingService with strategy routing. Each strategy method (_book_with_*) implements a different concurrency approach with proper error handling."
    },
    {
      "lines": "352-410",
      "explanation": "ConcurrencyTester harness that launches multiple threads simultaneously and collects results thread-safely."
    },
    {
      "lines": "412-500",
      "explanation": "Demonstration functions showing each strategy in action with 5 concurrent users trying to book the same room."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "createBookingWithLock_pessimistic": {
          "complexity": "O(d + w)",
          "explanation": "d = days in booking, w = wait time for lock (bounded by timeout)"
        },
        "createBookingWithLock_optimistic": {
          "complexity": "O(d \u00d7 r)",
          "explanation": "d = days, r = retry attempts (usually 1-3)"
        },
        "createBookingWithLock_constraint": {
          "complexity": "O(d)",
          "explanation": "d = days, single database operation"
        },
        "createBookingWithLock_distributed": {
          "complexity": "O(1 + d)",
          "explanation": "O(1) for lock acquisition, O(d) for database constraint check"
        }
      },
      "overall_change": "Lock acquisition adds constant overhead. Database constraint check remains O(d). Overall per-booking: O(d) where d = number of days."
    },
    "space": {
      "additional_space": "O(k) for distributed locks where k = concurrent booking attempts",
      "explanation": "Each active booking attempt needs one lock key in Redis/memory. Locks expire automatically (TTL) so space is bounded by concurrent users, not total bookings."
    }
  },
  "dry_run": {
    "example_input": "5 users (A, B, C, D, E) concurrently trying to book Room R101 for Jan 10-12 using DISTRIBUTED strategy",
    "steps": [
      {
        "step": 1,
        "action": "All 5 requests arrive simultaneously",
        "state": "Lock available, room available",
        "explanation": "Each request generates unique owner_id and identical lock_key for R101:Jan10-12"
      },
      {
        "step": 2,
        "action": "User A wins lock race (SETNX)",
        "state": "Lock held by A, others waiting",
        "explanation": "Redis SETNX is atomic - only one can succeed. Others enter retry loop."
      },
      {
        "step": 3,
        "action": "Users B,C,D,E timeout waiting for lock",
        "state": "B,C,D,E return LOCK_TIMEOUT",
        "explanation": "2-second timeout expires while A holds lock. They fail fast with retry_after_ms suggestion."
      },
      {
        "step": 4,
        "action": "User A checks availability",
        "state": "Room available for all dates",
        "explanation": "SELECT query returns all dates as available"
      },
      {
        "step": 5,
        "action": "User A inserts booking",
        "state": "Constraint check passes",
        "explanation": "INSERT succeeds, dates marked unavailable, booking record created"
      },
      {
        "step": 6,
        "action": "User A releases lock",
        "state": "Lock released, booking complete",
        "explanation": "Lock deleted from Redis. A receives CONFIRMED response with booking_id."
      }
    ],
    "final_output": "User A: CONFIRMED (BK_12345678), Users B,C,D,E: FAILED (LOCK_TIMEOUT with retry suggestion)"
  },
  "edge_cases": [
    {
      "case": "Lock acquired but process crashes before release",
      "handling": "TTL on distributed lock auto-expires (5 seconds). Database constraint prevents any partially-complete state.",
      "gotcha": "TTL must be longer than typical transaction time but short enough to not block others too long"
    },
    {
      "case": "Two requests with overlapping but not identical dates",
      "handling": "Different lock keys (different date ranges). Database constraint catches overlap at INSERT time.",
      "gotcha": "Lock key should be per-room, not per-room-date-range for full protection. Trade-off: coarser locks = more contention."
    },
    {
      "case": "Redis unavailable (network partition)",
      "handling": "Fall back to constraint-only mode. Database constraint is the safety net - never skip it.",
      "gotcha": "Don't let lock failure cause booking failure. Graceful degradation is key."
    },
    {
      "case": "Same user booking same room twice",
      "handling": "Second request fails at constraint check (duplicate booking_id or duplicate room-date).",
      "gotcha": "Generate unique booking_id per attempt to avoid false constraint violations."
    },
    {
      "case": "Check-in equals check-out date",
      "handling": "Validation rejects: check_in must be strictly before check_out (0-night stay invalid).",
      "gotcha": "Define business rules clearly in validation layer before hitting database."
    }
  ],
  "test_cases": [
    {
      "name": "Basic concurrent booking - only one succeeds",
      "input": "5 users booking same room, same dates, simultaneously",
      "expected": "Exactly 1 CONFIRMED, 4 FAILED",
      "explanation": "Any locking strategy should ensure no double-booking. The number of confirmations must always be exactly 1."
    },
    {
      "name": "Non-overlapping concurrent bookings - all succeed",
      "input": "5 users booking DIFFERENT rooms simultaneously",
      "expected": "All 5 CONFIRMED",
      "explanation": "Different rooms have different locks. No contention, all should succeed."
    },
    {
      "name": "Overlapping date ranges",
      "input": "User A books Jan 1-5, User B books Jan 3-7 (sequentially)",
      "expected": "A: CONFIRMED, B: FAILED (ROOM_UNAVAILABLE)",
      "explanation": "Dates Jan 3-5 overlap. Database constraint catches this even without explicit lock."
    },
    {
      "name": "Lock timeout recovery",
      "input": "Simulate slow transaction holding lock, other users should timeout and can retry",
      "expected": "Slow user: CONFIRMED, Others: FAILED with retry_after_ms set",
      "explanation": "Failed users receive actionable error with retry guidance, not silent failure."
    },
    {
      "name": "Idempotency check",
      "input": "Same booking request submitted twice by same user",
      "expected": "First: CONFIRMED, Second: FAILED (constraint)",
      "explanation": "System should not create duplicate bookings even from same user."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Check-then-insert without locking",
      "why_wrong": "Race condition between availability check and insert allows double-booking",
      "correct_approach": "Always use database constraint as safety net, optionally add locks for performance",
      "code_example_wrong": "if is_available(room):\n    insert_booking(room)  # RACE!",
      "code_example_correct": "with distributed_lock(room):\n    if is_available(room):\n        insert_booking(room)  # SAFE"
    },
    {
      "mistake": "Not handling lock timeout gracefully",
      "why_wrong": "User gets generic error, doesn't know to retry, poor experience",
      "correct_approach": "Return structured error with retry_after_ms suggestion",
      "code_example_wrong": "if not lock.acquire():\n    raise Exception('Failed')",
      "code_example_correct": "if not lock.acquire():\n    return BookingResponse(FAILED, retry_after_ms=2000)"
    },
    {
      "mistake": "Forgetting to release lock in error paths",
      "why_wrong": "Lock stays held until TTL, blocking all other users",
      "correct_approach": "Use try/finally or context manager for guaranteed release",
      "code_example_wrong": "lock.acquire()\n# ... if exception here, lock never released\nlock.release()",
      "code_example_correct": "with lock:\n    # ... exception safe, auto-release"
    },
    {
      "mistake": "Using same lock granularity for all scenarios",
      "why_wrong": "Too coarse: blocks unrelated bookings. Too fine: doesn't prevent overlapping dates.",
      "correct_approach": "Lock per room (not per room-date) + rely on constraint for date overlap",
      "code_example_wrong": "lock_key = f'{room_id}:{date}'  # Too fine!",
      "code_example_correct": "lock_key = f'{room_id}'  # Or room_id:date_range_hash"
    }
  ],
  "interview_tips": {
    "how_to_present": "1) Start by acknowledging the race condition problem explicitly. Draw the timeline showing how check-then-insert fails. 2) Present layered defense: distributed lock for performance, database constraint for correctness. 3) Discuss trade-offs between strategies. 4) Show awareness of distributed system challenges (network partition, Redis failure).",
    "what_to_mention": [
      "Database constraint is the SOURCE OF TRUTH - never skip it",
      "Distributed lock is an OPTIMIZATION - graceful degradation if unavailable",
      "TTL on locks prevents deadlock from crashed processes",
      "Idempotency considerations for retry scenarios",
      "Monitoring: track lock contention, constraint violations for capacity planning"
    ],
    "time_allocation": "Spend 5 min on problem acknowledgment and race condition explanation, 8 min on solution design with trade-offs, 5 min on edge cases and distributed system concerns",
    "if_stuck": [
      "Think about what happens if two requests arrive at exactly the same time",
      "What is the absolute minimum guarantee you need? (Answer: database constraint)",
      "How would you improve performance while keeping that guarantee? (Answer: distributed lock)",
      "What if your distributed lock service (Redis) goes down? (Answer: fall back to constraint-only)"
    ]
  },
  "connection_to_next_part": "Part 3 typically covers **Search Optimization and Caching**. The concurrent booking solution here establishes the write path; Part 3 focuses on making reads fast. Key connections: 1) Cache invalidation when bookings modify availability, 2) Read replicas for search queries while writes go to primary, 3) Eventual consistency trade-offs for search results vs. strong consistency for booking confirmation.",
  "generated_at": "2026-01-14T15:21:46.669904",
  "_meta": {
    "problem_id": "booking_reservation_system",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}