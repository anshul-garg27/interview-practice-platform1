{
  "problem_title": "Employee Access Management System - Part 3: Time-Based Access Control",
  "part_number": 3,
  "builds_on": "Part 2 (Role-Based Access Control with Groups)",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 introduces temporal dimension to access control. Access grants can now have expiration timestamps, enabling scenarios like contractor access, temporary elevated privileges, or time-limited resource sharing. This requires modifying the core data structure from storing just access types to storing access-expiry pairs, plus adding efficient time-based query and cleanup mechanisms.",
    "new_requirements": [
      "Support granting access with an expiration timestamp",
      "Query access valid at a specific point in time",
      "Handle both permanent (no expiry) and temporary access simultaneously",
      "Efficiently clean up expired entries without scanning all data",
      "Permanent access should not be downgraded to temporary",
      "Multiple temporary grants should extend (not replace) expiry"
    ],
    "new_constraints": [
      "Time-based queries must be efficient O(k) where k is access types for that employee-resource pair",
      "Cleanup must be O(expired entries), not O(all entries)",
      "Must handle mixed permanent/temporary access correctly",
      "Expiry timestamp of -1 or Long.MAX_VALUE indicates permanent access"
    ],
    "key_insight": "The 'AHA!' moment is realizing we need TWO data structures working together: (1) The main access map modified to store expiry timestamps instead of just presence, enabling O(k) time-based queries, and (2) A min-heap indexed by expiry time enabling O(expired) cleanup. Lazy evaluation at query time handles correctness; the heap handles memory efficiency."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    DATA STRUCTURE EVOLUTION                       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                   \u2551\n\u2551  PART 2 (Before):                                                \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2551\n\u2551  \u2502 access[E1][R1] = {READ, WRITE}                      \u2502         \u2551\n\u2551  \u2502                   \u2191                                  \u2502         \u2551\n\u2551  \u2502              Just a Set                             \u2502         \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2551\n\u2551                                                                   \u2551\n\u2551  PART 3 (After):                                                 \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2551\n\u2551  \u2502 access[E1][R1] = {READ: 3000, WRITE: -1}            \u2502         \u2551\n\u2551  \u2502                   \u2191           \u2191                      \u2502         \u2551\n\u2551  \u2502              expires      permanent                  \u2502         \u2551\n\u2551  \u2502              at t=3000    (never expires)           \u2502         \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2551\n\u2551                                                                   \u2551\n\u2551  + expiry_heap (min-heap):                                       \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2551\n\u2551  \u2502 [(3000, E1, R1, READ), (5000, E2, R2, ADMIN), ...]  \u2502         \u2551\n\u2551  \u2502     \u2191                                                \u2502         \u2551\n\u2551  \u2502  sorted by expiry time for O(expired) cleanup       \u2502         \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2551\n\u2551                                                                   \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  TIME-BASED ACCESS FLOW                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                       \u2502\n\u2502  1. GRANT WITH EXPIRY                                                \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                                                 \u2502\n\u2502                                                                       \u2502\n\u2502  grantAccessWithExpiry(E1, R1, READ, 3000)                           \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u25bc                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u2502\n\u2502  \u2502 Check: current[E1][R1][READ] = ?    \u2502                             \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u251c\u2500\u2500\u2192 If -1 (permanent): DO NOTHING                             \u2502\n\u2502       \u2502                       (don't downgrade)                       \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u251c\u2500\u2500\u2192 If None or < 3000: UPDATE to 3000                         \u2502\n\u2502       \u2502                       + add (3000,E1,R1,READ) to heap        \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u2514\u2500\u2500\u2192 If >= 3000: DO NOTHING                                    \u2502\n\u2502                        (don't shorten)                                \u2502\n\u2502                                                                       \u2502\n\u2502  2. QUERY AT TIME                                                    \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                                                    \u2502\n\u2502                                                                       \u2502\n\u2502  retrieveAccessAtTime(E1, R1, 2500)                                  \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u25bc                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n\u2502  \u2502 For each (accessType, expiry) in [E1][R1]:   \u2502                    \u2502\n\u2502  \u2502   If expiry == -1 OR expiry > 2500:          \u2502                    \u2502\n\u2502  \u2502      Include in result                        \u2502                    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n\u2502                                                                       \u2502\n\u2502  Timeline visualization:                                              \u2502\n\u2502                                                                       \u2502\n\u2502     0        1000       2000       3000       4000                   \u2502\n\u2502     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                     \u2502\n\u2502     \u2502                    \u2502 query    \u2502                                \u2502\n\u2502     \u2502                    \u25bc t=2500   \u2502                                \u2502\n\u2502     \u2502 READ \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2502 (expires at 3000)             \u2502\n\u2502     \u2502                     \u2551         \u2502                                \u2502\n\u2502     \u2502 WRITE \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u25b6 (permanent)   \u2502\n\u2502     \u2502                     \u2551                                          \u2502\n\u2502     \u2502              Result: [READ, WRITE]                             \u2502\n\u2502                                                                       \u2502\n\u2502  3. CLEANUP                                                          \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                                                          \u2502\n\u2502                                                                       \u2502\n\u2502  cleanupExpired(3500)                                                \u2502\n\u2502       \u2502                                                               \u2502\n\u2502       \u25bc                                                               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n\u2502  \u2502 While heap.top().expiry <= 3500:             \u2502                    \u2502\n\u2502  \u2502   entry = heap.pop()                          \u2502                    \u2502\n\u2502  \u2502   if access[entry] still has same expiry:    \u2502                    \u2502\n\u2502  \u2502      delete it (lazy validation)             \u2502                    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n\u2502                                                                       \u2502\n\u2502  Why lazy validation? Because expiry might have been                 \u2502\n\u2502  extended or access made permanent since heap entry                  \u2502\n\u2502  was added.                                                          \u2502\n\u2502                                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Store expiry in main map, but for cleanup, iterate through ALL entries checking each expiry against current time. Query is still O(k), but cleanup becomes O(N) where N is total entries.",
      "time_complexity": "O(N) for cleanup, O(k) for query",
      "space_complexity": "O(N) - no additional structures",
      "why_not_optimal": "Cleanup scanning all entries is inefficient for large systems. With millions of access entries, cleanup becomes a bottleneck. Also violates the requirement of O(expired entries) cleanup."
    },
    {
      "name": "Optimal: Dual-Index with Lazy Validation",
      "description": "Maintain the access map with expiry timestamps PLUS a min-heap indexed by expiry time. The heap enables finding expired entries in O(log N) per entry. Use lazy validation during cleanup - when popping from heap, verify the entry still exists with that exact expiry before deleting (it might have been extended or made permanent).",
      "time_complexity": "O(1) grant, O(k) query, O(E log N) cleanup where E = expired entries",
      "space_complexity": "O(N) for access data + O(N) for heap = O(N) total",
      "key_insight": "The heap doesn't need to be perfectly synchronized with the access map. We just need lazy validation during cleanup - if the expiry in the heap doesn't match the current expiry in the map, skip that heap entry. This avoids expensive heap updates on every modification."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution uses a **dual-index architecture**:\n\n1. **Primary Index (Access Map)**: `Map<EmpId, Map<ResId, Map<AccessType, Expiry>>>` - Modified from Part 2 to store expiry timestamp (-1 for permanent) instead of just presence. Enables O(1) access lookup and O(k) time-based queries.\n\n2. **Secondary Index (Expiry Heap)**: Min-heap of `(expiry, empId, resId, accessType)` tuples - Enables finding the next expiring entry in O(1) and processing expired entries in O(log N) each.\n\n**Key Design Decisions**:\n\n- **Lazy Validation**: When cleaning up, we pop from the heap but verify the entry still exists with that exact expiry before deletion. This handles cases where access was extended, revoked, or made permanent after the heap entry was created.\n\n- **Permanent Access Priority**: If an employee has permanent access (expiry = -1), subsequent temporary grants are ignored. This prevents security issues from accidentally downgrading access.\n\n- **Extension Semantics**: Multiple temporary grants extend (take max) rather than replace. This is safer and matches enterprise IAM behavior.\n\n- **Time-Based Query Filtering**: At query time, we simply iterate access types and filter by `expiry == -1 OR expiry > currentTime`. This is O(k) where k is typically small.\n\n**Why This Beats Alternatives**:\n\n- TreeMap by expiry: Would need updates on every grant, O(log N) per operation\n- Sorted list: O(N) insertion\n- Our approach: O(1) grant (heap push is amortized O(1)), O(E log N) cleanup",
    "data_structures": [
      {
        "structure": "HashMap<String, HashMap<String, HashMap<AccessType, Long>>>",
        "purpose": "Primary storage - maps employee\u2192resource\u2192accessType\u2192expiryTimestamp for O(1) lookups"
      },
      {
        "structure": "PriorityQueue/heapq (min-heap)",
        "purpose": "Secondary index sorted by expiry time for O(log N) cleanup operations"
      },
      {
        "structure": "Tuple/Record (expiry, empId, resId, accessType)",
        "purpose": "Heap entries containing all info needed to locate and validate access entries"
      }
    ],
    "algorithm_steps": [
      "Step 1: grantAccessWithExpiry - Check if current expiry is -1 (permanent). If so, return early. Otherwise, update expiry to max(current, new) and push entry to heap.",
      "Step 2: retrieveAccessAtTime - Iterate through access types for (empId, resId), include in result if expiry == -1 OR expiry > currentTime.",
      "Step 3: cleanupExpired - While heap.top().expiry <= currentTime: pop entry, verify map still has matching expiry (lazy validation), if match then delete from map.",
      "Step 4: Handle nested map cleanup - After deleting access type, remove empty resource maps, then empty employee maps.",
      "Step 5: Integration with Part 2 - Check both direct access AND group access in retrieveAccessAtTime, applying same time filtering to both."
    ]
  },
  "solution_python_lines": [
    "from enum import Enum",
    "from typing import Dict, List, Set, Tuple, Optional",
    "from collections import defaultdict",
    "import heapq",
    "",
    "",
    "class AccessType(Enum):",
    "    \"\"\"Types of access that can be granted to resources.\"\"\"",
    "    READ = \"READ\"",
    "    WRITE = \"WRITE\"",
    "    ADMIN = \"ADMIN\"",
    "",
    "",
    "class AccessManager:",
    "    \"\"\"",
    "    Enterprise Access Management System with Time-Based Access Control.",
    "    ",
    "    Supports:",
    "    - Direct employee access (permanent and temporary)",
    "    - Group-based access inheritance (from Part 2)",
    "    - Time-based queries and efficient cleanup",
    "    ",
    "    Time Complexity:",
    "    - grant_access: O(1)",
    "    - grant_access_with_expiry: O(log N) amortized for heap push",
    "    - retrieve_access_at_time: O(k + g) where k=access types, g=groups",
    "    - cleanup_expired: O(E log N) where E=expired entries",
    "    \"\"\"",
    "    ",
    "    # Constant for permanent access (never expires)",
    "    PERMANENT = -1",
    "    ",
    "    def __init__(self):",
    "        # Primary index: employee_id -> resource_id -> access_type -> expiry_timestamp",
    "        # expiry = -1 means permanent access",
    "        self._direct_access: Dict[str, Dict[str, Dict[AccessType, int]]] = \\",
    "            defaultdict(lambda: defaultdict(dict))",
    "        ",
    "        # Groups (from Part 2): group_id -> set of employee_ids",
    "        self._groups: Dict[str, Set[str]] = defaultdict(set)",
    "        ",
    "        # Group access: group_id -> resource_id -> access_type -> expiry",
    "        self._group_access: Dict[str, Dict[str, Dict[AccessType, int]]] = \\",
    "            defaultdict(lambda: defaultdict(dict))",
    "        ",
    "        # Secondary index for efficient cleanup: min-heap of (expiry, emp_id, res_id, access_type_name)",
    "        self._expiry_heap: List[Tuple[int, str, str, str]] = []",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 1: Basic Access Management",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def grant_access(self, employee_id: str, resource_id: str, ",
    "                     access_type: AccessType) -> None:",
    "        \"\"\"",
    "        Grant permanent access to an employee for a resource.",
    "        ",
    "        Args:",
    "            employee_id: Unique identifier for the employee",
    "            resource_id: Unique identifier for the resource",
    "            access_type: Type of access to grant (READ, WRITE, or ADMIN)",
    "        \"\"\"",
    "        self._direct_access[employee_id][resource_id][access_type] = self.PERMANENT",
    "    ",
    "    def revoke_access(self, employee_id: str, resource_id: str,",
    "                      access_type: Optional[AccessType] = None) -> None:",
    "        \"\"\"",
    "        Revoke access from an employee.",
    "        ",
    "        Args:",
    "            employee_id: Employee to revoke access from",
    "            resource_id: Resource to revoke access to",
    "            access_type: Specific type to revoke, or None for all access",
    "        \"\"\"",
    "        if employee_id not in self._direct_access:",
    "            return",
    "        if resource_id not in self._direct_access[employee_id]:",
    "            return",
    "        ",
    "        if access_type is None:",
    "            # Revoke all access to this resource",
    "            del self._direct_access[employee_id][resource_id]",
    "            if not self._direct_access[employee_id]:",
    "                del self._direct_access[employee_id]",
    "        else:",
    "            # Revoke specific access type",
    "            self._direct_access[employee_id][resource_id].pop(access_type, None)",
    "            # Clean up empty dicts",
    "            if not self._direct_access[employee_id][resource_id]:",
    "                del self._direct_access[employee_id][resource_id]",
    "            if not self._direct_access[employee_id]:",
    "                del self._direct_access[employee_id]",
    "    ",
    "    def retrieve_access(self, employee_id: str, resource_id: str) -> List[AccessType]:",
    "        \"\"\"",
    "        Retrieve all current access types (permanent only, for backward compatibility).",
    "        \"\"\"",
    "        result: Set[AccessType] = set()",
    "        ",
    "        # Direct access (permanent only)",
    "        if employee_id in self._direct_access:",
    "            if resource_id in self._direct_access[employee_id]:",
    "                for access_type, expiry in self._direct_access[employee_id][resource_id].items():",
    "                    if expiry == self.PERMANENT:",
    "                        result.add(access_type)",
    "        ",
    "        # Group access (permanent only)",
    "        for group_id, members in self._groups.items():",
    "            if employee_id in members and group_id in self._group_access:",
    "                if resource_id in self._group_access[group_id]:",
    "                    for access_type, expiry in self._group_access[group_id][resource_id].items():",
    "                        if expiry == self.PERMANENT:",
    "                            result.add(access_type)",
    "        ",
    "        return sorted(result, key=lambda x: x.name)",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 2: Group-Based Access Control",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def add_to_group(self, employee_id: str, group_id: str) -> None:",
    "        \"\"\"Add an employee to a group.\"\"\"",
    "        self._groups[group_id].add(employee_id)",
    "    ",
    "    def remove_from_group(self, employee_id: str, group_id: str) -> None:",
    "        \"\"\"Remove an employee from a group.\"\"\"",
    "        if group_id in self._groups:",
    "            self._groups[group_id].discard(employee_id)",
    "    ",
    "    def grant_group_access(self, group_id: str, resource_id: str,",
    "                           access_type: AccessType) -> None:",
    "        \"\"\"Grant permanent access to all members of a group.\"\"\"",
    "        self._group_access[group_id][resource_id][access_type] = self.PERMANENT",
    "    ",
    "    def grant_group_access_with_expiry(self, group_id: str, resource_id: str,",
    "                                        access_type: AccessType, ",
    "                                        expiry_timestamp: int) -> None:",
    "        \"\"\"Grant temporary access to all members of a group.\"\"\"",
    "        current = self._group_access[group_id][resource_id].get(access_type)",
    "        ",
    "        if current == self.PERMANENT:",
    "            return  # Don't downgrade permanent access",
    "        ",
    "        if current is None or expiry_timestamp > current:",
    "            self._group_access[group_id][resource_id][access_type] = expiry_timestamp",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # PART 3: Time-Based Access Control",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def grant_access_with_expiry(self, employee_id: str, resource_id: str,",
    "                                  access_type: AccessType, ",
    "                                  expiry_timestamp: int) -> None:",
    "        \"\"\"",
    "        Grant temporary access that expires at the given timestamp.",
    "        ",
    "        Behavior:",
    "        - If employee has permanent access, this is a no-op (don't downgrade)",
    "        - If employee has temporary access expiring earlier, extend it",
    "        - If employee has no access, grant with given expiry",
    "        ",
    "        Args:",
    "            employee_id: Employee to grant access to",
    "            resource_id: Resource to grant access for",
    "            access_type: Type of access to grant",
    "            expiry_timestamp: Unix timestamp when access expires",
    "        \"\"\"",
    "        current_expiry = self._direct_access[employee_id][resource_id].get(access_type)",
    "        ",
    "        # Don't downgrade permanent access to temporary",
    "        if current_expiry == self.PERMANENT:",
    "            return",
    "        ",
    "        # Grant or extend temporary access",
    "        if current_expiry is None or expiry_timestamp > current_expiry:",
    "            self._direct_access[employee_id][resource_id][access_type] = expiry_timestamp",
    "            # Add to cleanup heap for efficient expiry processing",
    "            heapq.heappush(",
    "                self._expiry_heap,",
    "                (expiry_timestamp, employee_id, resource_id, access_type.name)",
    "            )",
    "    ",
    "    def retrieve_access_at_time(self, employee_id: str, resource_id: str,",
    "                                 current_time: int) -> List[AccessType]:",
    "        \"\"\"",
    "        Retrieve all access types valid at the specified time.",
    "        ",
    "        Includes both permanent access and temporary access that hasn't expired.",
    "        Also includes access inherited from groups.",
    "        ",
    "        Args:",
    "            employee_id: Employee to check access for",
    "            resource_id: Resource to check access to",
    "            current_time: Timestamp to evaluate access at",
    "        ",
    "        Returns:",
    "            List of AccessType enums valid at the given time",
    "        \"\"\"",
    "        result: Set[AccessType] = set()",
    "        ",
    "        # Check direct access",
    "        if employee_id in self._direct_access:",
    "            if resource_id in self._direct_access[employee_id]:",
    "                for access_type, expiry in self._direct_access[employee_id][resource_id].items():",
    "                    if self._is_valid_at_time(expiry, current_time):",
    "                        result.add(access_type)",
    "        ",
    "        # Check group access (inherited from all groups employee belongs to)",
    "        for group_id, members in self._groups.items():",
    "            if employee_id in members and group_id in self._group_access:",
    "                if resource_id in self._group_access[group_id]:",
    "                    for access_type, expiry in self._group_access[group_id][resource_id].items():",
    "                        if self._is_valid_at_time(expiry, current_time):",
    "                            result.add(access_type)",
    "        ",
    "        return sorted(result, key=lambda x: x.name)",
    "    ",
    "    def _is_valid_at_time(self, expiry: int, current_time: int) -> bool:",
    "        \"\"\"Check if access with given expiry is valid at current_time.\"\"\"",
    "        return expiry == self.PERMANENT or expiry > current_time",
    "    ",
    "    def cleanup_expired(self, current_time: int) -> int:",
    "        \"\"\"",
    "        Remove all expired access entries from storage.",
    "        ",
    "        Uses the expiry heap for efficient O(expired entries * log N) cleanup",
    "        instead of scanning all entries O(N).",
    "        ",
    "        Uses lazy validation: when popping from heap, verifies the entry",
    "        still exists with that exact expiry before deleting.",
    "        ",
    "        Args:",
    "            current_time: Current timestamp - entries expiring at or before",
    "                         this time will be cleaned up",
    "        ",
    "        Returns:",
    "            Number of entries actually cleaned up",
    "        \"\"\"",
    "        cleaned = 0",
    "        ",
    "        while self._expiry_heap and self._expiry_heap[0][0] <= current_time:",
    "            expiry, emp_id, res_id, access_type_name = heapq.heappop(self._expiry_heap)",
    "            ",
    "            try:",
    "                access_type = AccessType[access_type_name]",
    "            except KeyError:",
    "                continue  # Invalid access type, skip",
    "            ",
    "            # Lazy validation: verify entry still exists with this exact expiry",
    "            # It might have been extended, made permanent, or already revoked",
    "            if emp_id in self._direct_access:",
    "                if res_id in self._direct_access[emp_id]:",
    "                    current_expiry = self._direct_access[emp_id][res_id].get(access_type)",
    "                    ",
    "                    if current_expiry is not None and current_expiry == expiry:",
    "                        # Entry matches - safe to delete",
    "                        del self._direct_access[emp_id][res_id][access_type]",
    "                        cleaned += 1",
    "                        ",
    "                        # Clean up empty nested dicts to prevent memory leaks",
    "                        if not self._direct_access[emp_id][res_id]:",
    "                            del self._direct_access[emp_id][res_id]",
    "                        if not self._direct_access[emp_id]:",
    "                            del self._direct_access[emp_id]",
    "        ",
    "        return cleaned",
    "    ",
    "    def has_access_at_time(self, employee_id: str, resource_id: str,",
    "                           access_type: AccessType, current_time: int) -> bool:",
    "        \"\"\"",
    "        Quick check if employee has specific access at given time.",
    "        More efficient than retrieve_access_at_time when checking single type.",
    "        \"\"\"",
    "        # Check direct access",
    "        if employee_id in self._direct_access:",
    "            if resource_id in self._direct_access[employee_id]:",
    "                expiry = self._direct_access[employee_id][resource_id].get(access_type)",
    "                if expiry is not None and self._is_valid_at_time(expiry, current_time):",
    "                    return True",
    "        ",
    "        # Check group access",
    "        for group_id, members in self._groups.items():",
    "            if employee_id in members and group_id in self._group_access:",
    "                if resource_id in self._group_access[group_id]:",
    "                    expiry = self._group_access[group_id][resource_id].get(access_type)",
    "                    if expiry is not None and self._is_valid_at_time(expiry, current_time):",
    "                        return True",
    "        ",
    "        return False",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstration of Time-Based Access Control system.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"  Employee Access Management System - Part 3: Time-Based Access\")",
    "    print(\"=\" * 70)",
    "    ",
    "    manager = AccessManager()",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    print(\"\\n\ud83d\udccb Example 1: Basic Temporary Access\")",
    "    print(\"\u2500\" * 50)",
    "    ",
    "    manager.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    print(\"Granted: E1 READ on R1, expires at t=1000\")",
    "    ",
    "    access_500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 500)",
    "    access_1500 = manager.retrieve_access_at_time(\"E1\", \"R1\", 1500)",
    "    ",
    "    print(f\"  Query at t=500:  {[a.name for a in access_500]}\")",
    "    print(f\"  Query at t=1500: {[a.name for a in access_1500]}\")",
    "    print(\"  \u2713 READ expired at t=1000, not visible at t=1500\")",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    print(\"\\n\ud83d\udccb Example 2: Mixed Permanent and Temporary\")",
    "    print(\"\u2500\" * 50)",
    "    ",
    "    manager2 = AccessManager()",
    "    manager2.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    manager2.grant_access(\"E1\", \"R1\", AccessType.WRITE)  # Permanent",
    "    ",
    "    print(\"Granted: E1 READ on R1, expires at t=1000\")",
    "    print(\"Granted: E1 WRITE on R1, PERMANENT\")",
    "    ",
    "    access = manager2.retrieve_access_at_time(\"E1\", \"R1\", 1500)",
    "    print(f\"  Query at t=1500: {[a.name for a in access]}\")",
    "    print(\"  \u2713 READ expired, WRITE permanent still valid\")",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    print(\"\\n\ud83d\udccb Example 3: Access Extension\")",
    "    print(\"\u2500\" * 50)",
    "    ",
    "    manager3 = AccessManager()",
    "    manager3.grant_access_with_expiry(\"E1\", \"R1\", AccessType.ADMIN, 1000)",
    "    print(\"Granted: E1 ADMIN on R1, expires at t=1000\")",
    "    ",
    "    manager3.grant_access_with_expiry(\"E1\", \"R1\", AccessType.ADMIN, 2000)",
    "    print(\"Extended: E1 ADMIN on R1, now expires at t=2000\")",
    "    ",
    "    print(f\"  Query at t=1500: {[a.name for a in manager3.retrieve_access_at_time('E1', 'R1', 1500)]}\")",
    "    print(f\"  Query at t=2500: {[a.name for a in manager3.retrieve_access_at_time('E1', 'R1', 2500)]}\")",
    "    print(\"  \u2713 Access was extended to t=2000\")",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    print(\"\\n\ud83d\udccb Example 4: Efficient Cleanup\")",
    "    print(\"\u2500\" * 50)",
    "    ",
    "    manager4 = AccessManager()",
    "    manager4.grant_access_with_expiry(\"E1\", \"R1\", AccessType.READ, 1000)",
    "    manager4.grant_access_with_expiry(\"E2\", \"R2\", AccessType.WRITE, 2000)",
    "    manager4.grant_access_with_expiry(\"E3\", \"R3\", AccessType.ADMIN, 3000)",
    "    manager4.grant_access(\"E4\", \"R4\", AccessType.READ)  # Permanent",
    "    ",
    "    print(\"Created 3 temporary + 1 permanent access entries\")",
    "    ",
    "    cleaned = manager4.cleanup_expired(1500)",
    "    print(f\"\\n  Cleanup at t=1500: Removed {cleaned} expired entries\")",
    "    print(f\"  E1/R1 at t=1500: {[a.name for a in manager4.retrieve_access_at_time('E1', 'R1', 1500)]}\")",
    "    print(f\"  E2/R2 at t=1500: {[a.name for a in manager4.retrieve_access_at_time('E2', 'R2', 1500)]}\")",
    "    print(f\"  E4/R4 at t=1500: {[a.name for a in manager4.retrieve_access_at_time('E4', 'R4', 1500)]}\")",
    "    ",
    "    # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
    "    print(\"\\n\ud83d\udccb Example 5: Group Access with Expiry\")",
    "    print(\"\u2500\" * 50)",
    "    ",
    "    manager5 = AccessManager()",
    "    manager5.add_to_group(\"E1\", \"engineering\")",
    "    manager5.add_to_group(\"E2\", \"engineering\")",
    "    manager5.grant_group_access_with_expiry(\"engineering\", \"codebase\", AccessType.WRITE, 5000)",
    "    manager5.grant_access_with_expiry(\"E1\", \"codebase\", AccessType.ADMIN, 3000)",
    "    ",
    "    print(\"E1, E2 added to 'engineering' group\")",
    "    print(\"Group: WRITE on 'codebase' expires at t=5000\")",
    "    print(\"E1 direct: ADMIN on 'codebase' expires at t=3000\")",
    "    ",
    "    print(f\"\\n  E1 at t=2000: {[a.name for a in manager5.retrieve_access_at_time('E1', 'codebase', 2000)]}\")",
    "    print(f\"  E1 at t=4000: {[a.name for a in manager5.retrieve_access_at_time('E1', 'codebase', 4000)]}\")",
    "    print(f\"  E2 at t=4000: {[a.name for a in manager5.retrieve_access_at_time('E2', 'codebase', 4000)]}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"  \u2705 All examples completed successfully!\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Types of access that can be granted to resources.",
    " */",
    "enum AccessType {",
    "    READ, WRITE, ADMIN",
    "}",
    "",
    "/**",
    " * Heap entry for tracking access expiration.",
    " */",
    "class ExpiryEntry implements Comparable<ExpiryEntry> {",
    "    long expiry;",
    "    String employeeId;",
    "    String resourceId;",
    "    AccessType accessType;",
    "    ",
    "    ExpiryEntry(long expiry, String employeeId, String resourceId, AccessType accessType) {",
    "        this.expiry = expiry;",
    "        this.employeeId = employeeId;",
    "        this.resourceId = resourceId;",
    "        this.accessType = accessType;",
    "    }",
    "    ",
    "    @Override",
    "    public int compareTo(ExpiryEntry other) {",
    "        return Long.compare(this.expiry, other.expiry);",
    "    }",
    "}",
    "",
    "/**",
    " * Enterprise Access Management System with Time-Based Access Control.",
    " * ",
    " * Supports:",
    " * - Direct employee access (permanent and temporary)",
    " * - Group-based access inheritance",
    " * - Time-based queries and efficient cleanup",
    " */",
    "public class AccessManager {",
    "    ",
    "    // Constant for permanent access (never expires)",
    "    private static final long PERMANENT = -1L;",
    "    ",
    "    // Primary index: employee -> resource -> accessType -> expiry",
    "    private Map<String, Map<String, Map<AccessType, Long>>> directAccess;",
    "    ",
    "    // Groups: group_id -> set of employee_ids",
    "    private Map<String, Set<String>> groups;",
    "    ",
    "    // Group access: group -> resource -> accessType -> expiry",
    "    private Map<String, Map<String, Map<AccessType, Long>>> groupAccess;",
    "    ",
    "    // Secondary index for cleanup: min-heap by expiry time",
    "    private PriorityQueue<ExpiryEntry> expiryHeap;",
    "    ",
    "    public AccessManager() {",
    "        directAccess = new HashMap<>();",
    "        groups = new HashMap<>();",
    "        groupAccess = new HashMap<>();",
    "        expiryHeap = new PriorityQueue<>();",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 1: Basic Access Management",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Grant permanent access to an employee.",
    "     */",
    "    public void grantAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        directAccess",
    "            .computeIfAbsent(employeeId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .put(accessType, PERMANENT);",
    "    }",
    "    ",
    "    /**",
    "     * Revoke access from an employee.",
    "     */",
    "    public void revokeAccess(String employeeId, String resourceId, AccessType accessType) {",
    "        if (!directAccess.containsKey(employeeId)) return;",
    "        if (!directAccess.get(employeeId).containsKey(resourceId)) return;",
    "        ",
    "        if (accessType == null) {",
    "            // Revoke all access to this resource",
    "            directAccess.get(employeeId).remove(resourceId);",
    "        } else {",
    "            directAccess.get(employeeId).get(resourceId).remove(accessType);",
    "        }",
    "        ",
    "        // Clean up empty maps",
    "        if (directAccess.get(employeeId).get(resourceId) != null && ",
    "            directAccess.get(employeeId).get(resourceId).isEmpty()) {",
    "            directAccess.get(employeeId).remove(resourceId);",
    "        }",
    "        if (directAccess.get(employeeId).isEmpty()) {",
    "            directAccess.remove(employeeId);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve permanent access types (backward compatible).",
    "     */",
    "    public List<AccessType> retrieveAccess(String employeeId, String resourceId) {",
    "        Set<AccessType> result = new TreeSet<>();",
    "        ",
    "        // Direct access",
    "        Map<String, Map<AccessType, Long>> empAccess = directAccess.get(employeeId);",
    "        if (empAccess != null && empAccess.containsKey(resourceId)) {",
    "            for (Map.Entry<AccessType, Long> entry : empAccess.get(resourceId).entrySet()) {",
    "                if (entry.getValue() == PERMANENT) {",
    "                    result.add(entry.getKey());",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Group access",
    "        for (Map.Entry<String, Set<String>> groupEntry : groups.entrySet()) {",
    "            if (groupEntry.getValue().contains(employeeId)) {",
    "                String groupId = groupEntry.getKey();",
    "                if (groupAccess.containsKey(groupId) && ",
    "                    groupAccess.get(groupId).containsKey(resourceId)) {",
    "                    for (Map.Entry<AccessType, Long> entry : ",
    "                         groupAccess.get(groupId).get(resourceId).entrySet()) {",
    "                        if (entry.getValue() == PERMANENT) {",
    "                            result.add(entry.getKey());",
    "                        }",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return new ArrayList<>(result);",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 2: Group-Based Access Control",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public void addToGroup(String employeeId, String groupId) {",
    "        groups.computeIfAbsent(groupId, k -> new HashSet<>()).add(employeeId);",
    "    }",
    "    ",
    "    public void removeFromGroup(String employeeId, String groupId) {",
    "        if (groups.containsKey(groupId)) {",
    "            groups.get(groupId).remove(employeeId);",
    "        }",
    "    }",
    "    ",
    "    public void grantGroupAccess(String groupId, String resourceId, AccessType accessType) {",
    "        groupAccess",
    "            .computeIfAbsent(groupId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>())",
    "            .put(accessType, PERMANENT);",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // PART 3: Time-Based Access Control",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Grant temporary access that expires at the given timestamp.",
    "     * ",
    "     * - If employee has permanent access, this is a no-op",
    "     * - If employee has temporary access expiring earlier, extend it",
    "     */",
    "    public void grantAccessWithExpiry(String employeeId, String resourceId,",
    "                                       AccessType accessType, long expiryTimestamp) {",
    "        Map<AccessType, Long> accessMap = directAccess",
    "            .computeIfAbsent(employeeId, k -> new HashMap<>())",
    "            .computeIfAbsent(resourceId, k -> new HashMap<>());",
    "        ",
    "        Long currentExpiry = accessMap.get(accessType);",
    "        ",
    "        // Don't downgrade permanent access",
    "        if (currentExpiry != null && currentExpiry == PERMANENT) {",
    "            return;",
    "        }",
    "        ",
    "        // Grant or extend temporary access",
    "        if (currentExpiry == null || expiryTimestamp > currentExpiry) {",
    "            accessMap.put(accessType, expiryTimestamp);",
    "            expiryHeap.add(new ExpiryEntry(expiryTimestamp, employeeId, ",
    "                                           resourceId, accessType));",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve all access types valid at the specified time.",
    "     */",
    "    public List<AccessType> retrieveAccessAtTime(String employeeId, String resourceId,",
    "                                                  long currentTime) {",
    "        Set<AccessType> result = new TreeSet<>();",
    "        ",
    "        // Check direct access",
    "        Map<String, Map<AccessType, Long>> empAccess = directAccess.get(employeeId);",
    "        if (empAccess != null && empAccess.containsKey(resourceId)) {",
    "            for (Map.Entry<AccessType, Long> entry : empAccess.get(resourceId).entrySet()) {",
    "                if (isValidAtTime(entry.getValue(), currentTime)) {",
    "                    result.add(entry.getKey());",
    "                }",
    "            }",
    "        }",
    "        ",
    "        // Check group access",
    "        for (Map.Entry<String, Set<String>> groupEntry : groups.entrySet()) {",
    "            if (groupEntry.getValue().contains(employeeId)) {",
    "                String groupId = groupEntry.getKey();",
    "                if (groupAccess.containsKey(groupId) && ",
    "                    groupAccess.get(groupId).containsKey(resourceId)) {",
    "                    for (Map.Entry<AccessType, Long> entry : ",
    "                         groupAccess.get(groupId).get(resourceId).entrySet()) {",
    "                        if (isValidAtTime(entry.getValue(), currentTime)) {",
    "                            result.add(entry.getKey());",
    "                        }",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return new ArrayList<>(result);",
    "    }",
    "    ",
    "    private boolean isValidAtTime(long expiry, long currentTime) {",
    "        return expiry == PERMANENT || expiry > currentTime;",
    "    }",
    "    ",
    "    /**",
    "     * Remove all expired access entries.",
    "     * Uses lazy validation for efficiency.",
    "     */",
    "    public int cleanupExpired(long currentTime) {",
    "        int cleaned = 0;",
    "        ",
    "        while (!expiryHeap.isEmpty() && expiryHeap.peek().expiry <= currentTime) {",
    "            ExpiryEntry entry = expiryHeap.poll();",
    "            ",
    "            // Lazy validation: verify entry still exists with exact expiry",
    "            if (directAccess.containsKey(entry.employeeId) &&",
    "                directAccess.get(entry.employeeId).containsKey(entry.resourceId)) {",
    "                ",
    "                Map<AccessType, Long> accessMap = ",
    "                    directAccess.get(entry.employeeId).get(entry.resourceId);",
    "                Long currentExpiry = accessMap.get(entry.accessType);",
    "                ",
    "                if (currentExpiry != null && currentExpiry == entry.expiry) {",
    "                    accessMap.remove(entry.accessType);",
    "                    cleaned++;",
    "                    ",
    "                    // Clean up empty maps",
    "                    if (accessMap.isEmpty()) {",
    "                        directAccess.get(entry.employeeId).remove(entry.resourceId);",
    "                    }",
    "                    if (directAccess.get(entry.employeeId).isEmpty()) {",
    "                        directAccess.remove(entry.employeeId);",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return cleaned;",
    "    }",
    "    ",
    "    /**",
    "     * Quick check if employee has specific access at given time.",
    "     */",
    "    public boolean hasAccessAtTime(String employeeId, String resourceId,",
    "                                    AccessType accessType, long currentTime) {",
    "        // Check direct access",
    "        if (directAccess.containsKey(employeeId) &&",
    "            directAccess.get(employeeId).containsKey(resourceId)) {",
    "            Long expiry = directAccess.get(employeeId).get(resourceId).get(accessType);",
    "            if (expiry != null && isValidAtTime(expiry, currentTime)) {",
    "                return true;",
    "            }",
    "        }",
    "        ",
    "        // Check group access",
    "        for (Map.Entry<String, Set<String>> groupEntry : groups.entrySet()) {",
    "            if (groupEntry.getValue().contains(employeeId)) {",
    "                String groupId = groupEntry.getKey();",
    "                if (groupAccess.containsKey(groupId) &&",
    "                    groupAccess.get(groupId).containsKey(resourceId)) {",
    "                    Long expiry = groupAccess.get(groupId).get(resourceId).get(accessType);",
    "                    if (expiry != null && isValidAtTime(expiry, currentTime)) {",
    "                        return true;",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return false;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // Main method for demonstration",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"  Employee Access Management - Part 3: Time-Based Access\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        AccessManager manager = new AccessManager();",
    "        ",
    "        // Example 1: Basic Temporary Access",
    "        System.out.println(\"\\n\ud83d\udccb Example 1: Basic Temporary Access\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        manager.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.READ, 1000);",
    "        System.out.println(\"Granted: E1 READ on R1, expires at t=1000\");",
    "        ",
    "        System.out.println(\"  Query at t=500:  \" + ",
    "            manager.retrieveAccessAtTime(\"E1\", \"R1\", 500));",
    "        System.out.println(\"  Query at t=1500: \" + ",
    "            manager.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "        ",
    "        // Example 2: Mixed Permanent and Temporary",
    "        System.out.println(\"\\n\ud83d\udccb Example 2: Mixed Permanent and Temporary\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        AccessManager manager2 = new AccessManager();",
    "        manager2.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.READ, 1000);",
    "        manager2.grantAccess(\"E1\", \"R1\", AccessType.WRITE);",
    "        ",
    "        System.out.println(\"  Query at t=1500: \" + ",
    "            manager2.retrieveAccessAtTime(\"E1\", \"R1\", 1500));",
    "        ",
    "        // Example 3: Cleanup",
    "        System.out.println(\"\\n\ud83d\udccb Example 3: Efficient Cleanup\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        AccessManager manager3 = new AccessManager();",
    "        manager3.grantAccessWithExpiry(\"E1\", \"R1\", AccessType.READ, 1000);",
    "        manager3.grantAccessWithExpiry(\"E2\", \"R2\", AccessType.WRITE, 2000);",
    "        manager3.grantAccessWithExpiry(\"E3\", \"R3\", AccessType.ADMIN, 3000);",
    "        ",
    "        int cleaned = manager3.cleanupExpired(1500);",
    "        System.out.println(\"  Cleanup at t=1500: Removed \" + cleaned + \" entries\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"  \u2705 All examples completed!\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-12",
      "explanation": "Imports and AccessType enum definition. We use an enum for type safety and to avoid string comparison errors."
    },
    {
      "lines": "14-30",
      "explanation": "Class docstring and constants. PERMANENT = -1 is our sentinel value indicating access never expires."
    },
    {
      "lines": "32-50",
      "explanation": "Data structure initialization. Three nested maps for direct access, groups, and group access. Plus a min-heap for efficient cleanup indexing."
    },
    {
      "lines": "55-65",
      "explanation": "grant_access method sets expiry to PERMANENT (-1), indicating access never expires. This is backward compatible with Part 1/2."
    },
    {
      "lines": "140-165",
      "explanation": "grant_access_with_expiry - the key new method. First checks if current access is permanent (don't downgrade). Then updates only if new expiry is later (extension semantics). Adds entry to heap for cleanup tracking."
    },
    {
      "lines": "167-195",
      "explanation": "retrieve_access_at_time - filters by checking expiry == -1 OR expiry > currentTime. Checks both direct and group access."
    },
    {
      "lines": "200-235",
      "explanation": "cleanup_expired - pops from heap while expiry <= currentTime. Uses lazy validation to verify entry still exists with exact same expiry before deleting. This handles cases where access was extended or revoked."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "grantAccessWithExpiry": {
          "complexity": "O(log N)",
          "explanation": "HashMap lookups are O(1), heap push is O(log N) where N is number of temporary access entries"
        },
        "retrieveAccessAtTime": {
          "complexity": "O(k + G)",
          "explanation": "k = access types for this employee-resource pair, G = number of groups. Both typically small constants."
        },
        "cleanupExpired": {
          "complexity": "O(E log N)",
          "explanation": "E = number of expired entries, each heap pop is O(log N). Only processes expired entries, not all entries."
        },
        "hasAccessAtTime": {
          "complexity": "O(G)",
          "explanation": "Single HashMap lookup O(1) plus group iteration O(G)"
        }
      },
      "overall_change": "Query complexity remains O(k) but now includes time filtering. Cleanup improves from O(N) naive scan to O(E log N) targeted cleanup."
    },
    "space": {
      "additional_space": "O(T) for expiry heap where T = temporary access grants",
      "explanation": "Each temporary access grant adds one heap entry. Permanent access doesn't add heap entries. Heap entries are cleaned up as they expire. In worst case, heap size equals number of unexpired temporary grants."
    }
  },
  "dry_run": {
    "example_input": "grantAccessWithExpiry(E1, R1, READ, 1000), grantAccessWithExpiry(E1, R1, WRITE, 2000), retrieveAccessAtTime(E1, R1, 1500), cleanupExpired(1500)",
    "steps": [
      {
        "step": 1,
        "action": "grantAccessWithExpiry(E1, R1, READ, 1000)",
        "state": "access[E1][R1] = {READ: 1000}, heap = [(1000, E1, R1, READ)]",
        "explanation": "New temporary READ access expiring at t=1000"
      },
      {
        "step": 2,
        "action": "grantAccessWithExpiry(E1, R1, WRITE, 2000)",
        "state": "access[E1][R1] = {READ: 1000, WRITE: 2000}, heap = [(1000,..), (2000,..)]",
        "explanation": "Add WRITE access with different expiry"
      },
      {
        "step": 3,
        "action": "retrieveAccessAtTime(E1, R1, 1500)",
        "state": "Checking READ: 1000 > 1500? NO. WRITE: 2000 > 1500? YES",
        "explanation": "READ expired (1000 <= 1500), WRITE valid (2000 > 1500). Return [WRITE]"
      },
      {
        "step": 4,
        "action": "cleanupExpired(1500)",
        "state": "Pop (1000, E1, R1, READ). Verify access[E1][R1][READ] == 1000. Delete.",
        "explanation": "Heap pop finds READ expired. Lazy validation confirms expiry matches. Delete from map."
      },
      {
        "step": 5,
        "action": "Final state",
        "state": "access[E1][R1] = {WRITE: 2000}, heap = [(2000, E1, R1, WRITE)]",
        "explanation": "READ cleaned up, WRITE remains with expiry 2000"
      }
    ],
    "final_output": "retrieveAccessAtTime returns [WRITE], cleanupExpired returns 1"
  },
  "edge_cases": [
    {
      "case": "Grant temporary then permanent for same type",
      "handling": "grant_access sets expiry to -1, which can 'upgrade' temporary to permanent. Heap entry becomes stale.",
      "gotcha": "During cleanup, stale heap entries are skipped due to lazy validation (expiry mismatch)"
    },
    {
      "case": "Grant permanent then temporary for same type",
      "handling": "grantAccessWithExpiry checks if current expiry is -1 and returns early",
      "gotcha": "Must not downgrade permanent access - security requirement"
    },
    {
      "case": "Multiple temporary grants with different expiries",
      "handling": "Only update if new expiry > current expiry (extension)",
      "gotcha": "Each grant adds heap entry, but lazy validation handles duplicates"
    },
    {
      "case": "Query for non-existent employee/resource",
      "handling": "Returns empty list - no access",
      "gotcha": "Don't throw exception, just return []"
    },
    {
      "case": "Cleanup when access was revoked manually",
      "handling": "Lazy validation: heap entry exists but map entry doesn't - skip",
      "gotcha": "Always check map before deleting"
    },
    {
      "case": "Group access with expiry",
      "handling": "Group access stored separately with same expiry semantics",
      "gotcha": "Must check both direct AND group access in queries"
    }
  ],
  "test_cases": [
    {
      "name": "Basic expiry",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); retrieveAccessAtTime(E1, R1, 500); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[READ]; []",
      "explanation": "Access valid before expiry, invalid after"
    },
    {
      "name": "Mixed permanent and temporary",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); grantAccess(E1, R1, WRITE); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[WRITE]",
      "explanation": "Temporary READ expired, permanent WRITE remains"
    },
    {
      "name": "Access extension",
      "input": "grantAccessWithExpiry(E1, R1, READ, 1000); grantAccessWithExpiry(E1, R1, READ, 2000); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[READ]",
      "explanation": "Second grant extended expiry to 2000"
    },
    {
      "name": "Cannot downgrade permanent",
      "input": "grantAccess(E1, R1, READ); grantAccessWithExpiry(E1, R1, READ, 1000); retrieveAccessAtTime(E1, R1, 1500)",
      "expected": "[READ]",
      "explanation": "Permanent access not affected by temporary grant"
    },
    {
      "name": "Cleanup efficiency",
      "input": "Grant 1000 entries expiring at various times; cleanupExpired(500)",
      "expected": "Only entries with expiry <= 500 are removed",
      "explanation": "Heap-based cleanup only processes expired entries"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using current system time instead of passed timestamp",
      "why_wrong": "The method takes currentTime as parameter for testability and determinism",
      "correct_approach": "Always use the passed currentTime parameter, never System.currentTimeMillis()",
      "code_example_wrong": "// Wrong: if (expiry < System.currentTimeMillis())",
      "code_example_correct": "// Correct: if (expiry <= currentTime)"
    },
    {
      "mistake": "Replacing expiry instead of extending",
      "why_wrong": "If user has access until 2000, granting until 1500 shouldn't shorten it",
      "correct_approach": "Only update if new expiry > current expiry",
      "code_example_wrong": "accessMap.put(accessType, newExpiry);",
      "code_example_correct": "if (currentExpiry == null || newExpiry > currentExpiry) { accessMap.put(accessType, newExpiry); }"
    },
    {
      "mistake": "Forgetting lazy validation in cleanup",
      "why_wrong": "Access might have been extended or revoked since heap entry was added",
      "correct_approach": "Verify map entry exists with exact same expiry before deleting",
      "code_example_wrong": "// Wrong: delete directly from map based on heap entry",
      "code_example_correct": "// Correct: if (currentExpiry != null && currentExpiry == heapExpiry) { delete; }"
    },
    {
      "mistake": "Using <= vs > for expiry comparison",
      "why_wrong": "Off-by-one: at t=1000 with expiry=1000, is access valid?",
      "correct_approach": "Access is valid if expiry > currentTime (expired AT expiry time, not after)",
      "code_example_wrong": "if (expiry >= currentTime) // valid",
      "code_example_correct": "if (expiry > currentTime) // valid - expired exactly at expiry time"
    },
    {
      "mistake": "Not checking group access in time-based queries",
      "why_wrong": "Employee might have access through group with expiry",
      "correct_approach": "Check both direct access AND all groups employee belongs to",
      "code_example_wrong": "// Only checking directAccess",
      "code_example_correct": "// Check directAccess THEN iterate all groups and check groupAccess"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the two key challenges: (1) efficient time-based queries and (2) efficient cleanup. Then present the dual-index solution - primary map for O(1) lookups modified to store expiry, plus heap for O(E log N) cleanup. Emphasize the lazy validation insight.",
    "what_to_mention": [
      "Why we need two data structures working together",
      "The lazy validation pattern and why it's necessary",
      "Trade-offs: heap adds O(log N) to grants but enables efficient cleanup",
      "Security consideration: permanent access should never be downgraded",
      "Real-world relevance: AWS IAM, Okta use similar patterns",
      "Memory consideration: cleanup prevents unbounded growth"
    ],
    "time_allocation": "3 min understanding requirements, 5 min data structure design, 10 min implementation, 2 min edge cases",
    "if_stuck": [
      "Think about what data you need at query time - just filter on expiry",
      "How do you efficiently find expired entries without scanning all? \u2192 sorted structure",
      "What if expiry changed since you indexed it? \u2192 need validation",
      "Use -1 or Long.MAX_VALUE for permanent to simplify comparisons"
    ]
  },
  "connection_to_next_part": "Part 4 might introduce access audit logging (who had access when), hierarchical resources (access to /folder grants access to /folder/file), or delegated administration (certain users can grant access to others). The time-based infrastructure we built here naturally extends to audit logs by storing (time, action, user, resource, access_type) tuples.",
  "generated_at": "2026-01-14T15:04:47.391657",
  "_meta": {
    "problem_id": "employee_access_management",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}