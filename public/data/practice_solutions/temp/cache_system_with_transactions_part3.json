{
  "problem_title": "Key-Value Cache with Transaction Support - Part 3: Nested Transactions",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 supported single-level transactions with BEGIN/COMMIT/ROLLBACK. Part 3 extends this to support **nested transactions** - multiple transaction levels that form a stack. Key behavioral changes: (1) COMMIT no longer writes directly to main cache - it merges current level to parent level, (2) Only the outermost COMMIT writes to main cache, (3) ROLLBACK only discards the innermost transaction level, (4) GET must traverse multiple levels to find values.",
    "new_requirements": [
      "Multiple BEGIN calls create nested transaction levels (stack)",
      "COMMIT merges current level to parent (not main cache)",
      "Only top-level COMMIT affects main cache",
      "ROLLBACK only reverts innermost transaction",
      "GET must search from innermost to outermost, respecting deletions at each level"
    ],
    "new_constraints": [
      "Transaction stack can be arbitrarily deep",
      "Deletions at inner levels must block lookups from reaching outer levels",
      "Commits must properly merge both changes AND deletions to parent"
    ],
    "key_insight": "Model transactions as a **stack of change layers**. Each layer contains two components: (1) a HashMap of key-value changes, and (2) a Set of deleted keys. The deletion set is critical - without it, a DELETE in a transaction would 'leak through' to parent levels during GET operations. On COMMIT, we merge both changes and deletions to the parent layer. On ROLLBACK, we simply discard the top layer."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    NESTED TRANSACTION ARCHITECTURE                     \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                        \u2551\n\u2551  PART 2 (Single Level):              PART 3 (Nested Levels):          \u2551\n\u2551                                                                        \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2551\n\u2551  \u2502  Transaction    \u2502                 \u2502    Level 3      \u2502\u25c0\u2500 Current   \u2551\n\u2551  \u2502  (changes only) \u2502                 \u2502  changes + dels \u2502              \u2551\n\u2551  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524              \u2551\n\u2551  \u2502   Main Cache    \u2502                 \u2502    Level 2      \u2502              \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502  changes + dels \u2502              \u2551\n\u2551                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524              \u2551\n\u2551                                      \u2502    Level 1      \u2502              \u2551\n\u2551                                      \u2502  changes + dels \u2502              \u2551\n\u2551                                      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524              \u2551\n\u2551                                      \u2502   Main Cache    \u2502              \u2551\n\u2551                                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2551\n\u2551                                                                        \u2551\n\u2551  Each Level = { changes: HashMap, deletions: HashSet }                \u2551\n\u2551                                                                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                         OPERATION FLOW DIAGRAMS                        \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                        \u2551\n\u2551  GET key - Traverse stack top-to-bottom:                              \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 for each level (top \u2192 bottom):                                   \u2502  \u2551\n\u2551  \u2502   if key in level.deletions \u2192 return NULL (blocked!)            \u2502  \u2551\n\u2551  \u2502   if key in level.changes \u2192 return value (found!)               \u2502  \u2551\n\u2551  \u2502 finally check main_cache                                         \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                        \u2551\n\u2551  COMMIT - Merge down:                                                  \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 Before:          After:                                          \u2502  \u2551\n\u2551  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u2502  \u2551\n\u2551  \u2502 \u2502Level 2  \u2502      \u2502Level 1  \u2502 \u2190 Merged!                          \u2502  \u2551\n\u2551  \u2502 \u2502 a=100   \u2502      \u2502 a=100   \u2502                                     \u2502  \u2551\n\u2551  \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2192   \u2502 b=20    \u2502                                     \u2502  \u2551\n\u2551  \u2502 \u2502Level 1  \u2502      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                     \u2502  \u2551\n\u2551  \u2502 \u2502 b=20    \u2502      \u2502 Main    \u2502                                     \u2502  \u2551\n\u2551  \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502  \u2551\n\u2551  \u2502 \u2502 Main    \u2502                                                      \u2502  \u2551\n\u2551  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                      \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                        \u2551\n\u2551  ROLLBACK - Discard top:                                              \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\n\u2551  \u2502 Before:          After:                                          \u2502  \u2551\n\u2551  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                      \u2502  \u2551\n\u2551  \u2502 \u2502Level 2  \u2502 \u2500\u2500\u2500\u2192 DISCARDED                                       \u2502  \u2551\n\u2551  \u2502 \u2502 a=100   \u2502                                                      \u2502  \u2551\n\u2551  \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u2502  \u2551\n\u2551  \u2502 \u2502Level 1  \u2502  \u2192   \u2502Level 1  \u2502 \u2190 Now current                      \u2502  \u2551\n\u2551  \u2502 \u2502 b=20    \u2502      \u2502 b=20    \u2502                                     \u2502  \u2551\n\u2551  \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524      \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                                     \u2502  \u2551\n\u2551  \u2502 \u2502 Main    \u2502      \u2502 Main    \u2502                                     \u2502  \u2551\n\u2551  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502  \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\n\u2551                                                                        \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Single Transaction HashMap",
      "description": "Simply use the Part 2 solution with a single transaction HashMap. On BEGIN, only allow if no transaction active, or overwrite existing transaction.",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(n) where n = keys",
      "why_not_optimal": "Cannot support nested transactions at all. Multiple BEGINs would either fail or overwrite previous transaction state. No way to model hierarchical commit/rollback behavior."
    },
    {
      "name": "Stack of Changes Only",
      "description": "Use a stack of HashMaps for changes, but don't track deletions separately. On DELETE, just remove the key from current level.",
      "time_complexity": "O(d) for GET where d = depth",
      "space_complexity": "O(d * k) where k = keys per level",
      "why_not_optimal": "CRITICAL FLAW: Deletions 'leak through'. If you DELETE a key in Level 2, then GET would look in Level 1 and find the old value. Deletions must BLOCK lookups from reaching parent levels."
    },
    {
      "name": "Optimal: Stack of (Changes, Deletions) Tuples",
      "description": "Each transaction level maintains TWO data structures: a HashMap for changes and a HashSet for deletions. GET traverses the stack checking both. COMMIT merges both to parent. ROLLBACK pops the entire level.",
      "time_complexity": "O(d) for GET, O(k) for COMMIT, O(1) for others",
      "space_complexity": "O(d * k) where d = depth, k = avg keys per level",
      "key_insight": "The deletion set acts as a 'shadow' that blocks lookups. When we DELETE a key, we're not just removing it from current level - we're saying 'stop looking here, this key doesn't exist from this point of view.' This is the key to correct nested transaction semantics."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The solution uses a **transaction stack** where each level is a tuple of `(changes_dict, deletions_set)`.\n\n**Why Two Data Structures Per Level?**\n\nConsider this scenario:\n```\nMain: {a: 1}\nBEGIN\n  DELETE a\n  GET a  \u2192 Should return NULL, not 1!\n```\n\nIf we only tracked changes, the DELETE would remove `a` from changes (which was empty), and GET would find `a=1` in main cache. **Wrong!**\n\nBy maintaining a `deletions` set, DELETE adds `a` to that set. GET checks: \"Is `a` in deletions?\" \u2192 Yes \u2192 Return NULL immediately, don't look further.\n\n**Merge Logic on COMMIT:**\n\n1. **Apply deletions first**: For each key in current.deletions:\n   - Remove from parent.changes (undo any previous set)\n   - Add to parent.deletions (propagate the deletion)\n\n2. **Apply changes second**: For each key in current.changes:\n   - Add/update in parent.changes\n   - Remove from parent.deletions (a set overrides a delete)\n\nThis ordering ensures that `SET a 5; DELETE a; SET a 10` correctly results in `a=10`.",
    "data_structures": [
      {
        "structure": "List/Stack of tuples",
        "purpose": "Transaction levels - each level is (HashMap changes, HashSet deletions)"
      },
      {
        "structure": "HashMap (main_cache)",
        "purpose": "Permanent storage - base level"
      },
      {
        "structure": "HashMap (changes)",
        "purpose": "Key-value modifications at each transaction level"
      },
      {
        "structure": "HashSet (deletions)",
        "purpose": "Keys marked as deleted at each level - blocks lookups"
      }
    ],
    "algorithm_steps": [
      "**BEGIN**: Push new tuple `({}, set())` onto transaction stack",
      "**SET key value**: If in transaction \u2192 add to top level's changes, remove from deletions. Else \u2192 add to main cache",
      "**GET key**: Traverse stack top-to-bottom. At each level: if key in deletions \u2192 return NULL; if key in changes \u2192 return value. Finally check main cache",
      "**DELETE key**: If in transaction \u2192 remove from changes, add to deletions. Else \u2192 remove from main cache",
      "**COMMIT**: Pop top level. For each deletion \u2192 remove from parent changes, add to parent deletions. For each change \u2192 add to parent changes, remove from parent deletions. If no parent \u2192 apply to main cache",
      "**ROLLBACK**: Simply pop top level (discard all changes and deletions)"
    ]
  },
  "solution_python_lines": [
    "from typing import List, Optional, Dict, Set, Tuple",
    "",
    "",
    "class Cache:",
    "    \"\"\"",
    "    Key-Value Cache with Nested Transaction Support.",
    "    ",
    "    Implements a Redis-like cache with support for arbitrarily nested",
    "    transactions using a stack-based approach. Each transaction level",
    "    maintains its own set of changes and deletions.",
    "    ",
    "    Time Complexity:",
    "        - SET: O(1)",
    "        - GET: O(d) where d = transaction depth",
    "        - DELETE: O(1)",
    "        - BEGIN: O(1)",
    "        - COMMIT: O(k) where k = changes in current level",
    "        - ROLLBACK: O(1)",
    "    ",
    "    Space Complexity: O(n + d*k) where n = main cache size,",
    "                      d = depth, k = avg changes per level",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize cache with empty main storage and transaction stack.\"\"\"",
    "        self._main_cache: Dict[str, str] = {}",
    "        # Stack of transaction levels: List of (changes_dict, deletions_set)",
    "        self._transaction_stack: List[Tuple[Dict[str, str], Set[str]]] = []",
    "    ",
    "    def set(self, key: str, value: str) -> None:",
    "        \"\"\"",
    "        Store a key-value pair.",
    "        ",
    "        If in a transaction, stores in current transaction level.",
    "        Otherwise, stores directly in main cache.",
    "        ",
    "        Args:",
    "            key: The key to store",
    "            value: The value to associate with the key",
    "        \"\"\"",
    "        if self._transaction_stack:",
    "            changes, deletions = self._transaction_stack[-1]",
    "            changes[key] = value",
    "            deletions.discard(key)  # SET overrides any pending DELETE",
    "        else:",
    "            self._main_cache[key] = value",
    "    ",
    "    def get(self, key: str) -> Optional[str]:",
    "        \"\"\"",
    "        Retrieve a value by key.",
    "        ",
    "        Traverses transaction stack from top (innermost) to bottom (outermost),",
    "        then checks main cache. Respects deletions at each level.",
    "        ",
    "        Args:",
    "            key: The key to look up",
    "            ",
    "        Returns:",
    "            The value if found, None if not found or deleted",
    "        \"\"\"",
    "        # Traverse from innermost (top) to outermost transaction",
    "        for changes, deletions in reversed(self._transaction_stack):",
    "            if key in deletions:",
    "                return None  # Key was deleted at this level - stop looking!",
    "            if key in changes:",
    "                return changes[key]  # Found at this level",
    "        ",
    "        # Not found in any transaction, check main cache",
    "        return self._main_cache.get(key)",
    "    ",
    "    def delete(self, key: str) -> None:",
    "        \"\"\"",
    "        Remove a key-value pair.",
    "        ",
    "        If in a transaction, marks the key as deleted in current level.",
    "        This blocks GET from finding the key in parent levels.",
    "        ",
    "        Args:",
    "            key: The key to delete",
    "        \"\"\"",
    "        if self._transaction_stack:",
    "            changes, deletions = self._transaction_stack[-1]",
    "            changes.pop(key, None)  # Remove from current level's changes",
    "            deletions.add(key)      # Mark as deleted (blocks lookups)",
    "        else:",
    "            self._main_cache.pop(key, None)",
    "    ",
    "    def begin(self) -> None:",
    "        \"\"\"",
    "        Start a new nested transaction level.",
    "        ",
    "        Creates a new transaction layer on the stack.",
    "        All subsequent operations affect this new level until",
    "        COMMIT or ROLLBACK is called.",
    "        \"\"\"",
    "        self._transaction_stack.append(({}, set()))",
    "    ",
    "    def commit(self) -> bool:",
    "        \"\"\"",
    "        Commit the current transaction level.",
    "        ",
    "        Merges all changes and deletions to the parent level.",
    "        If this is the outermost transaction, writes to main cache.",
    "        ",
    "        Returns:",
    "            True if a transaction was committed, False if no active transaction",
    "        \"\"\"",
    "        if not self._transaction_stack:",
    "            return False",
    "        ",
    "        changes, deletions = self._transaction_stack.pop()",
    "        ",
    "        if self._transaction_stack:",
    "            # Merge to parent transaction level",
    "            parent_changes, parent_deletions = self._transaction_stack[-1]",
    "            ",
    "            # Step 1: Apply deletions (must come first)",
    "            # These override any previous SETs in parent",
    "            for key in deletions:",
    "                parent_changes.pop(key, None)",
    "                parent_deletions.add(key)",
    "            ",
    "            # Step 2: Apply changes (these override deletions)",
    "            for key, value in changes.items():",
    "                parent_changes[key] = value",
    "                parent_deletions.discard(key)",
    "        else:",
    "            # Merge to main cache (outermost transaction)",
    "            for key in deletions:",
    "                self._main_cache.pop(key, None)",
    "            self._main_cache.update(changes)",
    "        ",
    "        return True",
    "    ",
    "    def rollback(self) -> bool:",
    "        \"\"\"",
    "        Rollback the current transaction level.",
    "        ",
    "        Discards all changes and deletions in the current level.",
    "        Parent level and main cache are completely unaffected.",
    "        ",
    "        Returns:",
    "            True if rolled back successfully, False if no active transaction",
    "        \"\"\"",
    "        if not self._transaction_stack:",
    "            return False",
    "        ",
    "        self._transaction_stack.pop()  # Simply discard",
    "        return True",
    "    ",
    "    def execute(self, commands: List[str]) -> List[str]:",
    "        \"\"\"",
    "        Execute a list of commands and return results.",
    "        ",
    "        Commands: SET key value, GET key, DELETE key,",
    "                  BEGIN, COMMIT, ROLLBACK",
    "        ",
    "        Args:",
    "            commands: List of command strings to execute",
    "            ",
    "        Returns:",
    "            List of string results for commands that produce output",
    "        \"\"\"",
    "        results: List[str] = []",
    "        ",
    "        for command in commands:",
    "            parts = command.split()",
    "            op = parts[0].upper()",
    "            ",
    "            if op == \"SET\":",
    "                self.set(parts[1], parts[2])",
    "            elif op == \"GET\":",
    "                value = self.get(parts[1])",
    "                results.append(value if value is not None else \"NULL\")",
    "            elif op == \"DELETE\":",
    "                self.delete(parts[1])",
    "            elif op == \"BEGIN\":",
    "                self.begin()",
    "            elif op == \"COMMIT\":",
    "                results.append(\"true\" if self.commit() else \"false\")",
    "            elif op == \"ROLLBACK\":",
    "                results.append(\"true\" if self.rollback() else \"false\")",
    "        ",
    "        return results",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DEMONSTRATION AND TESTING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "if __name__ == \"__main__\":",
    "    print(\"\u2550\" * 70)",
    "    print(\"KEY-VALUE CACHE WITH NESTED TRANSACTIONS - DEMO\")",
    "    print(\"\u2550\" * 70)",
    "    ",
    "    # Example 1: Basic nested commit",
    "    print(\"\\n\ud83d\udccc Example 1: Nested Commit then Rollback\")",
    "    print(\"-\" * 50)",
    "    cache1 = Cache()",
    "    commands1 = [",
    "        \"SET a 1\",",
    "        \"BEGIN\",",
    "        \"SET a 10\",",
    "        \"BEGIN\",",
    "        \"SET a 100\",",
    "        \"GET a\",",
    "        \"COMMIT\",",
    "        \"GET a\",",
    "        \"ROLLBACK\",",
    "        \"GET a\"",
    "    ]",
    "    print(f\"Commands: {commands1}\")",
    "    result1 = cache1.execute(commands1)",
    "    print(f\"Results:  {result1}\")",
    "    print(f\"Expected: ['100', 'true', '100', 'true', '1']\")",
    "    ",
    "    # Example 2: Rollback inner, commit outer",
    "    print(\"\\n\ud83d\udccc Example 2: Rollback Inner, Commit Outer\")",
    "    print(\"-\" * 50)",
    "    cache2 = Cache()",
    "    commands2 = [",
    "        \"BEGIN\",",
    "        \"SET x 1\",",
    "        \"BEGIN\",",
    "        \"SET y 2\",",
    "        \"ROLLBACK\",",
    "        \"GET y\",",
    "        \"COMMIT\",",
    "        \"GET x\",",
    "        \"GET y\"",
    "    ]",
    "    print(f\"Commands: {commands2}\")",
    "    result2 = cache2.execute(commands2)",
    "    print(f\"Results:  {result2}\")",
    "    print(f\"Expected: ['true', 'NULL', 'true', '1', 'NULL']\")",
    "    ",
    "    # Example 3: Deep nesting with deletions",
    "    print(\"\\n\ud83d\udccc Example 3: Deep Nesting with Deletions\")",
    "    print(\"-\" * 50)",
    "    cache3 = Cache()",
    "    commands3 = [",
    "        \"SET a 1\",",
    "        \"SET b 2\",",
    "        \"BEGIN\",",
    "        \"DELETE a\",",
    "        \"GET a\",",
    "        \"BEGIN\",",
    "        \"SET a 100\",",
    "        \"GET a\",",
    "        \"COMMIT\",",
    "        \"GET a\",",
    "        \"COMMIT\",",
    "        \"GET a\",",
    "        \"GET b\"",
    "    ]",
    "    print(f\"Commands: {commands3}\")",
    "    result3 = cache3.execute(commands3)",
    "    print(f\"Results:  {result3}\")",
    "    print(f\"Expected: ['NULL', '100', '100', 'true', '100', '2']\")",
    "    ",
    "    print(\"\\n\" + \"\u2550\" * 70)",
    "    print(\"ALL TESTS COMPLETED!\")",
    "    print(\"\u2550\" * 70)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Key-Value Cache with Nested Transaction Support.",
    " * ",
    " * Implements a Redis-like cache with support for arbitrarily nested",
    " * transactions using a stack-based approach. Each transaction level",
    " * maintains its own set of changes and deletions.",
    " * ",
    " * Time Complexity:",
    " *   - SET: O(1)",
    " *   - GET: O(d) where d = transaction depth",
    " *   - DELETE: O(1)",
    " *   - BEGIN: O(1)",
    " *   - COMMIT: O(k) where k = changes in current level",
    " *   - ROLLBACK: O(1)",
    " */",
    "public class Cache {",
    "    private final Map<String, String> mainCache;",
    "    private final List<TransactionLevel> transactionStack;",
    "    ",
    "    /**",
    "     * Inner class representing a single transaction level.",
    "     * Contains both changes (key-value pairs) and deletions (blocked keys).",
    "     */",
    "    private static class TransactionLevel {",
    "        final Map<String, String> changes = new HashMap<>();",
    "        final Set<String> deletions = new HashSet<>();",
    "    }",
    "    ",
    "    public Cache() {",
    "        mainCache = new HashMap<>();",
    "        transactionStack = new ArrayList<>();",
    "    }",
    "    ",
    "    /**",
    "     * Store a key-value pair.",
    "     * If in transaction, stores in current level. Otherwise, stores in main cache.",
    "     */",
    "    public void set(String key, String value) {",
    "        if (!transactionStack.isEmpty()) {",
    "            TransactionLevel current = transactionStack.get(transactionStack.size() - 1);",
    "            current.changes.put(key, value);",
    "            current.deletions.remove(key);  // SET overrides any pending DELETE",
    "        } else {",
    "            mainCache.put(key, value);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve a value by key.",
    "     * Traverses stack from top to bottom, respecting deletions at each level.",
    "     * @return The value if found, null if not found or deleted",
    "     */",
    "    public String get(String key) {",
    "        // Traverse from innermost (top) to outermost transaction",
    "        for (int i = transactionStack.size() - 1; i >= 0; i--) {",
    "            TransactionLevel level = transactionStack.get(i);",
    "            if (level.deletions.contains(key)) {",
    "                return null;  // Key was deleted - stop looking!",
    "            }",
    "            if (level.changes.containsKey(key)) {",
    "                return level.changes.get(key);  // Found at this level",
    "            }",
    "        }",
    "        // Not found in transactions, check main cache",
    "        return mainCache.get(key);",
    "    }",
    "    ",
    "    /**",
    "     * Remove a key-value pair.",
    "     * If in transaction, marks key as deleted (blocks lookups to parent levels).",
    "     */",
    "    public void delete(String key) {",
    "        if (!transactionStack.isEmpty()) {",
    "            TransactionLevel current = transactionStack.get(transactionStack.size() - 1);",
    "            current.changes.remove(key);",
    "            current.deletions.add(key);  // Mark as deleted",
    "        } else {",
    "            mainCache.remove(key);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Start a new nested transaction level.",
    "     */",
    "    public void begin() {",
    "        transactionStack.add(new TransactionLevel());",
    "    }",
    "    ",
    "    /**",
    "     * Commit current transaction level to parent (or main cache if outermost).",
    "     * @return true if committed, false if no active transaction",
    "     */",
    "    public boolean commit() {",
    "        if (transactionStack.isEmpty()) {",
    "            return false;",
    "        }",
    "        ",
    "        TransactionLevel current = transactionStack.remove(transactionStack.size() - 1);",
    "        ",
    "        if (!transactionStack.isEmpty()) {",
    "            // Merge to parent transaction level",
    "            TransactionLevel parent = transactionStack.get(transactionStack.size() - 1);",
    "            ",
    "            // Step 1: Apply deletions first",
    "            for (String key : current.deletions) {",
    "                parent.changes.remove(key);",
    "                parent.deletions.add(key);",
    "            }",
    "            ",
    "            // Step 2: Apply changes (these override deletions)",
    "            for (Map.Entry<String, String> entry : current.changes.entrySet()) {",
    "                parent.changes.put(entry.getKey(), entry.getValue());",
    "                parent.deletions.remove(entry.getKey());",
    "            }",
    "        } else {",
    "            // Merge to main cache (outermost transaction)",
    "            for (String key : current.deletions) {",
    "                mainCache.remove(key);",
    "            }",
    "            mainCache.putAll(current.changes);",
    "        }",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Rollback current transaction level (discard all changes).",
    "     * @return true if rolled back, false if no active transaction",
    "     */",
    "    public boolean rollback() {",
    "        if (transactionStack.isEmpty()) {",
    "            return false;",
    "        }",
    "        transactionStack.remove(transactionStack.size() - 1);",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Execute a list of commands and return results.",
    "     */",
    "    public List<String> execute(List<String> commands) {",
    "        List<String> results = new ArrayList<>();",
    "        ",
    "        for (String command : commands) {",
    "            String[] parts = command.split(\" \");",
    "            String op = parts[0].toUpperCase();",
    "            ",
    "            switch (op) {",
    "                case \"SET\":",
    "                    set(parts[1], parts[2]);",
    "                    break;",
    "                case \"GET\":",
    "                    String value = get(parts[1]);",
    "                    results.add(value != null ? value : \"NULL\");",
    "                    break;",
    "                case \"DELETE\":",
    "                    delete(parts[1]);",
    "                    break;",
    "                case \"BEGIN\":",
    "                    begin();",
    "                    break;",
    "                case \"COMMIT\":",
    "                    results.add(commit() ? \"true\" : \"false\");",
    "                    break;",
    "                case \"ROLLBACK\":",
    "                    results.add(rollback() ? \"true\" : \"false\");",
    "                    break;",
    "            }",
    "        }",
    "        ",
    "        return results;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // DEMONSTRATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\u2550\".repeat(70));",
    "        System.out.println(\"KEY-VALUE CACHE WITH NESTED TRANSACTIONS - DEMO\");",
    "        System.out.println(\"\u2550\".repeat(70));",
    "        ",
    "        // Example 1",
    "        System.out.println(\"\\n\ud83d\udccc Example 1: Nested Commit then Rollback\");",
    "        System.out.println(\"-\".repeat(50));",
    "        Cache cache1 = new Cache();",
    "        List<String> result1 = cache1.execute(Arrays.asList(",
    "            \"SET a 1\", \"BEGIN\", \"SET a 10\", \"BEGIN\", \"SET a 100\",",
    "            \"GET a\", \"COMMIT\", \"GET a\", \"ROLLBACK\", \"GET a\"",
    "        ));",
    "        System.out.println(\"Results:  \" + result1);",
    "        System.out.println(\"Expected: [100, true, 100, true, 1]\");",
    "        ",
    "        // Example 2",
    "        System.out.println(\"\\n\ud83d\udccc Example 2: Rollback Inner, Commit Outer\");",
    "        System.out.println(\"-\".repeat(50));",
    "        Cache cache2 = new Cache();",
    "        List<String> result2 = cache2.execute(Arrays.asList(",
    "            \"BEGIN\", \"SET x 1\", \"BEGIN\", \"SET y 2\", \"ROLLBACK\",",
    "            \"GET y\", \"COMMIT\", \"GET x\", \"GET y\"",
    "        ));",
    "        System.out.println(\"Results:  \" + result2);",
    "        System.out.println(\"Expected: [true, NULL, true, 1, NULL]\");",
    "        ",
    "        System.out.println(\"\\n\" + \"\u2550\".repeat(70));",
    "        System.out.println(\"ALL TESTS COMPLETED!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-22",
      "explanation": "Class documentation and imports. Key insight: each transaction level needs BOTH a changes dict AND a deletions set."
    },
    {
      "lines": "24-27",
      "explanation": "Instance variables: main_cache (permanent storage) and transaction_stack (list of levels). Each level is a tuple of (changes, deletions)."
    },
    {
      "lines": "29-43",
      "explanation": "SET operation: if in transaction, add to current level's changes AND remove from deletions (a SET overrides a pending DELETE). Otherwise, write directly to main cache."
    },
    {
      "lines": "45-65",
      "explanation": "GET operation: **Critical** - traverse stack from TOP (innermost) to BOTTOM. At each level: (1) if key in deletions \u2192 return NULL immediately (deletion blocks lookup), (2) if key in changes \u2192 return value. Finally check main_cache."
    },
    {
      "lines": "67-82",
      "explanation": "DELETE operation: if in transaction, remove from changes AND add to deletions. The deletions set is what prevents GET from seeing the key in parent levels."
    },
    {
      "lines": "84-92",
      "explanation": "BEGIN: simply push a new empty level onto the stack. O(1) operation."
    },
    {
      "lines": "94-125",
      "explanation": "COMMIT: the most complex operation. Pop top level, then merge to parent (or main cache). **Order matters**: apply deletions first, then changes. This ensures that 'DELETE a; SET a 5' results in a=5 being set."
    },
    {
      "lines": "127-140",
      "explanation": "ROLLBACK: simply pop and discard the top level. All changes and deletions in that level are lost. O(1) operation."
    },
    {
      "lines": "142-170",
      "explanation": "EXECUTE: command parser. Routes each command to appropriate method, collects results from GET/COMMIT/ROLLBACK."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "begin": {
          "complexity": "O(1)",
          "explanation": "Just push empty tuple onto stack"
        },
        "commit": {
          "complexity": "O(k)",
          "explanation": "Must iterate through all changes and deletions in current level to merge. k = number of keys modified in current level"
        },
        "rollback": {
          "complexity": "O(1)",
          "explanation": "Just pop and discard"
        },
        "get": {
          "complexity": "O(d)",
          "explanation": "Must traverse all d transaction levels in worst case"
        },
        "set": {
          "complexity": "O(1)",
          "explanation": "Just update current level"
        },
        "delete": {
          "complexity": "O(1)",
          "explanation": "Just update current level"
        }
      },
      "overall_change": "GET becomes O(d) instead of O(1) due to stack traversal. COMMIT becomes O(k) due to merge operation. This is acceptable as d (depth) is typically small in practice."
    },
    "space": {
      "additional_space": "O(d * k)",
      "explanation": "d = nesting depth, k = average keys per level. Each level stores its own changes HashMap and deletions HashSet. In worst case, each level could duplicate all keys."
    }
  },
  "dry_run": {
    "example_input": "SET a 1, BEGIN, SET a 10, BEGIN, SET a 100, GET a, COMMIT, GET a, ROLLBACK, GET a",
    "steps": [
      {
        "step": 1,
        "action": "SET a 1",
        "state": "Main: {a:1}, Stack: []",
        "explanation": "No transaction active, write directly to main cache"
      },
      {
        "step": 2,
        "action": "BEGIN",
        "state": "Main: {a:1}, Stack: [L1:({},{})]",
        "explanation": "Push new empty level L1 onto stack"
      },
      {
        "step": 3,
        "action": "SET a 10",
        "state": "Main: {a:1}, Stack: [L1:({a:10},{})]",
        "explanation": "In transaction, write to L1's changes"
      },
      {
        "step": 4,
        "action": "BEGIN",
        "state": "Main: {a:1}, Stack: [L1:({a:10},{}), L2:({},{})]",
        "explanation": "Push new level L2 onto stack"
      },
      {
        "step": 5,
        "action": "SET a 100",
        "state": "Main: {a:1}, Stack: [L1:({a:10},{}), L2:({a:100},{})]",
        "explanation": "Write to L2 (topmost level)"
      },
      {
        "step": 6,
        "action": "GET a",
        "state": "Output: '100'",
        "explanation": "Start at L2: a=100 found! Return immediately."
      },
      {
        "step": 7,
        "action": "COMMIT",
        "state": "Main: {a:1}, Stack: [L1:({a:100},{})]",
        "explanation": "Pop L2, merge to L1. L2.changes={a:100} \u2192 L1.changes[a]=100. Output: 'true'"
      },
      {
        "step": 8,
        "action": "GET a",
        "state": "Output: '100'",
        "explanation": "Check L1: a=100 found! Return."
      },
      {
        "step": 9,
        "action": "ROLLBACK",
        "state": "Main: {a:1}, Stack: []",
        "explanation": "Pop L1, discard all changes. Stack is now empty. Output: 'true'"
      },
      {
        "step": 10,
        "action": "GET a",
        "state": "Output: '1'",
        "explanation": "No transactions. Check main cache: a=1. Return '1'"
      }
    ],
    "final_output": "['100', 'true', '100', 'true', '1']"
  },
  "edge_cases": [
    {
      "case": "COMMIT/ROLLBACK with no transaction",
      "handling": "Check if stack is empty, return false",
      "gotcha": "Don't crash or throw exception - silently return false"
    },
    {
      "case": "DELETE in inner transaction, then GET",
      "handling": "Deletions set blocks lookups from reaching parent levels",
      "gotcha": "Without deletion tracking, GET would incorrectly find value in parent"
    },
    {
      "case": "SET after DELETE in same transaction",
      "handling": "SET removes key from deletions set",
      "gotcha": "Order: DELETE a, SET a 5 should result in a=5, not a deleted"
    },
    {
      "case": "Multiple commits emptying the stack",
      "handling": "Last commit writes to main cache",
      "gotcha": "Make sure final merge goes to main cache, not null parent"
    },
    {
      "case": "GET for key that doesn't exist anywhere",
      "handling": "Return None/null after traversing all levels",
      "gotcha": "Don't confuse 'not found' with 'deleted' - both return NULL"
    },
    {
      "case": "Very deep nesting (100+ levels)",
      "handling": "Stack grows linearly, GET traverses all levels",
      "gotcha": "Consider if performance degradation is acceptable for use case"
    }
  ],
  "test_cases": [
    {
      "name": "Basic nested commit then rollback",
      "input": "[SET a 1, BEGIN, SET a 10, BEGIN, SET a 100, GET a, COMMIT, GET a, ROLLBACK, GET a]",
      "expected": "[100, true, 100, true, 1]",
      "explanation": "Inner commit merges to outer, outer rollback discards all, back to original"
    },
    {
      "name": "Inner rollback preserves outer",
      "input": "[BEGIN, SET x 1, BEGIN, SET y 2, ROLLBACK, GET y, COMMIT, GET x, GET y]",
      "expected": "[true, NULL, true, 1, NULL]",
      "explanation": "Rolling back inner only discards y=2, outer x=1 commits to main"
    },
    {
      "name": "Delete in transaction blocks parent",
      "input": "[SET a 1, BEGIN, DELETE a, GET a, ROLLBACK, GET a]",
      "expected": "[NULL, true, 1]",
      "explanation": "DELETE marks key as deleted, GET sees NULL. Rollback restores access."
    },
    {
      "name": "Override delete with set",
      "input": "[SET a 1, BEGIN, DELETE a, SET a 99, GET a, COMMIT, GET a]",
      "expected": "[99, true, 99]",
      "explanation": "SET after DELETE should work - key ends up as 99"
    },
    {
      "name": "No transaction commit fails",
      "input": "[COMMIT, ROLLBACK]",
      "expected": "[false, false]",
      "explanation": "Both return false when no active transaction"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not tracking deletions separately",
      "why_wrong": "If you only remove from changes HashMap, GET will find value in parent level. Example: Main has {a:1}, BEGIN, DELETE a, GET a \u2192 would return 1 instead of NULL",
      "correct_approach": "Maintain a deletions Set at each level. GET checks deletions FIRST at each level.",
      "code_example_wrong": "def delete(self, key):\n    if self.transaction_stack:\n        self.transaction_stack[-1].pop(key, None)  # WRONG!",
      "code_example_correct": "def delete(self, key):\n    if self.transaction_stack:\n        changes, deletions = self.transaction_stack[-1]\n        changes.pop(key, None)\n        deletions.add(key)  # CORRECT!"
    },
    {
      "mistake": "Committing directly to main cache",
      "why_wrong": "With nested transactions, COMMIT should merge to parent level, not main cache. Only the outermost commit writes to main.",
      "correct_approach": "Check if stack has more than one level. If yes, merge to parent. If this was last level, merge to main cache.",
      "code_example_wrong": "def commit(self):\n    changes = self.transaction_stack.pop()\n    self.main_cache.update(changes)  # WRONG for nested!",
      "code_example_correct": "def commit(self):\n    changes, deletions = self.transaction_stack.pop()\n    if self.transaction_stack:\n        # Merge to parent\n    else:\n        self.main_cache.update(changes)"
    },
    {
      "mistake": "Wrong merge order: changes before deletions",
      "why_wrong": "If you apply changes first then deletions, 'DELETE a; SET a 5' would incorrectly result in a being deleted",
      "correct_approach": "Apply deletions to parent FIRST (remove from changes, add to deletions), THEN apply changes (add to changes, remove from deletions)",
      "code_example_wrong": "parent.changes.update(current.changes)  # WRONG ORDER\nfor k in current.deletions:\n    parent.deletions.add(k)",
      "code_example_correct": "for k in current.deletions:  # DELETIONS FIRST\n    parent.changes.pop(k, None)\n    parent.deletions.add(k)\nfor k, v in current.changes.items():  # THEN CHANGES\n    parent.changes[k] = v\n    parent.deletions.discard(k)"
    },
    {
      "mistake": "Forgetting to remove from deletions when setting",
      "why_wrong": "If you DELETE then SET in same transaction, key would remain in deletions, blocking future GETs",
      "correct_approach": "When SET is called, also remove the key from deletions set",
      "code_example_wrong": "def set(self, key, value):\n    self.transaction_stack[-1].changes[key] = value  # INCOMPLETE",
      "code_example_correct": "def set(self, key, value):\n    changes, deletions = self.transaction_stack[-1]\n    changes[key] = value\n    deletions.discard(key)  # IMPORTANT!"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the key insight: 'Nested transactions form a stack, and each level needs to track BOTH changes AND deletions. The deletion set is crucial because it blocks lookups from reaching parent levels.' Draw the stack diagram. Walk through a simple example before coding.",
    "what_to_mention": [
      "Why deletions need a separate set (key insight!)",
      "COMMIT merges to parent, not main cache",
      "Order matters in merge: deletions first, then changes",
      "GET traverses from innermost to outermost",
      "This pattern is used in real databases (savepoints)"
    ],
    "time_allocation": "Understanding: 2min, Approach explanation: 3min, Coding: 7min, Testing: 3min",
    "if_stuck": [
      "Think about what DELETE should do - it's not just removing, it's blocking",
      "Consider: Main={a:1}, BEGIN, DELETE a, GET a - what should return?",
      "Draw the stack with levels, visualize what data each level needs",
      "Think of COMMIT as 'merge down' and ROLLBACK as 'discard top'"
    ]
  },
  "connection_to_next_part": "Part 4 could add TTL (time-to-live) for entries, making each transaction level track not just values but also expiration timestamps. This would require the deletion set to include both explicit deletes AND expired entries.",
  "generated_at": "2026-01-14T15:03:11.147737",
  "_meta": {
    "problem_id": "cache_system_with_transactions",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}