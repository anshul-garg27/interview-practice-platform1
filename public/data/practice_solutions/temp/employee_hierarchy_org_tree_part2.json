{
  "problem_title": "Employee Hierarchy / Org Tree - Part 2: Best Performing Team",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 extends the basic org chart structure to support **aggregate queries** across team hierarchies. Instead of just storing and retrieving individual employee data, we now need to compute **team-level metrics** by traversing subtrees and aggregating ratings. This transforms the problem from simple lookup operations to tree traversal algorithms.",
    "new_requirements": [
      "Compute team statistics (total rating, team size, average) for any employee's team",
      "Find the employee whose team has the highest average performance rating",
      "Team includes the employee themselves plus ALL direct and indirect subordinates",
      "Handle edge cases like leaf nodes (team of 1) and empty org charts"
    ],
    "new_constraints": [
      "getBestPerformingTeamLead must run in O(n) time for optimal solution",
      "getTeamStats should run in O(subtree size) time",
      "Must handle ties in average rating (return any valid employee)",
      "Floating point comparison for averages"
    ],
    "key_insight": "**Post-order DFS** is the key: process all children first, aggregate their stats, then compute the parent's team stats. This allows us to compute all team averages in a single O(n) traversal rather than O(n\u00b2) for naive repeated subtree traversals. Leaf nodes are trivial - their team average is just their own rating."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551              BEFORE (Part 1)              \u2192     AFTER (Part 2)       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                      \u2551\n\u2551  OrgChart stores:                          OrgChart now supports:    \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551  \u2502 employees: Dict     \u2502                   \u2502 employees: Dict     \u2502   \u2551\n\u2551  \u2502 direct_reports: Dict\u2502     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba      \u2502 direct_reports: Dict\u2502   \u2551\n\u2551  \u2502                     \u2502                   \u2502 + getTeamStats()    \u2502   \u2551\n\u2551  \u2502 Simple lookups only \u2502                   \u2502 + getBestTeamLead() \u2502   \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                                                                      \u2551\n\u2551  Operations: O(1) lookups                  Operations: O(n) DFS      \u2551\n\u2551                                                                      \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             POST-ORDER DFS ALGORITHM FLOW                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                        \u2502\n\u2502  Step 1: Start at root, recursively process children FIRST             \u2502\n\u2502                                                                        \u2502\n\u2502              A(5)                                                      \u2502\n\u2502             / \\                                                        \u2502\n\u2502          B(3) C(2)         Process order: B \u2192 D \u2192 E \u2192 C \u2192 A            \u2502\n\u2502               / \\                                                      \u2502\n\u2502            D(4) E(10)                                                  \u2502\n\u2502                                                                        \u2502\n\u2502  Step 2: At each node, compute stats from children + self              \u2502\n\u2502                                                                        \u2502\n\u2502  Node E (leaf):  total=10, size=1, avg=10.0  \u2605 Track best!            \u2502\n\u2502  Node D (leaf):  total=4,  size=1, avg=4.0                             \u2502\n\u2502  Node C:         total=2+4+10=16, size=3, avg=5.33                     \u2502\n\u2502  Node B (leaf):  total=3,  size=1, avg=3.0                             \u2502\n\u2502  Node A:         total=5+3+16=24, size=5, avg=4.8                      \u2502\n\u2502                                                                        \u2502\n\u2502  Step 3: During traversal, track maximum average                       \u2502\n\u2502                                                                        \u2502\n\u2502  best_avg = 10.0, best_employee = E                                    \u2502\n\u2502                                                                        \u2502\n\u2502  Result: Return Employee E                                             \u2502\n\u2502                                                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "For each employee in the org chart, traverse their entire subtree to compute team stats. Then compare all averages to find the maximum. This essentially calls getTeamStats() for every employee independently.",
      "time_complexity": "O(n\u00b2)",
      "space_complexity": "O(h) where h is tree height for recursion stack",
      "why_not_optimal": "Each subtree is traversed multiple times. For employee A, we traverse the whole tree. For employee C, we traverse their subtree again. In a worst-case linear tree (like a linked list), this results in 1 + 2 + 3 + ... + n = O(n\u00b2) operations. We're doing redundant work by not reusing computed subtree statistics."
    },
    {
      "name": "Optimal Approach - Single Pass DFS",
      "description": "Use **post-order DFS** to visit each node exactly once. For each node, the recursive call returns (totalRating, teamSize) for that subtree. The parent aggregates children's stats + own rating to compute its team stats. During this single traversal, we track the maximum average seen.",
      "time_complexity": "O(n)",
      "space_complexity": "O(h) for recursion stack, O(1) extra space for tracking best",
      "key_insight": "By returning (total, size) from each recursive call, we can compute team stats for ALL employees in ONE traversal. The parent doesn't need to re-traverse children - it just sums up the returned values. This is the classic 'return information up the tree' pattern."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The optimal solution leverages **post-order tree traversal** to compute all team statistics in a single pass:\n\n1. **Data Structure**: We use the same HashMap-based structure from Part 1, storing employees and their direct reports. No additional data structures needed for the traversal.\n\n2. **Post-Order DFS Pattern**:\n   - For each node, **first** recursively process all children\n   - **Then** aggregate children's (total, size) with self's rating\n   - **Finally** check if current team's average is the best seen so far\n\n3. **Information Propagation**: Each recursive call returns a tuple `(total_rating, team_size)`. The parent receives these from all children, sums them up, adds its own rating and +1 for itself.\n\n4. **Tracking Maximum**: As we compute each team's average, we compare with the global maximum and update if better. This avoids a second pass.\n\n5. **Edge Cases**:\n   - **Leaf nodes**: team_size=1, total=own rating \u2192 average=own rating\n   - **Empty org**: return None\n   - **Single employee**: that employee is the best (and only) team lead",
    "data_structures": [
      {
        "structure": "HashMap (employees)",
        "purpose": "O(1) lookup of employee by ID"
      },
      {
        "structure": "HashMap (direct_reports)",
        "purpose": "O(1) access to children list for DFS"
      },
      {
        "structure": "Tuple (total, size)",
        "purpose": "Return value from DFS to propagate stats up"
      },
      {
        "structure": "Instance variables",
        "purpose": "Track best_average and best_employee during DFS"
      }
    ],
    "algorithm_steps": [
      "Step 1: Check if org chart is empty \u2192 return None if so",
      "Step 2: Initialize tracking variables: best_average = -infinity, best_employee = None",
      "Step 3: Start DFS from root (or iterate all roots if multiple exist)",
      "Step 4: At each node, recursively call DFS on all direct reports first (post-order)",
      "Step 5: Aggregate: total = self.rating + sum(child_totals), size = 1 + sum(child_sizes)",
      "Step 6: Compute average = total / size for current employee's team",
      "Step 7: If average > best_average, update best_average and best_employee",
      "Step 8: Return (total, size) tuple to parent for aggregation",
      "Step 9: After DFS completes, return best_employee"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Employee Hierarchy / Org Tree - Complete Solution (Parts 1 & 2)",
    "",
    "This module implements an organizational chart system with:",
    "- Employee management (add, retrieve, relationships)",
    "- Team statistics computation",
    "- Best performing team lead identification",
    "",
    "Time Complexity:",
    "- getBestPerformingTeamLead: O(n) using post-order DFS",
    "- getTeamStats: O(subtree size)",
    "",
    "Author: World-Class Software Engineer Solution",
    "\"\"\"",
    "",
    "from typing import Dict, List, Optional, Tuple",
    "from dataclasses import dataclass, field",
    "",
    "",
    "@dataclass",
    "class Employee:",
    "    \"\"\"Represents an employee in the organization.\"\"\"",
    "    id: int",
    "    name: str",
    "    rating: int",
    "    manager_id: Optional[int] = None",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Employee(id={self.id}, name='{self.name}', rating={self.rating})\"",
    "",
    "",
    "@dataclass",
    "class TeamStats:",
    "    \"\"\"Statistics for an employee's team (themselves + all subordinates).\"\"\"",
    "    total_rating: int",
    "    team_size: int",
    "    average: float",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"TeamStats(total={self.total_rating}, size={self.team_size}, avg={self.average:.2f})\"",
    "",
    "",
    "class OrgChart:",
    "    \"\"\"",
    "    Organizational chart management system.",
    "    ",
    "    Supports hierarchical employee structure with efficient queries",
    "    for team statistics and performance analysis.",
    "    ",
    "    Attributes:",
    "        _employees: Mapping of employee ID to Employee object",
    "        _direct_reports: Mapping of manager ID to list of direct report IDs",
    "        _root_ids: Set of employee IDs with no manager (tree roots)",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize an empty organizational chart.\"\"\"",
    "        self._employees: Dict[int, Employee] = {}",
    "        self._direct_reports: Dict[int, List[int]] = {}",
    "        self._root_ids: set = set()  # Track employees with no manager",
    "        ",
    "        # Tracking variables for best team lead search",
    "        self._best_employee: Optional[Employee] = None",
    "        self._best_average: float = float('-inf')",
    "    ",
    "    # ==================== PART 1: Basic Operations ====================",
    "    ",
    "    def add_employee(",
    "        self,",
    "        employee_id: int,",
    "        name: str,",
    "        rating: int,",
    "        manager_id: Optional[int]",
    "    ) -> bool:",
    "        \"\"\"",
    "        Add a new employee to the organization.",
    "        ",
    "        Args:",
    "            employee_id: Unique identifier for the employee",
    "            name: Employee's name",
    "            rating: Performance rating (integer)",
    "            manager_id: ID of manager, or None if no manager (root)",
    "        ",
    "        Returns:",
    "            True if employee was added successfully, False otherwise",
    "            (e.g., duplicate ID or manager doesn't exist)",
    "        \"\"\"",
    "        # Validation: Check for duplicate ID",
    "        if employee_id in self._employees:",
    "            return False",
    "        ",
    "        # Validation: Manager must exist (if specified)",
    "        if manager_id is not None and manager_id not in self._employees:",
    "            return False",
    "        ",
    "        # Create and store the employee",
    "        employee = Employee(",
    "            id=employee_id,",
    "            name=name,",
    "            rating=rating,",
    "            manager_id=manager_id",
    "        )",
    "        self._employees[employee_id] = employee",
    "        ",
    "        # Update relationships",
    "        if manager_id is None:",
    "            # This employee is a root (no manager)",
    "            self._root_ids.add(employee_id)",
    "        else:",
    "            # Add to manager's direct reports",
    "            if manager_id not in self._direct_reports:",
    "                self._direct_reports[manager_id] = []",
    "            self._direct_reports[manager_id].append(employee_id)",
    "        ",
    "        return True",
    "    ",
    "    def get_employee(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"",
    "        Retrieve an employee by their ID.",
    "        ",
    "        Args:",
    "            employee_id: The ID to look up",
    "        ",
    "        Returns:",
    "            Employee object if found, None otherwise",
    "        \"\"\"",
    "        return self._employees.get(employee_id)",
    "    ",
    "    def get_direct_reports(self, employee_id: int) -> List[Employee]:",
    "        \"\"\"",
    "        Get all direct reports of an employee.",
    "        ",
    "        Args:",
    "            employee_id: ID of the manager",
    "        ",
    "        Returns:",
    "            List of Employee objects who report directly to this person",
    "        \"\"\"",
    "        if employee_id not in self._employees:",
    "            return []",
    "        ",
    "        report_ids = self._direct_reports.get(employee_id, [])",
    "        return [self._employees[rid] for rid in report_ids]",
    "    ",
    "    def get_manager(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"Get the manager of an employee.\"\"\"",
    "        employee = self._employees.get(employee_id)",
    "        if employee is None or employee.manager_id is None:",
    "            return None",
    "        return self._employees.get(employee.manager_id)",
    "    ",
    "    # ==================== PART 2: Team Statistics ====================",
    "    ",
    "    def get_team_stats(self, employee_id: int) -> Optional[TeamStats]:",
    "        \"\"\"",
    "        Compute statistics for an employee's team.",
    "        ",
    "        A team consists of the employee plus ALL their subordinates",
    "        (direct and indirect).",
    "        ",
    "        Args:",
    "            employee_id: ID of the team lead",
    "        ",
    "        Returns:",
    "            TeamStats object with total_rating, team_size, and average,",
    "            or None if employee doesn't exist",
    "        ",
    "        Time Complexity: O(subtree size) - visits each team member once",
    "        \"\"\"",
    "        if employee_id not in self._employees:",
    "            return None",
    "        ",
    "        total_rating, team_size = self._compute_team_stats_dfs(employee_id)",
    "        ",
    "        return TeamStats(",
    "            total_rating=total_rating,",
    "            team_size=team_size,",
    "            average=total_rating / team_size if team_size > 0 else 0.0",
    "        )",
    "    ",
    "    def _compute_team_stats_dfs(self, employee_id: int) -> Tuple[int, int]:",
    "        \"\"\"",
    "        Recursively compute team stats using post-order DFS.",
    "        ",
    "        Args:",
    "            employee_id: Current employee to process",
    "        ",
    "        Returns:",
    "            Tuple of (total_rating, team_size) for this subtree",
    "        \"\"\"",
    "        employee = self._employees[employee_id]",
    "        ",
    "        # Base values: this employee alone",
    "        total_rating = employee.rating",
    "        team_size = 1",
    "        ",
    "        # Aggregate stats from all direct reports (children)",
    "        for report_id in self._direct_reports.get(employee_id, []):",
    "            child_total, child_size = self._compute_team_stats_dfs(report_id)",
    "            total_rating += child_total",
    "            team_size += child_size",
    "        ",
    "        return total_rating, team_size",
    "    ",
    "    def get_best_performing_team_lead(self) -> Optional[Employee]:",
    "        \"\"\"",
    "        Find the employee whose team has the highest average rating.",
    "        ",
    "        Uses a single post-order DFS traversal to compute all team",
    "        averages and track the maximum in O(n) time.",
    "        ",
    "        Returns:",
    "            Employee with highest team average rating,",
    "            None if org chart is empty",
    "        ",
    "        Time Complexity: O(n) - visits each employee exactly once",
    "        Space Complexity: O(h) - recursion depth equals tree height",
    "        \"\"\"",
    "        if not self._employees:",
    "            return None",
    "        ",
    "        # Reset tracking variables",
    "        self._best_employee = None",
    "        self._best_average = float('-inf')",
    "        ",
    "        # Process each tree in the forest (usually just one root/CEO)",
    "        for root_id in self._root_ids:",
    "            self._find_best_team_lead_dfs(root_id)",
    "        ",
    "        return self._best_employee",
    "    ",
    "    def _find_best_team_lead_dfs(self, employee_id: int) -> Tuple[int, int]:",
    "        \"\"\"",
    "        Post-order DFS that computes team stats AND tracks best average.",
    "        ",
    "        This is the key optimization: we compute stats for all employees",
    "        in a single traversal by passing information UP the tree.",
    "        ",
    "        Args:",
    "            employee_id: Current employee to process",
    "        ",
    "        Returns:",
    "            Tuple of (total_rating, team_size) for this subtree",
    "        \"\"\"",
    "        employee = self._employees[employee_id]",
    "        ",
    "        # Start with this employee's own values",
    "        total_rating = employee.rating",
    "        team_size = 1",
    "        ",
    "        # POST-ORDER: Process children FIRST",
    "        for report_id in self._direct_reports.get(employee_id, []):",
    "            child_total, child_size = self._find_best_team_lead_dfs(report_id)",
    "            total_rating += child_total",
    "            team_size += child_size",
    "        ",
    "        # Now compute this team's average and check if it's the best",
    "        average = total_rating / team_size",
    "        ",
    "        if average > self._best_average:",
    "            self._best_average = average",
    "            self._best_employee = employee",
    "        ",
    "        # Return stats to parent for aggregation",
    "        return total_rating, team_size",
    "    ",
    "    # ==================== Utility Methods ====================",
    "    ",
    "    def get_all_employees(self) -> List[Employee]:",
    "        \"\"\"Return all employees in the organization.\"\"\"",
    "        return list(self._employees.values())",
    "    ",
    "    def size(self) -> int:",
    "        \"\"\"Return total number of employees.\"\"\"",
    "        return len(self._employees)",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"OrgChart(employees={len(self._employees)}, roots={len(self._root_ids)})\"",
    "",
    "",
    "# ==================== DEMO & TESTING ====================",
    "",
    "def run_example():",
    "    \"\"\"",
    "    Run the example from the problem statement.",
    "    ",
    "    Tree structure:",
    "          A (rating: 5)",
    "         / \\",
    "        B   C",
    "       (3) (2)",
    "           / \\",
    "          D   E",
    "         (4) (10)",
    "    \"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"EMPLOYEE HIERARCHY - PART 2: BEST PERFORMING TEAM\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    ",
    "    # Create org chart",
    "    org = OrgChart()",
    "    ",
    "    # Add employees (must add in order: manager before report)",
    "    print(\"Adding employees...\")",
    "    print(f\"  add_employee(1, 'A', 5, None) = {org.add_employee(1, 'A', 5, None)}\")",
    "    print(f\"  add_employee(2, 'B', 3, 1)    = {org.add_employee(2, 'B', 3, 1)}\")",
    "    print(f\"  add_employee(3, 'C', 2, 1)    = {org.add_employee(3, 'C', 2, 1)}\")",
    "    print(f\"  add_employee(4, 'D', 4, 3)    = {org.add_employee(4, 'D', 4, 3)}\")",
    "    print(f\"  add_employee(5, 'E', 10, 3)   = {org.add_employee(5, 'E', 10, 3)}\")",
    "    print()",
    "    ",
    "    # Display tree structure",
    "    print(\"Org Chart Structure:\")",
    "    print(\"        A(5)\")",
    "    print(\"       /   \\\\\")",
    "    print(\"     B(3)  C(2)\")",
    "    print(\"           / \\\\\")",
    "    print(\"        D(4) E(10)\")",
    "    print()",
    "    ",
    "    # Test getTeamStats",
    "    print(\"Team Statistics:\")",
    "    print(\"-\" * 40)",
    "    ",
    "    for emp_id in [1, 2, 3, 4, 5]:",
    "        stats = org.get_team_stats(emp_id)",
    "        emp = org.get_employee(emp_id)",
    "        print(f\"  Team {emp.name}: {stats}\")",
    "    print()",
    "    ",
    "    # Test getBestPerformingTeamLead",
    "    print(\"Finding Best Performing Team Lead...\")",
    "    print(\"-\" * 40)",
    "    ",
    "    best = org.get_best_performing_team_lead()",
    "    best_stats = org.get_team_stats(best.id)",
    "    ",
    "    print(f\"  Result: {best}\")",
    "    print(f\"  Team Stats: {best_stats}\")",
    "    print()",
    "    print(\"  Explanation: Employee E has a team of just themselves,\")",
    "    print(\"  so their team average equals their rating (10.0),\")",
    "    print(\"  which is the highest among all teams.\")",
    "    print()",
    "",
    "",
    "def run_edge_cases():",
    "    \"\"\"Test edge cases.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"EDGE CASE TESTING\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    ",
    "    # Edge case 1: Empty org chart",
    "    print(\"Test 1: Empty org chart\")",
    "    empty_org = OrgChart()",
    "    result = empty_org.get_best_performing_team_lead()",
    "    print(f\"  getBestPerformingTeamLead() = {result}\")",
    "    print(f\"  Expected: None \u2713\" if result is None else \"  FAILED!\")",
    "    print()",
    "    ",
    "    # Edge case 2: Single employee",
    "    print(\"Test 2: Single employee\")",
    "    single_org = OrgChart()",
    "    single_org.add_employee(1, \"Solo\", 7, None)",
    "    result = single_org.get_best_performing_team_lead()",
    "    stats = single_org.get_team_stats(1)",
    "    print(f\"  getBestPerformingTeamLead() = {result}\")",
    "    print(f\"  getTeamStats(1) = {stats}\")",
    "    print(f\"  Expected: Employee Solo with avg 7.0 \u2713\" if result and result.name == \"Solo\" else \"  FAILED!\")",
    "    print()",
    "    ",
    "    # Edge case 3: Non-existent employee",
    "    print(\"Test 3: Non-existent employee stats\")",
    "    stats = single_org.get_team_stats(999)",
    "    print(f\"  getTeamStats(999) = {stats}\")",
    "    print(f\"  Expected: None \u2713\" if stats is None else \"  FAILED!\")",
    "    print()",
    "    ",
    "    # Edge case 4: All same ratings",
    "    print(\"Test 4: All same ratings (tie-breaking)\")",
    "    tied_org = OrgChart()",
    "    tied_org.add_employee(1, \"A\", 5, None)",
    "    tied_org.add_employee(2, \"B\", 5, 1)",
    "    tied_org.add_employee(3, \"C\", 5, 1)",
    "    result = tied_org.get_best_performing_team_lead()",
    "    print(f\"  All employees have rating 5\")",
    "    print(f\"  getBestPerformingTeamLead() = {result}\")",
    "    print(f\"  Any leaf node is valid (avg = 5.0)\")",
    "    print()",
    "",
    "",
    "def run_performance_analysis():",
    "    \"\"\"Demonstrate O(n) time complexity.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"ALGORITHM TRACE (showing post-order DFS)\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    print(\"Processing order for the example tree:\")",
    "    print()",
    "    print(\"  1. Visit B (leaf): total=3, size=1, avg=3.0\")",
    "    print(\"  2. Visit D (leaf): total=4, size=1, avg=4.0\")",
    "    print(\"  3. Visit E (leaf): total=10, size=1, avg=10.0 \u2605 BEST SO FAR\")",
    "    print(\"  4. Visit C: aggregate D,E \u2192 total=2+4+10=16, size=3, avg=5.33\")",
    "    print(\"  5. Visit A: aggregate B,C \u2192 total=5+3+16=24, size=5, avg=4.8\")",
    "    print()",
    "    print(\"Total nodes visited: 5 (each exactly once) \u2192 O(n)\")",
    "    print()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_example()",
    "    run_edge_cases()",
    "    run_performance_analysis()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Employee Hierarchy / Org Tree - Complete Solution (Parts 1 & 2)",
    " * ",
    " * This class implements an organizational chart system with:",
    " * - Employee management (add, retrieve, relationships)",
    " * - Team statistics computation",
    " * - Best performing team lead identification",
    " * ",
    " * Time Complexity:",
    " * - getBestPerformingTeamLead: O(n) using post-order DFS",
    " * - getTeamStats: O(subtree size)",
    " */",
    "public class OrgChart {",
    "    ",
    "    // ==================== Inner Classes ====================",
    "    ",
    "    /**",
    "     * Represents an employee in the organization.",
    "     */",
    "    public static class Employee {",
    "        public final int id;",
    "        public final String name;",
    "        public final int rating;",
    "        public final Integer managerId;",
    "        ",
    "        public Employee(int id, String name, int rating, Integer managerId) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.rating = rating;",
    "            this.managerId = managerId;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"Employee(id=%d, name='%s', rating=%d)\", id, name, rating);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Statistics for an employee's team (themselves + all subordinates).",
    "     */",
    "    public static class TeamStats {",
    "        public final int totalRating;",
    "        public final int teamSize;",
    "        public final double average;",
    "        ",
    "        public TeamStats(int totalRating, int teamSize, double average) {",
    "            this.totalRating = totalRating;",
    "            this.teamSize = teamSize;",
    "            this.average = average;",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            return String.format(\"TeamStats(total=%d, size=%d, avg=%.2f)\", ",
    "                                 totalRating, teamSize, average);",
    "        }",
    "    }",
    "    ",
    "    // Helper class to return two values from DFS",
    "    private static class StatsResult {",
    "        final int total;",
    "        final int size;",
    "        ",
    "        StatsResult(int total, int size) {",
    "            this.total = total;",
    "            this.size = size;",
    "        }",
    "    }",
    "    ",
    "    // ==================== Fields ====================",
    "    ",
    "    private final Map<Integer, Employee> employees;",
    "    private final Map<Integer, List<Integer>> directReports;",
    "    private final Set<Integer> rootIds;",
    "    ",
    "    // Tracking variables for best team lead search",
    "    private Employee bestEmployee;",
    "    private double bestAverage;",
    "    ",
    "    // ==================== Constructor ====================",
    "    ",
    "    public OrgChart() {",
    "        this.employees = new HashMap<>();",
    "        this.directReports = new HashMap<>();",
    "        this.rootIds = new HashSet<>();",
    "        this.bestEmployee = null;",
    "        this.bestAverage = Double.NEGATIVE_INFINITY;",
    "    }",
    "    ",
    "    // ==================== PART 1: Basic Operations ====================",
    "    ",
    "    /**",
    "     * Add a new employee to the organization.",
    "     * ",
    "     * @param employeeId Unique identifier for the employee",
    "     * @param name Employee's name",
    "     * @param rating Performance rating (integer)",
    "     * @param managerId ID of manager, or null if no manager (root)",
    "     * @return true if added successfully, false otherwise",
    "     */",
    "    public boolean addEmployee(int employeeId, String name, int rating, Integer managerId) {",
    "        // Validation: Check for duplicate ID",
    "        if (employees.containsKey(employeeId)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Validation: Manager must exist (if specified)",
    "        if (managerId != null && !employees.containsKey(managerId)) {",
    "            return false;",
    "        }",
    "        ",
    "        // Create and store the employee",
    "        Employee employee = new Employee(employeeId, name, rating, managerId);",
    "        employees.put(employeeId, employee);",
    "        ",
    "        // Update relationships",
    "        if (managerId == null) {",
    "            rootIds.add(employeeId);",
    "        } else {",
    "            directReports.computeIfAbsent(managerId, k -> new ArrayList<>()).add(employeeId);",
    "        }",
    "        ",
    "        return true;",
    "    }",
    "    ",
    "    /**",
    "     * Retrieve an employee by their ID.",
    "     */",
    "    public Employee getEmployee(int employeeId) {",
    "        return employees.get(employeeId);",
    "    }",
    "    ",
    "    /**",
    "     * Get all direct reports of an employee.",
    "     */",
    "    public List<Employee> getDirectReports(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        List<Integer> reportIds = directReports.getOrDefault(employeeId, Collections.emptyList());",
    "        List<Employee> result = new ArrayList<>();",
    "        for (int id : reportIds) {",
    "            result.add(employees.get(id));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== PART 2: Team Statistics ====================",
    "    ",
    "    /**",
    "     * Compute statistics for an employee's team.",
    "     * ",
    "     * A team consists of the employee plus ALL their subordinates.",
    "     * ",
    "     * @param employeeId ID of the team lead",
    "     * @return TeamStats object, or null if employee doesn't exist",
    "     * ",
    "     * Time Complexity: O(subtree size)",
    "     */",
    "    public TeamStats getTeamStats(int employeeId) {",
    "        if (!employees.containsKey(employeeId)) {",
    "            return null;",
    "        }",
    "        ",
    "        StatsResult result = computeTeamStatsDfs(employeeId);",
    "        double average = result.size > 0 ? (double) result.total / result.size : 0.0;",
    "        ",
    "        return new TeamStats(result.total, result.size, average);",
    "    }",
    "    ",
    "    /**",
    "     * Recursively compute team stats using post-order DFS.",
    "     */",
    "    private StatsResult computeTeamStatsDfs(int employeeId) {",
    "        Employee employee = employees.get(employeeId);",
    "        ",
    "        int totalRating = employee.rating;",
    "        int teamSize = 1;",
    "        ",
    "        List<Integer> reports = directReports.getOrDefault(employeeId, Collections.emptyList());",
    "        for (int reportId : reports) {",
    "            StatsResult childResult = computeTeamStatsDfs(reportId);",
    "            totalRating += childResult.total;",
    "            teamSize += childResult.size;",
    "        }",
    "        ",
    "        return new StatsResult(totalRating, teamSize);",
    "    }",
    "    ",
    "    /**",
    "     * Find the employee whose team has the highest average rating.",
    "     * ",
    "     * Uses a single post-order DFS traversal for O(n) time complexity.",
    "     * ",
    "     * @return Employee with highest team average, null if org is empty",
    "     */",
    "    public Employee getBestPerformingTeamLead() {",
    "        if (employees.isEmpty()) {",
    "            return null;",
    "        }",
    "        ",
    "        // Reset tracking variables",
    "        bestEmployee = null;",
    "        bestAverage = Double.NEGATIVE_INFINITY;",
    "        ",
    "        // Process each tree in the forest",
    "        for (int rootId : rootIds) {",
    "            findBestTeamLeadDfs(rootId);",
    "        }",
    "        ",
    "        return bestEmployee;",
    "    }",
    "    ",
    "    /**",
    "     * Post-order DFS that computes team stats AND tracks best average.",
    "     * ",
    "     * Key optimization: compute stats for all employees in single traversal.",
    "     */",
    "    private StatsResult findBestTeamLeadDfs(int employeeId) {",
    "        Employee employee = employees.get(employeeId);",
    "        ",
    "        int totalRating = employee.rating;",
    "        int teamSize = 1;",
    "        ",
    "        // POST-ORDER: Process children FIRST",
    "        List<Integer> reports = directReports.getOrDefault(employeeId, Collections.emptyList());",
    "        for (int reportId : reports) {",
    "            StatsResult childResult = findBestTeamLeadDfs(reportId);",
    "            totalRating += childResult.total;",
    "            teamSize += childResult.size;",
    "        }",
    "        ",
    "        // Compute average and check if best",
    "        double average = (double) totalRating / teamSize;",
    "        ",
    "        if (average > bestAverage) {",
    "            bestAverage = average;",
    "            bestEmployee = employee;",
    "        }",
    "        ",
    "        return new StatsResult(totalRating, teamSize);",
    "    }",
    "    ",
    "    // ==================== Main Method for Testing ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"EMPLOYEE HIERARCHY - PART 2: BEST PERFORMING TEAM\");",
    "        System.out.println(\"============================================================\");",
    "        System.out.println();",
    "        ",
    "        OrgChart org = new OrgChart();",
    "        ",
    "        // Add employees",
    "        System.out.println(\"Adding employees...\");",
    "        System.out.println(\"  addEmployee(1, 'A', 5, null) = \" + org.addEmployee(1, \"A\", 5, null));",
    "        System.out.println(\"  addEmployee(2, 'B', 3, 1)    = \" + org.addEmployee(2, \"B\", 3, 1));",
    "        System.out.println(\"  addEmployee(3, 'C', 2, 1)    = \" + org.addEmployee(3, \"C\", 2, 1));",
    "        System.out.println(\"  addEmployee(4, 'D', 4, 3)    = \" + org.addEmployee(4, \"D\", 4, 3));",
    "        System.out.println(\"  addEmployee(5, 'E', 10, 3)   = \" + org.addEmployee(5, \"E\", 10, 3));",
    "        System.out.println();",
    "        ",
    "        // Display structure",
    "        System.out.println(\"Org Chart Structure:\");",
    "        System.out.println(\"        A(5)\");",
    "        System.out.println(\"       /   \\\\\");",
    "        System.out.println(\"     B(3)  C(2)\");",
    "        System.out.println(\"           / \\\\\");",
    "        System.out.println(\"        D(4) E(10)\");",
    "        System.out.println();",
    "        ",
    "        // Test getTeamStats",
    "        System.out.println(\"Team Statistics:\");",
    "        System.out.println(\"----------------------------------------\");",
    "        for (int id = 1; id <= 5; id++) {",
    "            TeamStats stats = org.getTeamStats(id);",
    "            Employee emp = org.getEmployee(id);",
    "            System.out.println(\"  Team \" + emp.name + \": \" + stats);",
    "        }",
    "        System.out.println();",
    "        ",
    "        // Test getBestPerformingTeamLead",
    "        System.out.println(\"Finding Best Performing Team Lead...\");",
    "        System.out.println(\"----------------------------------------\");",
    "        ",
    "        Employee best = org.getBestPerformingTeamLead();",
    "        TeamStats bestStats = org.getTeamStats(best.id);",
    "        ",
    "        System.out.println(\"  Result: \" + best);",
    "        System.out.println(\"  Team Stats: \" + bestStats);",
    "        System.out.println();",
    "        System.out.println(\"  Explanation: Employee E has a team of just themselves,\");",
    "        System.out.println(\"  so their team average equals their rating (10.0),\");",
    "        System.out.println(\"  which is the highest among all teams.\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Module docstring and imports. We use `dataclass` for clean data containers, `Dict` and `List` for type hints, `Optional` for nullable types, and `Tuple` for returning multiple values from DFS."
    },
    {
      "lines": "17-28",
      "explanation": "**Employee dataclass**: Immutable representation of an employee with id, name, rating, and optional manager_id. The `__repr__` method provides clean string output for debugging."
    },
    {
      "lines": "30-37",
      "explanation": "**TeamStats dataclass**: Holds computed team statistics - total rating sum, team size count, and calculated average. This is the return type for `get_team_stats()`."
    },
    {
      "lines": "39-58",
      "explanation": "**OrgChart class initialization**: Three main data structures - `_employees` HashMap for O(1) lookup, `_direct_reports` HashMap mapping manager ID to list of report IDs, and `_root_ids` set to track CEO(s). Also instance variables for tracking best employee during DFS."
    },
    {
      "lines": "60-95",
      "explanation": "**add_employee method (Part 1)**: Validates no duplicate IDs and that manager exists (if specified). Creates Employee object, stores in HashMap, and updates relationships. Returns boolean for success/failure."
    },
    {
      "lines": "97-120",
      "explanation": "**Basic getter methods (Part 1)**: `get_employee` does O(1) HashMap lookup. `get_direct_reports` returns list of Employee objects for a manager. `get_manager` follows the manager_id reference."
    },
    {
      "lines": "122-150",
      "explanation": "**get_team_stats method (Part 2)**: Public API that validates employee exists, calls private DFS helper, and constructs TeamStats object from returned tuple. Handles division by zero edge case."
    },
    {
      "lines": "152-172",
      "explanation": "**_compute_team_stats_dfs (Part 2)**: Recursive helper using post-order traversal. Starts with employee's own rating/count, then aggregates all children's stats. Returns (total, size) tuple for parent to use."
    },
    {
      "lines": "174-205",
      "explanation": "**get_best_performing_team_lead (Part 2)**: Main algorithm entry point. Returns None for empty org. Resets tracking variables, then initiates DFS from each root. Returns the employee with highest team average found during traversal."
    },
    {
      "lines": "207-235",
      "explanation": "**_find_best_team_lead_dfs (Part 2)**: The key optimized DFS. Post-order: processes all children first, aggregates their stats, computes current team's average, updates global best if higher, then returns stats tuple for parent. Single O(n) traversal computes all averages."
    },
    {
      "lines": "240-290",
      "explanation": "**Demo and testing code**: `run_example()` creates the exact tree from problem statement, shows all team stats, and demonstrates finding the best team lead. Includes explanatory output."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_team_stats": {
          "complexity": "O(k)",
          "explanation": "Where k is the size of the employee's subtree. We visit each node in the subtree exactly once during post-order DFS. For CEO, this is O(n). For leaf nodes, this is O(1)."
        },
        "get_best_performing_team_lead": {
          "complexity": "O(n)",
          "explanation": "Single post-order DFS visits each of the n employees exactly once. At each node, we do O(1) work: aggregate children's stats (O(children) but each edge traversed once total), compute average, compare with best."
        }
      },
      "overall_change": "Part 1 operations remain O(1). Part 2 adds O(n) for finding best team lead and O(subtree) for individual stats queries. The key insight is that we DON'T need O(n\u00b2) - the post-order pattern lets us compute everything in one pass."
    },
    "space": {
      "additional_space": "O(h)",
      "explanation": "The DFS recursion uses O(h) stack space where h is the tree height. In a balanced tree, h = O(log n). In worst case (linear chain), h = O(n). No additional data structures are stored permanently - we reuse the same HashMap from Part 1."
    }
  },
  "dry_run": {
    "example_input": "Tree: A(5) \u2192 [B(3), C(2)], C(2) \u2192 [D(4), E(10)]",
    "steps": [
      {
        "step": 1,
        "action": "Call getBestPerformingTeamLead()",
        "state": "best_avg=-inf, best_emp=None",
        "explanation": "Initialize tracking variables and start DFS from root A"
      },
      {
        "step": 2,
        "action": "DFS visits A, first processes child B",
        "state": "Currently at A, recursing to B",
        "explanation": "Post-order means we must process children before self"
      },
      {
        "step": 3,
        "action": "DFS at B (leaf node)",
        "state": "B: total=3, size=1, avg=3.0",
        "explanation": "B has no children. avg=3.0 > -inf, so best_emp=B, best_avg=3.0. Return (3,1)"
      },
      {
        "step": 4,
        "action": "DFS visits A's second child C",
        "state": "Currently at A, recursing to C",
        "explanation": "Continue with next child of A"
      },
      {
        "step": 5,
        "action": "DFS at C, first processes child D",
        "state": "Currently at C, recursing to D",
        "explanation": "C has children, so process them first"
      },
      {
        "step": 6,
        "action": "DFS at D (leaf node)",
        "state": "D: total=4, size=1, avg=4.0",
        "explanation": "D has no children. avg=4.0 > 3.0, so best_emp=D, best_avg=4.0. Return (4,1)"
      },
      {
        "step": 7,
        "action": "DFS at C's second child E",
        "state": "Currently at C, recursing to E",
        "explanation": "Continue with next child of C"
      },
      {
        "step": 8,
        "action": "DFS at E (leaf node)",
        "state": "E: total=10, size=1, avg=10.0",
        "explanation": "E has no children. avg=10.0 > 4.0, so best_emp=E, best_avg=10.0. Return (10,1)"
      },
      {
        "step": 9,
        "action": "Back at C, aggregate children",
        "state": "C: total=2+4+10=16, size=1+1+1=3",
        "explanation": "C's stats: own rating + D's total + E's total = 16, own count + D's size + E's size = 3"
      },
      {
        "step": 10,
        "action": "Compute C's team average",
        "state": "C: avg=16/3=5.33",
        "explanation": "5.33 < 10.0, so best_emp stays E. Return (16,3) to parent A"
      },
      {
        "step": 11,
        "action": "Back at A, aggregate children",
        "state": "A: total=5+3+16=24, size=1+1+3=5",
        "explanation": "A's stats: own rating + B's total + C's total = 24, own + B's size + C's size = 5"
      },
      {
        "step": 12,
        "action": "Compute A's team average",
        "state": "A: avg=24/5=4.8",
        "explanation": "4.8 < 10.0, so best_emp stays E. DFS complete."
      }
    ],
    "final_output": "Employee E with team average 10.0"
  },
  "edge_cases": [
    {
      "case": "Empty organization",
      "handling": "Return None from getBestPerformingTeamLead. Check `if not self._employees` at start.",
      "gotcha": "Don't forget to handle this - calling DFS on an empty tree would crash."
    },
    {
      "case": "Single employee (root only)",
      "handling": "That employee is both root and leaf. Their team is themselves, average = own rating.",
      "gotcha": "This is actually the highest possible average if they have a high rating."
    },
    {
      "case": "Non-existent employee ID",
      "handling": "getTeamStats returns None. Check `if employee_id not in self._employees`.",
      "gotcha": "Don't assume all IDs are valid - always validate input."
    },
    {
      "case": "All employees have same rating",
      "handling": "Leaf nodes will have highest average (team of 1). Return any leaf.",
      "gotcha": "Ties are allowed - the problem says 'return any' employee with max average."
    },
    {
      "case": "Linear tree (linked list structure)",
      "handling": "Algorithm still works - DFS degrades to O(n) depth but still O(n) time.",
      "gotcha": "Stack overflow possible for very deep trees (>1000 levels). Consider iterative approach for production."
    },
    {
      "case": "Multiple roots (forest)",
      "handling": "Iterate over all roots in `_root_ids` set. DFS each tree.",
      "gotcha": "Don't assume single CEO - the org might have multiple independent hierarchies."
    }
  ],
  "test_cases": [
    {
      "name": "Basic example from problem",
      "input": "add(1,A,5,null), add(2,B,3,1), add(3,C,2,1), add(4,D,4,3), add(5,E,10,3)",
      "expected": "getBestPerformingTeamLead() \u2192 Employee E, getTeamStats(1) \u2192 (24, 5, 4.8)",
      "explanation": "E has team avg 10.0 (highest), A's team has 5 members totaling 24 rating"
    },
    {
      "name": "Empty organization",
      "input": "No employees added",
      "expected": "getBestPerformingTeamLead() \u2192 None",
      "explanation": "Edge case - must handle gracefully"
    },
    {
      "name": "Single employee",
      "input": "add(1, Solo, 7, null)",
      "expected": "getBestPerformingTeamLead() \u2192 Employee Solo, getTeamStats(1) \u2192 (7, 1, 7.0)",
      "explanation": "Only employee is trivially the best team lead"
    },
    {
      "name": "Manager with lower rating than reports",
      "input": "add(1,Boss,1,null), add(2,Star,100,1)",
      "expected": "getBestPerformingTeamLead() \u2192 Employee Star with avg 100.0",
      "explanation": "Star's team (just themselves) beats Boss's team avg of (1+100)/2=50.5"
    },
    {
      "name": "Deep linear tree",
      "input": "A(10)\u2192B(9)\u2192C(8)\u2192D(7)",
      "expected": "getBestPerformingTeamLead() \u2192 Employee A (avg=34/4=8.5), D has avg 7.0",
      "explanation": "Counterintuitively, the root has highest avg when ratings decrease down"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using O(n\u00b2) approach by calling getTeamStats for every employee",
      "why_wrong": "For each of n employees, traversing their subtree. In worst case (linear tree), this is 1+2+3+...+n = O(n\u00b2)",
      "correct_approach": "Single DFS pass that computes all stats and tracks maximum simultaneously",
      "code_example_wrong": "for emp_id in employees:\n    stats = get_team_stats(emp_id)  # O(n) each!\n    if stats.average > best_avg: ...",
      "code_example_correct": "def dfs(emp_id):\n    # Process children, aggregate, update best, return stats\n    # Single O(n) traversal"
    },
    {
      "mistake": "Forgetting that leaf nodes have team size of 1",
      "why_wrong": "Leads to division by zero or wrong average calculation",
      "correct_approach": "Initialize team_size=1 for the current employee before adding children",
      "code_example_wrong": "total = sum(child_totals)  # Forgot self!\nsize = sum(child_sizes)   # Forgot self!",
      "code_example_correct": "total = self.rating + sum(child_totals)\nsize = 1 + sum(child_sizes)"
    },
    {
      "mistake": "Pre-order instead of post-order traversal",
      "why_wrong": "Computing average before processing children means children's stats aren't available yet",
      "correct_approach": "Post-order: recursively process ALL children first, THEN compute current node's stats",
      "code_example_wrong": "def dfs(emp):\n    avg = emp.rating / 1  # Wrong! Children not processed\n    for child in children:\n        dfs(child)  # Too late!",
      "code_example_correct": "def dfs(emp):\n    for child in children:\n        child_total, child_size = dfs(child)  # Process FIRST\n    total = emp.rating + child_totals\n    avg = total / size  # NOW correct"
    },
    {
      "mistake": "Modifying tracking variables without resetting",
      "why_wrong": "Calling getBestPerformingTeamLead multiple times gives wrong results",
      "correct_approach": "Reset best_average and best_employee at the START of each call",
      "code_example_wrong": "def getBestPerformingTeamLead():\n    # best_average still has value from previous call!\n    for root in roots:\n        dfs(root)",
      "code_example_correct": "def getBestPerformingTeamLead():\n    self._best_average = float('-inf')  # RESET!\n    self._best_employee = None\n    for root in roots:\n        dfs(root)"
    },
    {
      "mistake": "Using greater-than-or-equal for comparison",
      "why_wrong": "Inconsistent results when there are ties - might return different employee each call",
      "correct_approach": "Use strict greater-than (>) for deterministic tie-breaking (returns first encountered)",
      "code_example_wrong": "if avg >= best_avg:  # Overwrites on ties",
      "code_example_correct": "if avg > best_avg:  # Keeps first with max"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the definition of 'team' (self + ALL subordinates). Draw the example tree and manually compute a few team averages. Then explain why naive O(n\u00b2) is wasteful. Present the key insight: 'If I know my children's stats, I can compute my stats in O(1).' This leads naturally to post-order DFS. Code incrementally - first getTeamStats (simpler), then getBestPerformingTeamLead (optimization).",
    "what_to_mention": [
      "Time complexity improvement from O(n\u00b2) naive to O(n) optimal",
      "Post-order traversal pattern: children before self",
      "Returning (total, size) tuple enables parent aggregation",
      "Leaf node edge case: team of 1 = highest possible individual average",
      "Space complexity is O(h) for recursion stack",
      "Production consideration: iterative DFS for very deep trees"
    ],
    "time_allocation": "~3 min to clarify problem and draw example, ~5 min to explain approach and complexity, ~10 min to code with comments, ~2 min to trace through example",
    "if_stuck": [
      "Think about what information a parent node needs from its children",
      "What if you could only visit each node once? What would you compute?",
      "For a leaf node, what's the team stats? Can parent use that?",
      "Is there a way to avoid re-traversing subtrees?"
    ]
  },
  "connection_to_next_part": "Part 2's DFS pattern of aggregating subtree information is foundational. Part 3 might extend this to: (1) finding common manager (LCA problem), (2) team budget queries with cached subtree sums, (3) reorganization operations that require updating multiple subtree aggregates, or (4) finding the k-th level of a team. The (total, size) tuple pattern can be extended to track additional metrics like min/max rating, team depth, etc.",
  "generated_at": "2026-01-14T15:06:46.706560",
  "_meta": {
    "problem_id": "employee_hierarchy_org_tree",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}