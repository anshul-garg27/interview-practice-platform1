{
  "problem_title": "Song Play Analytics System - Part 2: Recent Plays (With Duplicates)",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 2 adds temporal tracking to our analytics system. While Part 1 focused on aggregating unique listeners per song (deduplicated), Part 2 requires us to maintain a chronological record of ALL play events including duplicates. This is a fundamentally different data model - we're now tracking a timeline of events rather than just aggregated counts.",
    "new_requirements": [
      "Track every play event in chronological order",
      "Allow duplicate entries (same song can appear consecutively)",
      "Return song NAMES (not IDs) in results",
      "Support reverse chronological retrieval (most recent first)",
      "Handle cases where fewer plays exist than requested"
    ],
    "new_constraints": [
      "Must maintain O(1) time for recording plays (append operation)",
      "Recent plays retrieval should be O(count) time complexity",
      "Space grows linearly with total number of plays"
    ],
    "key_insight": "The key insight is that we need TWO separate data structures: the existing Set-based structure for unique listener counting (Part 1), and a NEW List-based structure for chronological play history (Part 2). These serve different purposes and cannot be merged - one deduplicates, one preserves duplicates."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    PART 1 vs PART 2 DATA MODEL                    \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                   \u2551\n\u2551  PART 1 DATA (Unique Listeners - Deduplicated):                  \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2551\n\u2551  \u2502  Song 1 (Alpha): {user1, user2}  \u2192 2 unique \u2502                 \u2551\n\u2551  \u2502  Song 2 (Beta):  {user1}         \u2192 1 unique \u2502                 \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2551\n\u2551                                                                   \u2551\n\u2551  PART 2 DATA (Play History - Preserves Duplicates):              \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2551\n\u2551  \u2502  playHistory: [Alpha, Beta, Alpha, Alpha]   \u2502                 \u2551\n\u2551  \u2502                 t=1    t=2   t=3    t=4     \u2502                 \u2551\n\u2551  \u2502                 \u2191                    \u2191      \u2502                 \u2551\n\u2551  \u2502              oldest              newest     \u2502                 \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2551\n\u2551                                                                   \u2551\n\u2551  getRecentPlays(3):                                               \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2551\n\u2551  \u2502  Step 1: Take last 3 \u2192 [Beta, Alpha, Alpha] \u2502                 \u2551\n\u2551  \u2502  Step 2: Reverse     \u2192 [Alpha, Alpha, Beta] \u2502                 \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    ALGORITHM FLOW: getRecentPlays(3)               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                    \u2502\n\u2502  playHistory = [\"Alpha\", \"Beta\", \"Alpha\", \"Alpha\"]                \u2502\n\u2502                    0       1       2        3                      \u2502\n\u2502                                                                    \u2502\n\u2502  Step 1: Calculate actual count                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502  count = 3                                             \u2502       \u2502\n\u2502  \u2502  len(playHistory) = 4                                  \u2502       \u2502\n\u2502  \u2502  actualCount = min(3, 4) = 3                           \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                    \u2502\n\u2502  Step 2: Extract last N elements                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502  playHistory[-3:] = [\"Beta\", \"Alpha\", \"Alpha\"]        \u2502       \u2502\n\u2502  \u2502                       \u2191        \u2191        \u2191              \u2502       \u2502\n\u2502  \u2502                    index 1   index 2   index 3         \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                    \u2502\n\u2502  Step 3: Reverse for most-recent-first                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502  result = [\"Alpha\", \"Alpha\", \"Beta\"]                  \u2502       \u2502\n\u2502  \u2502             \u2191         \u2191        \u2191                       \u2502       \u2502\n\u2502  \u2502          most      2nd      3rd most                   \u2502       \u2502\n\u2502  \u2502         recent    recent    recent                     \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Store Only IDs",
      "description": "Store song IDs in the play history instead of names, then look up names during retrieval",
      "time_complexity": "O(count) for retrieval",
      "space_complexity": "O(total_plays)",
      "why_not_optimal": "While functionally correct, storing IDs requires a lookup for each result item. Since song names don't change, it's more efficient to store the name directly. This is a minor optimization but demonstrates good design thinking."
    },
    {
      "name": "Optimal Approach - Direct Name Storage",
      "description": "Store song names directly in the play history list. On each play, append the song name. For retrieval, slice the last N elements and reverse.",
      "time_complexity": "O(1) for play_song, O(count) for get_recent_plays",
      "space_complexity": "O(total_plays)",
      "key_insight": "Store the data in the format you'll need to return it. Since we return names, store names. The list naturally maintains chronological order, and Python/Java make it easy to slice from the end and reverse."
    },
    {
      "name": "Alternative - Deque with Max Size",
      "description": "Use a bounded deque that only keeps the last K plays (e.g., last 1000). This limits memory but loses old history.",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(K) where K is max history size",
      "key_insight": "In production systems, you often don't need infinite history. A bounded deque provides constant memory usage while still supporting recent plays queries."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution Explanation\n\n### Core Insight\nThe key to Part 2 is recognizing that we need **two parallel data models**:\n\n1. **Aggregated View** (Part 1): Uses `Set` to deduplicate listeners per song\n2. **Timeline View** (Part 2): Uses `List` to preserve ALL plays in order\n\n### Data Structure Choice\nWe use a simple **ArrayList/List** because:\n- **O(1) append**: Adding to the end is constant time\n- **O(1) access by index**: Getting the last N elements is efficient\n- **Natural ordering**: Items maintain insertion order automatically\n\n### Algorithm for `getRecentPlays(count)`\n1. **Boundary check**: If count \u2264 0, return empty list\n2. **Calculate actual count**: `min(count, len(history))` handles edge cases\n3. **Slice from end**: Get the last N elements\n4. **Reverse**: Return in most-recent-first order\n\n### Why Store Names Instead of IDs?\nStoring names directly avoids lookups during retrieval:\n```\nID Storage:    play \u2192 store ID \u2192 retrieve \u2192 lookup name \u2192 return\nName Storage:  play \u2192 store name \u2192 retrieve \u2192 return (no lookup!)\n```\n\n### Integration with Part 1\nThe `play_song` method now does **two things**:\n1. Add user to unique listeners set (Part 1 behavior)\n2. Append song name to play history (Part 2 addition)\n\nThis is a classic example of the **Open/Closed Principle** - we're extending functionality without modifying existing behavior.",
    "data_structures": [
      {
        "structure": "List<String> playHistory",
        "purpose": "Stores all song names in chronological order of plays. Allows duplicates to capture the exact sequence of what was played."
      },
      {
        "structure": "Dict[int, str] songs",
        "purpose": "Maps song IDs to names for O(1) lookup when recording plays"
      },
      {
        "structure": "Dict[int, Set[int]] uniqueListeners",
        "purpose": "From Part 1 - tracks unique listeners per song"
      }
    ],
    "algorithm_steps": [
      "Step 1: In __init__, add playHistory as an empty list",
      "Step 2: In play_song, after updating unique listeners, append song name to playHistory",
      "Step 3: In get_recent_plays, calculate actualCount = min(count, len(playHistory))",
      "Step 4: Extract the last actualCount elements from playHistory",
      "Step 5: Reverse the extracted elements for most-recent-first ordering",
      "Step 6: Return the reversed list"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Song Play Analytics System - Part 2: Recent Plays",
    "",
    "A music streaming analytics system that tracks song plays and generates",
    "insights based on unique listeners AND recent play history.",
    "",
    "Time Complexity:",
    "    - add_song: O(1)",
    "    - play_song: O(1)",
    "    - get_top_songs: O(S log S) where S = number of songs",
    "    - get_recent_plays: O(count)",
    "",
    "Space Complexity: O(S + P) where S = songs, P = total plays",
    "\"\"\"",
    "",
    "from typing import Dict, List, Set, Tuple",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    A music streaming analytics system that tracks song plays",
    "    and generates insights based on unique listeners and play history.",
    "    \"\"\"",
    "",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize the analytics system with empty data structures.\"\"\"",
    "        # Part 1 data structures",
    "        self._next_id: int = 1",
    "        self._songs: Dict[int, str] = {}  # song_id -> song_name",
    "        self._unique_listeners: Dict[int, Set[int]] = {}  # song_id -> set of user_ids",
    "        ",
    "        # Part 2 data structure - chronological play history",
    "        self._play_history: List[str] = []  # List of song names in order played",
    "",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"",
    "        Add a new song to the library.",
    "",
    "        Args:",
    "            name: The name of the song",
    "",
    "        Returns:",
    "            The auto-assigned song ID (starts at 1, increments)",
    "",
    "        Example:",
    "            >>> analytics = SongAnalytics()",
    "            >>> analytics.add_song('Bohemian Rhapsody')",
    "            1",
    "        \"\"\"",
    "        song_id = self._next_id",
    "        self._next_id += 1",
    "        self._songs[song_id] = name",
    "        self._unique_listeners[song_id] = set()",
    "        return song_id",
    "",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"",
    "        Record a play event for a song by a user.",
    "",
    "        This method:",
    "        1. Updates unique listener count for the song (Part 1)",
    "        2. Appends to play history for recent plays tracking (Part 2)",
    "",
    "        Args:",
    "            song_id: The ID of the song being played",
    "            user_id: The ID of the user playing the song",
    "",
    "        Note:",
    "            Invalid song IDs are silently ignored.",
    "        \"\"\"",
    "        # Validate song exists",
    "        if song_id not in self._songs:",
    "            return  # Silently ignore invalid song IDs",
    "",
    "        # Part 1: Track unique listener (Set handles deduplication)",
    "        self._unique_listeners[song_id].add(user_id)",
    "",
    "        # Part 2: Track play in chronological history",
    "        song_name = self._songs[song_id]",
    "        self._play_history.append(song_name)",
    "",
    "    def get_top_songs(self, n: int) -> List[str]:",
    "        \"\"\"",
    "        Get the top N songs by unique listener count.",
    "",
    "        Args:",
    "            n: Number of top songs to return",
    "",
    "        Returns:",
    "            List of song names sorted by:",
    "            1. Unique listener count (descending)",
    "            2. Song ID (ascending) for ties",
    "        \"\"\"",
    "        if n <= 0:",
    "            return []",
    "",
    "        # Build list of (negative_count, song_id, song_name) for sorting",
    "        song_stats: List[Tuple[int, int, str]] = []",
    "        for song_id, listeners in self._unique_listeners.items():",
    "            count = len(listeners)",
    "            name = self._songs[song_id]",
    "            # Negative count for descending order, positive ID for ascending",
    "            song_stats.append((-count, song_id, name))",
    "",
    "        # Sort by (-count, song_id) - Python's tuple comparison handles this",
    "        song_stats.sort()",
    "",
    "        # Extract top n song names",
    "        return [name for _, _, name in song_stats[:n]]",
    "",
    "    def get_recent_plays(self, count: int) -> List[str]:",
    "        \"\"\"",
    "        Get the most recently played songs.",
    "",
    "        Args:",
    "            count: Number of recent plays to return",
    "",
    "        Returns:",
    "            List of song names in reverse chronological order",
    "            (most recent first). Duplicates ARE allowed - if a song",
    "            was played twice in a row, it appears twice.",
    "",
    "        Example:",
    "            If play order was: Alpha -> Beta -> Alpha -> Alpha",
    "            get_recent_plays(3) returns: ['Alpha', 'Alpha', 'Beta']",
    "        \"\"\"",
    "        # Handle edge cases",
    "        if count <= 0:",
    "            return []",
    "",
    "        # Calculate how many plays we can actually return",
    "        actual_count = min(count, len(self._play_history))",
    "",
    "        if actual_count == 0:",
    "            return []",
    "",
    "        # Get last N plays and reverse for most-recent-first",
    "        # Using slice notation: [-N:] gets last N elements",
    "        # [::-1] reverses the list",
    "        return self._play_history[-actual_count:][::-1]",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate the SongAnalytics system with Part 2 functionality.\"\"\"",
    "    print('=' * 60)",
    "    print('Song Play Analytics System - Part 2 Demo')",
    "    print('=' * 60)",
    "",
    "    # Initialize the system",
    "    analytics = SongAnalytics()",
    "",
    "    # Add songs",
    "    print('\\n\ud83d\udcc0 Adding songs...')",
    "    id_alpha = analytics.add_song('Alpha')",
    "    id_beta = analytics.add_song('Beta')",
    "    print(f'  Added \"Alpha\" with ID: {id_alpha}')",
    "    print(f'  Added \"Beta\" with ID: {id_beta}')",
    "",
    "    # Simulate play events",
    "    print('\\n\ud83c\udfb5 Playing songs...')",
    "    plays = [",
    "        (id_alpha, 1, 'Alpha by User 1'),",
    "        (id_beta, 1, 'Beta by User 1'),",
    "        (id_alpha, 2, 'Alpha by User 2'),",
    "        (id_alpha, 1, 'Alpha by User 1 (again)'),",
    "    ]",
    "",
    "    for song_id, user_id, description in plays:",
    "        analytics.play_song(song_id, user_id)",
    "        print(f'  \u25b6 {description}')",
    "",
    "    # Test recent plays",
    "    print('\\n\u23f1 Recent Plays Test:')",
    "    recent = analytics.get_recent_plays(3)",
    "    print(f'  get_recent_plays(3) = {recent}')",
    "    print(f'  Expected: [\"Alpha\", \"Alpha\", \"Beta\"]')",
    "",
    "    # Test edge case: requesting more than available",
    "    print('\\n\ud83d\udcca Edge Case - Request more than available:')",
    "    all_recent = analytics.get_recent_plays(10)",
    "    print(f'  get_recent_plays(10) = {all_recent}')",
    "    print(f'  (Only 4 plays exist, so returns all 4)')",
    "",
    "    # Test top songs (Part 1 still works)",
    "    print('\\n\ud83c\udfc6 Top Songs (Part 1 verification):')",
    "    top = analytics.get_top_songs(2)",
    "    print(f'  get_top_songs(2) = {top}')",
    "    print(f'  (Alpha has 2 unique listeners, Beta has 1)')",
    "",
    "    print('\\n' + '=' * 60)",
    "    print('Demo Complete!')",
    "    print('=' * 60)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Song Play Analytics System - Part 2: Recent Plays",
    " * ",
    " * A music streaming analytics system that tracks song plays and generates",
    " * insights based on unique listeners AND recent play history.",
    " * ",
    " * Time Complexity:",
    " *     - addSong: O(1)",
    " *     - playSong: O(1)",
    " *     - getTopSongs: O(S log S) where S = number of songs",
    " *     - getRecentPlays: O(count)",
    " * ",
    " * Space Complexity: O(S + P) where S = songs, P = total plays",
    " */",
    "public class SongAnalytics {",
    "    ",
    "    // Part 1 data structures",
    "    private int nextId;",
    "    private Map<Integer, String> songs;  // song_id -> song_name",
    "    private Map<Integer, Set<Integer>> uniqueListeners;  // song_id -> set of user_ids",
    "    ",
    "    // Part 2 data structure - chronological play history",
    "    private List<String> playHistory;  // List of song names in order played",
    "    ",
    "    /**",
    "     * Initialize the analytics system with empty data structures.",
    "     */",
    "    public SongAnalytics() {",
    "        this.nextId = 1;",
    "        this.songs = new HashMap<>();",
    "        this.uniqueListeners = new HashMap<>();",
    "        this.playHistory = new ArrayList<>();",
    "    }",
    "    ",
    "    /**",
    "     * Add a new song to the library.",
    "     * ",
    "     * @param name The name of the song",
    "     * @return The auto-assigned song ID (starts at 1, increments)",
    "     */",
    "    public int addSong(String name) {",
    "        int songId = nextId++;",
    "        songs.put(songId, name);",
    "        uniqueListeners.put(songId, new HashSet<>());",
    "        return songId;",
    "    }",
    "    ",
    "    /**",
    "     * Record a play event for a song by a user.",
    "     * ",
    "     * This method:",
    "     * 1. Updates unique listener count for the song (Part 1)",
    "     * 2. Appends to play history for recent plays tracking (Part 2)",
    "     * ",
    "     * @param songId The ID of the song being played",
    "     * @param userId The ID of the user playing the song",
    "     */",
    "    public void playSong(int songId, int userId) {",
    "        // Validate song exists",
    "        if (!songs.containsKey(songId)) {",
    "            return;  // Silently ignore invalid song IDs",
    "        }",
    "        ",
    "        // Part 1: Track unique listener (Set handles deduplication)",
    "        uniqueListeners.get(songId).add(userId);",
    "        ",
    "        // Part 2: Track play in chronological history",
    "        String songName = songs.get(songId);",
    "        playHistory.add(songName);",
    "    }",
    "    ",
    "    /**",
    "     * Get the top N songs by unique listener count.",
    "     * ",
    "     * @param n Number of top songs to return",
    "     * @return List of song names sorted by unique listeners (desc), then ID (asc)",
    "     */",
    "    public List<String> getTopSongs(int n) {",
    "        if (n <= 0) {",
    "            return new ArrayList<>();",
    "        }",
    "        ",
    "        // Build list of [song_id, listener_count] for sorting",
    "        List<int[]> songStats = new ArrayList<>();",
    "        for (Map.Entry<Integer, Set<Integer>> entry : uniqueListeners.entrySet()) {",
    "            int songId = entry.getKey();",
    "            int count = entry.getValue().size();",
    "            songStats.add(new int[]{songId, count});",
    "        }",
    "        ",
    "        // Sort by count (descending), then by ID (ascending) for ties",
    "        songStats.sort((a, b) -> {",
    "            if (a[1] != b[1]) {",
    "                return b[1] - a[1];  // Descending by count",
    "            }",
    "            return a[0] - b[0];  // Ascending by ID",
    "        });",
    "        ",
    "        // Extract top n song names",
    "        List<String> result = new ArrayList<>();",
    "        for (int i = 0; i < Math.min(n, songStats.size()); i++) {",
    "            result.add(songs.get(songStats.get(i)[0]));",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get the most recently played songs.",
    "     * ",
    "     * @param count Number of recent plays to return",
    "     * @return List of song names in reverse chronological order",
    "     *         (most recent first). Duplicates ARE allowed.",
    "     */",
    "    public List<String> getRecentPlays(int count) {",
    "        List<String> result = new ArrayList<>();",
    "        ",
    "        // Handle edge cases",
    "        if (count <= 0 || playHistory.isEmpty()) {",
    "            return result;",
    "        }",
    "        ",
    "        // Calculate start index for slicing from end",
    "        int startIndex = Math.max(0, playHistory.size() - count);",
    "        ",
    "        // Iterate backwards to get most-recent-first ordering",
    "        for (int i = playHistory.size() - 1; i >= startIndex; i--) {",
    "            result.add(playHistory.get(i));",
    "        }",
    "        ",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Main method to demonstrate the SongAnalytics system.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Song Play Analytics System - Part 2 Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Initialize the system",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        ",
    "        // Add songs",
    "        System.out.println(\"\\n\ud83d\udcc0 Adding songs...\");",
    "        int idAlpha = analytics.addSong(\"Alpha\");",
    "        int idBeta = analytics.addSong(\"Beta\");",
    "        System.out.println(\"  Added 'Alpha' with ID: \" + idAlpha);",
    "        System.out.println(\"  Added 'Beta' with ID: \" + idBeta);",
    "        ",
    "        // Simulate play events",
    "        System.out.println(\"\\n\ud83c\udfb5 Playing songs...\");",
    "        analytics.playSong(idAlpha, 1);",
    "        System.out.println(\"  \u25b6 Alpha by User 1\");",
    "        analytics.playSong(idBeta, 1);",
    "        System.out.println(\"  \u25b6 Beta by User 1\");",
    "        analytics.playSong(idAlpha, 2);",
    "        System.out.println(\"  \u25b6 Alpha by User 2\");",
    "        analytics.playSong(idAlpha, 1);",
    "        System.out.println(\"  \u25b6 Alpha by User 1 (again)\");",
    "        ",
    "        // Test recent plays",
    "        System.out.println(\"\\n\u23f1 Recent Plays Test:\");",
    "        List<String> recent = analytics.getRecentPlays(3);",
    "        System.out.println(\"  getRecentPlays(3) = \" + recent);",
    "        System.out.println(\"  Expected: [Alpha, Alpha, Beta]\");",
    "        ",
    "        // Test edge case",
    "        System.out.println(\"\\n\ud83d\udcca Edge Case - Request more than available:\");",
    "        List<String> allRecent = analytics.getRecentPlays(10);",
    "        System.out.println(\"  getRecentPlays(10) = \" + allRecent);",
    "        ",
    "        // Verify Part 1 still works",
    "        System.out.println(\"\\n\ud83c\udfc6 Top Songs (Part 1 verification):\");",
    "        List<String> top = analytics.getTopSongs(2);",
    "        System.out.println(\"  getTopSongs(2) = \" + top);",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Demo Complete!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and class documentation explaining the purpose, time complexity, and space complexity of the system."
    },
    {
      "lines": "23-28",
      "explanation": "Instance variables declaration. Part 1 structures (songs map, uniqueListeners map) plus the NEW playHistory list for Part 2."
    },
    {
      "lines": "30-36",
      "explanation": "Constructor initializes all data structures. Note that playHistory starts as an empty ArrayList."
    },
    {
      "lines": "38-48",
      "explanation": "addSong method (unchanged from Part 1) - creates song entry and initializes empty listener set."
    },
    {
      "lines": "50-68",
      "explanation": "MODIFIED playSong method - now does two things: (1) adds user to unique listeners set, (2) appends song NAME to playHistory for recent plays tracking."
    },
    {
      "lines": "70-95",
      "explanation": "getTopSongs method (unchanged from Part 1) - sorts by listener count descending, ID ascending for ties."
    },
    {
      "lines": "97-120",
      "explanation": "NEW getRecentPlays method - calculates start index, iterates backwards through playHistory, builds result list in most-recent-first order."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "get_recent_plays": {
          "complexity": "O(count)",
          "explanation": "We iterate at most 'count' times to build the result list. The slice operation in Python is O(k) where k is the slice size, and reversing is also O(k)."
        }
      },
      "modified_methods": {
        "play_song": {
          "complexity": "O(1)",
          "explanation": "Adding to a Set is O(1) average, appending to a List is O(1) amortized. No change to asymptotic complexity."
        }
      },
      "overall_change": "No degradation to existing operations. The new get_recent_plays is O(count) which is optimal - you can't return N items faster than O(N)."
    },
    "space": {
      "additional_space": "O(P) where P is total number of plays",
      "explanation": "We now store every play event in playHistory. Unlike the uniqueListeners Set which deduplicates, this list grows with every play. In a production system, you might want to bound this with a circular buffer or periodic cleanup."
    }
  },
  "dry_run": {
    "example_input": "Operations: SongAnalytics(), add_song('Alpha'), add_song('Beta'), play_song(1,1), play_song(2,1), play_song(1,2), play_song(1,1), get_recent_plays(3)",
    "steps": [
      {
        "step": 1,
        "action": "SongAnalytics()",
        "state": "nextId=1, songs={}, uniqueListeners={}, playHistory=[]",
        "explanation": "Initialize empty system"
      },
      {
        "step": 2,
        "action": "add_song('Alpha')",
        "state": "nextId=2, songs={1:'Alpha'}, uniqueListeners={1:{}}, playHistory=[]",
        "explanation": "Alpha added with ID 1"
      },
      {
        "step": 3,
        "action": "add_song('Beta')",
        "state": "nextId=3, songs={1:'Alpha',2:'Beta'}, uniqueListeners={1:{},2:{}}, playHistory=[]",
        "explanation": "Beta added with ID 2"
      },
      {
        "step": 4,
        "action": "play_song(1,1)",
        "state": "uniqueListeners={1:{1},2:{}}, playHistory=['Alpha']",
        "explanation": "User 1 plays Alpha - added to both unique listeners AND play history"
      },
      {
        "step": 5,
        "action": "play_song(2,1)",
        "state": "uniqueListeners={1:{1},2:{1}}, playHistory=['Alpha','Beta']",
        "explanation": "User 1 plays Beta - Beta appended to history"
      },
      {
        "step": 6,
        "action": "play_song(1,2)",
        "state": "uniqueListeners={1:{1,2},2:{1}}, playHistory=['Alpha','Beta','Alpha']",
        "explanation": "User 2 plays Alpha - Alpha appears again in history (duplicate allowed!)"
      },
      {
        "step": 7,
        "action": "play_song(1,1)",
        "state": "uniqueListeners={1:{1,2},2:{1}}, playHistory=['Alpha','Beta','Alpha','Alpha']",
        "explanation": "User 1 plays Alpha again - uniqueListeners unchanged (deduplicated), but playHistory gets another Alpha"
      },
      {
        "step": 8,
        "action": "get_recent_plays(3)",
        "state": "Extract last 3: ['Beta','Alpha','Alpha'] \u2192 Reverse: ['Alpha','Alpha','Beta']",
        "explanation": "Take last 3 from playHistory, reverse for most-recent-first"
      }
    ],
    "final_output": "['Alpha', 'Alpha', 'Beta']"
  },
  "edge_cases": [
    {
      "case": "Requesting more plays than exist",
      "handling": "Use min(count, len(history)) to avoid index errors",
      "gotcha": "Don't throw an exception - just return what's available"
    },
    {
      "case": "Empty history (no plays yet)",
      "handling": "Return empty list immediately",
      "gotcha": "Check before slicing to avoid returning [-0:]"
    },
    {
      "case": "count <= 0",
      "handling": "Return empty list",
      "gotcha": "Don't return negative-length slices"
    },
    {
      "case": "Invalid song ID in play_song",
      "handling": "Silently ignore - don't add to history",
      "gotcha": "Make sure to validate BEFORE adding to playHistory"
    },
    {
      "case": "Same song played many times consecutively",
      "handling": "All occurrences appear in history",
      "gotcha": "This is expected behavior - don't accidentally deduplicate"
    }
  ],
  "test_cases": [
    {
      "name": "Basic recent plays",
      "input": "add_song('A'), add_song('B'), play(1,1), play(2,1), play(1,1), get_recent_plays(2)",
      "expected": "['A', 'B']",
      "explanation": "Last 2 plays were B then A, reversed = [A, B]"
    },
    {
      "name": "Request more than available",
      "input": "add_song('Only'), play(1,1), get_recent_plays(5)",
      "expected": "['Only']",
      "explanation": "Only 1 play exists, return just that"
    },
    {
      "name": "Empty history",
      "input": "add_song('Never Played'), get_recent_plays(3)",
      "expected": "[]",
      "explanation": "No plays recorded yet"
    },
    {
      "name": "Consecutive duplicates",
      "input": "add_song('Repeat'), play(1,1), play(1,1), play(1,1), get_recent_plays(3)",
      "expected": "['Repeat', 'Repeat', 'Repeat']",
      "explanation": "Same song 3 times = 3 entries in result"
    },
    {
      "name": "Zero count",
      "input": "add_song('X'), play(1,1), get_recent_plays(0)",
      "expected": "[]",
      "explanation": "Requesting 0 plays returns empty list"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Storing song IDs instead of names in playHistory",
      "why_wrong": "Requires extra lookup during retrieval, adds complexity",
      "correct_approach": "Store names directly since that's what we return",
      "code_example_wrong": "playHistory.append(song_id)  # Wrong!",
      "code_example_correct": "playHistory.append(self._songs[song_id])  # Correct!"
    },
    {
      "mistake": "Forgetting to reverse the result",
      "why_wrong": "Returning oldest-first instead of most-recent-first",
      "correct_approach": "Always reverse after slicing from end",
      "code_example_wrong": "return self._play_history[-count:]  # Wrong order!",
      "code_example_correct": "return self._play_history[-count:][::-1]  # Correct!"
    },
    {
      "mistake": "Using a Set for play history",
      "why_wrong": "Sets deduplicate and don't maintain insertion order (pre-Python 3.7)",
      "correct_approach": "Use a List to preserve order and allow duplicates",
      "code_example_wrong": "self._play_history = set()  # Wrong!",
      "code_example_correct": "self._play_history = []  # Correct!"
    },
    {
      "mistake": "Adding to history before validating song ID",
      "why_wrong": "Could add None or cause KeyError",
      "correct_approach": "Validate song exists first, then add to history",
      "code_example_wrong": "self._play_history.append(self._songs[song_id])\nif song_id not in self._songs: return",
      "code_example_correct": "if song_id not in self._songs: return\nself._play_history.append(self._songs[song_id])"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining that Part 2 requires PARALLEL data tracking - one for aggregation (Part 1), one for chronology (Part 2). Emphasize that these serve different purposes. Then show the simple modification to play_song and the straightforward get_recent_plays implementation.",
    "what_to_mention": [
      "Explicitly state that you're adding a List for O(1) append operations",
      "Mention the trade-off: memory grows linearly with plays",
      "Note that storing names (not IDs) avoids lookup overhead",
      "Explain the slice-and-reverse pattern for most-recent-first",
      "Discuss potential optimization: bounded deque for production"
    ],
    "time_allocation": "5-7 minutes for Part 2. This is simpler than Part 1 - the key insight is just 'add a list and append to it'. Spend most time on edge cases.",
    "if_stuck": [
      "Think about what data structure naturally maintains order \u2192 List/Array",
      "How do you get the last N elements? \u2192 Slice from end",
      "How do you reverse order? \u2192 Iterate backwards or use [::-1]",
      "Should you store IDs or names? \u2192 Store what you return"
    ]
  },
  "connection_to_next_part": "Part 2 establishes the foundation for temporal queries. A natural Part 3 extension could be: 'Get unique songs played in the last N plays' (combining the deduplication of Part 1 with the recency of Part 2), or 'Get plays by a specific user' (requiring per-user history tracking), or 'Get songs played between timestamps' (requiring timestamp storage instead of just order).",
  "generated_at": "2026-01-14T15:34:46.296870",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}