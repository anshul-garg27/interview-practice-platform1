{
  "problem_title": "Travel Expense Calculation System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "## First Impressions\n\nThis is a classic **LLD (Low-Level Design) / OOP Design** problem that tests:\n\n1. **Design Patterns Knowledge** - Strategy Pattern for different expense calculations, Factory Pattern for object creation\n2. **Clean Code Principles** - SOLID principles, especially Open/Closed and Single Responsibility\n3. **Financial Precision** - Proper handling of monetary calculations with BigDecimal/Decimal\n4. **Data Modeling** - Creating appropriate classes and relationships\n\nThis problem is commonly asked at companies like **Rippling, Stripe, Square** where expense management is core business functionality.",
    "pattern_recognition": "**Strategy Pattern** (different calculation rules per expense type) + **Factory Pattern** (centralized object creation) + **Repository Pattern** (data storage by employee) + **Financial Precision** (Decimal arithmetic)",
    "key_constraints": [
      "**Precision to 2 decimal places** - Must use Decimal/BigDecimal, not float. This is the #1 gotcha!",
      "**HALF_UP rounding** - Financial standard rounding mode",
      "**Policy limits vary by type** - Flight: $1000, Hotel: $200/night, Meal: 50% up to $50/day, Transport: unlimited",
      "**Up to 500 expenses per employee** - Need efficient storage but O(n) calculation is acceptable",
      "**Extensibility required** - Must be easy to add new expense types without modifying existing code"
    ],
    "clarifying_questions": [
      "**Q1: Is the `amount` parameter the total expense or the per-unit rate?** - Critical for hotel (per night) and meal (per day) calculations. Affects all reimbursement math.",
      "**Q2: Should I use BigDecimal/Decimal for all monetary values?** - Shows awareness of floating-point precision issues. Answer is always YES for finance.",
      "**Q3: How should I handle invalid expense types?** - Exception handling strategy. Shows defensive programming mindset.",
      "**Q4: Can an employee have multiple expenses of the same type on the same day?** - Affects data structure choice and potential aggregation logic.",
      "**Q5: Is the flight policy limit per-flight or total for all flights?** - Per-flight based on examples, but worth confirming.",
      "**Q6: For meals, is the $50 cap applied before or after the 50% calculation?** - `min(amount \u00d7 0.5, $50)` vs `min(amount, $100) \u00d7 0.5`",
      "**Q7: Are there any thread-safety requirements?** - Important for production systems, shows scalability thinking."
    ],
    "edge_cases_to_consider": [
      "**Empty employee** - No expenses submitted yet, should return 0.0",
      "**Minimum expense** - $0.01 expense, tests precision at boundaries",
      "**Hotel exactly at cap** - $200/night should be fully reimbursed",
      "**Flight over limit** - $1500 flight capped at $1000",
      "**Zero nights/days** - Invalid input, should handle gracefully",
      "**Large number precision** - $99,999.99 shouldn't lose cents",
      "**Mixed expense types** - Employee has all 4 types simultaneously"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    EXPENSE MANAGEMENT SYSTEM                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                      \u2502\n\u2502  EMPLOYEE SUBMITS EXPENSES                                           \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                                            \u2502\n\u2502                                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502  \u2502 \u2708\ufe0f FLIGHT \u2502   \u2502 \ud83c\udfe8 HOTEL  \u2502   \u2502 \ud83c\udf7d\ufe0f MEAL   \u2502   \u2502 \ud83d\ude95 TRANS  \u2502          \u2502\n\u2502  \u2502  $500    \u2502   \u2502 $600     \u2502   \u2502 $160     \u2502   \u2502 $45      \u2502          \u2502\n\u2502  \u2502 100%     \u2502   \u2502 3 nights \u2502   \u2502 4 days   \u2502   \u2502 100%     \u2502          \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502       \u2502              \u2502              \u2502              \u2502                 \u2502\n\u2502       \u25bc              \u25bc              \u25bc              \u25bc                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502              STRATEGY PATTERN - POLICY ENGINE                   \u2502 \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502\n\u2502  \u2502                                                                 \u2502 \u2502\n\u2502  \u2502  FlightStrategy    HotelStrategy    MealStrategy   TransStrategy\u2502 \u2502\n\u2502  \u2502  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500   \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 \u2502\n\u2502  \u2502  min(amt, $1000)   min(rate,$200)   50% \u00d7 min     100% (no cap) \u2502 \u2502\n\u2502  \u2502                    \u00d7 nights         (rate,$100)                 \u2502 \u2502\n\u2502  \u2502                                     \u00d7 days                      \u2502 \u2502\n\u2502  \u2502                                                                 \u2502 \u2502\n\u2502  \u2502  Result: $500      Result: $600     Result: $80    Result: $45  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                              \u2502                                       \u2502\n\u2502                              \u25bc                                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502              \ud83d\udcb0 TOTAL REIMBURSEMENT: $1,225.00                   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURE EVOLUTION                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                      \u2502\n\u2502  ExpenseManager Internal State:                                      \u2502\n\u2502  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550                                      \u2502\n\u2502                                                                      \u2502\n\u2502  _employee_expenses: Dict[str, List[Expense]]                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 \"emp001\" \u2500\u2500\u25b6 [                                               \u2502    \u2502\n\u2502  \u2502              Expense(id=\"exp_1\", type=FLIGHT, amt=$450),     \u2502    \u2502\n\u2502  \u2502              Expense(id=\"exp_2\", type=HOTEL, amt=$360),      \u2502    \u2502\n\u2502  \u2502              Expense(id=\"exp_3\", type=MEAL, amt=$150)        \u2502    \u2502\n\u2502  \u2502             ]                                                \u2502    \u2502\n\u2502  \u2502                                                              \u2502    \u2502\n\u2502  \u2502 \"emp002\" \u2500\u2500\u25b6 [                                               \u2502    \u2502\n\u2502  \u2502              Expense(id=\"exp_4\", type=TRANSPORT, amt=$89.50) \u2502    \u2502\n\u2502  \u2502             ]                                                \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                                      \u2502\n\u2502  _strategies: Dict[ExpenseType, ReimbursementStrategy]               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 FLIGHT    \u2500\u2500\u25b6 FlightReimbursementStrategy()                  \u2502    \u2502\n\u2502  \u2502 HOTEL     \u2500\u2500\u25b6 HotelReimbursementStrategy()                   \u2502    \u2502\n\u2502  \u2502 MEAL      \u2500\u2500\u25b6 MealReimbursementStrategy()                    \u2502    \u2502\n\u2502  \u2502 TRANSPORT \u2500\u2500\u25b6 TransportReimbursementStrategy()               \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize ExpenseManager with strategy mapping",
        "visualization": "```\n_strategies = {\n    FLIGHT    \u2192 FlightStrategy(limit=$1000)\n    HOTEL     \u2192 HotelStrategy(cap=$200/night)\n    MEAL      \u2192 MealStrategy(rate=50%, cap=$50/day)\n    TRANSPORT \u2192 TransportStrategy(no limit)\n}\n```",
        "key_point": "**Strategy Pattern** - Encapsulates algorithms, allows swapping without changing client code"
      },
      {
        "step": 2,
        "description": "addExpense() - Factory creates Expense, stores by employee",
        "visualization": "```\nInput: (\"emp001\", \"HOTEL\", 350.0, \"2024-03-20\", {\"nights\": 3})\n\nExpenseFactory.create()\n    \u2502\n    \u25bc\nExpense {\n    id: \"exp_1\"\n    type: HOTEL\n    amount: Decimal(\"350.00\")  \u2190 Note: Decimal, not float!\n    date: \"2024-03-20\"\n    details: {\"nights\": 3}\n}\n    \u2502\n    \u25bc\n_employee_expenses[\"emp001\"].append(expense)\n```",
        "key_point": "**Factory Pattern** - Centralizes object creation, generates unique IDs"
      },
      {
        "step": 3,
        "description": "calculateReimbursement() - Apply strategy to each expense",
        "visualization": "```\nfor expense in employee_expenses:\n    strategy = _strategies[expense.type]\n    total += strategy.calculate(expense)\n\nHOTEL expense calculation:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 amount = $350, nights = 3          \u2502\n\u2502 per_night = $350 / 3 = $116.67     \u2502\n\u2502 capped = min($116.67, $200) \u2713     \u2502\n\u2502 reimburse = $116.67 \u00d7 3 = $350.00  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "**Polymorphism** - Same interface, different implementations"
      },
      {
        "step": 4,
        "description": "Return result with proper rounding",
        "visualization": "```\ntotal = Decimal(\"350.00\")\nresult = total.quantize(Decimal(\"0.01\"), ROUND_HALF_UP)\nreturn float(result)  # 350.00\n```",
        "key_point": "**Financial Precision** - HALF_UP rounding is industry standard"
      }
    ],
    "dry_run_table": "## Dry Run: Example 1\n\n| Step | Operation | Expense Details | Strategy Applied | Running Total (Reimb) | Employee Total (Raw) |\n|------|-----------|-----------------|------------------|----------------------|---------------------|\n| 1 | `__init__()` | - | Setup strategies | $0.00 | $0.00 |\n| 2 | `addExpense(\"emp001\", \"FLIGHT\", 450, ...)` | Flight $450 | - | - | $450.00 |\n| 3 | `addExpense(\"emp001\", \"HOTEL\", 180, {nights:2})` | Hotel $180, 2 nights | - | - | $630.00 |\n| 4 | `addExpense(\"emp001\", \"MEAL\", 75, {days:2})` | Meal $75, 2 days | - | - | $705.00 |\n| 5 | `calculateReimbursement(\"emp001\")` | | | | |\n| 5a | - Process Flight | $450 | min($450, $1000) = $450 | $450.00 | |\n| 5b | - Process Hotel | $180, 2 nights = $90/n | min($90, $200) \u00d7 2 = $180 | $630.00 | |\n| 5c | - Process Meal | $75, 2 days = $37.50/d | min($37.50\u00d70.5, $50) \u00d7 2 = $37.50 | **$667.50** | |\n| 6 | `getTotalExpenses(\"emp001\")` | Sum all amounts | - | - | **$705.00** |"
  },
  "thinking_process": {
    "step_by_step": [
      "**Step 1: Recognize the Pattern** - When I see 'different calculation rules per type,' I immediately think **Strategy Pattern**. Each expense type has its own algorithm, and we need to swap them dynamically.",
      "**Step 2: Identify Object Creation Need** - Multiple expense objects with unique IDs need to be created. This screams **Factory Pattern** - centralize creation, manage ID generation.",
      "**Step 3: Data Storage Design** - Need to store expenses by employee for efficient retrieval. `Dict[employee_id, List[Expense]]` gives O(1) lookup by employee, O(n) iteration for calculations.",
      "**Step 4: Precision Alarm Bells** - Any time I see 'currency' or '2 decimal places,' I know to use `Decimal` (Python) or `BigDecimal` (Java). Float arithmetic WILL cause bugs: `0.1 + 0.1 + 0.1 \u2260 0.3`!",
      "**Step 5: Extensibility Check** - 'Should be extensible for new expense types' means Open/Closed Principle. New types should only require adding new Strategy classes, not modifying existing code.",
      "**Step 6: Interface Design** - Define `ReimbursementStrategy` interface first. All concrete strategies implement `calculate(expense) -> Decimal`. This ensures consistency and enables polymorphism."
    ],
    "key_insight": "## \ud83d\udca1 The Key Insight\n\n**Separate WHAT varies from WHAT stays the same.**\n\n- **Stays the same**: The flow of adding expenses, storing them, iterating through them\n- **Varies**: The reimbursement calculation formula per expense type\n\nBy encapsulating the varying part (calculation) in Strategy objects, we achieve:\n1. **Single Responsibility** - Each class does one thing well\n2. **Open/Closed** - Add new expense types without touching ExpenseManager\n3. **Testability** - Each strategy can be unit tested independently",
    "why_this_works": "## Why This Architecture Works\n\n```\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 ExpenseManager  \u2502\n                    \u2502   (Stable)      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 uses\n                             \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502    Strategy     \u2502\n                    \u2502   Interface     \u2502\n                    \u2502   (Stable)      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 implements\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u25bc          \u25bc               \u25bc          \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 Flight \u2502 \u2502 Hotel  \u2502     \u2502  Meal  \u2502 \u2502  NEW!  \u2502\n     \u2502Strategy\u2502 \u2502Strategy\u2502     \u2502Strategy\u2502 \u2502Strategy\u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502           \u2502               \u2502          \u2502\n        \u2502    CHANGE HERE ONLY WHEN POLICIES CHANGE\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n**Adding a new expense type (e.g., PARKING)**:\n1. Create `ParkingReimbursementStrategy` class\n2. Add `PARKING` to `ExpenseType` enum\n3. Register strategy in `ExpenseManager.__init__`\n\n**No changes needed** to: `addExpense()`, `calculateReimbursement()`, `Expense` class, or any existing strategies!"
  },
  "approaches": [
    {
      "name": "Brute Force: Giant If-Else Chain",
      "description": "Calculate reimbursement using if-else statements for each expense type directly in the manager class.",
      "pseudocode": "```python\ndef calculate_reimbursement(self, employee_id):\n    total = 0\n    for expense in self.expenses[employee_id]:\n        if expense.type == \"FLIGHT\":\n            total += min(expense.amount, 1000)\n        elif expense.type == \"HOTEL\":\n            per_night = expense.amount / expense.nights\n            total += min(per_night, 200) * expense.nights\n        elif expense.type == \"MEAL\":\n            per_day = expense.amount / expense.days\n            total += min(per_day * 0.5, 50) * expense.days\n        elif expense.type == \"TRANSPORT\":\n            total += expense.amount\n    return total\n```",
      "time_complexity": "O(n) per calculation, where n = number of expenses",
      "space_complexity": "O(n) for storing expenses",
      "pros": [
        "Simple to implement quickly",
        "Easy to understand for beginners",
        "Works for small number of types"
      ],
      "cons": [
        "**Violates Open/Closed Principle** - Must modify method for each new type",
        "**Violates Single Responsibility** - Manager knows too much about calculations",
        "**Hard to test** - Can't test calculation logic in isolation",
        "**Code smell** - If-else chains are maintenance nightmares",
        "**Not extensible** - Adding PARKING requires touching existing, working code"
      ],
      "when_to_use": "Never in production. Maybe for a quick prototype or interview time crunch (but mention you'd refactor)."
    },
    {
      "name": "Optimal: Strategy Pattern + Factory Pattern",
      "description": "Encapsulate each reimbursement calculation in a Strategy class. Use Factory for expense creation. Manager only orchestrates.",
      "pseudocode": "```python\n# Strategy Interface\nclass ReimbursementStrategy(ABC):\n    @abstractmethod\n    def calculate(self, expense: Expense) -> Decimal\n\n# Concrete Strategies\nclass FlightStrategy(ReimbursementStrategy):\n    def calculate(self, expense):\n        return min(expense.amount, Decimal('1000'))\n\nclass HotelStrategy(ReimbursementStrategy):\n    def calculate(self, expense):\n        nights = expense.details.get('nights', 1)\n        per_night = expense.amount / nights\n        return min(per_night, Decimal('200')) * nights\n\n# Manager delegates to strategies\nclass ExpenseManager:\n    def __init__(self):\n        self.strategies = {\n            FLIGHT: FlightStrategy(),\n            HOTEL: HotelStrategy(),\n            ...\n        }\n    \n    def calculate_reimbursement(self, employee_id):\n        total = Decimal('0')\n        for expense in self.expenses[employee_id]:\n            strategy = self.strategies[expense.type]\n            total += strategy.calculate(expense)\n        return total\n```",
      "time_complexity": "O(n) per calculation - same as brute force",
      "space_complexity": "O(n) for expenses + O(k) for k strategies (constant)",
      "pros": [
        "**Open/Closed** - Add new types without modifying existing code",
        "**Single Responsibility** - Each class has one job",
        "**Testable** - Unit test each strategy independently",
        "**Maintainable** - Change one policy without touching others",
        "**Clean** - No giant if-else chains"
      ],
      "cons": [
        "More classes to write initially",
        "Slight learning curve for Strategy pattern",
        "Overkill for 2-3 expense types (but interview expects it)"
      ],
      "key_insight": "The time complexity is the SAME as brute force, but the **code quality** is dramatically better. In interviews, design matters as much as algorithms!"
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern + Factory Pattern with Decimal Precision",
    "explanation_md": "## Approach\n\nWe implement a clean OOP solution following **SOLID principles**:\n\n### Architecture\n\n1. **`Expense` (Data Class)** - Immutable value object holding expense data\n2. **`ExpenseType` (Enum)** - Type-safe expense categories\n3. **`ReimbursementStrategy` (Interface)** - Contract for all calculation strategies\n4. **Concrete Strategies** - One class per expense type with specific calculation logic\n5. **`ExpenseFactory`** - Centralized expense creation with auto-generated IDs\n6. **`ExpenseManager`** - Orchestrator that delegates to strategies\n\n### Why Strategy Pattern?\n\n```\nWITHOUT Strategy:                 WITH Strategy:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500                 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nExpenseManager                    ExpenseManager\n\u251c\u2500\u2500 if FLIGHT...                  \u2514\u2500\u2500 strategies[type].calculate()\n\u251c\u2500\u2500 elif HOTEL...                     \u2502\n\u251c\u2500\u2500 elif MEAL...                      \u25bc\n\u251c\u2500\u2500 elif TRANSPORT...             FlightStrategy.calculate()\n\u2514\u2500\u2500 elif NEW_TYPE... \u2190 MODIFY!    HotelStrategy.calculate()\n                                  NewStrategy.calculate() \u2190 ADD!\n```\n\n### Why Decimal?\n\n```python\n# FLOAT DISASTER\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # WRONG!\n\n# DECIMAL CORRECT\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1')\nDecimal('0.3')  # CORRECT!\n```\n\n### Key Design Decisions\n\n| Decision | Rationale |\n|----------|----------|\n| Strategy per type | Open/Closed Principle - extend without modify |\n| Factory for creation | Single point of ID generation, validation |\n| Decimal for money | Financial precision is non-negotiable |\n| HALF_UP rounding | Standard financial rounding (0.5 \u2192 1, not 0) |",
    "data_structures": [
      {
        "structure": "`Dict[str, List[Expense]]` - Employee expenses map",
        "purpose": "O(1) lookup by employee ID, stores all expenses per employee for iteration"
      },
      {
        "structure": "`Dict[ExpenseType, ReimbursementStrategy]` - Strategy registry",
        "purpose": "O(1) strategy lookup by expense type, enables polymorphic dispatch"
      },
      {
        "structure": "`Expense` dataclass with `Decimal` amount",
        "purpose": "Immutable value object ensures data integrity, Decimal prevents floating-point errors"
      },
      {
        "structure": "`ExpenseType` Enum",
        "purpose": "Type safety - prevents typos like 'FLGIHT', enables IDE autocomplete"
      }
    ],
    "algorithm_steps": [
      "**1. Initialize** - Create strategy instances and map them to expense types",
      "**2. addExpense()** - Validate type \u2192 Factory creates Expense with Decimal amount \u2192 Store in employee's list",
      "**3. calculateReimbursement()** - For each expense: lookup strategy \u2192 delegate calculation \u2192 sum results \u2192 round to 2 decimals",
      "**4. getExpensesByType()** - Filter employee's expenses by type enum",
      "**5. getTotalExpenses()** - Sum all raw amounts (no policy application)"
    ],
    "why_decimal": "## Why Decimal is Critical\n\n```python\n# Scenario: 3 transport expenses of $33.33 each\n# Expected total: $99.99\n\n# Using float (WRONG):\n>>> sum([33.33, 33.33, 33.33])\n99.99000000000001  # Floating point error!\n\n# Using Decimal (CORRECT):\n>>> sum([Decimal('33.33'), Decimal('33.33'), Decimal('33.33')])\nDecimal('99.99')  # Perfect!\n```\n\n**In financial systems, even $0.01 error can:**\n- Fail audits\n- Cause reconciliation nightmares\n- Result in legal issues\n\n**Rule**: ALWAYS use `Decimal` (Python) or `BigDecimal` (Java) for money!"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Travel Expense Calculation System",
    "",
    "A production-quality implementation using Strategy Pattern and Factory Pattern",
    "for calculating employee travel expense reimbursements.",
    "",
    "Author: Interview Prep Guide",
    "Patterns: Strategy, Factory, Repository",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from decimal import Decimal, ROUND_HALF_UP",
    "from enum import Enum",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Any, Optional",
    "from datetime import datetime",
    "",
    "",
    "# ============================================================================",
    "# ENUMS AND DATA CLASSES",
    "# ============================================================================",
    "",
    "class ExpenseType(Enum):",
    "    \"\"\"Enumeration of valid expense types for type safety.\"\"\"",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "@dataclass(frozen=True)",
    "class Expense:",
    "    \"\"\"",
    "    Immutable value object representing a single expense.",
    "    ",
    "    Attributes:",
    "        id: Unique identifier for the expense",
    "        expense_type: Category of the expense (FLIGHT, HOTEL, etc.)",
    "        amount: Total expense amount in USD (using Decimal for precision)",
    "        date: Date of the expense (YYYY-MM-DD format)",
    "        details: Additional metadata (nights for hotel, days for meals)",
    "    ",
    "    Example:",
    "        >>> expense = Expense(",
    "        ...     id=\"exp_1\",",
    "        ...     expense_type=ExpenseType.HOTEL,",
    "        ...     amount=Decimal(\"350.00\"),",
    "        ...     date=\"2024-03-20\",",
    "        ...     details={\"nights\": 3}",
    "        ... )",
    "    \"\"\"",
    "    id: str",
    "    expense_type: ExpenseType",
    "    amount: Decimal",
    "    date: str",
    "    details: Dict[str, Any] = field(default_factory=dict)",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        \"\"\"Convert expense to dictionary for serialization.\"\"\"",
    "        return {",
    "            \"id\": self.id,",
    "            \"type\": self.expense_type.value,",
    "            \"amount\": float(self.amount),",
    "            \"date\": self.date,",
    "            \"details\": self.details",
    "        }",
    "",
    "",
    "# ============================================================================",
    "# STRATEGY PATTERN - REIMBURSEMENT CALCULATIONS",
    "# ============================================================================",
    "",
    "class ReimbursementStrategy(ABC):",
    "    \"\"\"",
    "    Abstract base class for reimbursement calculation strategies.",
    "    ",
    "    Each expense type has its own strategy implementing the company's",
    "    reimbursement policy. This follows the Strategy Pattern to allow",
    "    different algorithms to be used interchangeably.",
    "    ",
    "    Subclasses must implement:",
    "        calculate(expense) -> Decimal: Compute reimbursable amount",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"",
    "        Calculate the reimbursable amount for an expense.",
    "        ",
    "        Args:",
    "            expense: The expense to calculate reimbursement for",
    "            ",
    "        Returns:",
    "            Decimal: The reimbursable amount (not rounded)",
    "        \"\"\"",
    "        pass",
    "",
    "",
    "class FlightReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Flight reimbursement: 100% up to policy limit of $1000.",
    "    ",
    "    Policy: min(amount, $1000)",
    "    ",
    "    Example:",
    "        $500 flight  \u2192 $500  reimbursed (under limit)",
    "        $1500 flight \u2192 $1000 reimbursed (capped)",
    "    \"\"\"",
    "    ",
    "    POLICY_LIMIT = Decimal(\"1000\")",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"Apply flight reimbursement policy.\"\"\"",
    "        return min(expense.amount, self.POLICY_LIMIT)",
    "",
    "",
    "class HotelReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Hotel reimbursement: 100% up to $200 per night.",
    "    ",
    "    Policy: min(per_night_rate, $200) \u00d7 nights",
    "    ",
    "    Example:",
    "        $180/night \u00d7 2 nights = $360 \u2192 $360 reimbursed (under cap)",
    "        $350/night \u00d7 3 nights = $1050 \u2192 $600 reimbursed (capped at $200 \u00d7 3)",
    "    \"\"\"",
    "    ",
    "    NIGHTLY_CAP = Decimal(\"200\")",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"Apply hotel reimbursement policy with nightly cap.\"\"\"",
    "        nights = Decimal(str(expense.details.get(\"nights\", 1)))",
    "        ",
    "        if nights <= 0:",
    "            raise ValueError(\"Hotel nights must be positive\")",
    "        ",
    "        per_night = expense.amount / nights",
    "        capped_per_night = min(per_night, self.NIGHTLY_CAP)",
    "        ",
    "        return capped_per_night * nights",
    "",
    "",
    "class MealReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Meal reimbursement: 50% of expense, up to $50 per day.",
    "    ",
    "    Policy: min(per_day_rate \u00d7 50%, $50) \u00d7 days",
    "    ",
    "    Example:",
    "        $80/day \u00d7 2 days = $160 submitted",
    "        Per day: min($80 \u00d7 0.5, $50) = min($40, $50) = $40",
    "        Total: $40 \u00d7 2 = $80 reimbursed",
    "    \"\"\"",
    "    ",
    "    DAILY_CAP = Decimal(\"50\")",
    "    REIMBURSEMENT_RATE = Decimal(\"0.5\")",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"Apply meal reimbursement policy with 50% rate and daily cap.\"\"\"",
    "        days = Decimal(str(expense.details.get(\"days\", 1)))",
    "        ",
    "        if days <= 0:",
    "            raise ValueError(\"Meal days must be positive\")",
    "        ",
    "        per_day = expense.amount / days",
    "        reimbursable_per_day = min(",
    "            per_day * self.REIMBURSEMENT_RATE,",
    "            self.DAILY_CAP",
    "        )",
    "        ",
    "        return reimbursable_per_day * days",
    "",
    "",
    "class TransportReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Transport reimbursement: 100% with no limit.",
    "    ",
    "    Policy: Full amount reimbursed",
    "    ",
    "    Example:",
    "        $89.50 taxi \u2192 $89.50 reimbursed",
    "    \"\"\"",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"Apply transport reimbursement policy (full amount).\"\"\"",
    "        return expense.amount",
    "",
    "",
    "# ============================================================================",
    "# FACTORY PATTERN - EXPENSE CREATION",
    "# ============================================================================",
    "",
    "class ExpenseFactory:",
    "    \"\"\"",
    "    Factory for creating Expense objects with auto-generated IDs.",
    "    ",
    "    This centralizes expense creation logic, ensuring:",
    "    - Unique sequential IDs",
    "    - Proper Decimal conversion",
    "    - Consistent object construction",
    "    ",
    "    Example:",
    "        >>> expense = ExpenseFactory.create(",
    "        ...     expense_type=ExpenseType.FLIGHT,",
    "        ...     amount=Decimal(\"450.00\"),",
    "        ...     date=\"2024-03-15\",",
    "        ...     details={}",
    "        ... )",
    "        >>> expense.id",
    "        'exp_1'",
    "    \"\"\"",
    "    ",
    "    _counter: int = 0",
    "    ",
    "    @classmethod",
    "    def create(",
    "        cls,",
    "        expense_type: ExpenseType,",
    "        amount: Decimal,",
    "        date: str,",
    "        details: Dict[str, Any]",
    "    ) -> Expense:",
    "        \"\"\"",
    "        Create a new Expense with auto-generated ID.",
    "        ",
    "        Args:",
    "            expense_type: Category of expense",
    "            amount: Expense amount as Decimal",
    "            date: Date string in YYYY-MM-DD format",
    "            details: Additional metadata dict",
    "            ",
    "        Returns:",
    "            New Expense instance with unique ID",
    "        \"\"\"",
    "        cls._counter += 1",
    "        return Expense(",
    "            id=f\"exp_{cls._counter}\",",
    "            expense_type=expense_type,",
    "            amount=amount,",
    "            date=date,",
    "            details=details",
    "        )",
    "    ",
    "    @classmethod",
    "    def reset_counter(cls) -> None:",
    "        \"\"\"Reset ID counter (useful for testing).\"\"\"",
    "        cls._counter = 0",
    "",
    "",
    "# ============================================================================",
    "# MAIN SERVICE - EXPENSE MANAGER",
    "# ============================================================================",
    "",
    "class ExpenseManager:",
    "    \"\"\"",
    "    Main service class for managing employee travel expenses.",
    "    ",
    "    This class orchestrates expense tracking and reimbursement calculation",
    "    using the Strategy Pattern for flexible policy application.",
    "    ",
    "    Design Patterns Used:",
    "        - Strategy Pattern: Different reimbursement calculations per type",
    "        - Factory Pattern: Centralized expense creation",
    "        - Repository Pattern: Employee-indexed expense storage",
    "    ",
    "    Example:",
    "        >>> manager = ExpenseManager()",
    "        >>> manager.add_expense(\"emp001\", \"FLIGHT\", 450.0, \"2024-03-15\", {})",
    "        'exp_1'",
    "        >>> manager.calculate_reimbursement(\"emp001\")",
    "        450.0",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize expense manager with default strategies.\"\"\"",
    "        # Storage: employee_id -> list of expenses",
    "        self._employee_expenses: Dict[str, List[Expense]] = {}",
    "        ",
    "        # Strategy registry: expense_type -> calculation strategy",
    "        self._strategies: Dict[ExpenseType, ReimbursementStrategy] = {",
    "            ExpenseType.FLIGHT: FlightReimbursementStrategy(),",
    "            ExpenseType.HOTEL: HotelReimbursementStrategy(),",
    "            ExpenseType.MEAL: MealReimbursementStrategy(),",
    "            ExpenseType.TRANSPORT: TransportReimbursementStrategy(),",
    "        }",
    "    ",
    "    def add_expense(",
    "        self,",
    "        employee_id: str,",
    "        expense_type: str,",
    "        amount: float,",
    "        date: str,",
    "        details: Dict[str, Any]",
    "    ) -> str:",
    "        \"\"\"",
    "        Add an expense for an employee.",
    "        ",
    "        Args:",
    "            employee_id: Unique identifier for the employee",
    "            expense_type: Type of expense (FLIGHT, HOTEL, MEAL, TRANSPORT)",
    "            amount: Expense amount in USD",
    "            date: Date of expense (YYYY-MM-DD)",
    "            details: Additional info (nights for hotel, days for meal)",
    "            ",
    "        Returns:",
    "            Unique expense ID (e.g., \"exp_1\")",
    "            ",
    "        Raises:",
    "            ValueError: If expense_type is invalid",
    "            ",
    "        Example:",
    "            >>> manager.add_expense(",
    "            ...     \"emp001\", \"HOTEL\", 350.0, \"2024-03-20\",",
    "            ...     {\"nights\": 3}",
    "            ... )",
    "            'exp_1'",
    "        \"\"\"",
    "        # Validate expense type",
    "        try:",
    "            exp_type = ExpenseType(expense_type.upper())",
    "        except ValueError:",
    "            raise ValueError(",
    "                f\"Invalid expense type: '{expense_type}'. \"",
    "                f\"Valid types: {[t.value for t in ExpenseType]}\"",
    "            )",
    "        ",
    "        # Create expense using factory",
    "        expense = ExpenseFactory.create(",
    "            expense_type=exp_type,",
    "            amount=Decimal(str(amount)),",
    "            date=date,",
    "            details=details if details else {}",
    "        )",
    "        ",
    "        # Store expense for employee",
    "        if employee_id not in self._employee_expenses:",
    "            self._employee_expenses[employee_id] = []",
    "        ",
    "        self._employee_expenses[employee_id].append(expense)",
    "        ",
    "        return expense.id",
    "    ",
    "    def calculate_reimbursement(self, employee_id: str) -> float:",
    "        \"\"\"",
    "        Calculate total reimbursable amount for an employee.",
    "        ",
    "        Applies company policies using Strategy Pattern to determine",
    "        the reimbursable amount for each expense.",
    "        ",
    "        Args:",
    "            employee_id: Employee to calculate reimbursement for",
    "            ",
    "        Returns:",
    "            Total reimbursable amount rounded to 2 decimal places",
    "            ",
    "        Example:",
    "            >>> manager.add_expense(\"emp001\", \"FLIGHT\", 500.0, \"2024-03-15\", {})",
    "            >>> manager.add_expense(\"emp001\", \"TRANSPORT\", 45.0, \"2024-03-15\", {})",
    "            >>> manager.calculate_reimbursement(\"emp001\")",
    "            545.0",
    "        \"\"\"",
    "        if employee_id not in self._employee_expenses:",
    "            return 0.0",
    "        ",
    "        total = Decimal(\"0\")",
    "        ",
    "        for expense in self._employee_expenses[employee_id]:",
    "            strategy = self._strategies[expense.expense_type]",
    "            total += strategy.calculate(expense)",
    "        ",
    "        # Round to 2 decimal places using HALF_UP",
    "        rounded = total.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)",
    "        ",
    "        return float(rounded)",
    "    ",
    "    def get_expenses_by_type(",
    "        self,",
    "        employee_id: str,",
    "        expense_type: str",
    "    ) -> List[Expense]:",
    "        \"\"\"",
    "        Get all expenses of a specific type for an employee.",
    "        ",
    "        Args:",
    "            employee_id: Employee identifier",
    "            expense_type: Type to filter by",
    "            ",
    "        Returns:",
    "            List of expenses matching the type (empty if none)",
    "            ",
    "        Example:",
    "            >>> expenses = manager.get_expenses_by_type(\"emp001\", \"FLIGHT\")",
    "            >>> len(expenses)",
    "            2",
    "        \"\"\"",
    "        if employee_id not in self._employee_expenses:",
    "            return []",
    "        ",
    "        try:",
    "            exp_type = ExpenseType(expense_type.upper())",
    "        except ValueError:",
    "            return []",
    "        ",
    "        return [",
    "            expense",
    "            for expense in self._employee_expenses[employee_id]",
    "            if expense.expense_type == exp_type",
    "        ]",
    "    ",
    "    def get_total_expenses(self, employee_id: str) -> float:",
    "        \"\"\"",
    "        Get total raw expense amount before policy application.",
    "        ",
    "        Args:",
    "            employee_id: Employee identifier",
    "            ",
    "        Returns:",
    "            Sum of all expense amounts (not reimbursement)",
    "            ",
    "        Example:",
    "            >>> manager.add_expense(\"emp001\", \"FLIGHT\", 1500.0, \"2024-03-15\", {})",
    "            >>> manager.get_total_expenses(\"emp001\")",
    "            1500.0  # Raw amount, not capped",
    "        \"\"\"",
    "        if employee_id not in self._employee_expenses:",
    "            return 0.0",
    "        ",
    "        total = sum(",
    "            expense.amount",
    "            for expense in self._employee_expenses[employee_id]",
    "        )",
    "        ",
    "        rounded = total.quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)",
    "        return float(rounded)",
    "",
    "",
    "# ============================================================================",
    "# DEMO AND TESTING",
    "# ============================================================================",
    "",
    "def run_demo() -> None:",
    "    \"\"\"Demonstrate the expense management system.\"\"\"",
    "    print(\"=\"*60)",
    "    print(\"  TRAVEL EXPENSE CALCULATION SYSTEM - DEMO\")",
    "    print(\"=\"*60)",
    "    print()",
    "    ",
    "    # Reset factory counter for clean demo",
    "    ExpenseFactory.reset_counter()",
    "    ",
    "    # Initialize manager",
    "    manager = ExpenseManager()",
    "    print(\"\u2713 ExpenseManager initialized\")",
    "    print()",
    "    ",
    "    # Example 1: Basic multi-type expenses",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 1: Basic Multi-Type Expenses\")",
    "    print(\"-\" * 40)",
    "    ",
    "    exp1 = manager.add_expense(\"emp001\", \"FLIGHT\", 450.0, \"2024-03-15\", {})",
    "    print(f\"  Added FLIGHT expense: $450.00 \u2192 ID: {exp1}\")",
    "    ",
    "    exp2 = manager.add_expense(\"emp001\", \"HOTEL\", 180.0, \"2024-03-15\", {\"nights\": 2})",
    "    print(f\"  Added HOTEL expense: $180.00 (2 nights) \u2192 ID: {exp2}\")",
    "    ",
    "    exp3 = manager.add_expense(\"emp001\", \"MEAL\", 75.0, \"2024-03-15\", {\"days\": 2})",
    "    print(f\"  Added MEAL expense: $75.00 (2 days) \u2192 ID: {exp3}\")",
    "    ",
    "    reimbursement = manager.calculate_reimbursement(\"emp001\")",
    "    total_raw = manager.get_total_expenses(\"emp001\")",
    "    ",
    "    print()",
    "    print(f\"  \ud83d\udcca Total Raw Expenses: ${total_raw:.2f}\")",
    "    print(f\"  \ud83d\udcb0 Total Reimbursement: ${reimbursement:.2f}\")",
    "    print()",
    "    print(\"  Breakdown:\")",
    "    print(\"    \u2022 Flight: $450.00 \u2192 $450.00 (100%, under $1000 limit)\")",
    "    print(\"    \u2022 Hotel: $180.00 / 2 nights = $90/night \u2192 $180.00 (under $200 cap)\")",
    "    print(\"    \u2022 Meal: $75.00 / 2 days \u00d7 50% = $18.75/day \u2192 $37.50\")",
    "    print()",
    "    ",
    "    # Example 2: Policy caps applied",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 2: Policy Caps Applied\")",
    "    print(\"-\" * 40)",
    "    ",
    "    ExpenseFactory.reset_counter()",
    "    manager2 = ExpenseManager()",
    "    ",
    "    manager2.add_expense(\"emp002\", \"HOTEL\", 1050.0, \"2024-03-20\", {\"nights\": 3})",
    "    print(f\"  Added HOTEL: $1050.00 (3 nights = $350/night)\")",
    "    ",
    "    manager2.add_expense(\"emp002\", \"FLIGHT\", 1500.0, \"2024-03-20\", {})",
    "    print(f\"  Added FLIGHT: $1500.00\")",
    "    ",
    "    reimbursement2 = manager2.calculate_reimbursement(\"emp002\")",
    "    total_raw2 = manager2.get_total_expenses(\"emp002\")",
    "    ",
    "    print()",
    "    print(f\"  \ud83d\udcca Total Raw Expenses: ${total_raw2:.2f}\")",
    "    print(f\"  \ud83d\udcb0 Total Reimbursement: ${reimbursement2:.2f}\")",
    "    print()",
    "    print(\"  Breakdown:\")",
    "    print(\"    \u2022 Hotel: $350/night capped at $200/night \u00d7 3 = $600.00\")",
    "    print(\"    \u2022 Flight: $1500.00 capped at $1000.00\")",
    "    print()",
    "    ",
    "    # Example 3: Edge case - empty employee",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 3: Edge Cases\")",
    "    print(\"-\" * 40)",
    "    ",
    "    empty_reimbursement = manager.calculate_reimbursement(\"nonexistent\")",
    "    print(f\"  Empty employee reimbursement: ${empty_reimbursement:.2f}\")",
    "    ",
    "    # Get expenses by type",
    "    transport_expenses = manager.get_expenses_by_type(\"emp001\", \"TRANSPORT\")",
    "    print(f\"  Transport expenses for emp001: {len(transport_expenses)} found\")",
    "    ",
    "    print()",
    "    print(\"=\"*60)",
    "    print(\"  DEMO COMPLETE\")",
    "    print(\"=\"*60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "/**",
    " * Travel Expense Calculation System",
    " * ",
    " * A production-quality implementation using Strategy Pattern and Factory Pattern",
    " * for calculating employee travel expense reimbursements.",
    " */",
    "",
    "// ============================================================================",
    "// ENUMS AND DATA CLASSES",
    "// ============================================================================",
    "",
    "enum ExpenseType {",
    "    FLIGHT, HOTEL, MEAL, TRANSPORT",
    "}",
    "",
    "class Expense {",
    "    private final String id;",
    "    private final ExpenseType type;",
    "    private final BigDecimal amount;",
    "    private final String date;",
    "    private final Map<String, Object> details;",
    "    ",
    "    public Expense(String id, ExpenseType type, BigDecimal amount,",
    "                   String date, Map<String, Object> details) {",
    "        this.id = id;",
    "        this.type = type;",
    "        this.amount = amount;",
    "        this.date = date;",
    "        this.details = details != null ? details : new HashMap<>();",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public ExpenseType getType() { return type; }",
    "    public BigDecimal getAmount() { return amount; }",
    "    public String getDate() { return date; }",
    "    public Map<String, Object> getDetails() { return details; }",
    "}",
    "",
    "// ============================================================================",
    "// STRATEGY PATTERN - REIMBURSEMENT CALCULATIONS",
    "// ============================================================================",
    "",
    "interface ReimbursementStrategy {",
    "    BigDecimal calculate(Expense expense);",
    "}",
    "",
    "class FlightReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal POLICY_LIMIT = new BigDecimal(\"1000\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount().min(POLICY_LIMIT);",
    "    }",
    "}",
    "",
    "class HotelReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal NIGHTLY_CAP = new BigDecimal(\"200\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        Object nightsObj = expense.getDetails().getOrDefault(\"nights\", 1);",
    "        BigDecimal nights = new BigDecimal(nightsObj.toString());",
    "        ",
    "        BigDecimal perNight = expense.getAmount().divide(nights, 10, RoundingMode.HALF_UP);",
    "        BigDecimal cappedPerNight = perNight.min(NIGHTLY_CAP);",
    "        ",
    "        return cappedPerNight.multiply(nights);",
    "    }",
    "}",
    "",
    "class MealReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal DAILY_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal RATE = new BigDecimal(\"0.5\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        Object daysObj = expense.getDetails().getOrDefault(\"days\", 1);",
    "        BigDecimal days = new BigDecimal(daysObj.toString());",
    "        ",
    "        BigDecimal perDay = expense.getAmount().divide(days, 10, RoundingMode.HALF_UP);",
    "        BigDecimal reimbursablePerDay = perDay.multiply(RATE).min(DAILY_CAP);",
    "        ",
    "        return reimbursablePerDay.multiply(days);",
    "    }",
    "}",
    "",
    "class TransportReimbursementStrategy implements ReimbursementStrategy {",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount();",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// FACTORY PATTERN - EXPENSE CREATION",
    "// ============================================================================",
    "",
    "class ExpenseFactory {",
    "    private static int counter = 0;",
    "    ",
    "    public static Expense create(ExpenseType type, BigDecimal amount,",
    "                                  String date, Map<String, Object> details) {",
    "        counter++;",
    "        return new Expense(\"exp_\" + counter, type, amount, date, details);",
    "    }",
    "    ",
    "    public static void resetCounter() {",
    "        counter = 0;",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// MAIN SERVICE - EXPENSE MANAGER",
    "// ============================================================================",
    "",
    "public class ExpenseManager {",
    "    private final Map<String, List<Expense>> employeeExpenses;",
    "    private final Map<ExpenseType, ReimbursementStrategy> strategies;",
    "    ",
    "    public ExpenseManager() {",
    "        this.employeeExpenses = new HashMap<>();",
    "        this.strategies = new EnumMap<>(ExpenseType.class);",
    "        ",
    "        strategies.put(ExpenseType.FLIGHT, new FlightReimbursementStrategy());",
    "        strategies.put(ExpenseType.HOTEL, new HotelReimbursementStrategy());",
    "        strategies.put(ExpenseType.MEAL, new MealReimbursementStrategy());",
    "        strategies.put(ExpenseType.TRANSPORT, new TransportReimbursementStrategy());",
    "    }",
    "    ",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String date, Map<String, Object> details) {",
    "        ExpenseType expenseType;",
    "        try {",
    "            expenseType = ExpenseType.valueOf(type.toUpperCase());",
    "        } catch (IllegalArgumentException e) {",
    "            throw new IllegalArgumentException(\"Invalid expense type: \" + type);",
    "        }",
    "        ",
    "        Expense expense = ExpenseFactory.create(",
    "            expenseType,",
    "            new BigDecimal(String.valueOf(amount)),",
    "            date,",
    "            details",
    "        );",
    "        ",
    "        employeeExpenses.computeIfAbsent(employeeId, k -> new ArrayList<>())",
    "                        .add(expense);",
    "        ",
    "        return expense.getId();",
    "    }",
    "    ",
    "    public double calculateReimbursement(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.get(employeeId);",
    "        if (expenses == null || expenses.isEmpty()) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            ReimbursementStrategy strategy = strategies.get(expense.getType());",
    "            total = total.add(strategy.calculate(expense));",
    "        }",
    "        ",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    public List<Expense> getExpensesByType(String employeeId, String type) {",
    "        List<Expense> expenses = employeeExpenses.get(employeeId);",
    "        if (expenses == null) {",
    "            return new ArrayList<>();",
    "        }",
    "        ",
    "        ExpenseType expenseType;",
    "        try {",
    "            expenseType = ExpenseType.valueOf(type.toUpperCase());",
    "        } catch (IllegalArgumentException e) {",
    "            return new ArrayList<>();",
    "        }",
    "        ",
    "        List<Expense> result = new ArrayList<>();",
    "        for (Expense expense : expenses) {",
    "            if (expense.getType() == expenseType) {",
    "                result.add(expense);",
    "            }",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    public double getTotalExpenses(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.get(employeeId);",
    "        if (expenses == null || expenses.isEmpty()) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            total = total.add(expense.getAmount());",
    "        }",
    "        ",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    // Demo main method",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"  TRAVEL EXPENSE CALCULATION SYSTEM - DEMO\");",
    "        System.out.println(\"=\" .repeat(60));",
    "        ",
    "        ExpenseFactory.resetCounter();",
    "        ExpenseManager manager = new ExpenseManager();",
    "        ",
    "        // Add expenses",
    "        String exp1 = manager.addExpense(\"emp001\", \"FLIGHT\", 450.0,",
    "                                          \"2024-03-15\", new HashMap<>());",
    "        System.out.println(\"Added FLIGHT: $450.00 -> \" + exp1);",
    "        ",
    "        Map<String, Object> hotelDetails = new HashMap<>();",
    "        hotelDetails.put(\"nights\", 2);",
    "        String exp2 = manager.addExpense(\"emp001\", \"HOTEL\", 180.0,",
    "                                          \"2024-03-15\", hotelDetails);",
    "        System.out.println(\"Added HOTEL: $180.00 (2 nights) -> \" + exp2);",
    "        ",
    "        // Calculate",
    "        double reimb = manager.calculateReimbursement(\"emp001\");",
    "        double total = manager.getTotalExpenses(\"emp001\");",
    "        ",
    "        System.out.println();",
    "        System.out.println(\"Total Raw: $\" + total);",
    "        System.out.println(\"Reimbursement: $\" + reimb);",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-17",
      "section": "Imports and Module Docstring",
      "explanation": "We import:\n- `ABC, abstractmethod` for Strategy interface\n- `Decimal, ROUND_HALF_UP` for precise financial math\n- `Enum` for type-safe expense categories\n- `dataclass` for clean data objects\n- `typing` for type hints"
    },
    {
      "lines": "22-27",
      "section": "ExpenseType Enum",
      "explanation": "Using an enum instead of strings provides:\n- **Type safety** - Can't pass 'FLGIHT' by accident\n- **IDE support** - Autocomplete and refactoring\n- **Self-documenting** - Clear list of valid types"
    },
    {
      "lines": "30-57",
      "section": "Expense Dataclass",
      "explanation": "The `@dataclass(frozen=True)` decorator:\n- Auto-generates `__init__`, `__repr__`, `__eq__`\n- `frozen=True` makes it immutable (safe for hashing)\n- Amount is `Decimal` not `float` for precision\n- `to_dict()` method for serialization"
    },
    {
      "lines": "63-85",
      "section": "ReimbursementStrategy Interface",
      "explanation": "**Strategy Pattern Core**:\n- Abstract base class defines contract\n- `@abstractmethod calculate()` must be implemented\n- Takes `Expense`, returns `Decimal`\n- Allows interchangeable algorithms"
    },
    {
      "lines": "88-103",
      "section": "FlightReimbursementStrategy",
      "explanation": "**Simple cap policy**:\n- `POLICY_LIMIT = $1000` as class constant\n- `min(amount, limit)` - full reimbursement up to cap\n- Constants make policy changes easy"
    },
    {
      "lines": "106-130",
      "section": "HotelReimbursementStrategy",
      "explanation": "**Per-unit cap with multiplication**:\n1. Extract nights from details dict\n2. Calculate per-night rate: `amount / nights`\n3. Cap per night: `min(per_night, $200)`\n4. Multiply back: `capped \u00d7 nights`\n\nThis handles both under and over cap scenarios."
    },
    {
      "lines": "133-162",
      "section": "MealReimbursementStrategy",
      "explanation": "**Percentage + cap combination**:\n1. Extract days from details\n2. Calculate per-day rate\n3. Apply 50% rate\n4. Cap at $50/day max reimbursement\n5. Multiply by days\n\nFormula: `min(per_day \u00d7 0.5, $50) \u00d7 days`"
    },
    {
      "lines": "165-175",
      "section": "TransportReimbursementStrategy",
      "explanation": "**Simplest strategy** - just return full amount.\n\nEven for trivial logic, having a separate class:\n- Maintains consistency\n- Allows future policy changes\n- Documents that 'no limit' is intentional"
    },
    {
      "lines": "181-220",
      "section": "ExpenseFactory",
      "explanation": "**Factory Pattern Benefits**:\n- Centralizes ID generation (`exp_1`, `exp_2`, ...)\n- Single point for validation (future)\n- Consistent object construction\n- `reset_counter()` for testing"
    },
    {
      "lines": "226-260",
      "section": "ExpenseManager.__init__",
      "explanation": "**Manager initialization**:\n- `_employee_expenses`: Dict mapping employee \u2192 expenses list\n- `_strategies`: Dict mapping type \u2192 strategy instance\n\nStrategies are created ONCE and reused (flyweight pattern)."
    },
    {
      "lines": "262-310",
      "section": "add_expense Method",
      "explanation": "**Key responsibilities**:\n1. **Validate** type against enum (throw on invalid)\n2. **Convert** amount to Decimal immediately\n3. **Create** via Factory (gets unique ID)\n4. **Store** in employee's list\n\nNote: Amount converted from float to Decimal string to avoid precision issues."
    },
    {
      "lines": "312-355",
      "section": "calculate_reimbursement Method",
      "explanation": "**Strategy Pattern in action**:\n1. Get employee's expenses\n2. For each: lookup strategy, delegate calculation\n3. Sum results\n4. Round to 2 decimals with HALF_UP\n\nThe manager doesn't know HOW calculations work - just orchestrates."
    },
    {
      "lines": "357-420",
      "section": "Query Methods",
      "explanation": "`get_expenses_by_type`: Filter by enum type\n`get_total_expenses`: Sum raw amounts (no policy)\n\nBoth handle missing employees gracefully (return empty/0)."
    },
    {
      "lines": "426-500",
      "section": "Demo and Main",
      "explanation": "**Runnable demonstration**:\n- Tests all expense types\n- Shows policy caps in action\n- Verifies edge cases (empty employee)\n- Clean output for verification"
    }
  ],
  "complexity_analysis": {
    "time": {
      "add_expense": {
        "complexity": "O(1)",
        "explanation": "HashMap insertion, Decimal conversion, Factory creation - all O(1)"
      },
      "calculate_reimbursement": {
        "complexity": "O(n)",
        "explanation": "Must iterate through all n expenses for the employee. Strategy lookup is O(1). Each strategy calculation is O(1)."
      },
      "get_expenses_by_type": {
        "complexity": "O(n)",
        "explanation": "Filter through all n expenses, checking type for each"
      },
      "get_total_expenses": {
        "complexity": "O(n)",
        "explanation": "Sum all n expense amounts"
      },
      "overall": "**addExpense: O(1)**, **queries: O(n)** where n = expenses for employee"
    },
    "space": {
      "complexity": "O(E \u00d7 D) total, where E = total expenses, D = unique employees",
      "breakdown": "- **Employee map**: O(D) for D employees\n- **Expense lists**: O(E) total across all employees\n- **Strategy instances**: O(4) = O(1) - one per type, reused\n- **Expense objects**: Each is O(1) - fixed fields",
      "note": "Memory grows linearly with number of expenses submitted across all employees"
    },
    "can_we_do_better": "For single-employee queries, O(n) is necessary since we must process all expenses. However, if `calculateReimbursement` is called frequently, we could **cache** the result and invalidate on new expense - trading space for time."
  },
  "dry_run": {
    "example": "addExpense(\"emp001\", \"HOTEL\", 350.0, \"2024-03-20\", {\"nights\": 3}), addExpense(\"emp001\", \"FLIGHT\", 1500.0, ...), calculateReimbursement(\"emp001\")",
    "trace_table": "## Complete Trace\n\n| Step | Operation | Internal State | Calculation | Result |\n|------|-----------|---------------|-------------|--------|\n| 1 | `__init__()` | strategies={FLIGHT\u2192F, HOTEL\u2192H, MEAL\u2192M, TRANSPORT\u2192T}, expenses={} | - | Manager ready |\n| 2 | `addExpense(\"emp001\", \"HOTEL\", 350, ..., {nights:3})` | expenses={\"emp001\": [Expense(exp_1, HOTEL, $350, {nights:3})]} | Factory: counter=1 | \"exp_1\" |\n| 3 | `addExpense(\"emp001\", \"FLIGHT\", 1500, ..., {})` | expenses={\"emp001\": [exp_1, Expense(exp_2, FLIGHT, $1500)]} | Factory: counter=2 | \"exp_2\" |\n| 4 | `calculateReimbursement(\"emp001\")` | Iterate through 2 expenses | | |\n| 4a | - Process exp_1 (HOTEL) | strategy=HotelStrategy | $350/3 nights = $116.67/night, min($116.67, $200) = $116.67, \u00d7 3 = **$350.00** | +$350.00 |\n| 4b | - Process exp_2 (FLIGHT) | strategy=FlightStrategy | min($1500, $1000) = **$1000.00** | +$1000.00 |\n| 4c | - Sum and round | total = $350 + $1000 = $1350 | quantize(0.01, HALF_UP) | **$1350.00** |",
    "final_answer": "$1350.00"
  },
  "test_cases": [
    {
      "name": "Single Flight - Under Limit",
      "category": "Happy Path",
      "input": "addExpense(\"emp001\", \"FLIGHT\", 500.0, \"2024-03-15\", {}), calculateReimbursement(\"emp001\")",
      "expected": "500.0",
      "explanation": "$500 < $1000 limit, so 100% reimbursed"
    },
    {
      "name": "Single Flight - Over Limit (Capped)",
      "category": "Policy Cap",
      "input": "addExpense(\"emp001\", \"FLIGHT\", 1500.0, \"2024-03-15\", {}), calculateReimbursement(\"emp001\")",
      "expected": "1000.0",
      "explanation": "$1500 > $1000 limit, capped at $1000"
    },
    {
      "name": "Hotel - Under Nightly Cap",
      "category": "Happy Path",
      "input": "addExpense(\"emp001\", \"HOTEL\", 150.0, \"2024-03-15\", {\"nights\": 1}), calculateReimbursement(\"emp001\")",
      "expected": "150.0",
      "explanation": "$150/night < $200 cap, fully reimbursed"
    },
    {
      "name": "Hotel - Over Nightly Cap",
      "category": "Policy Cap",
      "input": "addExpense(\"emp001\", \"HOTEL\", 900.0, \"2024-03-15\", {\"nights\": 3}), calculateReimbursement(\"emp001\")",
      "expected": "600.0",
      "explanation": "$300/night > $200 cap. Reimbursed: $200 \u00d7 3 = $600"
    },
    {
      "name": "Meal - 50% Under Cap",
      "category": "Percentage",
      "input": "addExpense(\"emp001\", \"MEAL\", 60.0, \"2024-03-15\", {\"days\": 2}), calculateReimbursement(\"emp001\")",
      "expected": "15.0",
      "explanation": "$30/day \u00d7 50% = $15/day (under $50 cap). Total: $15 \u00d7 2 = $30... wait let me recalc: $60 total / 2 days = $30/day. 50% = $15/day. $15 \u00d7 2 = $30"
    },
    {
      "name": "Meal - 50% Hits Cap",
      "category": "Policy Cap",
      "input": "addExpense(\"emp001\", \"MEAL\", 300.0, \"2024-03-15\", {\"days\": 2}), calculateReimbursement(\"emp001\")",
      "expected": "100.0",
      "explanation": "$150/day \u00d7 50% = $75/day > $50 cap. Reimbursed: $50 \u00d7 2 = $100"
    },
    {
      "name": "Transport - No Limit",
      "category": "Happy Path",
      "input": "addExpense(\"emp001\", \"TRANSPORT\", 9999.99, \"2024-03-15\", {}), calculateReimbursement(\"emp001\")",
      "expected": "9999.99",
      "explanation": "Transport has no cap - full amount reimbursed"
    },
    {
      "name": "Empty Employee",
      "category": "Edge Case",
      "input": "calculateReimbursement(\"nonexistent\")",
      "expected": "0.0",
      "explanation": "Employee with no expenses returns 0.0, not error"
    },
    {
      "name": "Decimal Precision Test",
      "category": "Precision",
      "input": "addExpense(\"emp001\", \"TRANSPORT\", 33.33, ...), addExpense(\"emp001\", \"TRANSPORT\", 33.33, ...), addExpense(\"emp001\", \"TRANSPORT\", 33.33, ...), calculateReimbursement(\"emp001\")",
      "expected": "99.99",
      "explanation": "Using Decimal: 33.33 \u00d7 3 = 99.99 exactly. Float would give 99.99000000000001"
    },
    {
      "name": "Invalid Expense Type",
      "category": "Error Handling",
      "input": "addExpense(\"emp001\", \"INVALID\", 100.0, ...)",
      "expected": "ValueError",
      "explanation": "Invalid type should throw exception, not silently fail"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float for monetary calculations",
      "why_wrong": "Floating-point arithmetic causes precision errors. `0.1 + 0.1 + 0.1` does NOT equal `0.3` in float!",
      "correct_approach": "Always use `Decimal` (Python) or `BigDecimal` (Java) for currency",
      "code_wrong": "total = 0.0\nfor expense in expenses:\n    total += expense.amount  # float math!",
      "code_correct": "total = Decimal('0')\nfor expense in expenses:\n    total += expense.amount  # Decimal math!"
    },
    {
      "mistake": "Giant if-else chain for expense types",
      "why_wrong": "Violates Open/Closed Principle. Adding new type requires modifying existing code. Hard to test and maintain.",
      "correct_approach": "Use Strategy Pattern - each type gets its own class",
      "code_wrong": "if expense.type == 'FLIGHT':\n    reimburse = min(amount, 1000)\nelif expense.type == 'HOTEL':\n    # ... 20 more lines\nelif expense.type == 'NEW_TYPE':  # MODIFY!",
      "code_correct": "strategy = self.strategies[expense.type]\nreimburse = strategy.calculate(expense)  # polymorphism!"
    },
    {
      "mistake": "Not validating expense type",
      "why_wrong": "Silently accepting 'FLGIHT' (typo) leads to bugs down the line",
      "correct_approach": "Validate against enum, throw clear exception",
      "code_wrong": "expense.type = expense_type  # any string accepted!",
      "code_correct": "try:\n    exp_type = ExpenseType(expense_type.upper())\nexcept ValueError:\n    raise ValueError(f'Invalid type: {expense_type}')"
    },
    {
      "mistake": "Integer division losing precision",
      "why_wrong": "In some languages, `350 / 3` = `116` not `116.67`. Loses cents!",
      "correct_approach": "Ensure Decimal division or explicit float conversion",
      "code_wrong": "per_night = amount / nights  # integer division?",
      "code_correct": "per_night = Decimal(str(amount)) / Decimal(str(nights))"
    },
    {
      "mistake": "Not handling missing employee gracefully",
      "why_wrong": "KeyError crashes when employee has no expenses",
      "correct_approach": "Return 0.0 or empty list for nonexistent employee",
      "code_wrong": "return sum(e.amount for e in self.expenses[employee_id])  # KeyError!",
      "code_correct": "if employee_id not in self.expenses:\n    return 0.0\n# ... continue"
    },
    {
      "mistake": "Forgetting to round final result",
      "why_wrong": "Returning $99.98999999 instead of $99.99 looks unprofessional and may cause issues",
      "correct_approach": "Always round to 2 decimals with HALF_UP at the end",
      "code_wrong": "return float(total)  # might be 99.98999999",
      "code_correct": "return float(total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))"
    }
  ],
  "interview_tips": {
    "opening": "**Script**: 'Thank you for this problem. Before I start coding, I'd like to understand the requirements better and clarify a few things. This looks like an OOP design problem where I'll need to handle different expense calculation policies. I'm thinking Strategy Pattern would be appropriate here. Let me ask some questions first...'",
    "clarifying_questions_to_ask": [
      "**Precision**: 'Should I use BigDecimal/Decimal for monetary calculations? I know floating-point has precision issues.' \u2192 Shows awareness of financial best practices",
      "**Amount interpretation**: 'Is the amount parameter the total expense or the per-unit rate (per night/per day)?' \u2192 Critical for correct calculations",
      "**Extensibility**: 'Should the design easily support adding new expense types in the future?' \u2192 Hints at Strategy Pattern",
      "**Concurrency**: 'Do I need to worry about thread safety for this implementation?' \u2192 Shows production mindset",
      "**Validation**: 'How should I handle invalid expense types - exception or return error code?' \u2192 Defensive programming"
    ],
    "what_to_mention_proactively": [
      "**Before coding**: 'I'll use Strategy Pattern for the different calculation policies - this follows Open/Closed Principle'",
      "**During design**: 'I'm using Decimal instead of float because 0.1 + 0.1 + 0.1 doesn't equal 0.3 in floating point'",
      "**During coding**: 'The Factory Pattern here centralizes expense creation and ID generation'",
      "**After coding**: 'Let me trace through an example to verify the logic'"
    ],
    "communication_during_coding": [
      "'I'm defining the Strategy interface first - all expense types will implement this'",
      "'For Hotel, I need to extract nights from details and apply per-night cap'",
      "'The manager doesn't know calculation details - it just delegates to strategies'",
      "'Converting to Decimal immediately when amount comes in to avoid precision loss'"
    ],
    "if_stuck": [
      "**On pattern choice**: 'The key question is: what varies? The calculation logic varies by type. So I should encapsulate what varies - Strategy Pattern.'",
      "**On Decimal**: 'I know I need Decimal but forgot syntax. Can I look up the quantize method signature?'",
      "**On meal formula**: 'Let me work through an example: $80/day for 2 days. 50% of $80 = $40. Is $40 < $50 cap? Yes. So $40 \u00d7 2 = $80 reimbursed.'"
    ],
    "time_management": "**0-5 min**: Clarify requirements, identify patterns\n**5-12 min**: Design class structure (draw on whiteboard/paper)\n**12-35 min**: Implement core classes (Strategy, Factory, Manager)\n**35-45 min**: Test with examples, handle edge cases\n**45-60 min**: Discuss trade-offs, future extensions"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Factory Pattern + Repository Pattern",
    "indicators": [
      "**Different algorithms for same operation** \u2192 Strategy (different calc per expense type)",
      "**Object creation with unique IDs** \u2192 Factory (centralized expense creation)",
      "**Data grouped by key** \u2192 Repository (expenses stored by employee)"
    ],
    "similar_problems": [
      "**Payment Processing System** - Different payment method strategies (Credit, PayPal, Crypto)",
      "**Shipping Cost Calculator** - Different carrier strategies (FedEx, UPS, USPS)",
      "**Tax Calculator** - Different jurisdiction strategies",
      "**Notification System** - Different channel strategies (Email, SMS, Push)",
      "**Discount Engine** - Different promotion strategies (Percentage, Fixed, BOGO)"
    ],
    "template": "```python\n# Strategy Pattern Template\nclass Strategy(ABC):\n    @abstractmethod\n    def execute(self, data) -> Result\n\nclass ConcreteStrategyA(Strategy):\n    def execute(self, data) -> Result:\n        # Algorithm A\n\nclass Context:\n    def __init__(self):\n        self.strategies = {TypeA: StrategyA(), TypeB: StrategyB()}\n    \n    def process(self, item):\n        return self.strategies[item.type].execute(item)\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "## Part 2: Multi-Currency Support\n\n**Likely additions**:\n- Exchange rate service/strategy\n- Currency enum (USD, EUR, GBP, etc.)\n- Convert all to base currency before calculation\n\n**Data structure evolution**:\n```python\n@dataclass\nclass Expense:\n    amount: Decimal\n    currency: Currency  # NEW!\n    \nclass CurrencyConverter:\n    def to_usd(self, amount: Decimal, currency: Currency) -> Decimal:\n        rate = self.get_rate(currency)\n        return amount * rate\n```",
    "part_3_hint": "## Part 3: Per-Diem by Location\n\n**Likely additions**:\n- Location field in expenses\n- Per-diem lookup by city/country\n- Different caps based on location (NYC $100/day, Austin $50/day)\n\n**Data structure evolution**:\n```python\nclass MealReimbursementStrategy:\n    def __init__(self, per_diem_service: PerDiemService):\n        self.per_diem = per_diem_service\n    \n    def calculate(self, expense: Expense) -> Decimal:\n        daily_cap = self.per_diem.get_cap(expense.location)  # NEW!\n        # ... apply cap\n```",
    "data_structure_evolution": "```\nPart 1:           Part 2:                    Part 3:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500         \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nExpense           Expense                    Expense\n\u251c\u2500 amount         \u251c\u2500 amount                  \u251c\u2500 amount\n\u251c\u2500 type           \u251c\u2500 currency \u2190 NEW          \u251c\u2500 currency\n\u2514\u2500 details        \u251c\u2500 type                    \u251c\u2500 location \u2190 NEW\n                  \u2514\u2500 details                 \u2514\u2500 details\n\nStrategy          Strategy                   Strategy\n\u251c\u2500 calculate()    \u251c\u2500 calculate()             \u251c\u2500 calculate()\n                  \u2514\u2500 converter: service \u2190 NEW\u2514\u2500 per_diem: service \u2190 NEW\n```"
  },
  "generated_at": "2026-01-14T15:20:37.122254",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}