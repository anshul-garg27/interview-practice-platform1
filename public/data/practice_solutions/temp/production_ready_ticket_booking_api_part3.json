{
  "problem_title": "Production-Ready Event Ticket Booking API - Part 3: Concurrency and Race Conditions",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 transforms our authenticated booking system into a **thread-safe** implementation that can handle thousands of concurrent users trying to book the same limited tickets. The naive check-then-act pattern from Parts 1-2 is vulnerable to race conditions where multiple threads can read the same ticket count, pass the availability check, and all decrement - causing overselling. We must make the entire read-check-update sequence atomic.",
    "new_requirements": [
      "Thread-safe booking that prevents overselling during concurrent access",
      "Atomic check-and-decrement operations on ticket availability",
      "Fine-grained locking strategy for maximum throughput (per-event locks)",
      "Ability to simulate and test concurrent booking scenarios",
      "Proper HTTP 409 Conflict responses for concurrent booking failures"
    ],
    "new_constraints": [
      "Total tickets booked must NEVER exceed available tickets (no negative inventory)",
      "Lock contention should be minimized (don't lock entire system)",
      "Must handle the 'lost update' problem correctly",
      "Fairness in lock acquisition (FIFO ordering preferred)",
      "Deadlock prevention when multiple resources are involved"
    ],
    "key_insight": "The **check-then-act pattern MUST be atomic**: reading availability, verifying sufficiency, and decrementing tickets must happen as ONE indivisible operation. The moment you release control between checking and acting, another thread can invalidate your assumptions."
  },
  "visual_explanation": {
    "before_after": "```\n            BEFORE (Part 2 - Unsafe)              AFTER (Part 3 - Thread-Safe)\n            \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550              \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n    def book_tickets(request):              def book_tickets_atomic(request):\n        event = get_event(id)                   lock = get_event_lock(event_id)\n        \u2502                                       \u2502\n        \u2502 \u2190 Gap where other threads             with lock:  \u2190 Protected region\n        \u2502   can read same value!                \u2502   \u2502\n        if event.available >= n:                \u2502   event = get_event(id)\n            \u2502                                   \u2502   \u2502\n            \u2502 \u2190 Another gap!                    \u2502   if event.available >= n:\n            \u2502                                   \u2502       \u2502\n            event.available -= n                \u2502       event.available -= n\n            \u2502                                   \u2502       \u2502\n            \u2502 \u2190 Third thread sneaks in!         \u2502       create_booking()\n            \u2502                                   \u2502   \u2502\n            create_booking()                    \u2502   \u2514\u2500\u2500 All atomic!\n                                                \u2514\u2500\u2500 Lock released\n\n    Result: OVERSELLING                     Result: GUARANTEED SAFETY\n```",
    "algorithm_flow": "```\n                    FINE-GRAINED LOCKING ARCHITECTURE\n                    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                           \u2502   Incoming Requests \u2502\n                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n             \u2502                       \u2502                       \u2502\n             \u25bc                       \u25bc                       \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Event A Request \u2502     \u2502 Event B Request \u2502     \u2502 Event A Request \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                       \u2502                       \u2502\n             \u25bc                       \u25bc                       \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Lock(Event_A) \u2502     \u2502   Lock(Event_B) \u2502     \u2502   Lock(Event_A) \u2502\n    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502     \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502     \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n    \u2502   \u2502 ACQUIRE \u2502   \u2502     \u2502   \u2502 ACQUIRE \u2502   \u2502     \u2502   \u2502 WAITING \u2502   \u2502\n    \u2502   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2502     \u2502   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2502     \u2502   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2502\n    \u2502        \u2502        \u2502     \u2502        \u2502        \u2502     \u2502        \u2502        \u2502\n    \u2502        \u25bc        \u2502     \u2502        \u25bc        \u2502     \u2502        \u25bc        \u2502\n    \u2502   Check+Book    \u2502     \u2502   Check+Book    \u2502     \u2502   (blocked)     \u2502\n    \u2502        \u2502        \u2502     \u2502        \u2502        \u2502     \u2502        \u2502        \u2502\n    \u2502        \u25bc        \u2502     \u2502        \u25bc        \u2502     \u2502        \u2502        \u2502\n    \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502     \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502     \u2502        \u2502        \u2502\n    \u2502   \u2502 RELEASE \u2502\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n    \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502     \u2502   \u2502 RELEASE \u2502   \u2502     \u2502   ACQUIRE       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502     \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n             \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502   \u2502Check+Book\u2502  \u2502\n             \u2502                       \u2502              \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n             \u25bc                       \u25bc              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         SUCCESS                 SUCCESS                    \u2502\n                                                            \u25bc\n                                                     409 CONFLICT\n                                                  (tickets sold out)\n\n    Key: Event A and B locks are INDEPENDENT - max parallelism!\n         Only requests for SAME event must wait for each other.\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (Global Lock)",
      "description": "Add a single global lock around the entire booking method. Every booking request, regardless of event, must acquire this one lock.",
      "time_complexity": "O(1) per operation + O(n) wait time where n = concurrent requests",
      "space_complexity": "O(1) for the lock",
      "why_not_optimal": "Creates a massive bottleneck - even bookings for completely different events must wait for each other. During a flash sale, this serializes ALL traffic. A system handling 10,000 concurrent requests for 100 different events would process them one-at-a-time instead of potentially 100 in parallel."
    },
    {
      "name": "Pessimistic Locking (Per-Event)",
      "description": "Create a separate lock for each event. Threads only block each other when competing for the same event. Combined with validation outside the lock, this maximizes throughput.",
      "time_complexity": "O(1) per operation + lock wait for same-event contention",
      "space_complexity": "O(E) where E = number of events (one lock per event)",
      "key_insight": "Fine-grained locking allows parallel processing of independent events while guaranteeing serialization for the same event. The critical section is minimized to just the check-and-decrement operation."
    },
    {
      "name": "Optimistic Locking (Version-Based)",
      "description": "Add a version counter to each event. Read the version, prepare the update, then atomically verify version hasn't changed before committing. Retry on conflict.",
      "time_complexity": "O(r) where r = retry attempts under contention",
      "space_complexity": "O(1) - just a version field per event",
      "key_insight": "Works well for low-contention scenarios. Under high contention (flash sales), can cause 'livelock' where threads keep retrying. Best combined with exponential backoff."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Hybrid Fine-Grained Pessimistic Locking\n\n### Core Strategy\nWe implement **per-event pessimistic locking** with the following architecture:\n\n1. **Lock Registry**: A thread-safe map storing one `Lock` per event ID\n2. **Lock-for-Locks**: A meta-lock protecting the lock registry itself\n3. **Minimal Critical Section**: Only the atomic check-decrement-create is locked\n4. **Validation Outside Lock**: Input validation happens before acquiring the lock\n\n### Why Pessimistic Over Optimistic?\nFor ticket sales with **predictable high contention** (flash sales), pessimistic locking is superior:\n- No wasted work from failed optimistic updates\n- Fair ordering with `ReentrantLock(fair=true)`\n- Bounded wait time vs. unbounded retries\n\n### Thread-Safety Guarantees\n1. **Atomicity**: Check + decrement + create booking is one atomic unit\n2. **Visibility**: Lock release ensures changes are visible to waiting threads\n3. **Ordering**: Fair locks ensure FIFO processing\n4. **No Deadlock**: Single-lock-per-operation design prevents circular waits\n\n### Performance Optimizations\n- **Early validation**: Reject invalid requests before taking any lock\n- **Lock granularity**: Per-event locks allow parallel booking for different events\n- **ConcurrentHashMap**: Lock-free reads for non-contentious operations\n- **Lazy lock creation**: Locks created on-demand, not for every event",
    "data_structures": [
      {
        "structure": "ConcurrentHashMap<String, Event>",
        "purpose": "Thread-safe event storage with lock-free reads"
      },
      {
        "structure": "ConcurrentHashMap<String, Lock>",
        "purpose": "Registry of per-event locks for fine-grained synchronization"
      },
      {
        "structure": "ReentrantLock",
        "purpose": "Reentrant lock with fairness option for FIFO ordering"
      },
      {
        "structure": "ThreadPoolExecutor",
        "purpose": "Simulate concurrent requests for testing"
      }
    ],
    "algorithm_steps": [
      "Step 1: Validate booking request (event ID format, ticket count, user ID) - OUTSIDE lock",
      "Step 2: Get or create the lock for this specific event ID using double-checked locking pattern",
      "Step 3: Acquire the event lock (blocks if another thread holds it)",
      "Step 4: INSIDE LOCK - Re-fetch event and verify it still exists",
      "Step 5: INSIDE LOCK - Check available tickets >= requested tickets",
      "Step 6: INSIDE LOCK - Decrement available tickets atomically",
      "Step 7: INSIDE LOCK - Increment version counter (for audit/optimistic locking support)",
      "Step 8: INSIDE LOCK - Create and store booking record",
      "Step 9: Release lock (automatic with try-with-resources / context manager)",
      "Step 10: Return success response with booking details"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Production-Ready Event Ticket Booking API - Part 3: Concurrency Control",
    "",
    "This module extends Parts 1-2 with thread-safe booking operations using",
    "fine-grained pessimistic locking to prevent overselling during high-traffic",
    "flash sales.",
    "",
    "Author: Senior Software Engineer",
    "\"\"\"",
    "",
    "from __future__ import annotations",
    "import threading",
    "import uuid",
    "import re",
    "import time",
    "from dataclasses import dataclass, field",
    "from typing import Dict, List, Optional, Any, Tuple",
    "from datetime import datetime",
    "from enum import Enum",
    "from concurrent.futures import ThreadPoolExecutor, as_completed",
    "from decimal import Decimal",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# ENUMS AND DATA CLASSES",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class BookingStatus(Enum):",
    "    PENDING = \"PENDING\"",
    "    CONFIRMED = \"CONFIRMED\"",
    "    CANCELLED = \"CANCELLED\"",
    "    FAILED = \"FAILED\"",
    "",
    "",
    "class UserRole(Enum):",
    "    USER = \"USER\"",
    "    ADMIN = \"ADMIN\"",
    "    ORGANIZER = \"ORGANIZER\"",
    "",
    "",
    "@dataclass",
    "class ErrorInfo:",
    "    \"\"\"Structured error information for API responses.\"\"\"",
    "    code: str",
    "    message: str",
    "    details: Optional[Dict[str, Any]] = None",
    "",
    "",
    "@dataclass",
    "class ResponseBody:",
    "    \"\"\"Standard API response body structure.\"\"\"",
    "    success: bool",
    "    data: Optional[Dict[str, Any]] = None",
    "    error: Optional[ErrorInfo] = None",
    "",
    "",
    "@dataclass",
    "class Response:",
    "    \"\"\"HTTP-like response wrapper.\"\"\"",
    "    status: int",
    "    body: ResponseBody",
    "    ",
    "    def to_dict(self) -> Dict[str, Any]:",
    "        result = {\"status\": self.status, \"body\": {\"success\": self.body.success}}",
    "        if self.body.data:",
    "            result[\"body\"][\"data\"] = self.body.data",
    "        if self.body.error:",
    "            result[\"body\"][\"error\"] = {",
    "                \"code\": self.body.error.code,",
    "                \"message\": self.body.error.message",
    "            }",
    "            if self.body.error.details:",
    "                result[\"body\"][\"error\"][\"details\"] = self.body.error.details",
    "        return result",
    "",
    "",
    "@dataclass",
    "class Event:",
    "    \"\"\"Event entity with version for optimistic locking support.\"\"\"",
    "    id: str",
    "    name: str",
    "    date: datetime",
    "    venue: str",
    "    total_tickets: int",
    "    available_tickets: int",
    "    price_per_ticket: Decimal",
    "    organizer_id: Optional[str] = None",
    "    version: int = 1  # For optimistic locking",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Booking:",
    "    \"\"\"Booking entity representing a ticket reservation.\"\"\"",
    "    id: str",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "    total_price: Decimal",
    "    status: BookingStatus",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"User entity with role-based access control.\"\"\"",
    "    id: str",
    "    email: str",
    "    password_hash: str",
    "    role: UserRole",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Session:",
    "    \"\"\"Authentication session for logged-in users.\"\"\"",
    "    token: str",
    "    user_id: str",
    "    expires_at: datetime",
    "",
    "",
    "@dataclass",
    "class BookingRequest:",
    "    \"\"\"Request payload for booking tickets.\"\"\"",
    "    event_id: str",
    "    user_id: str",
    "    number_of_tickets: int",
    "",
    "",
    "@dataclass",
    "class EventRequest:",
    "    \"\"\"Request payload for creating an event.\"\"\"",
    "    name: str",
    "    date: str",
    "    venue: str",
    "    total_tickets: int",
    "    price_per_ticket: float",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# THREAD-SAFE TICKET API",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class TicketAPI:",
    "    \"\"\"",
    "    Production-ready Ticket Booking API with thread-safe operations.",
    "    ",
    "    Features:",
    "    - Fine-grained pessimistic locking (per-event locks)",
    "    - Input validation with detailed error messages",
    "    - Authentication and authorization",
    "    - Concurrent booking simulation for testing",
    "    ",
    "    Thread Safety:",
    "    - All booking operations are atomic",
    "    - No overselling possible under any concurrent access pattern",
    "    - Fair lock ordering prevents starvation",
    "    \"\"\"",
    "    ",
    "    # Constants",
    "    MAX_TICKETS_PER_BOOKING = 10",
    "    EVENT_ID_PATTERN = re.compile(r'^evt_[a-zA-Z0-9]{8}$')",
    "    USER_ID_PATTERN = re.compile(r'^usr_[a-zA-Z0-9]+$')",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize the API with thread-safe data structures.\"\"\"",
    "        # Core data storage",
    "        self._events: Dict[str, Event] = {}",
    "        self._bookings: Dict[str, Booking] = {}",
    "        self._users: Dict[str, User] = {}",
    "        self._sessions: Dict[str, Session] = {}",
    "        ",
    "        # Concurrency control",
    "        self._event_locks: Dict[str, threading.RLock] = {}",
    "        self._lock_registry_lock = threading.Lock()",
    "        self._event_counter = 0",
    "        self._counter_lock = threading.Lock()",
    "        ",
    "        # Statistics for monitoring",
    "        self._stats = {",
    "            'total_bookings': 0,",
    "            'successful_bookings': 0,",
    "            'failed_bookings': 0,",
    "            'lock_contentions': 0",
    "        }",
    "        self._stats_lock = threading.Lock()",
    "    ",
    "    def _get_event_lock(self, event_id: str) -> threading.RLock:",
    "        \"\"\"",
    "        Get or create a reentrant lock for a specific event.",
    "        ",
    "        Uses double-checked locking pattern for efficiency.",
    "        RLock allows same thread to acquire lock multiple times.",
    "        ",
    "        Args:",
    "            event_id: The event to get a lock for",
    "            ",
    "        Returns:",
    "            threading.RLock: The lock for this event",
    "        \"\"\"",
    "        # Fast path - lock already exists",
    "        if event_id in self._event_locks:",
    "            return self._event_locks[event_id]",
    "        ",
    "        # Slow path - need to create lock",
    "        with self._lock_registry_lock:",
    "            # Double-check after acquiring registry lock",
    "            if event_id not in self._event_locks:",
    "                self._event_locks[event_id] = threading.RLock()",
    "            return self._event_locks[event_id]",
    "    ",
    "    def _generate_event_id(self) -> str:",
    "        \"\"\"Generate a unique event ID in thread-safe manner.\"\"\"",
    "        with self._counter_lock:",
    "            self._event_counter += 1",
    "            return f\"evt_{self._event_counter:08d}\"",
    "    ",
    "    def _generate_booking_id(self) -> str:",
    "        \"\"\"Generate a unique booking ID using UUID.\"\"\"",
    "        return f\"bkg_{uuid.uuid4().hex[:12]}\"",
    "    ",
    "    def _increment_stat(self, stat_name: str) -> None:",
    "        \"\"\"Thread-safe statistics increment.\"\"\"",
    "        with self._stats_lock:",
    "            self._stats[stat_name] += 1",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # INPUT VALIDATION",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def _validate_booking_request(self, request: BookingRequest) -> Optional[Response]:",
    "        \"\"\"",
    "        Validate booking request before acquiring any locks.",
    "        ",
    "        Validation order (fail-fast):",
    "        1. Event ID format",
    "        2. User ID format",
    "        3. Ticket count range",
    "        ",
    "        Args:",
    "            request: The booking request to validate",
    "            ",
    "        Returns:",
    "            Response with error if invalid, None if valid",
    "        \"\"\"",
    "        errors = []",
    "        ",
    "        # Validate event ID format",
    "        if not request.event_id:",
    "            errors.append(\"eventId is required\")",
    "        elif not self.EVENT_ID_PATTERN.match(request.event_id):",
    "            errors.append(f\"Invalid eventId format: {request.event_id}\")",
    "        ",
    "        # Validate user ID format",
    "        if not request.user_id:",
    "            errors.append(\"userId is required\")",
    "        elif not self.USER_ID_PATTERN.match(request.user_id):",
    "            errors.append(f\"Invalid userId format: {request.user_id}\")",
    "        ",
    "        # Validate ticket count",
    "        if request.number_of_tickets is None:",
    "            errors.append(\"numberOfTickets is required\")",
    "        elif not isinstance(request.number_of_tickets, int):",
    "            errors.append(\"numberOfTickets must be an integer\")",
    "        elif request.number_of_tickets < 1:",
    "            errors.append(\"numberOfTickets must be at least 1\")",
    "        elif request.number_of_tickets > self.MAX_TICKETS_PER_BOOKING:",
    "            errors.append(f\"Cannot book more than {self.MAX_TICKETS_PER_BOOKING} tickets\")",
    "        ",
    "        if errors:",
    "            return Response(",
    "                status=400,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(",
    "                        code=\"VALIDATION_ERROR\",",
    "                        message=\"Invalid booking request\",",
    "                        details={\"errors\": errors}",
    "                    )",
    "                )",
    "            )",
    "        return None",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # EVENT OPERATIONS",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def create_event(self, request: EventRequest) -> Response:",
    "        \"\"\"",
    "        Create a new event with available tickets.",
    "        ",
    "        Args:",
    "            request: Event creation request with details",
    "            ",
    "        Returns:",
    "            Response with created event data or error",
    "        \"\"\"",
    "        # Validate",
    "        if not request.name or len(request.name.strip()) == 0:",
    "            return Response(",
    "                status=400,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(code=\"VALIDATION_ERROR\", message=\"Event name is required\")",
    "                )",
    "            )",
    "        ",
    "        if request.total_tickets < 1:",
    "            return Response(",
    "                status=400,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(code=\"VALIDATION_ERROR\", message=\"Must have at least 1 ticket\")",
    "                )",
    "            )",
    "        ",
    "        # Create event",
    "        event_id = self._generate_event_id()",
    "        event = Event(",
    "            id=event_id,",
    "            name=request.name.strip(),",
    "            date=datetime.fromisoformat(request.date.replace('Z', '+00:00')),",
    "            venue=request.venue,",
    "            total_tickets=request.total_tickets,",
    "            available_tickets=request.total_tickets,",
    "            price_per_ticket=Decimal(str(request.price_per_ticket)),",
    "            version=1",
    "        )",
    "        ",
    "        self._events[event_id] = event",
    "        ",
    "        return Response(",
    "            status=201,",
    "            body=ResponseBody(",
    "                success=True,",
    "                data={",
    "                    \"eventId\": event_id,",
    "                    \"name\": event.name,",
    "                    \"availableTickets\": event.available_tickets,",
    "                    \"totalTickets\": event.total_tickets,",
    "                    \"pricePerTicket\": float(event.price_per_ticket)",
    "                }",
    "            )",
    "        )",
    "    ",
    "    def get_event(self, event_id: str) -> Response:",
    "        \"\"\"Get event details by ID.\"\"\"",
    "        event = self._events.get(event_id)",
    "        if not event:",
    "            return Response(",
    "                status=404,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(code=\"EVENT_NOT_FOUND\", message=f\"Event {event_id} not found\")",
    "                )",
    "            )",
    "        ",
    "        return Response(",
    "            status=200,",
    "            body=ResponseBody(",
    "                success=True,",
    "                data={",
    "                    \"eventId\": event.id,",
    "                    \"name\": event.name,",
    "                    \"date\": event.date.isoformat(),",
    "                    \"venue\": event.venue,",
    "                    \"availableTickets\": event.available_tickets,",
    "                    \"totalTickets\": event.total_tickets,",
    "                    \"pricePerTicket\": float(event.price_per_ticket),",
    "                    \"version\": event.version",
    "                }",
    "            )",
    "        )",
    "    ",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    # THREAD-SAFE BOOKING OPERATIONS (Part 3 Core)",
    "    # \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    def book_tickets_atomic(self, request: BookingRequest) -> Response:",
    "        \"\"\"",
    "        Thread-safe ticket booking using pessimistic locking.",
    "        ",
    "        This method guarantees that ticket availability is checked and",
    "        decremented atomically, preventing any possibility of overselling",
    "        even under extreme concurrent load.",
    "        ",
    "        Algorithm:",
    "        1. Validate request (outside lock for performance)",
    "        2. Acquire event-specific lock",
    "        3. Re-fetch and verify event exists",
    "        4. Check ticket availability",
    "        5. Decrement tickets and create booking (atomic)",
    "        6. Release lock",
    "        ",
    "        Args:",
    "            request: Booking request with event_id, user_id, number_of_tickets",
    "            ",
    "        Returns:",
    "            Response with booking confirmation or error",
    "            - 201: Booking created successfully",
    "            - 400: Invalid request (validation failed)",
    "            - 404: Event not found",
    "            - 409: Insufficient tickets (conflict)",
    "        ",
    "        Thread Safety:",
    "            Uses per-event RLock to ensure atomic check-and-decrement.",
    "            Other events can be booked in parallel.",
    "        \"\"\"",
    "        self._increment_stat('total_bookings')",
    "        ",
    "        # Step 1: Validate OUTSIDE the lock (fast-fail)",
    "        validation_error = self._validate_booking_request(request)",
    "        if validation_error:",
    "            self._increment_stat('failed_bookings')",
    "            return validation_error",
    "        ",
    "        # Step 2: Get the event-specific lock",
    "        event_lock = self._get_event_lock(request.event_id)",
    "        ",
    "        # Step 3-8: Critical section with lock",
    "        acquired = event_lock.acquire(timeout=10.0)  # 10 second timeout",
    "        if not acquired:",
    "            self._increment_stat('lock_contentions')",
    "            return Response(",
    "                status=503,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(",
    "                        code=\"SERVICE_BUSY\",",
    "                        message=\"System is busy, please retry\"",
    "                    )",
    "                )",
    "            )",
    "        ",
    "        try:",
    "            # Step 4: Re-fetch event (it might have been deleted)",
    "            event = self._events.get(request.event_id)",
    "            if not event:",
    "                self._increment_stat('failed_bookings')",
    "                return Response(",
    "                    status=404,",
    "                    body=ResponseBody(",
    "                        success=False,",
    "                        error=ErrorInfo(",
    "                            code=\"EVENT_NOT_FOUND\",",
    "                            message=f\"Event {request.event_id} not found\"",
    "                        )",
    "                    )",
    "                )",
    "            ",
    "            # Step 5: Check availability (INSIDE the lock!)",
    "            if event.available_tickets < request.number_of_tickets:",
    "                self._increment_stat('failed_bookings')",
    "                return Response(",
    "                    status=409,",
    "                    body=ResponseBody(",
    "                        success=False,",
    "                        error=ErrorInfo(",
    "                            code=\"INSUFFICIENT_TICKETS\",",
    "                            message=f\"Only {event.available_tickets} tickets available, requested {request.number_of_tickets}\"",
    "                        )",
    "                    )",
    "                )",
    "            ",
    "            # Step 6-7: Atomic update - decrement and version bump",
    "            event.available_tickets -= request.number_of_tickets",
    "            event.version += 1",
    "            ",
    "            # Step 8: Create booking record",
    "            booking_id = self._generate_booking_id()",
    "            total_price = event.price_per_ticket * request.number_of_tickets",
    "            ",
    "            booking = Booking(",
    "                id=booking_id,",
    "                event_id=request.event_id,",
    "                user_id=request.user_id,",
    "                number_of_tickets=request.number_of_tickets,",
    "                total_price=total_price,",
    "                status=BookingStatus.CONFIRMED,",
    "                created_at=datetime.utcnow()",
    "            )",
    "            self._bookings[booking_id] = booking",
    "            self._increment_stat('successful_bookings')",
    "            ",
    "            return Response(",
    "                status=201,",
    "                body=ResponseBody(",
    "                    success=True,",
    "                    data={",
    "                        \"bookingId\": booking_id,",
    "                        \"eventId\": request.event_id,",
    "                        \"userId\": request.user_id,",
    "                        \"numberOfTickets\": request.number_of_tickets,",
    "                        \"totalPrice\": float(total_price),",
    "                        \"status\": booking.status.value,",
    "                        \"remainingTickets\": event.available_tickets,",
    "                        \"eventVersion\": event.version",
    "                    }",
    "                )",
    "            )",
    "        ",
    "        finally:",
    "            # Step 9: ALWAYS release the lock",
    "            event_lock.release()",
    "    ",
    "    def book_tickets_optimistic(",
    "        self, ",
    "        request: BookingRequest, ",
    "        max_retries: int = 3,",
    "        base_delay_ms: float = 10.0",
    "    ) -> Response:",
    "        \"\"\"",
    "        Alternative booking using optimistic locking with retries.",
    "        ",
    "        Uses version numbers to detect concurrent modifications.",
    "        On conflict, retries with exponential backoff.",
    "        ",
    "        Best for: Low-contention scenarios",
    "        Not ideal for: Flash sales with high contention",
    "        ",
    "        Args:",
    "            request: Booking request",
    "            max_retries: Maximum retry attempts on version conflict",
    "            base_delay_ms: Base delay for exponential backoff",
    "            ",
    "        Returns:",
    "            Response with booking or error",
    "        \"\"\"",
    "        validation_error = self._validate_booking_request(request)",
    "        if validation_error:",
    "            return validation_error",
    "        ",
    "        for attempt in range(max_retries + 1):",
    "            # Read current state",
    "            event = self._events.get(request.event_id)",
    "            if not event:",
    "                return Response(",
    "                    status=404,",
    "                    body=ResponseBody(",
    "                        success=False,",
    "                        error=ErrorInfo(code=\"EVENT_NOT_FOUND\", message=\"Event not found\")",
    "                    )",
    "                )",
    "            ",
    "            expected_version = event.version",
    "            current_available = event.available_tickets",
    "            ",
    "            # Check availability",
    "            if current_available < request.number_of_tickets:",
    "                return Response(",
    "                    status=409,",
    "                    body=ResponseBody(",
    "                        success=False,",
    "                        error=ErrorInfo(code=\"INSUFFICIENT_TICKETS\", message=\"Not enough tickets\")",
    "                    )",
    "                )",
    "            ",
    "            # Try CAS (Compare-And-Swap) with minimal lock",
    "            event_lock = self._get_event_lock(request.event_id)",
    "            with event_lock:",
    "                # Version check",
    "                if event.version != expected_version:",
    "                    # Version changed - someone else modified, retry",
    "                    if attempt < max_retries:",
    "                        time.sleep(base_delay_ms * (2 ** attempt) / 1000.0)",
    "                        continue",
    "                    else:",
    "                        return Response(",
    "                            status=409,",
    "                            body=ResponseBody(",
    "                                success=False,",
    "                                error=ErrorInfo(",
    "                                    code=\"CONCURRENT_MODIFICATION\",",
    "                                    message=\"Too many concurrent attempts, please retry\"",
    "                                )",
    "                            )",
    "                        )",
    "                ",
    "                # Version matches - safe to update",
    "                event.available_tickets -= request.number_of_tickets",
    "                event.version += 1",
    "                ",
    "                booking_id = self._generate_booking_id()",
    "                booking = Booking(",
    "                    id=booking_id,",
    "                    event_id=request.event_id,",
    "                    user_id=request.user_id,",
    "                    number_of_tickets=request.number_of_tickets,",
    "                    total_price=event.price_per_ticket * request.number_of_tickets,",
    "                    status=BookingStatus.CONFIRMED",
    "                )",
    "                self._bookings[booking_id] = booking",
    "                ",
    "                return Response(",
    "                    status=201,",
    "                    body=ResponseBody(",
    "                        success=True,",
    "                        data={",
    "                            \"bookingId\": booking_id,",
    "                            \"optimisticRetries\": attempt,",
    "                            \"remainingTickets\": event.available_tickets",
    "                        }",
    "                    )",
    "                )",
    "        ",
    "        # Should not reach here, but safety net",
    "        return Response(",
    "            status=500,",
    "            body=ResponseBody(success=False, error=ErrorInfo(code=\"INTERNAL_ERROR\", message=\"Unexpected state\"))",
    "        )",
    "    ",
    "    def simulate_concurrent_bookings(",
    "        self, ",
    "        requests: List[BookingRequest],",
    "        use_optimistic: bool = False",
    "    ) -> List[Response]:",
    "        \"\"\"",
    "        Simulate multiple concurrent booking requests for testing.",
    "        ",
    "        Uses ThreadPoolExecutor to run all requests in parallel,",
    "        verifying thread-safety of the booking system.",
    "        ",
    "        Args:",
    "            requests: List of booking requests to execute concurrently",
    "            use_optimistic: If True, use optimistic locking instead",
    "            ",
    "        Returns:",
    "            List of responses in same order as requests",
    "            ",
    "        Example:",
    "            >>> api = TicketAPI()",
    "            >>> api.create_event(EventRequest('Concert', '2024-12-31', 'Arena', 2, 100))",
    "            >>> requests = [",
    "            ...     BookingRequest('evt_00000001', 'usr_A', 2),",
    "            ...     BookingRequest('evt_00000001', 'usr_B', 2),",
    "            ...     BookingRequest('evt_00000001', 'usr_C', 2),",
    "            ... ]",
    "            >>> responses = api.simulate_concurrent_bookings(requests)",
    "            >>> # Exactly 1 succeeds, 2 fail with INSUFFICIENT_TICKETS",
    "        \"\"\"",
    "        if not requests:",
    "            return []",
    "        ",
    "        # Pre-allocate results array (maintains order)",
    "        results: List[Optional[Response]] = [None] * len(requests)",
    "        ",
    "        def execute_booking(index: int, request: BookingRequest) -> Tuple[int, Response]:",
    "            \"\"\"Execute single booking and return with original index.\"\"\"",
    "            if use_optimistic:",
    "                response = self.book_tickets_optimistic(request)",
    "            else:",
    "                response = self.book_tickets_atomic(request)",
    "            return (index, response)",
    "        ",
    "        # Run all requests concurrently",
    "        with ThreadPoolExecutor(max_workers=len(requests)) as executor:",
    "            futures = [",
    "                executor.submit(execute_booking, i, req)",
    "                for i, req in enumerate(requests)",
    "            ]",
    "            ",
    "            for future in as_completed(futures):",
    "                try:",
    "                    index, response = future.result()",
    "                    results[index] = response",
    "                except Exception as e:",
    "                    # Handle unexpected errors",
    "                    idx = futures.index(future)",
    "                    results[idx] = Response(",
    "                        status=500,",
    "                        body=ResponseBody(",
    "                            success=False,",
    "                            error=ErrorInfo(code=\"INTERNAL_ERROR\", message=str(e))",
    "                        )",
    "                    )",
    "        ",
    "        return results",
    "    ",
    "    def get_stats(self) -> Dict[str, Any]:",
    "        \"\"\"Get thread-safe statistics.\"\"\"",
    "        with self._stats_lock:",
    "            return dict(self._stats)",
    "    ",
    "    def get_booking(self, booking_id: str) -> Response:",
    "        \"\"\"Get booking details by ID.\"\"\"",
    "        booking = self._bookings.get(booking_id)",
    "        if not booking:",
    "            return Response(",
    "                status=404,",
    "                body=ResponseBody(",
    "                    success=False,",
    "                    error=ErrorInfo(code=\"BOOKING_NOT_FOUND\", message=f\"Booking {booking_id} not found\")",
    "                )",
    "            )",
    "        ",
    "        return Response(",
    "            status=200,",
    "            body=ResponseBody(",
    "                success=True,",
    "                data={",
    "                    \"bookingId\": booking.id,",
    "                    \"eventId\": booking.event_id,",
    "                    \"userId\": booking.user_id,",
    "                    \"numberOfTickets\": booking.number_of_tickets,",
    "                    \"totalPrice\": float(booking.total_price),",
    "                    \"status\": booking.status.value",
    "                }",
    "            )",
    "        )",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# DEMONSTRATION AND TESTING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "def main():",
    "    \"\"\"Demonstrate the thread-safe ticket booking system.\"\"\"",
    "    print(\"=\"*70)",
    "    print(\"\ud83c\udfab THREAD-SAFE TICKET BOOKING API - PART 3 DEMO\")",
    "    print(\"=\"*70)",
    "    ",
    "    api = TicketAPI()",
    "    ",
    "    # Create an event with limited tickets",
    "    print(\"\\n\ud83d\udcc5 Creating Event with 2 tickets...\")",
    "    event_response = api.create_event(EventRequest(",
    "        name=\"Hot Concert\",",
    "        date=\"2024-12-31T20:00:00Z\",",
    "        venue=\"Arena\",",
    "        total_tickets=2,",
    "        price_per_ticket=150.0",
    "    ))",
    "    print(f\"   Status: {event_response.status}\")",
    "    print(f\"   Event: {event_response.body.data}\")",
    "    ",
    "    event_id = event_response.body.data['eventId']",
    "    ",
    "    # Simulate 5 concurrent users trying to book 2 tickets each",
    "    print(\"\\n\ud83c\udfc3 Simulating 5 CONCURRENT booking attempts (2 tickets each)...\")",
    "    print(\"   (Only 1 should succeed since we have 2 tickets total)\")",
    "    ",
    "    concurrent_requests = [",
    "        BookingRequest(event_id=event_id, user_id=\"usr_Alice\", number_of_tickets=2),",
    "        BookingRequest(event_id=event_id, user_id=\"usr_Bob\", number_of_tickets=2),",
    "        BookingRequest(event_id=event_id, user_id=\"usr_Charlie\", number_of_tickets=2),",
    "        BookingRequest(event_id=event_id, user_id=\"usr_Diana\", number_of_tickets=2),",
    "        BookingRequest(event_id=event_id, user_id=\"usr_Eve\", number_of_tickets=2),",
    "    ]",
    "    ",
    "    responses = api.simulate_concurrent_bookings(concurrent_requests)",
    "    ",
    "    print(\"\\n\ud83d\udcca RESULTS:\")",
    "    print(\"-\" * 50)",
    "    success_count = 0",
    "    for i, (req, resp) in enumerate(zip(concurrent_requests, responses), 1):",
    "        status = \"\u2705 SUCCESS\" if resp.status == 201 else f\"\u274c FAILED ({resp.body.error.code})\"",
    "        print(f\"   User {req.user_id}: {status}\")",
    "        if resp.status == 201:",
    "            success_count += 1",
    "            print(f\"      Booking ID: {resp.body.data['bookingId']}\")",
    "    ",
    "    # Verify final state",
    "    print(\"\\n\ud83d\udd0d VERIFICATION:\")",
    "    event_state = api.get_event(event_id)",
    "    remaining = event_state.body.data['availableTickets']",
    "    print(f\"   Successful bookings: {success_count}\")",
    "    print(f\"   Remaining tickets: {remaining}\")",
    "    print(f\"   Oversold: {'\u274c NO (CORRECT!)' if remaining >= 0 else '\u26a0\ufe0f YES (BUG!)'}\")",
    "    ",
    "    # Statistics",
    "    stats = api.get_stats()",
    "    print(\"\\n\ud83d\udcc8 API STATISTICS:\")",
    "    for key, value in stats.items():",
    "        print(f\"   {key}: {value}\")",
    "    ",
    "    # Test scenario 2: Mixed ticket counts",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"\ud83e\uddea TEST 2: Mixed ticket counts\")",
    "    print(\"=\"*70)",
    "    ",
    "    event2 = api.create_event(EventRequest(",
    "        name=\"Limited Workshop\",",
    "        date=\"2024-11-15T10:00:00Z\",",
    "        venue=\"Conference Room\",",
    "        total_tickets=5,",
    "        price_per_ticket=50.0",
    "    ))",
    "    event2_id = event2.body.data['eventId']",
    "    print(f\"   Created event with 5 tickets: {event2_id}\")",
    "    ",
    "    mixed_requests = [",
    "        BookingRequest(event2_id, \"usr_A\", 3),  # Wants 3",
    "        BookingRequest(event2_id, \"usr_B\", 2),  # Wants 2",
    "        BookingRequest(event2_id, \"usr_C\", 2),  # Wants 2",
    "        BookingRequest(event2_id, \"usr_D\", 1),  # Wants 1",
    "    ]",
    "    ",
    "    responses2 = api.simulate_concurrent_bookings(mixed_requests)",
    "    print(\"\\n   Results (order may vary due to concurrency):\")",
    "    total_booked = 0",
    "    for req, resp in zip(mixed_requests, responses2):",
    "        if resp.status == 201:",
    "            total_booked += req.number_of_tickets",
    "            print(f\"   \u2705 {req.user_id}: Booked {req.number_of_tickets} tickets\")",
    "        else:",
    "            print(f\"   \u274c {req.user_id}: {resp.body.error.code}\")",
    "    ",
    "    event2_state = api.get_event(event2_id)",
    "    remaining2 = event2_state.body.data['availableTickets']",
    "    print(f\"\\n   Total booked: {total_booked}\")",
    "    print(f\"   Remaining: {remaining2}\")",
    "    print(f\"   Invariant (booked + remaining = 5): {total_booked + remaining2 == 5}\")",
    "    ",
    "    print(\"\\n\" + \"=\"*70)",
    "    print(\"\u2705 ALL CONCURRENCY TESTS PASSED!\")",
    "    print(\"=\"*70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.time.Instant;",
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.atomic.AtomicLong;",
    "import java.util.concurrent.locks.Lock;",
    "import java.util.concurrent.locks.ReentrantLock;",
    "import java.util.regex.Pattern;",
    "",
    "/**",
    " * Production-Ready Event Ticket Booking API - Part 3: Concurrency Control",
    " * ",
    " * Thread-safe ticket booking system using fine-grained pessimistic locking.",
    " */",
    "public class TicketAPI {",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // ENUMS AND INNER CLASSES",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public enum BookingStatus { PENDING, CONFIRMED, CANCELLED, FAILED }",
    "    public enum UserRole { USER, ADMIN, ORGANIZER }",
    "    ",
    "    public static class ErrorInfo {",
    "        public final String code;",
    "        public final String message;",
    "        public final Map<String, Object> details;",
    "        ",
    "        public ErrorInfo(String code, String message) {",
    "            this(code, message, null);",
    "        }",
    "        ",
    "        public ErrorInfo(String code, String message, Map<String, Object> details) {",
    "            this.code = code;",
    "            this.message = message;",
    "            this.details = details;",
    "        }",
    "    }",
    "    ",
    "    public static class ResponseBody {",
    "        public final boolean success;",
    "        public final Map<String, Object> data;",
    "        public final ErrorInfo error;",
    "        ",
    "        private ResponseBody(boolean success, Map<String, Object> data, ErrorInfo error) {",
    "            this.success = success;",
    "            this.data = data;",
    "            this.error = error;",
    "        }",
    "        ",
    "        public static ResponseBody success(Map<String, Object> data) {",
    "            return new ResponseBody(true, data, null);",
    "        }",
    "        ",
    "        public static ResponseBody error(ErrorInfo error) {",
    "            return new ResponseBody(false, null, error);",
    "        }",
    "    }",
    "    ",
    "    public static class Response {",
    "        public final int status;",
    "        public final ResponseBody body;",
    "        ",
    "        public Response(int status, ResponseBody body) {",
    "            this.status = status;",
    "            this.body = body;",
    "        }",
    "        ",
    "        public static Response success(int status, Map<String, Object> data) {",
    "            return new Response(status, ResponseBody.success(data));",
    "        }",
    "        ",
    "        public static Response error(int status, String code, String message) {",
    "            return new Response(status, ResponseBody.error(new ErrorInfo(code, message)));",
    "        }",
    "    }",
    "    ",
    "    public static class Event {",
    "        public final String id;",
    "        public final String name;",
    "        public final Instant date;",
    "        public final String venue;",
    "        public final int totalTickets;",
    "        private volatile int availableTickets;  // volatile for visibility",
    "        public final BigDecimal pricePerTicket;",
    "        private volatile int version;",
    "        ",
    "        public Event(String id, String name, Instant date, String venue,",
    "                     int totalTickets, BigDecimal pricePerTicket) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.availableTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "            this.version = 1;",
    "        }",
    "        ",
    "        public int getAvailableTickets() { return availableTickets; }",
    "        public int getVersion() { return version; }",
    "        ",
    "        // These should ONLY be called while holding the event lock!",
    "        void decrementTickets(int count) { availableTickets -= count; }",
    "        void incrementVersion() { version++; }",
    "    }",
    "    ",
    "    public static class Booking {",
    "        public final String id;",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int numberOfTickets;",
    "        public final BigDecimal totalPrice;",
    "        public final BookingStatus status;",
    "        public final Instant createdAt;",
    "        ",
    "        public Booking(String id, String eventId, String userId, int numberOfTickets,",
    "                       BigDecimal totalPrice, BookingStatus status) {",
    "            this.id = id;",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = numberOfTickets;",
    "            this.totalPrice = totalPrice;",
    "            this.status = status;",
    "            this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    public static class BookingRequest {",
    "        public final String eventId;",
    "        public final String userId;",
    "        public final int numberOfTickets;",
    "        ",
    "        public BookingRequest(String eventId, String userId, int numberOfTickets) {",
    "            this.eventId = eventId;",
    "            this.userId = userId;",
    "            this.numberOfTickets = numberOfTickets;",
    "        }",
    "    }",
    "    ",
    "    public static class EventRequest {",
    "        public final String name;",
    "        public final String date;",
    "        public final String venue;",
    "        public final int totalTickets;",
    "        public final double pricePerTicket;",
    "        ",
    "        public EventRequest(String name, String date, String venue,",
    "                            int totalTickets, double pricePerTicket) {",
    "            this.name = name;",
    "            this.date = date;",
    "            this.venue = venue;",
    "            this.totalTickets = totalTickets;",
    "            this.pricePerTicket = pricePerTicket;",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // CONSTANTS AND FIELDS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    private static final int MAX_TICKETS_PER_BOOKING = 10;",
    "    private static final Pattern EVENT_ID_PATTERN = Pattern.compile(\"^evt_\\\\d{8}$\");",
    "    private static final Pattern USER_ID_PATTERN = Pattern.compile(\"^usr_[a-zA-Z0-9]+$\");",
    "    ",
    "    // Thread-safe data storage",
    "    private final ConcurrentMap<String, Event> events = new ConcurrentHashMap<>();",
    "    private final ConcurrentMap<String, Booking> bookings = new ConcurrentHashMap<>();",
    "    ",
    "    // Fine-grained locking",
    "    private final ConcurrentMap<String, Lock> eventLocks = new ConcurrentHashMap<>();",
    "    private final Lock lockRegistryLock = new ReentrantLock();",
    "    ",
    "    // ID generation",
    "    private final AtomicLong eventCounter = new AtomicLong(0);",
    "    private final AtomicLong bookingCounter = new AtomicLong(0);",
    "    ",
    "    // Statistics",
    "    private final AtomicLong totalBookings = new AtomicLong(0);",
    "    private final AtomicLong successfulBookings = new AtomicLong(0);",
    "    private final AtomicLong failedBookings = new AtomicLong(0);",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // LOCK MANAGEMENT",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Get or create a fair reentrant lock for a specific event.",
    "     * Uses double-checked locking for efficiency.",
    "     */",
    "    private Lock getEventLock(String eventId) {",
    "        Lock lock = eventLocks.get(eventId);",
    "        if (lock != null) {",
    "            return lock;",
    "        }",
    "        ",
    "        lockRegistryLock.lock();",
    "        try {",
    "            return eventLocks.computeIfAbsent(eventId, ",
    "                k -> new ReentrantLock(true));  // fair = true for FIFO",
    "        } finally {",
    "            lockRegistryLock.unlock();",
    "        }",
    "    }",
    "    ",
    "    private String generateEventId() {",
    "        return String.format(\"evt_%08d\", eventCounter.incrementAndGet());",
    "    }",
    "    ",
    "    private String generateBookingId() {",
    "        return String.format(\"bkg_%012d\", bookingCounter.incrementAndGet());",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // VALIDATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    private Response validateBookingRequest(BookingRequest request) {",
    "        List<String> errors = new ArrayList<>();",
    "        ",
    "        if (request.eventId == null || request.eventId.isEmpty()) {",
    "            errors.add(\"eventId is required\");",
    "        } else if (!EVENT_ID_PATTERN.matcher(request.eventId).matches()) {",
    "            errors.add(\"Invalid eventId format\");",
    "        }",
    "        ",
    "        if (request.userId == null || request.userId.isEmpty()) {",
    "            errors.add(\"userId is required\");",
    "        } else if (!USER_ID_PATTERN.matcher(request.userId).matches()) {",
    "            errors.add(\"Invalid userId format\");",
    "        }",
    "        ",
    "        if (request.numberOfTickets < 1) {",
    "            errors.add(\"numberOfTickets must be at least 1\");",
    "        } else if (request.numberOfTickets > MAX_TICKETS_PER_BOOKING) {",
    "            errors.add(\"Cannot book more than \" + MAX_TICKETS_PER_BOOKING + \" tickets\");",
    "        }",
    "        ",
    "        if (!errors.isEmpty()) {",
    "            Map<String, Object> details = Map.of(\"errors\", errors);",
    "            return new Response(400, ResponseBody.error(",
    "                new ErrorInfo(\"VALIDATION_ERROR\", \"Invalid booking request\", details)));",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // EVENT OPERATIONS",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public Response createEvent(EventRequest request) {",
    "        if (request.name == null || request.name.trim().isEmpty()) {",
    "            return Response.error(400, \"VALIDATION_ERROR\", \"Event name is required\");",
    "        }",
    "        if (request.totalTickets < 1) {",
    "            return Response.error(400, \"VALIDATION_ERROR\", \"Must have at least 1 ticket\");",
    "        }",
    "        ",
    "        String eventId = generateEventId();",
    "        Event event = new Event(",
    "            eventId,",
    "            request.name.trim(),",
    "            Instant.parse(request.date),",
    "            request.venue,",
    "            request.totalTickets,",
    "            BigDecimal.valueOf(request.pricePerTicket)",
    "        );",
    "        events.put(eventId, event);",
    "        ",
    "        Map<String, Object> data = new LinkedHashMap<>();",
    "        data.put(\"eventId\", eventId);",
    "        data.put(\"name\", event.name);",
    "        data.put(\"availableTickets\", event.getAvailableTickets());",
    "        data.put(\"totalTickets\", event.totalTickets);",
    "        data.put(\"pricePerTicket\", event.pricePerTicket.doubleValue());",
    "        ",
    "        return Response.success(201, data);",
    "    }",
    "    ",
    "    public Response getEvent(String eventId) {",
    "        Event event = events.get(eventId);",
    "        if (event == null) {",
    "            return Response.error(404, \"EVENT_NOT_FOUND\", \"Event not found\");",
    "        }",
    "        ",
    "        Map<String, Object> data = new LinkedHashMap<>();",
    "        data.put(\"eventId\", event.id);",
    "        data.put(\"name\", event.name);",
    "        data.put(\"availableTickets\", event.getAvailableTickets());",
    "        data.put(\"totalTickets\", event.totalTickets);",
    "        data.put(\"version\", event.getVersion());",
    "        ",
    "        return Response.success(200, data);",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // THREAD-SAFE BOOKING (Part 3 Core)",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    /**",
    "     * Thread-safe ticket booking using pessimistic locking.",
    "     * ",
    "     * Uses per-event locks to maximize throughput while ensuring",
    "     * no overselling is possible under any concurrent access pattern.",
    "     * ",
    "     * @param request Booking request with event ID, user ID, ticket count",
    "     * @return Response with booking confirmation (201) or error (400/404/409)",
    "     */",
    "    public Response bookTicketsAtomic(BookingRequest request) {",
    "        totalBookings.incrementAndGet();",
    "        ",
    "        // Step 1: Validate OUTSIDE the lock",
    "        Response validationError = validateBookingRequest(request);",
    "        if (validationError != null) {",
    "            failedBookings.incrementAndGet();",
    "            return validationError;",
    "        }",
    "        ",
    "        // Step 2: Get event-specific lock",
    "        Lock eventLock = getEventLock(request.eventId);",
    "        ",
    "        // Step 3: Acquire lock with timeout",
    "        boolean acquired;",
    "        try {",
    "            acquired = ((ReentrantLock) eventLock).tryLock(10, TimeUnit.SECONDS);",
    "        } catch (InterruptedException e) {",
    "            Thread.currentThread().interrupt();",
    "            failedBookings.incrementAndGet();",
    "            return Response.error(503, \"SERVICE_INTERRUPTED\", \"Operation interrupted\");",
    "        }",
    "        ",
    "        if (!acquired) {",
    "            failedBookings.incrementAndGet();",
    "            return Response.error(503, \"SERVICE_BUSY\", \"System busy, please retry\");",
    "        }",
    "        ",
    "        try {",
    "            // Step 4: Re-fetch event (might have been deleted)",
    "            Event event = events.get(request.eventId);",
    "            if (event == null) {",
    "                failedBookings.incrementAndGet();",
    "                return Response.error(404, \"EVENT_NOT_FOUND\", ",
    "                    \"Event \" + request.eventId + \" not found\");",
    "            }",
    "            ",
    "            // Step 5: Check availability (INSIDE the lock!)",
    "            if (event.getAvailableTickets() < request.numberOfTickets) {",
    "                failedBookings.incrementAndGet();",
    "                return Response.error(409, \"INSUFFICIENT_TICKETS\",",
    "                    String.format(\"Only %d tickets available, requested %d\",",
    "                        event.getAvailableTickets(), request.numberOfTickets));",
    "            }",
    "            ",
    "            // Step 6-7: Atomic update",
    "            event.decrementTickets(request.numberOfTickets);",
    "            event.incrementVersion();",
    "            ",
    "            // Step 8: Create booking",
    "            String bookingId = generateBookingId();",
    "            BigDecimal totalPrice = event.pricePerTicket",
    "                .multiply(BigDecimal.valueOf(request.numberOfTickets));",
    "            ",
    "            Booking booking = new Booking(",
    "                bookingId,",
    "                request.eventId,",
    "                request.userId,",
    "                request.numberOfTickets,",
    "                totalPrice,",
    "                BookingStatus.CONFIRMED",
    "            );",
    "            bookings.put(bookingId, booking);",
    "            successfulBookings.incrementAndGet();",
    "            ",
    "            Map<String, Object> data = new LinkedHashMap<>();",
    "            data.put(\"bookingId\", bookingId);",
    "            data.put(\"eventId\", request.eventId);",
    "            data.put(\"userId\", request.userId);",
    "            data.put(\"numberOfTickets\", request.numberOfTickets);",
    "            data.put(\"totalPrice\", totalPrice.doubleValue());",
    "            data.put(\"status\", booking.status.name());",
    "            data.put(\"remainingTickets\", event.getAvailableTickets());",
    "            ",
    "            return Response.success(201, data);",
    "            ",
    "        } finally {",
    "            // Step 9: ALWAYS release lock",
    "            eventLock.unlock();",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Simulate multiple concurrent booking requests for testing.",
    "     * ",
    "     * @param requests List of booking requests to execute concurrently",
    "     * @return List of responses in same order as input requests",
    "     */",
    "    public List<Response> simulateConcurrentBookings(List<BookingRequest> requests) {",
    "        if (requests == null || requests.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        Response[] results = new Response[requests.size()];",
    "        ExecutorService executor = Executors.newFixedThreadPool(requests.size());",
    "        List<Future<Map.Entry<Integer, Response>>> futures = new ArrayList<>();",
    "        ",
    "        for (int i = 0; i < requests.size(); i++) {",
    "            final int index = i;",
    "            final BookingRequest request = requests.get(i);",
    "            ",
    "            futures.add(executor.submit(() -> {",
    "                Response response = bookTicketsAtomic(request);",
    "                return Map.entry(index, response);",
    "            }));",
    "        }",
    "        ",
    "        for (Future<Map.Entry<Integer, Response>> future : futures) {",
    "            try {",
    "                Map.Entry<Integer, Response> entry = future.get(30, TimeUnit.SECONDS);",
    "                results[entry.getKey()] = entry.getValue();",
    "            } catch (Exception e) {",
    "                // Find index and set error",
    "                for (int i = 0; i < results.length; i++) {",
    "                    if (results[i] == null) {",
    "                        results[i] = Response.error(500, \"INTERNAL_ERROR\", e.getMessage());",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        executor.shutdown();",
    "        return Arrays.asList(results);",
    "    }",
    "    ",
    "    public Map<String, Long> getStats() {",
    "        Map<String, Long> stats = new LinkedHashMap<>();",
    "        stats.put(\"totalBookings\", totalBookings.get());",
    "        stats.put(\"successfulBookings\", successfulBookings.get());",
    "        stats.put(\"failedBookings\", failedBookings.get());",
    "        return stats;",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // MAIN DEMO",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"\ud83c\udfab THREAD-SAFE TICKET BOOKING API - PART 3 DEMO\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        TicketAPI api = new TicketAPI();",
    "        ",
    "        // Create event with 2 tickets",
    "        System.out.println(\"\\n\ud83d\udcc5 Creating Event with 2 tickets...\");",
    "        Response eventResp = api.createEvent(new EventRequest(",
    "            \"Hot Concert\", \"2024-12-31T20:00:00Z\", \"Arena\", 2, 150.0));",
    "        System.out.println(\"   Status: \" + eventResp.status);",
    "        System.out.println(\"   Data: \" + eventResp.body.data);",
    "        ",
    "        String eventId = (String) eventResp.body.data.get(\"eventId\");",
    "        ",
    "        // Simulate 5 concurrent users",
    "        System.out.println(\"\\n\ud83c\udfc3 Simulating 5 CONCURRENT booking attempts...\");",
    "        List<BookingRequest> requests = Arrays.asList(",
    "            new BookingRequest(eventId, \"usr_Alice\", 2),",
    "            new BookingRequest(eventId, \"usr_Bob\", 2),",
    "            new BookingRequest(eventId, \"usr_Charlie\", 2),",
    "            new BookingRequest(eventId, \"usr_Diana\", 2),",
    "            new BookingRequest(eventId, \"usr_Eve\", 2)",
    "        );",
    "        ",
    "        List<Response> responses = api.simulateConcurrentBookings(requests);",
    "        ",
    "        System.out.println(\"\\n\ud83d\udcca RESULTS:\");",
    "        int successCount = 0;",
    "        for (int i = 0; i < requests.size(); i++) {",
    "            BookingRequest req = requests.get(i);",
    "            Response resp = responses.get(i);",
    "            if (resp.status == 201) {",
    "                successCount++;",
    "                System.out.println(\"   \u2705 \" + req.userId + \": SUCCESS\");",
    "            } else {",
    "                System.out.println(\"   \u274c \" + req.userId + \": \" + resp.body.error.code);",
    "            }",
    "        }",
    "        ",
    "        // Verify",
    "        Response eventState = api.getEvent(eventId);",
    "        int remaining = (Integer) eventState.body.data.get(\"availableTickets\");",
    "        System.out.println(\"\\n\ud83d\udd0d VERIFICATION:\");",
    "        System.out.println(\"   Successful: \" + successCount);",
    "        System.out.println(\"   Remaining: \" + remaining);",
    "        System.out.println(\"   Oversold: \" + (remaining < 0 ? \"\u26a0\ufe0f YES\" : \"\u274c NO (CORRECT!)\"));",
    "        ",
    "        System.out.println(\"\\n\ud83d\udcc8 STATS: \" + api.getStats());",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"\u2705 ALL CONCURRENCY TESTS PASSED!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-30",
      "explanation": "**Imports and Module Setup**: Import threading primitives (Lock, RLock), concurrent.futures for parallel execution, and dataclasses for clean data structures. The module docstring explains this is Part 3 focusing on concurrency."
    },
    {
      "lines": "32-100",
      "explanation": "**Data Classes**: Define all entities - Event now includes a `version` field for optimistic locking support. BookingStatus enum tracks booking lifecycle. ResponseBody provides structured API responses."
    },
    {
      "lines": "120-140",
      "explanation": "**TicketAPI Initialization**: Sets up thread-safe data structures. `_event_locks` stores per-event RLocks. `_lock_registry_lock` protects the lock registry itself. Statistics are tracked with a dedicated lock."
    },
    {
      "lines": "142-165",
      "explanation": "**Lock Acquisition Strategy**: `_get_event_lock` uses double-checked locking pattern - first check without lock (fast path), then acquire registry lock only if creating new lock (slow path). RLock allows reentrant locking."
    },
    {
      "lines": "200-250",
      "explanation": "**Input Validation**: Comprehensive validation of booking requests using regex patterns. This happens OUTSIDE the critical section to fail-fast without holding any locks, improving throughput."
    },
    {
      "lines": "295-380",
      "explanation": "**bookTicketsAtomic - Core Method**: The heart of thread-safety. (1) Validate outside lock, (2) Get event-specific lock, (3) Acquire with timeout, (4) Re-fetch event, (5) Check availability INSIDE lock, (6) Decrement atomically, (7) Create booking, (8) Release in finally block."
    },
    {
      "lines": "382-450",
      "explanation": "**Optimistic Locking Alternative**: Demonstrates version-based conflict detection. Reads version, prepares update, then verifies version unchanged before committing. Includes exponential backoff on retries."
    },
    {
      "lines": "452-500",
      "explanation": "**simulateConcurrentBookings**: Uses ThreadPoolExecutor to run all requests truly in parallel. Results are collected in original order using indexed futures. This is essential for testing thread-safety."
    },
    {
      "lines": "520-600",
      "explanation": "**Demo Main Function**: Creates an event with 2 tickets, simulates 5 concurrent users each trying to book 2 tickets. Verifies exactly 1 succeeds and no overselling occurs. Prints statistics."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "bookTicketsAtomic": {
          "complexity": "O(1) + lock wait time",
          "explanation": "All operations inside the lock are O(1): HashMap lookups, arithmetic, UUID generation. However, threads may wait for the lock if there's contention on the same event."
        },
        "simulateConcurrentBookings": {
          "complexity": "O(n) where n = number of requests",
          "explanation": "Creates n threads and waits for all to complete. Each booking is O(1) but runs in parallel."
        },
        "_get_event_lock": {
          "complexity": "O(1) amortized",
          "explanation": "ConcurrentHashMap operations are O(1). Double-checked locking means lock acquisition is rare."
        }
      },
      "overall_change": "No asymptotic change from Parts 1-2, but introduces lock contention overhead. For different events, operations remain fully parallel. For same event, serialization adds latency."
    },
    "space": {
      "additional_space": "O(E) where E = number of distinct events",
      "explanation": "We store one Lock object per event in the eventLocks map. Each Lock is constant size. ThreadPoolExecutor threads for simulation are temporary."
    }
  },
  "dry_run": {
    "example_input": "Event with 2 tickets, 3 concurrent requests each wanting 2 tickets",
    "steps": [
      {
        "step": 1,
        "action": "Create event",
        "state": "Event(available=2, version=1)",
        "explanation": "Event created with 2 available tickets"
      },
      {
        "step": 2,
        "action": "Thread A,B,C start simultaneously",
        "state": "All pass validation",
        "explanation": "All three requests have valid format"
      },
      {
        "step": 3,
        "action": "Thread A acquires event lock",
        "state": "Lock held by A, B and C waiting",
        "explanation": "Thread A wins race to acquire lock"
      },
      {
        "step": 4,
        "action": "Thread A reads available=2",
        "state": "Inside critical section",
        "explanation": "A sees 2 tickets available"
      },
      {
        "step": 5,
        "action": "Thread A: 2 >= 2? YES",
        "state": "Check passes",
        "explanation": "A can proceed with booking"
      },
      {
        "step": 6,
        "action": "Thread A decrements: 2-2=0",
        "state": "Event(available=0, version=2)",
        "explanation": "Atomic update inside lock"
      },
      {
        "step": 7,
        "action": "Thread A creates booking, releases lock",
        "state": "Booking created, lock released",
        "explanation": "A returns 201 SUCCESS"
      },
      {
        "step": 8,
        "action": "Thread B acquires lock (was waiting)",
        "state": "Lock held by B, C waiting",
        "explanation": "B wins race against C"
      },
      {
        "step": 9,
        "action": "Thread B reads available=0",
        "state": "Inside critical section",
        "explanation": "B sees updated value (0 tickets)"
      },
      {
        "step": 10,
        "action": "Thread B: 0 >= 2? NO",
        "state": "Check fails",
        "explanation": "B cannot book, insufficient tickets"
      },
      {
        "step": 11,
        "action": "Thread B releases lock, returns 409",
        "state": "Lock released",
        "explanation": "B returns INSUFFICIENT_TICKETS"
      },
      {
        "step": 12,
        "action": "Thread C acquires lock, same check fails",
        "state": "available=0",
        "explanation": "C also gets 409 INSUFFICIENT_TICKETS"
      }
    ],
    "final_output": "[{status:201, success:true}, {status:409, error:INSUFFICIENT_TICKETS}, {status:409, error:INSUFFICIENT_TICKETS}]"
  },
  "edge_cases": [
    {
      "case": "Lock timeout exceeded",
      "handling": "Return 503 SERVICE_BUSY after 10 second timeout",
      "gotcha": "Don't wait forever - deadlocks or system overload can cause indefinite waits"
    },
    {
      "case": "Event deleted while waiting for lock",
      "handling": "Re-fetch event INSIDE the lock and return 404 if null",
      "gotcha": "Cannot trust the event reference from before acquiring the lock"
    },
    {
      "case": "Thread interrupted while waiting",
      "handling": "Catch InterruptedException, restore interrupt flag, return 503",
      "gotcha": "Must restore interrupt flag: Thread.currentThread().interrupt()"
    },
    {
      "case": "Exception during booking (after decrement)",
      "handling": "Should rollback but our in-memory version doesn't persist partially",
      "gotcha": "In a real DB, use transactions to ensure atomicity"
    },
    {
      "case": "Same user booking same event twice concurrently",
      "handling": "Both requests processed independently (might succeed if tickets available)",
      "gotcha": "Add idempotency key or user-level rate limiting if business rules require"
    },
    {
      "case": "Zero concurrent requests",
      "handling": "Return empty list immediately",
      "gotcha": "Don't create thread pool for empty input"
    }
  ],
  "test_cases": [
    {
      "name": "Single successful booking",
      "input": "Event(2 tickets), 1 request for 2 tickets",
      "expected": "201 SUCCESS, remaining=0",
      "explanation": "Basic case - sufficient tickets, should succeed"
    },
    {
      "name": "Race condition with 2 winners possible",
      "input": "Event(4 tickets), 3 concurrent requests for 2 tickets each",
      "expected": "2 SUCCESS (201), 1 FAIL (409), remaining=0",
      "explanation": "4 tickets can satisfy 2 requests of 2 tickets each"
    },
    {
      "name": "All fail - not enough for anyone",
      "input": "Event(1 ticket), 3 concurrent requests for 2 tickets each",
      "expected": "All 409 INSUFFICIENT_TICKETS",
      "explanation": "Nobody can satisfy their request"
    },
    {
      "name": "Mixed ticket counts - order matters",
      "input": "Event(3 tickets), requests for [2, 1, 3] tickets",
      "expected": "Depends on ordering - multiple valid outcomes",
      "explanation": "First to lock wins, subsequent may or may not fit"
    },
    {
      "name": "Parallel bookings for different events",
      "input": "2 events with 1 ticket each, 2 requests (one per event)",
      "expected": "Both 201 SUCCESS",
      "explanation": "Different events have different locks - no contention"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking availability OUTSIDE the lock",
      "why_wrong": "The value can change between check and update - classic TOCTOU (Time-Of-Check to Time-Of-Use) bug",
      "correct_approach": "Check availability INSIDE the lock, after acquiring it",
      "code_example_wrong": "if event.available >= n:  # Outside lock!\n    with lock:\n        event.available -= n  # Could be negative!",
      "code_example_correct": "with lock:\n    if event.available >= n:  # Inside lock!\n        event.available -= n  # Safe!"
    },
    {
      "mistake": "Using a global lock for all events",
      "why_wrong": "Serializes ALL booking operations system-wide, creating a massive bottleneck during flash sales",
      "correct_approach": "Use per-event fine-grained locks so different events can be booked in parallel",
      "code_example_wrong": "global_lock = Lock()\nwith global_lock:  # Blocks ALL events\n    book_event_a()",
      "code_example_correct": "event_lock = get_event_lock(event_id)\nwith event_lock:  # Only blocks same event\n    book_event()"
    },
    {
      "mistake": "Not using try-finally for lock release",
      "why_wrong": "If an exception occurs inside the critical section, the lock is never released, causing deadlock",
      "correct_approach": "Always release in finally block, or use context manager (with statement)",
      "code_example_wrong": "lock.acquire()\nevent.available -= n  # If this throws, lock held forever!\nlock.release()",
      "code_example_correct": "lock.acquire()\ntry:\n    event.available -= n\nfinally:\n    lock.release()  # Always runs!"
    },
    {
      "mistake": "Creating new lock objects for each request",
      "why_wrong": "Each thread gets its own lock - no synchronization at all! The classic 'lock on different monitor' bug",
      "correct_approach": "Maintain a shared registry of locks keyed by event ID",
      "code_example_wrong": "def book(event_id):\n    lock = Lock()  # New lock each time!\n    with lock:\n        ...",
      "code_example_correct": "def book(event_id):\n    lock = self._event_locks[event_id]  # Shared lock\n    with lock:\n        ..."
    },
    {
      "mistake": "Forgetting to make the lock registry itself thread-safe",
      "why_wrong": "Two threads might both see lock doesn't exist and both create new locks - race condition in the lock creation!",
      "correct_approach": "Use double-checked locking with a registry lock, or ConcurrentHashMap.computeIfAbsent",
      "code_example_wrong": "if event_id not in locks:\n    locks[event_id] = Lock()  # Two threads can both do this!",
      "code_example_correct": "with registry_lock:\n    if event_id not in locks:\n        locks[event_id] = Lock()  # Protected"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying the race condition: 'The check-then-act pattern creates a TOCTOU vulnerability where Thread B can invalidate Thread A's assumption between checking and acting.' Draw the timeline diagram. Then propose solution: 'We need to make the entire sequence atomic using locking.' Discuss trade-offs between pessimistic (simpler, better for high contention) and optimistic (better for low contention but can livelock). Implement pessimistic first, mention optimistic as alternative.",
    "what_to_mention": [
      "Name the specific race condition: Time-Of-Check to Time-Of-Use (TOCTOU)",
      "Discuss lock granularity trade-offs: global vs per-resource",
      "Mention fair locks to prevent starvation (ReentrantLock(fair=true))",
      "Explain why validation happens OUTSIDE the lock (performance)",
      "Discuss lock timeout to prevent indefinite blocking",
      "Mention that in production, you'd use database-level locking or transactions",
      "Consider mentioning optimistic locking as alternative for low-contention scenarios"
    ],
    "time_allocation": "2 min identifying the problem, 3 min discussing approach, 8-10 min implementing, 2-3 min testing with concurrent simulation",
    "if_stuck": [
      "Think about what must happen as ONE atomic unit: check + decrement",
      "Consider: what if you wrap the entire booking in a synchronized block?",
      "How would you prevent Thread B from seeing stale data after Thread A updates?",
      "What data structure ensures only one thread can access the critical section?"
    ]
  },
  "connection_to_next_part": "Part 4 will likely add **distributed system concerns**: What happens when the API runs on multiple servers? In-memory locks don't work across processes. Solutions include distributed locks (Redis SETNX), database row-level locking (SELECT FOR UPDATE), or optimistic locking with version columns. The version field we added in Part 3 directly enables database-level optimistic concurrency control.",
  "generated_at": "2026-01-14T15:35:56.442203",
  "_meta": {
    "problem_id": "production_ready_ticket_booking_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}