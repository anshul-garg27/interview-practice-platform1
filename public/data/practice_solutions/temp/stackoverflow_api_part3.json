{
  "problem_title": "Stack Overflow API Design - Part 3: Search and Filtering",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 introduces **search and filtering capabilities** on top of the existing Q&A platform. While Parts 1-2 focused on CRUD operations and voting, Part 3 requires building an efficient search infrastructure with full-text search, tag-based filtering, and multi-criteria sorting. This fundamentally changes how we store data - we need to maintain additional index structures for fast retrieval.",
    "new_requirements": [
      "Full-text search across question titles and bodies with case-insensitive partial matching",
      "Tag-based filtering with AND/OR boolean logic",
      "Retrieve top questions by score",
      "Retrieve recent questions by creation time",
      "Find all unanswered questions",
      "Results sorted by relevance (match count) for text search"
    ],
    "new_constraints": [
      "Partial word matching required: 'java' must match 'JavaScript'",
      "Case-insensitive matching",
      "Relevance scoring based on number of query word matches",
      "Efficient search even with large question corpus"
    ],
    "key_insight": "The crucial insight is **pre-building inverted indexes at insert time**. Instead of scanning all questions for each search (O(N) per query), we maintain word\u2192questions and tag\u2192questions mappings. This trades O(W) insert overhead for O(1) word lookup during search. For partial matching, we still need to scan indexed words, but this is typically much smaller than scanning all question content."
  },
  "visual_explanation": {
    "before_after": "```\n    BEFORE (Naive Search - O(N) per query)\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    Questions Storage:\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 questions = {                           \u2502\n    \u2502   q_1: {title: \"Java Help\", body: ...}  \u2502\n    \u2502   q_2: {title: \"Python Tips\", ...}      \u2502\n    \u2502   q_3: {title: \"JavaScript Guide\", ...} \u2502\n    \u2502   ...                                   \u2502\n    \u2502   q_N: {...}                            \u2502\n    \u2502 }                                       \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    Search \"java\" \u2192 Scan ALL N questions \ud83d\ude30\n    \n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    AFTER (Inverted Index - O(1) lookup per word)\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502        Inverted Index (word_index)          \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 \"java\"       \u2192 {q_1, q_5, q_12}            \u2502\n    \u2502 \"javascript\" \u2192 {q_3, q_7}                  \u2502\n    \u2502 \"python\"     \u2192 {q_2, q_8, q_9}             \u2502\n    \u2502 \"help\"       \u2192 {q_1, q_2, q_3}             \u2502\n    \u2502 \"guide\"      \u2192 {q_3, q_10}                 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502          Tag Index (tag_index)              \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502 \"java\"    \u2192 {q_1, q_5, q_12}               \u2502\n    \u2502 \"python\"  \u2192 {q_2, q_8}                     \u2502\n    \u2502 \"spring\"  \u2192 {q_1, q_7}                     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    Search \"java\" \u2192 Direct lookup O(1) \u2192 {q_1, q_5, q_12} \u2728\n```",
    "algorithm_flow": "```\n    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551           searchQuestions(\"java spring\") Flow              \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n    Step 1: TOKENIZE QUERY\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 \"java spring\" \u2192 [\"java\", \"spring\"]\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\n    Step 2: FIND PARTIAL MATCHES FOR EACH WORD\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Query word: \"java\"                                         \u2502\n    \u2502                                                            \u2502\n    \u2502   Check indexed words:                                     \u2502\n    \u2502   \u251c\u2500 \"java\" contains \"java\"? \u2713 \u2192 questions: {q_1, q_5}     \u2502\n    \u2502   \u251c\u2500 \"javascript\" contains \"java\"? \u2713 \u2192 questions: {q_3}   \u2502\n    \u2502   \u2514\u2500 \"python\" contains \"java\"? \u2717                          \u2502\n    \u2502                                                            \u2502\n    \u2502   Matches for \"java\": {q_1, q_3, q_5}                      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Query word: \"spring\"                                       \u2502\n    \u2502                                                            \u2502\n    \u2502   \"spring\" contains \"spring\"? \u2713 \u2192 questions: {q_1, q_7}   \u2502\n    \u2502   \"springframework\" contains \"spring\"? \u2713 \u2192 {q_10}        \u2502\n    \u2502                                                            \u2502\n    \u2502   Matches for \"spring\": {q_1, q_7, q_10}                   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\n    Step 3: COUNT MATCHES FOR RELEVANCE\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  match_counts = {                                          \u2502\n    \u2502    q_1: 2    \u2190 matched both \"java\" and \"spring\"           \u2502\n    \u2502    q_3: 1    \u2190 matched \"java\" only                        \u2502\n    \u2502    q_5: 1    \u2190 matched \"java\" only                        \u2502\n    \u2502    q_7: 1    \u2190 matched \"spring\" only                      \u2502\n    \u2502    q_10: 1   \u2190 matched \"spring\" only                      \u2502\n    \u2502  }                                                         \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\n    Step 4: SORT BY RELEVANCE (match count DESC)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  Result: [q_1(2 matches), q_3(1), q_5(1), q_7(1), q_10(1)] \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551      searchByTags([\"java\", \"spring\"], matchAll=true)       \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 tag_index[\"java\"]   = {q_1, q_2}    \u2502\n    \u2502 tag_index[\"spring\"] = {q_1, q_3}    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n         matchAll = true (AND logic)\n                    \u2502\n                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Intersection: {q_1, q_2} \u2229 {q_1, q_3}\n    \u2502             = {q_1}                 \u2502\n    \u2502                                     \u2502\n    \u2502 Only q_1 has BOTH java AND spring  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n    \n    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n    \u2551      searchByTags([\"java\", \"spring\"], matchAll=false)      \u2551\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 tag_index[\"java\"]   = {q_1, q_2}    \u2502\n    \u2502 tag_index[\"spring\"] = {q_1, q_3}    \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n         matchAll = false (OR logic)\n                    \u2502\n                    \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Union: {q_1, q_2} \u222a {q_1, q_3}      \u2502\n    \u2502      = {q_1, q_2, q_3}              \u2502\n    \u2502                                     \u2502\n    \u2502 Questions with java OR spring      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension (Linear Scan)",
      "description": "Simply iterate through all questions for each search operation, checking title/body/tags directly. No pre-built indexes.",
      "time_complexity": "O(N \u00d7 L) per search, where N = questions, L = avg content length",
      "space_complexity": "O(1) additional space",
      "why_not_optimal": "With 10M questions and frequent searches, this approach becomes prohibitively slow. Each search requires scanning entire corpus. Production systems like Stack Overflow handle millions of searches daily - linear scan simply doesn't scale."
    },
    {
      "name": "Optimal Approach (Inverted Index)",
      "description": "Build inverted indexes at insert time: word\u2192questions and tag\u2192questions mappings. Use set operations (intersection/union) for boolean logic. Sort results by relevance score.",
      "time_complexity": "O(W \u00d7 M) for search, where W = query words, M = avg matches per word. Insert is O(content_length) for indexing.",
      "space_complexity": "O(total_words) for inverted index storage",
      "key_insight": "Trade insert-time overhead for query-time performance. Pre-compute indexes so that common operations (search by word, filter by tag) become O(1) lookups. Partial matching requires scanning indexed words but this is bounded by vocabulary size, not document count."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## The Inverted Index Strategy\n\n### Core Data Structures\n\n1. **Word Index** (`Dict[str, Set[str]]`): Maps each word to the set of question IDs containing that word. Built from tokenizing titles and bodies.\n\n2. **Tag Index** (`Dict[str, Set[str]]`): Maps each tag to question IDs. Direct mapping from question tags.\n\n### Key Design Decisions\n\n**1. Tokenization Strategy**\n- Use regex `\\w+` to extract alphanumeric words\n- Lowercase everything for case-insensitive matching\n- Index on insert, not on query\n\n**2. Partial Matching Trade-off**\n- For true partial matching ('java' in 'JavaScript'), we must scan indexed words\n- This is acceptable because vocabulary size << document count\n- Alternative: Use trie structure for O(prefix_length) lookup\n\n**3. Relevance Scoring**\n- Count how many query words each question matches\n- More matches = higher relevance\n- Tie-breaker: question ID for deterministic ordering\n\n**4. Set Operations for Tags**\n- AND logic: Set intersection `&=`\n- OR logic: Set union `|=`\n- Both are O(min(set_sizes)) operations\n\n### Algorithm Pseudocode\n\n```\nsearchQuestions(query):\n    words = tokenize(query)\n    match_counts = {}\n    \n    for query_word in words:\n        for indexed_word in word_index:\n            if query_word in indexed_word:  # partial match\n                for question_id in word_index[indexed_word]:\n                    match_counts[question_id]++\n    \n    return sort_by_match_count_descending(match_counts)\n```\n\n### Why This Works at Scale\n\n| Aspect | Naive | Inverted Index |\n|--------|-------|----------------|\n| Search | O(N\u00d7L) | O(W\u00d7M) |\n| Insert | O(1) | O(L) |\n| Memory | O(N\u00d7L) | O(N\u00d7L) |\n| Scalability | Poor | Excellent |\n\nFor Stack Overflow with 23M+ questions, the inverted index approach is **essential**.",
    "data_structures": [
      {
        "structure": "Dict[str, Set[str]] (word_index)",
        "purpose": "Maps each word to question IDs containing it - enables O(1) word lookup"
      },
      {
        "structure": "Dict[str, Set[str]] (tag_index)",
        "purpose": "Maps each tag to question IDs - enables O(1) tag filtering"
      },
      {
        "structure": "defaultdict",
        "purpose": "Auto-initializes empty sets for new words/tags"
      },
      {
        "structure": "Set operations",
        "purpose": "Intersection for AND, Union for OR - both O(min(sizes))"
      }
    ],
    "algorithm_steps": [
      "Step 1: On question insert, tokenize title+body into lowercase words",
      "Step 2: Add question ID to word_index[word] for each word",
      "Step 3: Add question ID to tag_index[tag] for each tag",
      "Step 4: For searchQuestions: tokenize query, find partial matches in indexed words, count matches per question, sort by count",
      "Step 5: For searchByTags: get question sets for each tag, apply set intersection (AND) or union (OR)",
      "Step 6: For getTopQuestions/getRecentQuestions: sort by score/date, return top N",
      "Step 7: For getUnansweredQuestions: filter questions with empty answers dict"
    ]
  },
  "solution_python_lines": [
    "from typing import Dict, List, Set, Optional",
    "from datetime import datetime",
    "from collections import defaultdict",
    "import re",
    "",
    "",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.\"\"\"",
    "    ",
    "    def __init__(self, user_id: str, display_name: str):",
    "        self.id = user_id",
    "        self.display_name = display_name",
    "        self.reputation = 0",
    "        self.created_at = datetime.now()",
    "",
    "",
    "class Question:",
    "    \"\"\"Represents a question with title, body, tags, and vote tracking.\"\"\"",
    "    ",
    "    def __init__(self, question_id: str, author_id: str, title: str, ",
    "                 body: str, tags: List[str]):",
    "        self.id = question_id",
    "        self.author_id = author_id",
    "        self.title = title",
    "        self.body = body",
    "        self.tags = tags",
    "        self.score = 0",
    "        self.created_at = datetime.now()",
    "        self.answers: Dict[str, 'Answer'] = {}",
    "        self.votes: Dict[str, int] = {}  # user_id -> vote value (+1/-1)",
    "",
    "",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.\"\"\"",
    "    ",
    "    def __init__(self, answer_id: str, question_id: str, ",
    "                 author_id: str, body: str):",
    "        self.id = answer_id",
    "        self.question_id = question_id",
    "        self.author_id = author_id",
    "        self.body = body",
    "        self.score = 0",
    "        self.created_at = datetime.now()",
    "        self.votes: Dict[str, int] = {}",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class for Stack Overflow platform.",
    "    Implements user management, Q&A, voting, and search functionality.",
    "    \"\"\"",
    "    ",
    "    # Vote constants",
    "    UPVOTE = 1",
    "    DOWNVOTE = -1",
    "    ",
    "    # Reputation changes",
    "    REP_UPVOTE = 10",
    "    REP_DOWNVOTE = -2",
    "    ",
    "    def __init__(self):",
    "        \"\"\"Initialize the Stack Overflow platform with empty storage.\"\"\"",
    "        # Core storage",
    "        self.users: Dict[str, User] = {}",
    "        self.questions: Dict[str, Question] = {}",
    "        self.answers: Dict[str, Answer] = {}",
    "        ",
    "        # Auto-increment counters for ID generation",
    "        self._question_counter = 0",
    "        self._answer_counter = 0",
    "        ",
    "        # Search indexes (Part 3 additions)",
    "        self._word_index: Dict[str, Set[str]] = defaultdict(set)",
    "        self._tag_index: Dict[str, Set[str]] = defaultdict(set)",
    "    ",
    "    # ==================== Helper Methods ====================",
    "    ",
    "    def _tokenize(self, text: str) -> List[str]:",
    "        \"\"\"",
    "        Tokenize text into lowercase words.",
    "        Uses regex to extract alphanumeric sequences.",
    "        ",
    "        Args:",
    "            text: Input text to tokenize",
    "            ",
    "        Returns:",
    "            List of lowercase words",
    "        \"\"\"",
    "        if not text:",
    "            return []",
    "        return re.findall(r'\\w+', text.lower())",
    "    ",
    "    def _index_question(self, question: Question) -> None:",
    "        \"\"\"",
    "        Add question to search indexes.",
    "        Called during question creation for O(1) search later.",
    "        ",
    "        Args:",
    "            question: The question to index",
    "        \"\"\"",
    "        # Index all words from title and body",
    "        all_words = self._tokenize(question.title) + self._tokenize(question.body)",
    "        for word in all_words:",
    "            self._word_index[word].add(question.id)",
    "        ",
    "        # Index by tags (normalized to lowercase)",
    "        for tag in question.tags:",
    "            self._tag_index[tag.lower()].add(question.id)",
    "    ",
    "    # ==================== Part 1: User Management ====================",
    "    ",
    "    def create_user(self, user_id: str, display_name: str) -> User:",
    "        \"\"\"",
    "        Create a new user.",
    "        ",
    "        Args:",
    "            user_id: Unique identifier for the user",
    "            display_name: User's display name",
    "            ",
    "        Returns:",
    "            Created User object",
    "            ",
    "        Raises:",
    "            ValueError: If user_id already exists",
    "        \"\"\"",
    "        if user_id in self.users:",
    "            raise ValueError(f\"User {user_id} already exists\")",
    "        ",
    "        user = User(user_id, display_name)",
    "        self.users[user_id] = user",
    "        return user",
    "    ",
    "    def get_user(self, user_id: str) -> Optional[User]:",
    "        \"\"\"Get user by ID, returns None if not found.\"\"\"",
    "        return self.users.get(user_id)",
    "    ",
    "    # ==================== Part 1: Question Management ====================",
    "    ",
    "    def post_question(self, user_id: str, title: str, body: str, ",
    "                      tags: List[str]) -> Question:",
    "        \"\"\"",
    "        Post a new question.",
    "        ",
    "        Args:",
    "            user_id: ID of the user posting the question",
    "            title: Question title",
    "            body: Question body content",
    "            tags: List of tags for the question",
    "            ",
    "        Returns:",
    "            Created Question object with auto-generated ID (q_1, q_2, ...)",
    "            ",
    "        Raises:",
    "            ValueError: If user not found",
    "        \"\"\"",
    "        if user_id not in self.users:",
    "            raise ValueError(f\"User {user_id} not found\")",
    "        ",
    "        self._question_counter += 1",
    "        question_id = f\"q_{self._question_counter}\"",
    "        ",
    "        question = Question(question_id, user_id, title, body, tags)",
    "        self.questions[question_id] = question",
    "        ",
    "        # Index for search (Part 3)",
    "        self._index_question(question)",
    "        ",
    "        return question",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"Get question by ID.\"\"\"",
    "        return self.questions.get(question_id)",
    "    ",
    "    # ==================== Part 1: Answer Management ====================",
    "    ",
    "    def post_answer(self, user_id: str, question_id: str, body: str) -> Answer:",
    "        \"\"\"",
    "        Post an answer to a question.",
    "        ",
    "        Args:",
    "            user_id: ID of user posting the answer",
    "            question_id: ID of question being answered",
    "            body: Answer content",
    "            ",
    "        Returns:",
    "            Created Answer object",
    "            ",
    "        Raises:",
    "            ValueError: If user or question not found",
    "        \"\"\"",
    "        if user_id not in self.users:",
    "            raise ValueError(f\"User {user_id} not found\")",
    "        if question_id not in self.questions:",
    "            raise ValueError(f\"Question {question_id} not found\")",
    "        ",
    "        self._answer_counter += 1",
    "        answer_id = f\"a_{self._answer_counter}\"",
    "        ",
    "        answer = Answer(answer_id, question_id, user_id, body)",
    "        self.answers[answer_id] = answer",
    "        self.questions[question_id].answers[answer_id] = answer",
    "        ",
    "        return answer",
    "    ",
    "    # ==================== Part 2: Voting System ====================",
    "    ",
    "    def vote_question(self, user_id: str, question_id: str, ",
    "                      is_upvote: bool) -> int:",
    "        \"\"\"",
    "        Vote on a question. Updates score and author reputation.",
    "        ",
    "        Args:",
    "            user_id: ID of user voting",
    "            question_id: ID of question being voted on",
    "            is_upvote: True for upvote (+1), False for downvote (-1)",
    "            ",
    "        Returns:",
    "            New score of the question",
    "        \"\"\"",
    "        if user_id not in self.users:",
    "            raise ValueError(f\"User {user_id} not found\")",
    "        if question_id not in self.questions:",
    "            raise ValueError(f\"Question {question_id} not found\")",
    "        ",
    "        question = self.questions[question_id]",
    "        vote_value = self.UPVOTE if is_upvote else self.DOWNVOTE",
    "        ",
    "        # Handle vote change (remove old vote if exists)",
    "        if user_id in question.votes:",
    "            old_vote = question.votes[user_id]",
    "            question.score -= old_vote",
    "            # Reverse reputation change",
    "            old_rep = self.REP_UPVOTE if old_vote > 0 else self.REP_DOWNVOTE",
    "            self.users[question.author_id].reputation -= old_rep",
    "        ",
    "        # Apply new vote",
    "        question.votes[user_id] = vote_value",
    "        question.score += vote_value",
    "        ",
    "        # Update author reputation",
    "        rep_change = self.REP_UPVOTE if is_upvote else self.REP_DOWNVOTE",
    "        self.users[question.author_id].reputation += rep_change",
    "        ",
    "        return question.score",
    "    ",
    "    def vote_answer(self, user_id: str, answer_id: str, ",
    "                    is_upvote: bool) -> int:",
    "        \"\"\"Vote on an answer. Updates score and author reputation.\"\"\"",
    "        if user_id not in self.users:",
    "            raise ValueError(f\"User {user_id} not found\")",
    "        if answer_id not in self.answers:",
    "            raise ValueError(f\"Answer {answer_id} not found\")",
    "        ",
    "        answer = self.answers[answer_id]",
    "        vote_value = self.UPVOTE if is_upvote else self.DOWNVOTE",
    "        ",
    "        if user_id in answer.votes:",
    "            old_vote = answer.votes[user_id]",
    "            answer.score -= old_vote",
    "            old_rep = self.REP_UPVOTE if old_vote > 0 else self.REP_DOWNVOTE",
    "            self.users[answer.author_id].reputation -= old_rep",
    "        ",
    "        answer.votes[user_id] = vote_value",
    "        answer.score += vote_value",
    "        ",
    "        rep_change = self.REP_UPVOTE if is_upvote else self.REP_DOWNVOTE",
    "        self.users[answer.author_id].reputation += rep_change",
    "        ",
    "        return answer.score",
    "    ",
    "    # ==================== Part 3: Search and Filtering ====================",
    "    ",
    "    def search_questions(self, query: str) -> List[Question]:",
    "        \"\"\"",
    "        Search questions by text query.",
    "        ",
    "        Behavior:",
    "        - Case-insensitive matching",
    "        - Partial word matching ('java' matches 'JavaScript')",
    "        - Results sorted by relevance (number of query words matched)",
    "        ",
    "        Args:",
    "            query: Space-separated search keywords",
    "            ",
    "        Returns:",
    "            List of matching questions sorted by relevance (most relevant first)",
    "        \"\"\"",
    "        if not query or not query.strip():",
    "            return []",
    "        ",
    "        query_words = self._tokenize(query)",
    "        if not query_words:",
    "            return []",
    "        ",
    "        # Count matches per question for relevance scoring",
    "        match_counts: Dict[str, int] = defaultdict(int)",
    "        ",
    "        for query_word in query_words:",
    "            # Check all indexed words for partial matches",
    "            for indexed_word, question_ids in self._word_index.items():",
    "                if query_word in indexed_word:  # Partial match check",
    "                    for qid in question_ids:",
    "                        match_counts[qid] += 1",
    "        ",
    "        if not match_counts:",
    "            return []",
    "        ",
    "        # Sort by relevance (match count DESC), then by ID for stability",
    "        sorted_question_ids = sorted(",
    "            match_counts.keys(),",
    "            key=lambda qid: (-match_counts[qid], qid)",
    "        )",
    "        ",
    "        return [self.questions[qid] for qid in sorted_question_ids]",
    "    ",
    "    def search_by_tags(self, tags: List[str], match_all: bool) -> List[Question]:",
    "        \"\"\"",
    "        Search questions by tags with AND/OR logic.",
    "        ",
    "        Args:",
    "            tags: List of tags to filter by",
    "            match_all: True for AND logic (all tags required),",
    "                       False for OR logic (any tag matches)",
    "                       ",
    "        Returns:",
    "            List of matching questions sorted by score (highest first)",
    "        \"\"\"",
    "        if not tags:",
    "            return []",
    "        ",
    "        # Normalize tags to lowercase",
    "        normalized_tags = [tag.lower() for tag in tags]",
    "        ",
    "        result_ids: Optional[Set[str]] = None",
    "        ",
    "        for tag in normalized_tags:",
    "            tag_questions = self._tag_index.get(tag, set())",
    "            ",
    "            if result_ids is None:",
    "                # First tag - initialize result set",
    "                result_ids = set(tag_questions)",
    "            elif match_all:",
    "                # AND logic: keep only questions with this tag too",
    "                result_ids &= tag_questions",
    "            else:",
    "                # OR logic: add questions with this tag",
    "                result_ids |= tag_questions",
    "        ",
    "        if not result_ids:",
    "            return []",
    "        ",
    "        # Sort by score (descending), then by ID for consistency",
    "        sorted_ids = sorted(",
    "            result_ids,",
    "            key=lambda qid: (-self.questions[qid].score, qid)",
    "        )",
    "        ",
    "        return [self.questions[qid] for qid in sorted_ids]",
    "    ",
    "    def get_top_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"",
    "        Get top questions sorted by score (highest first).",
    "        ",
    "        Args:",
    "            limit: Maximum number of questions to return",
    "            ",
    "        Returns:",
    "            List of top-scoring questions (up to limit)",
    "        \"\"\"",
    "        if limit <= 0:",
    "            return []",
    "        ",
    "        sorted_questions = sorted(",
    "            self.questions.values(),",
    "            key=lambda q: (-q.score, q.id)",
    "        )",
    "        ",
    "        return sorted_questions[:limit]",
    "    ",
    "    def get_recent_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"",
    "        Get most recent questions (newest first).",
    "        ",
    "        Args:",
    "            limit: Maximum number of questions to return",
    "            ",
    "        Returns:",
    "            List of most recent questions (up to limit)",
    "        \"\"\"",
    "        if limit <= 0:",
    "            return []",
    "        ",
    "        sorted_questions = sorted(",
    "            self.questions.values(),",
    "            key=lambda q: (-q.created_at.timestamp(), q.id)",
    "        )",
    "        ",
    "        return sorted_questions[:limit]",
    "    ",
    "    def get_unanswered_questions(self) -> List[Question]:",
    "        \"\"\"",
    "        Get all questions with no answers.",
    "        ",
    "        Returns:",
    "            List of unanswered questions sorted by age (oldest first)",
    "        \"\"\"",
    "        unanswered = [",
    "            q for q in self.questions.values()",
    "            if len(q.answers) == 0",
    "        ]",
    "        ",
    "        # Sort by creation time (oldest first - they need attention!)",
    "        return sorted(unanswered, key=lambda q: (q.created_at, q.id))",
    "",
    "",
    "# ==================== Demo / Main ====================",
    "",
    "def main():",
    "    \"\"\"Demonstrate Part 3: Search and Filtering functionality.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Stack Overflow API - Part 3: Search and Filtering Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Initialize platform",
    "    so = StackOverflow()",
    "    ",
    "    # Create users",
    "    alice = so.create_user(\"u1\", \"alice\")",
    "    bob = so.create_user(\"u2\", \"bob\")",
    "    print(f\"\\n\u2713 Created users: {alice.display_name}, {bob.display_name}\")",
    "    ",
    "    # Post questions with various tags",
    "    q1 = so.post_question(",
    "        \"u1\", ",
    "        \"Java Spring Boot Tutorial\",",
    "        \"How to create a REST API with Spring Boot and Java\",",
    "        [\"java\", \"spring\", \"rest\"]",
    "    )",
    "    ",
    "    q2 = so.post_question(",
    "        \"u1\",",
    "        \"Python List Comprehension Help\",",
    "        \"Need help understanding Python list comprehension syntax\",",
    "        [\"python\", \"syntax\"]",
    "    )",
    "    ",
    "    q3 = so.post_question(",
    "        \"u2\",",
    "        \"JavaScript Async Await\",",
    "        \"Understanding async/await patterns in JavaScript\",",
    "        [\"javascript\", \"async\"]",
    "    )",
    "    ",
    "    q4 = so.post_question(",
    "        \"u2\",",
    "        \"Java Hibernate ORM\",",
    "        \"Best practices for Java Hibernate mapping\",",
    "        [\"java\", \"hibernate\", \"orm\"]",
    "    )",
    "    ",
    "    print(f\"\\n\u2713 Posted 4 questions: {q1.id}, {q2.id}, {q3.id}, {q4.id}\")",
    "    ",
    "    # Add some votes",
    "    so.vote_question(\"u2\", \"q_1\", True)   # +1",
    "    so.vote_question(\"u2\", \"q_1\", True)   # stays +1",
    "    so.vote_question(\"u1\", \"q_3\", True)   # +1",
    "    so.vote_question(\"u1\", \"q_4\", True)   # +1",
    "    so.vote_question(\"u2\", \"q_4\", True)   # +2",
    "    print(f\"\\n\u2713 Added votes - Q1:{q1.score}, Q3:{q3.score}, Q4:{q4.score}\")",
    "    ",
    "    # Add an answer to Q1",
    "    a1 = so.post_answer(\"u2\", \"q_1\", \"Here's how to set up Spring Boot...\")",
    "    print(f\"\\n\u2713 Posted answer {a1.id} to Q1\")",
    "    ",
    "    # ===== DEMO: Search Questions =====",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"SEARCH DEMO: searchQuestions('java')\")",
    "    print(\"-\" * 60)",
    "    results = so.search_questions(\"java\")",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title}\")",
    "    ",
    "    print(\"\\nSEARCH DEMO: searchQuestions('spring boot')\")",
    "    results = so.search_questions(\"spring boot\")",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title}\")",
    "    ",
    "    # ===== DEMO: Search by Tags =====",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"TAG SEARCH: searchByTags(['java', 'spring'], matchAll=True)\")",
    "    print(\"-\" * 60)",
    "    results = so.search_by_tags([\"java\", \"spring\"], match_all=True)",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title} (tags: {q.tags})\")",
    "    ",
    "    print(\"\\nTAG SEARCH: searchByTags(['java', 'spring'], matchAll=False)\")",
    "    results = so.search_by_tags([\"java\", \"spring\"], match_all=False)",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title} (tags: {q.tags})\")",
    "    ",
    "    # ===== DEMO: Top Questions =====",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"TOP QUESTIONS: getTopQuestions(3)\")",
    "    print(\"-\" * 60)",
    "    results = so.get_top_questions(3)",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title} (score: {q.score})\")",
    "    ",
    "    # ===== DEMO: Unanswered Questions =====",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"UNANSWERED: getUnansweredQuestions()\")",
    "    print(\"-\" * 60)",
    "    results = so.get_unanswered_questions()",
    "    for q in results:",
    "        print(f\"  \u2192 {q.id}: {q.title} (answers: {len(q.answers)})\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo completed successfully!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.regex.*;",
    "import java.util.stream.*;",
    "import java.time.Instant;",
    "",
    "/**",
    " * Stack Overflow API Implementation - Part 3: Search and Filtering",
    " * Implements user management, Q&A, voting, and advanced search.",
    " */",
    "public class StackOverflow {",
    "    ",
    "    // Vote constants",
    "    private static final int UPVOTE = 1;",
    "    private static final int DOWNVOTE = -1;",
    "    private static final int REP_UPVOTE = 10;",
    "    private static final int REP_DOWNVOTE = -2;",
    "    ",
    "    // Core storage",
    "    private Map<String, User> users;",
    "    private Map<String, Question> questions;",
    "    private Map<String, Answer> answers;",
    "    ",
    "    // ID counters",
    "    private int questionCounter;",
    "    private int answerCounter;",
    "    ",
    "    // Search indexes (Part 3)",
    "    private Map<String, Set<String>> wordIndex;",
    "    private Map<String, Set<String>> tagIndex;",
    "    ",
    "    // Pattern for tokenization",
    "    private static final Pattern WORD_PATTERN = Pattern.compile(\"\\\\w+\");",
    "    ",
    "    // ==================== Inner Classes ====================",
    "    ",
    "    public static class User {",
    "        public String id;",
    "        public String displayName;",
    "        public int reputation;",
    "        public Instant createdAt;",
    "        ",
    "        public User(String id, String displayName) {",
    "            this.id = id;",
    "            this.displayName = displayName;",
    "            this.reputation = 0;",
    "            this.createdAt = Instant.now();",
    "        }",
    "    }",
    "    ",
    "    public static class Question {",
    "        public String id;",
    "        public String authorId;",
    "        public String title;",
    "        public String body;",
    "        public List<String> tags;",
    "        public int score;",
    "        public Instant createdAt;",
    "        public Map<String, Answer> answers;",
    "        public Map<String, Integer> votes;  // userId -> vote value",
    "        ",
    "        public Question(String id, String authorId, String title, ",
    "                        String body, List<String> tags) {",
    "            this.id = id;",
    "            this.authorId = authorId;",
    "            this.title = title;",
    "            this.body = body;",
    "            this.tags = new ArrayList<>(tags);",
    "            this.score = 0;",
    "            this.createdAt = Instant.now();",
    "            this.answers = new HashMap<>();",
    "            this.votes = new HashMap<>();",
    "        }",
    "    }",
    "    ",
    "    public static class Answer {",
    "        public String id;",
    "        public String questionId;",
    "        public String authorId;",
    "        public String body;",
    "        public int score;",
    "        public Instant createdAt;",
    "        public Map<String, Integer> votes;",
    "        ",
    "        public Answer(String id, String questionId, String authorId, String body) {",
    "            this.id = id;",
    "            this.questionId = questionId;",
    "            this.authorId = authorId;",
    "            this.body = body;",
    "            this.score = 0;",
    "            this.createdAt = Instant.now();",
    "            this.votes = new HashMap<>();",
    "        }",
    "    }",
    "    ",
    "    // ==================== Constructor ====================",
    "    ",
    "    public StackOverflow() {",
    "        this.users = new HashMap<>();",
    "        this.questions = new HashMap<>();",
    "        this.answers = new HashMap<>();",
    "        this.questionCounter = 0;",
    "        this.answerCounter = 0;",
    "        this.wordIndex = new HashMap<>();",
    "        this.tagIndex = new HashMap<>();",
    "    }",
    "    ",
    "    // ==================== Helper Methods ====================",
    "    ",
    "    private List<String> tokenize(String text) {",
    "        if (text == null || text.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        List<String> words = new ArrayList<>();",
    "        Matcher matcher = WORD_PATTERN.matcher(text.toLowerCase());",
    "        while (matcher.find()) {",
    "            words.add(matcher.group());",
    "        }",
    "        return words;",
    "    }",
    "    ",
    "    private void indexQuestion(Question question) {",
    "        // Index words from title and body",
    "        List<String> words = new ArrayList<>();",
    "        words.addAll(tokenize(question.title));",
    "        words.addAll(tokenize(question.body));",
    "        ",
    "        for (String word : words) {",
    "            wordIndex.computeIfAbsent(word, k -> new HashSet<>())",
    "                     .add(question.id);",
    "        }",
    "        ",
    "        // Index by tags",
    "        for (String tag : question.tags) {",
    "            tagIndex.computeIfAbsent(tag.toLowerCase(), k -> new HashSet<>())",
    "                    .add(question.id);",
    "        }",
    "    }",
    "    ",
    "    // ==================== Part 1: User Management ====================",
    "    ",
    "    public User createUser(String userId, String displayName) {",
    "        if (users.containsKey(userId)) {",
    "            throw new IllegalArgumentException(\"User \" + userId + \" already exists\");",
    "        }",
    "        User user = new User(userId, displayName);",
    "        users.put(userId, user);",
    "        return user;",
    "    }",
    "    ",
    "    public User getUser(String userId) {",
    "        return users.get(userId);",
    "    }",
    "    ",
    "    // ==================== Part 1: Question Management ====================",
    "    ",
    "    public Question postQuestion(String userId, String title, ",
    "                                  String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) {",
    "            throw new IllegalArgumentException(\"User \" + userId + \" not found\");",
    "        }",
    "        ",
    "        questionCounter++;",
    "        String questionId = \"q_\" + questionCounter;",
    "        ",
    "        Question question = new Question(questionId, userId, title, body, tags);",
    "        questions.put(questionId, question);",
    "        ",
    "        // Index for search",
    "        indexQuestion(question);",
    "        ",
    "        return question;",
    "    }",
    "    ",
    "    public Question getQuestion(String questionId) {",
    "        return questions.get(questionId);",
    "    }",
    "    ",
    "    // ==================== Part 1: Answer Management ====================",
    "    ",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!users.containsKey(userId)) {",
    "            throw new IllegalArgumentException(\"User \" + userId + \" not found\");",
    "        }",
    "        if (!questions.containsKey(questionId)) {",
    "            throw new IllegalArgumentException(\"Question \" + questionId + \" not found\");",
    "        }",
    "        ",
    "        answerCounter++;",
    "        String answerId = \"a_\" + answerCounter;",
    "        ",
    "        Answer answer = new Answer(answerId, questionId, userId, body);",
    "        answers.put(answerId, answer);",
    "        questions.get(questionId).answers.put(answerId, answer);",
    "        ",
    "        return answer;",
    "    }",
    "    ",
    "    // ==================== Part 2: Voting ====================",
    "    ",
    "    public int voteQuestion(String userId, String questionId, boolean isUpvote) {",
    "        if (!users.containsKey(userId)) {",
    "            throw new IllegalArgumentException(\"User not found\");",
    "        }",
    "        if (!questions.containsKey(questionId)) {",
    "            throw new IllegalArgumentException(\"Question not found\");",
    "        }",
    "        ",
    "        Question question = questions.get(questionId);",
    "        int voteValue = isUpvote ? UPVOTE : DOWNVOTE;",
    "        ",
    "        // Remove old vote if exists",
    "        if (question.votes.containsKey(userId)) {",
    "            int oldVote = question.votes.get(userId);",
    "            question.score -= oldVote;",
    "            int oldRep = oldVote > 0 ? REP_UPVOTE : REP_DOWNVOTE;",
    "            users.get(question.authorId).reputation -= oldRep;",
    "        }",
    "        ",
    "        question.votes.put(userId, voteValue);",
    "        question.score += voteValue;",
    "        ",
    "        int repChange = isUpvote ? REP_UPVOTE : REP_DOWNVOTE;",
    "        users.get(question.authorId).reputation += repChange;",
    "        ",
    "        return question.score;",
    "    }",
    "    ",
    "    public int voteAnswer(String userId, String answerId, boolean isUpvote) {",
    "        if (!users.containsKey(userId)) {",
    "            throw new IllegalArgumentException(\"User not found\");",
    "        }",
    "        if (!answers.containsKey(answerId)) {",
    "            throw new IllegalArgumentException(\"Answer not found\");",
    "        }",
    "        ",
    "        Answer answer = answers.get(answerId);",
    "        int voteValue = isUpvote ? UPVOTE : DOWNVOTE;",
    "        ",
    "        if (answer.votes.containsKey(userId)) {",
    "            int oldVote = answer.votes.get(userId);",
    "            answer.score -= oldVote;",
    "            int oldRep = oldVote > 0 ? REP_UPVOTE : REP_DOWNVOTE;",
    "            users.get(answer.authorId).reputation -= oldRep;",
    "        }",
    "        ",
    "        answer.votes.put(userId, voteValue);",
    "        answer.score += voteValue;",
    "        ",
    "        int repChange = isUpvote ? REP_UPVOTE : REP_DOWNVOTE;",
    "        users.get(answer.authorId).reputation += repChange;",
    "        ",
    "        return answer.score;",
    "    }",
    "    ",
    "    // ==================== Part 3: Search and Filtering ====================",
    "    ",
    "    /**",
    "     * Search questions by text query.",
    "     * Case-insensitive, partial word matching, sorted by relevance.",
    "     */",
    "    public List<Question> searchQuestions(String query) {",
    "        if (query == null || query.trim().isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        List<String> queryWords = tokenize(query);",
    "        if (queryWords.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        // Count matches per question",
    "        Map<String, Integer> matchCounts = new HashMap<>();",
    "        ",
    "        for (String queryWord : queryWords) {",
    "            // Check all indexed words for partial matches",
    "            for (Map.Entry<String, Set<String>> entry : wordIndex.entrySet()) {",
    "                if (entry.getKey().contains(queryWord)) {",
    "                    for (String qid : entry.getValue()) {",
    "                        matchCounts.merge(qid, 1, Integer::sum);",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        if (matchCounts.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        // Sort by match count (desc), then by ID",
    "        return matchCounts.keySet().stream()",
    "            .sorted((a, b) -> {",
    "                int cmp = Integer.compare(matchCounts.get(b), matchCounts.get(a));",
    "                return cmp != 0 ? cmp : a.compareTo(b);",
    "            })",
    "            .map(qid -> questions.get(qid))",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    /**",
    "     * Search questions by tags with AND/OR logic.",
    "     */",
    "    public List<Question> searchByTags(List<String> tags, boolean matchAll) {",
    "        if (tags == null || tags.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        Set<String> resultIds = null;",
    "        ",
    "        for (String tag : tags) {",
    "            String normalizedTag = tag.toLowerCase();",
    "            Set<String> tagQuestions = tagIndex.getOrDefault(normalizedTag, ",
    "                                                              Collections.emptySet());",
    "            ",
    "            if (resultIds == null) {",
    "                resultIds = new HashSet<>(tagQuestions);",
    "            } else if (matchAll) {",
    "                // AND: intersection",
    "                resultIds.retainAll(tagQuestions);",
    "            } else {",
    "                // OR: union",
    "                resultIds.addAll(tagQuestions);",
    "            }",
    "        }",
    "        ",
    "        if (resultIds == null || resultIds.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        // Sort by score (desc), then by ID",
    "        return resultIds.stream()",
    "            .sorted((a, b) -> {",
    "                int cmp = Integer.compare(questions.get(b).score, ",
    "                                          questions.get(a).score);",
    "                return cmp != 0 ? cmp : a.compareTo(b);",
    "            })",
    "            .map(qid -> questions.get(qid))",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    /**",
    "     * Get top questions by score.",
    "     */",
    "    public List<Question> getTopQuestions(int limit) {",
    "        if (limit <= 0) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        return questions.values().stream()",
    "            .sorted((a, b) -> {",
    "                int cmp = Integer.compare(b.score, a.score);",
    "                return cmp != 0 ? cmp : a.id.compareTo(b.id);",
    "            })",
    "            .limit(limit)",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    /**",
    "     * Get most recent questions.",
    "     */",
    "    public List<Question> getRecentQuestions(int limit) {",
    "        if (limit <= 0) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        return questions.values().stream()",
    "            .sorted((a, b) -> {",
    "                int cmp = b.createdAt.compareTo(a.createdAt);",
    "                return cmp != 0 ? cmp : a.id.compareTo(b.id);",
    "            })",
    "            .limit(limit)",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    /**",
    "     * Get all unanswered questions.",
    "     */",
    "    public List<Question> getUnansweredQuestions() {",
    "        return questions.values().stream()",
    "            .filter(q -> q.answers.isEmpty())",
    "            .sorted((a, b) -> {",
    "                int cmp = a.createdAt.compareTo(b.createdAt);",
    "                return cmp != 0 ? cmp : a.id.compareTo(b.id);",
    "            })",
    "            .collect(Collectors.toList());",
    "    }",
    "    ",
    "    // ==================== Main Demo ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API - Part 3: Search and Filtering Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow so = new StackOverflow();",
    "        ",
    "        // Create users",
    "        User alice = so.createUser(\"u1\", \"alice\");",
    "        User bob = so.createUser(\"u2\", \"bob\");",
    "        System.out.println(\"\\n\u2713 Created users\");",
    "        ",
    "        // Post questions",
    "        Question q1 = so.postQuestion(\"u1\", \"Java Spring Boot Tutorial\",",
    "            \"How to create REST API with Spring Boot\",",
    "            Arrays.asList(\"java\", \"spring\", \"rest\"));",
    "        ",
    "        Question q2 = so.postQuestion(\"u1\", \"Python List Help\",",
    "            \"Python list comprehension syntax\",",
    "            Arrays.asList(\"python\", \"syntax\"));",
    "        ",
    "        Question q3 = so.postQuestion(\"u2\", \"JavaScript Async\",",
    "            \"Understanding async await in JavaScript\",",
    "            Arrays.asList(\"javascript\", \"async\"));",
    "        ",
    "        Question q4 = so.postQuestion(\"u2\", \"Java Hibernate\",",
    "            \"Java Hibernate ORM best practices\",",
    "            Arrays.asList(\"java\", \"hibernate\"));",
    "        ",
    "        System.out.println(\"\u2713 Posted 4 questions\");",
    "        ",
    "        // Add votes",
    "        so.voteQuestion(\"u2\", \"q_1\", true);",
    "        so.voteQuestion(\"u1\", \"q_4\", true);",
    "        so.voteQuestion(\"u2\", \"q_4\", true);",
    "        ",
    "        // Add answer",
    "        so.postAnswer(\"u2\", \"q_1\", \"Here's how...\");",
    "        ",
    "        // Search demos",
    "        System.out.println(\"\\n\" + \"-\".repeat(60));",
    "        System.out.println(\"SEARCH: 'java'\");",
    "        for (Question q : so.searchQuestions(\"java\")) {",
    "            System.out.println(\"  \u2192 \" + q.id + \": \" + q.title);",
    "        }",
    "        ",
    "        System.out.println(\"\\nTAG SEARCH: ['java','spring'] AND\");",
    "        for (Question q : so.searchByTags(Arrays.asList(\"java\", \"spring\"), true)) {",
    "            System.out.println(\"  \u2192 \" + q.id + \": \" + q.title);",
    "        }",
    "        ",
    "        System.out.println(\"\\nTOP 3 QUESTIONS:\");",
    "        for (Question q : so.getTopQuestions(3)) {",
    "            System.out.println(\"  \u2192 \" + q.id + \" (score: \" + q.score + \")\");",
    "        }",
    "        ",
    "        System.out.println(\"\\nUNANSWERED:\");",
    "        for (Question q : so.getUnansweredQuestions()) {",
    "            System.out.println(\"  \u2192 \" + q.id + \": \" + q.title);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Demo completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-4",
      "explanation": "Python imports: typing for type hints, datetime for timestamps, defaultdict for auto-initializing dicts, re for tokenization regex"
    },
    {
      "lines": "7-14",
      "explanation": "User class: basic user representation with id, display name, reputation (modified by votes), and creation timestamp"
    },
    {
      "lines": "17-30",
      "explanation": "Question class: core entity with title, body, tags, score tracking, nested answers dict, and votes map (userId \u2192 vote value)"
    },
    {
      "lines": "33-44",
      "explanation": "Answer class: similar structure to Question with back-reference to question_id"
    },
    {
      "lines": "47-73",
      "explanation": "StackOverflow constructor: initializes core storage (users, questions, answers), ID counters, and **the two search indexes** (word_index, tag_index) as defaultdict(set)"
    },
    {
      "lines": "77-84",
      "explanation": "_tokenize helper: uses regex \\w+ to extract alphanumeric sequences, lowercases everything for case-insensitive matching"
    },
    {
      "lines": "86-99",
      "explanation": "_index_question: **key Part 3 addition** - called on every postQuestion to build inverted index. Tokenizes title+body, adds question ID to word_index[word] for each word, and to tag_index[tag] for each tag"
    },
    {
      "lines": "217-248",
      "explanation": "searchQuestions: tokenizes query, iterates over ALL indexed words checking for partial matches (queryWord in indexedWord), counts matches per question, sorts by match count descending"
    },
    {
      "lines": "250-283",
      "explanation": "searchByTags: implements AND/OR logic using set operations. AND = intersection (retainAll/&=), OR = union (addAll/|=). Result sorted by score"
    },
    {
      "lines": "285-301",
      "explanation": "getTopQuestions: simple sort of all questions by score descending, return first 'limit' items"
    },
    {
      "lines": "303-319",
      "explanation": "getRecentQuestions: sort by creation timestamp descending (newest first)"
    },
    {
      "lines": "321-333",
      "explanation": "getUnansweredQuestions: filter questions where answers dict is empty, sort by creation time (oldest first to prioritize)"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "searchQuestions": {
          "complexity": "O(W \u00d7 V \u00d7 M)",
          "explanation": "W=query words, V=vocabulary size (for partial matching scan), M=avg questions per matching word. Without partial matching it would be O(W \u00d7 M)."
        },
        "searchByTags": {
          "complexity": "O(T \u00d7 Q + R log R)",
          "explanation": "T=number of tags, Q=avg questions per tag for set operations, R=result size for sorting"
        },
        "getTopQuestions": {
          "complexity": "O(N log N)",
          "explanation": "Sorting all N questions. Could be O(N log K) with heap for top-K"
        },
        "getRecentQuestions": {
          "complexity": "O(N log N)",
          "explanation": "Same as getTopQuestions"
        },
        "getUnansweredQuestions": {
          "complexity": "O(N log U)",
          "explanation": "Filter O(N), then sort U unanswered questions"
        }
      },
      "overall_change": "Insert becomes O(L) where L=content length for indexing. Search becomes much faster than naive O(N\u00d7L) scan."
    },
    "space": {
      "additional_space": "O(T \u00d7 W) where T=total tokens across all questions, W=unique words",
      "explanation": "word_index stores each unique word mapped to question IDs. In practice, vocabulary grows sublinearly as questions are added (Heap's Law). tag_index is typically smaller as tags are limited."
    }
  },
  "dry_run": {
    "example_input": "searchQuestions('java') with questions: Q1='Java Spring Boot Tutorial', Q3='JavaScript Async', Q4='Java Hibernate'",
    "steps": [
      {
        "step": 1,
        "action": "Tokenize query 'java'",
        "state": "query_words = ['java']",
        "explanation": "Lowercase and extract words"
      },
      {
        "step": 2,
        "action": "Initialize match_counts = {}",
        "state": "Empty dict",
        "explanation": "Will track relevance per question"
      },
      {
        "step": 3,
        "action": "For query_word 'java', scan word_index",
        "state": "Checking all indexed words",
        "explanation": "Looking for partial matches"
      },
      {
        "step": 4,
        "action": "Check 'java' contains 'java'? YES",
        "state": "word_index['java'] = {q_1, q_4}",
        "explanation": "Q1 and Q4 have 'java' in title/body"
      },
      {
        "step": 5,
        "action": "match_counts[q_1] += 1, match_counts[q_4] += 1",
        "state": "match_counts = {q_1:1, q_4:1}",
        "explanation": "Both matched once"
      },
      {
        "step": 6,
        "action": "Check 'javascript' contains 'java'? YES",
        "state": "word_index['javascript'] = {q_3}",
        "explanation": "Partial match!"
      },
      {
        "step": 7,
        "action": "match_counts[q_3] += 1",
        "state": "match_counts = {q_1:1, q_4:1, q_3:1}",
        "explanation": "Q3 also matches via 'javascript'"
      },
      {
        "step": 8,
        "action": "Sort by (-match_count, id)",
        "state": "[q_1, q_3, q_4]",
        "explanation": "All have count=1, sort by ID"
      },
      {
        "step": 9,
        "action": "Return questions",
        "state": "[Q1, Q3, Q4]",
        "explanation": "Final result"
      }
    ],
    "final_output": "[Question(id='q_1', title='Java Spring Boot Tutorial'), Question(id='q_3', title='JavaScript Async'), Question(id='q_4', title='Java Hibernate')]"
  },
  "edge_cases": [
    {
      "case": "Empty query string",
      "handling": "Return empty list immediately",
      "gotcha": "Don't forget to check for whitespace-only strings too"
    },
    {
      "case": "Query with no matches",
      "handling": "Return empty list after search completes with no results",
      "gotcha": "Make sure match_counts is checked before sorting"
    },
    {
      "case": "Tags that don't exist",
      "handling": "tag_index.get(tag, set()) returns empty set, AND logic results in empty, OR continues",
      "gotcha": "With AND logic, one missing tag should return empty"
    },
    {
      "case": "limit = 0 or negative",
      "handling": "Return empty list",
      "gotcha": "Don't try to slice with negative indices"
    },
    {
      "case": "All questions unanswered",
      "handling": "Return all questions sorted by age",
      "gotcha": "Handle the case where there are no questions at all"
    },
    {
      "case": "Special characters in query",
      "handling": "Regex \\w+ ignores special chars, only extracts alphanumerics",
      "gotcha": "Query '@#$' becomes empty word list"
    },
    {
      "case": "matchAll=true with single tag",
      "handling": "Works correctly - single tag filter",
      "gotcha": "Set intersection with one set is just that set"
    }
  ],
  "test_cases": [
    {
      "name": "Basic text search",
      "input": "searchQuestions('java') after posting Q1 with title 'Java Help'",
      "expected": "[Q1]",
      "explanation": "Case-insensitive match of 'java' in 'Java'"
    },
    {
      "name": "Partial word matching",
      "input": "searchQuestions('java') with Q1='JavaScript Guide'",
      "expected": "[Q1]",
      "explanation": "'java' is contained in 'javascript'"
    },
    {
      "name": "Tag AND logic",
      "input": "searchByTags(['java', 'spring'], true) with Q1=tags['java','spring'], Q2=tags['java']",
      "expected": "[Q1]",
      "explanation": "Only Q1 has both java AND spring"
    },
    {
      "name": "Tag OR logic",
      "input": "searchByTags(['java', 'python'], false) with Q1=tags['java'], Q2=tags['python']",
      "expected": "[Q1, Q2]",
      "explanation": "Both questions match with OR logic"
    },
    {
      "name": "Top questions ordering",
      "input": "getTopQuestions(2) with Q1.score=5, Q2.score=10, Q3.score=3",
      "expected": "[Q2, Q1]",
      "explanation": "Sorted by score descending, limited to 2"
    },
    {
      "name": "Unanswered filter",
      "input": "getUnansweredQuestions() with Q1 having 1 answer, Q2 having 0 answers",
      "expected": "[Q2]",
      "explanation": "Only Q2 has no answers"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Case-sensitive matching",
      "why_wrong": "Problem requires case-insensitive search. 'Java' should match 'java' query.",
      "correct_approach": "Lowercase both indexed words and query words during tokenization",
      "code_example_wrong": "if query_word == indexed_word:",
      "code_example_correct": "if query_word.lower() in indexed_word.lower():"
    },
    {
      "mistake": "Exact word matching only",
      "why_wrong": "Problem requires partial matching: 'java' should match 'JavaScript'",
      "correct_approach": "Use 'in' operator or string.contains() for substring matching",
      "code_example_wrong": "if query_word == indexed_word:",
      "code_example_correct": "if query_word in indexed_word:  # 'java' in 'javascript' = True"
    },
    {
      "mistake": "Not building index on insert",
      "why_wrong": "Leads to O(N) search time instead of O(1) word lookup",
      "correct_approach": "Index question content in postQuestion method, not in searchQuestions",
      "code_example_wrong": "def searchQuestions: for q in questions: if query in q.title...",
      "code_example_correct": "def postQuestion: self._index_question(q)  # Build index here"
    },
    {
      "mistake": "Wrong set operation for AND/OR",
      "why_wrong": "AND requires intersection, OR requires union. Swapping these breaks filtering logic.",
      "correct_approach": "AND = set intersection (&=), OR = set union (|=)",
      "code_example_wrong": "if match_all: result |= tag_set  # Wrong!",
      "code_example_correct": "if match_all: result &= tag_set  # Intersection for AND"
    },
    {
      "mistake": "Not handling empty query/tags",
      "why_wrong": "Leads to runtime errors or incorrect empty results",
      "correct_approach": "Check for empty/null inputs at method start, return empty list",
      "code_example_wrong": "def searchQuestions(query): words = tokenize(query)...",
      "code_example_correct": "def searchQuestions(query): if not query or not query.strip(): return []"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the search requirements: 'I'll implement an inverted index for efficient search.' Draw the index structure before coding. Explain the trade-off: 'We pay O(L) at insert time to get O(1) word lookups at search time.' For the interviewer, this shows systems design thinking.",
    "what_to_mention": [
      "Inverted index pattern - fundamental to search engines",
      "Trade-off between insert cost and query performance",
      "Set operations for boolean logic (intersection/union)",
      "Partial matching limitation and alternatives (trie, n-grams)",
      "Relevance scoring by match count",
      "Scalability considerations (vocabulary size, index sharding)"
    ],
    "time_allocation": "15-20 mins: 3 mins clarifying requirements, 5 mins explaining index design, 10 mins implementation, 2 mins testing edge cases",
    "if_stuck": [
      "Start with naive O(N) scan, then optimize with index",
      "Think about how Google/Elasticsearch indexes documents",
      "For AND/OR: 'What set operation gives me elements in ALL sets? Intersection'",
      "For partial matching: 'If I can't do O(1), what's my vocabulary size?'"
    ]
  },
  "connection_to_next_part": "If there's a Part 4 on 'Comment System & Notifications', the search index can be extended to include answers and comments. Consider adding a general 'Post' abstraction. For real-time notifications, the indexing infrastructure supports event-driven updates. You might also explore: pagination for search results, caching popular queries, or distributed search across shards.",
  "generated_at": "2026-01-14T15:36:27.179454",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}