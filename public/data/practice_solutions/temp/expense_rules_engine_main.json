{
  "problem_title": "Corporate Expense Rules Engine",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic Rules Engine / Strategy Pattern** problem. We need to design an extensible system where different rule types can independently evaluate expenses. The key is creating a clean abstraction that allows adding new rule types without modifying existing code (Open/Closed Principle).",
    "pattern_recognition": "**Strategy Pattern** + **Iterator Pattern** - Each rule type is a strategy that encapsulates its own evaluation logic. We iterate through all expenses and all rules, collecting violations. This is similar to validation frameworks like Bean Validation in Java.",
    "key_constraints": [
      "**Amounts as strings** - Must parse to Decimal/BigDecimal for precise comparisons",
      "**Multiple violations per expense** - Cannot short-circuit; must check ALL rules",
      "**Extensibility required** - Design must easily accommodate new rule types",
      "**50 rules \u00d7 1000 expenses** - O(R \u00d7 E) is acceptable given constraints"
    ],
    "clarifying_questions": [
      "**Q: Should rule evaluation order matter?** - Determines if we need ordered collection",
      "**Q: Are amounts always valid decimal strings?** - Error handling strategy",
      "**Q: Should violations be ordered by expense_id or rule evaluation order?** - Output format clarity",
      "**Q: Can the same rule type appear multiple times?** - e.g., multiple BanRules for different fields",
      "**Q: Is the comparison for amounts strictly greater than, or greater than or equal?** - Boundary behavior",
      "**Q: How should we handle missing fields in expense data?** - Null/missing field strategy",
      "**Q: Do we need to support rule priorities or short-circuit evaluation?** - Future extensibility"
    ],
    "edge_cases_to_consider": [
      "Expense at exactly the limit boundary ($75.00 when limit is $75)",
      "Empty rules list (should return empty violations)",
      "Empty expenses list (should return empty violations)",
      "Expense violates ALL rules simultaneously",
      "BanRule on vendor_name vs vendor_type vs expense_type",
      "Decimal precision edge cases ($75.001 vs $75.00)",
      "Missing or null fields in expense data"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n                    EXPENSE RULES ENGINE FLOW\n\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502                      RULES                              \u2502\n     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n     \u2502  \u2502  BanRule    \u2502 \u2502 MaxAmount   \u2502 \u2502 VendorTypeLimit  \u2502   \u2502\n     \u2502  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502   \u2502\n     \u2502  \u2502 field:      \u2502 \u2502 max: $250   \u2502 \u2502 type: restaurant \u2502   \u2502\n     \u2502  \u2502 expense_type\u2502 \u2502             \u2502 \u2502 max: $75         \u2502   \u2502\n     \u2502  \u2502 value:      \u2502 \u2502             \u2502 \u2502                  \u2502   \u2502\n     \u2502  \u2502 airfare     \u2502 \u2502             \u2502 \u2502                  \u2502   \u2502\n     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n     \u2502         \u2502               \u2502                 \u2502             \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502               \u2502                 \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502  evaluate() \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502                      EXPENSES                             \u2502\n     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n     \u2502  \u2502 E001 \u2502 $49.99  \u2502 client_hosting \u2502 restaurant \u2502 \u2713     \u2502 \u2502\n     \u2502  \u2502 E002 \u2502 $350.00 \u2502 airfare        \u2502 airline    \u2502 \u2717 \u2717   \u2502 \u2502\n     \u2502  \u2502 E003 \u2502 $85.00  \u2502 meals          \u2502 restaurant \u2502 \u2717     \u2502 \u2502\n     \u2502  \u2502 E004 \u2502 $25.00  \u2502 supplies       \u2502 office     \u2502 \u2713     \u2502 \u2502\n     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                          \u2502 VIOLATIONS  \u2502\n                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  E002 \u2502 BanRule      \u2502 expense_type 'airfare' not allowed \u2502\n     \u2502  E002 \u2502 MaxAmount    \u2502 $350.00 exceeds $250.00 limit      \u2502\n     \u2502  E003 \u2502 VendorLimit  \u2502 restaurant $85.00 > $75.00 limit   \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n                    CLASS HIERARCHY\n\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502   <<abstract>>        \u2502\n              \u2502       Rule            \u2502\n              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n              \u2502 + evaluate(expense)   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502 + get_name()          \u2502      \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n                          \u2502                  \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n          \u2502               \u2502               \u2502  \u2502  returns\n    \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n    \u2502 BanRule   \u2502  \u2502 MaxAmount   \u2502  \u2502VendorTypeLimit\u2502  \u2502\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502    Rule     \u2502  \u2502    Rule       \u2502  \u2502\n    \u2502- field    \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n    \u2502- value    \u2502  \u2502- maxAmount  \u2502  \u2502- vendorType   \u2502  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502- maxAmount    \u2502  \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n                                                       \u25bc\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502      Violation          \u2502\n                                    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n                                    \u2502- expense_id: str        \u2502\n                                    \u2502- rule_name: str         \u2502\n                                    \u2502- reason: str            \u2502\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502    ExpenseRulesEngine       \u2502\n              \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n              \u2502+ evaluate_rules(rules,      \u2502\n              \u2502    expenses) -> Violations  \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Initialize empty violations list",
        "visualization": "violations = []",
        "key_point": "Collect ALL violations, don't short-circuit"
      },
      {
        "step": 2,
        "description": "Iterate through each expense",
        "visualization": "for expense in expenses:\n    # E001, E002, E003...",
        "key_point": "Outer loop over expenses"
      },
      {
        "step": 3,
        "description": "For each expense, evaluate ALL rules",
        "visualization": "    for rule in rules:\n        # BanRule, MaxAmount, VendorLimit...",
        "key_point": "Inner loop over rules - polymorphic dispatch"
      },
      {
        "step": 4,
        "description": "Each rule evaluates itself (Strategy Pattern)",
        "visualization": "        violation = rule.evaluate(expense)\n        if violation:\n            violations.append(violation)",
        "key_point": "Rule encapsulates its own logic - Single Responsibility"
      },
      {
        "step": 5,
        "description": "Return all collected violations",
        "visualization": "return violations",
        "key_point": "Multiple violations per expense preserved"
      }
    ],
    "dry_run_table": "| Expense | Rule | Field Check | Amount | Result | Reason |\n|---------|------|-------------|--------|--------|--------|\n| E001 $49.99 restaurant | BanRule(airfare) | expense_type != airfare | - | \u2713 PASS | - |\n| E001 $49.99 restaurant | MaxAmount(250) | - | 49.99 \u2264 250 | \u2713 PASS | - |\n| E001 $49.99 restaurant | VendorLimit(rest,75) | vendor_type == restaurant | 49.99 \u2264 75 | \u2713 PASS | - |\n| E002 $350 airfare | BanRule(airfare) | expense_type == airfare | - | \u2717 FAIL | airfare banned |\n| E002 $350 airfare | MaxAmount(250) | - | 350 > 250 | \u2717 FAIL | exceeds $250 |\n| E002 $350 airfare | VendorLimit(rest,75) | vendor_type != restaurant | - | \u2713 PASS | N/A |\n| E003 $85 restaurant | BanRule(airfare) | expense_type != airfare | - | \u2713 PASS | - |\n| E003 $85 restaurant | MaxAmount(250) | - | 85 \u2264 250 | \u2713 PASS | - |\n| E003 $85 restaurant | VendorLimit(rest,75) | vendor_type == restaurant | 85 > 75 | \u2717 FAIL | exceeds $75 |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'rules engine'**, I immediately think of the **Strategy Pattern** - each rule type is a strategy that encapsulates its evaluation logic",
      "**The key constraint 'easy to add new rule types'** confirms I need the **Open/Closed Principle** - open for extension (new rules), closed for modification (existing code)",
      "**'One expense can violate multiple rules'** means I can't short-circuit - must evaluate ALL rules for each expense",
      "**Amounts as strings** is a classic gotcha - I'll use **Decimal/BigDecimal** to avoid floating-point precision issues like 0.1 + 0.1 + 0.1 \u2260 0.3",
      "**Return type design** is critical - I need a Violation class that captures: which expense (expense_id), which rule (rule_name), and why (reason)",
      "**The interface design** should have evaluate(expense) \u2192 Optional[Violation], making it self-contained and testable"
    ],
    "key_insight": "The **Strategy Pattern** is the perfect fit here. Each rule type (Ban, MaxAmount, VendorTypeLimit) is a **strategy** that knows how to evaluate itself against an expense. The engine simply iterates and delegates - it doesn't need to know the details of each rule type. This achieves **Single Responsibility** (each rule handles its logic) and **Open/Closed** (adding new rules = adding new classes, no modification needed).",
    "why_this_works": "By defining a common `Rule` interface with an `evaluate(expense)` method, we achieve **polymorphism** - the engine treats all rules uniformly while each rule behaves differently. This is the essence of Strategy Pattern: define a family of algorithms, encapsulate each one, and make them interchangeable."
  },
  "approaches": [
    {
      "name": "Naive Approach: Switch/If-Else Chain",
      "description": "Use a big switch statement or if-else chain to handle each rule type differently in the main evaluation function.",
      "pseudocode": "def evaluate(rules, expenses):\n    violations = []\n    for expense in expenses:\n        for rule in rules:\n            if rule.type == 'ban':\n                if expense[rule.field] == rule.value:\n                    violations.append(...)\n            elif rule.type == 'max_amount':\n                if float(expense.amount) > rule.max:\n                    violations.append(...)\n            # ... more elif for each rule type\n    return violations",
      "time_complexity": "O(E \u00d7 R) where E = expenses, R = rules",
      "space_complexity": "O(V) where V = number of violations",
      "pros": [
        "Simple to understand initially",
        "Works for small number of rule types"
      ],
      "cons": [
        "Violates Open/Closed Principle - must modify evaluate() for each new rule",
        "Violates Single Responsibility - one function knows all rule logic",
        "Hard to test individual rules",
        "Code becomes unmanageable as rules grow"
      ],
      "when_to_use": "Never in production. Only acceptable for quick prototypes with 2-3 rule types."
    },
    {
      "name": "Optimal: Strategy Pattern with Rule Interface",
      "description": "Define a `Rule` interface with `evaluate(expense) -> Optional[Violation]`. Each rule type is a separate class implementing this interface. The engine simply iterates and delegates.",
      "pseudocode": "class Rule:\n    def evaluate(expense) -> Optional[Violation]\n\nclass BanRule(Rule):\n    def evaluate(expense):\n        if expense[self.field] == self.banned_value:\n            return Violation(...)\n        return None\n\ndef evaluate_rules(rules, expenses):\n    violations = []\n    for expense in expenses:\n        for rule in rules:\n            if v := rule.evaluate(expense):\n                violations.append(v)\n    return violations",
      "time_complexity": "O(E \u00d7 R) - same as naive, but cleaner",
      "space_complexity": "O(V) where V = number of violations",
      "pros": [
        "Open/Closed Principle - add new rules without changing engine",
        "Single Responsibility - each rule handles its logic",
        "Highly testable - unit test each rule independently",
        "Clean, maintainable code"
      ],
      "cons": [
        "Slightly more classes to write initially",
        "Requires understanding of OOP patterns"
      ],
      "key_insight": "The Strategy Pattern transforms a complex conditional into a simple polymorphic call. The engine doesn't care HOW rules evaluate - it just calls evaluate() and collects results."
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern Rules Engine with Decimal Precision",
    "explanation_md": "## Approach\n\nWe implement the **Strategy Pattern** where:\n\n1. **`Rule`** is an abstract base class defining the interface\n2. **`BanRule`**, **`MaxAmountRule`**, **`VendorTypeLimitRule`** are concrete strategies\n3. **`ExpenseRulesEngine`** orchestrates evaluation without knowing rule details\n\n### Why This Design?\n\n| Principle | How We Achieve It |\n|-----------|-------------------|\n| **Single Responsibility** | Each rule class handles ONE type of validation |\n| **Open/Closed** | Add new rules by adding new classes, not modifying existing |\n| **Liskov Substitution** | All rules can be used interchangeably via Rule interface |\n| **Dependency Inversion** | Engine depends on abstraction (Rule), not concrete classes |\n\n### Key Design Decisions\n\n1. **`evaluate()` returns `Optional[Violation]`** - Clean way to indicate pass (None) or fail (Violation)\n2. **`Decimal` for amounts** - Avoids floating-point precision traps\n3. **Violation as dataclass** - Clean, immutable data carrier\n4. **Engine is stateless** - Pure function, easy to test and parallelize",
    "data_structures": [
      {
        "structure": "Abstract Rule class",
        "purpose": "Defines contract for all rule types - evaluate() and get_name()"
      },
      {
        "structure": "Violation dataclass",
        "purpose": "Immutable data carrier for violation details"
      },
      {
        "structure": "List[Violation]",
        "purpose": "Accumulates all violations found"
      },
      {
        "structure": "Decimal",
        "purpose": "Precise monetary comparisons without floating-point errors"
      }
    ],
    "algorithm_steps": [
      "1. **Define Violation dataclass** with expense_id, rule_name, reason fields",
      "2. **Create abstract Rule class** with evaluate(expense) -> Optional[Violation]",
      "3. **Implement BanRule** - check if expense[field] matches banned value",
      "4. **Implement MaxAmountRule** - parse amount, compare against max",
      "5. **Implement VendorTypeLimitRule** - check vendor type match, then compare amount",
      "6. **Create ExpenseRulesEngine.evaluate_rules()** - nested loop: for each expense, for each rule",
      "7. **Collect and return all violations** - don't short-circuit, accumulate all"
    ],
    "why_decimal": "**Critical for financial applications!**\n\n```python\n# Using float (WRONG):\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # NOT 0.3!\n\n>>> 75.00 == 75.0\nTrue  # but...\n>>> 0.1 + 0.1 + 0.1 == 0.3\nFalse  # SURPRISE!\n\n# Using Decimal (CORRECT):\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1')\nDecimal('0.3')  # Exact!\n```"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Corporate Expense Rules Engine",
    "",
    "A flexible, extensible rules engine for validating corporate expenses.",
    "Uses Strategy Pattern for rule evaluation.",
    "",
    "Author: Interview Solution",
    "Time Complexity: O(E \u00d7 R) where E = expenses, R = rules",
    "Space Complexity: O(V) where V = violations",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass",
    "from decimal import Decimal, InvalidOperation",
    "from typing import List, Dict, Optional",
    "",
    "",
    "@dataclass(frozen=True)",
    "class Violation:",
    "    \"\"\"",
    "    Represents a rule violation for an expense.",
    "    ",
    "    Attributes:",
    "        expense_id: The ID of the expense that violated the rule",
    "        rule_name: The name/type of the rule that was violated",
    "        reason: Human-readable explanation of why the violation occurred",
    "    ",
    "    Example:",
    "        >>> v = Violation('E001', 'BanRule', \"expense_type 'airfare' is not allowed\")",
    "        >>> print(v.expense_id)",
    "        E001",
    "    \"\"\"",
    "    expense_id: str",
    "    rule_name: str",
    "    reason: str",
    "",
    "",
    "class Rule(ABC):",
    "    \"\"\"",
    "    Abstract base class for all expense rules.",
    "    ",
    "    Implements the Strategy Pattern - each concrete rule type",
    "    encapsulates its own evaluation logic.",
    "    ",
    "    Subclasses must implement:",
    "        - evaluate(expense): Check if expense violates this rule",
    "        - get_name(): Return the rule type name",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        \"\"\"",
    "        Evaluate an expense against this rule.",
    "        ",
    "        Args:",
    "            expense: Dictionary containing expense fields:",
    "                - expense_id: Unique identifier",
    "                - amount_usd: Amount as string (e.g., '49.99')",
    "                - expense_type: Type of expense",
    "                - vendor_type: Type of vendor",
    "                - vendor_name: Name of vendor",
    "        ",
    "        Returns:",
    "            Violation if rule is violated, None otherwise",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the name of this rule type.\"\"\"",
    "        pass",
    "",
    "",
    "class BanRule(Rule):",
    "    \"\"\"",
    "    Rule that bans expenses with specific field values.",
    "    ",
    "    Can ban by expense_type, vendor_type, or vendor_name.",
    "    ",
    "    Example:",
    "        >>> rule = BanRule('expense_type', 'entertainment')",
    "        >>> # Will flag any expense where expense_type == 'entertainment'",
    "    \"\"\"",
    "    ",
    "    def __init__(self, field: str, banned_value: str):",
    "        \"\"\"",
    "        Initialize a ban rule.",
    "        ",
    "        Args:",
    "            field: The expense field to check ('expense_type', 'vendor_type', 'vendor_name')",
    "            banned_value: The value that is not allowed",
    "        \"\"\"",
    "        if field not in ('expense_type', 'vendor_type', 'vendor_name'):",
    "            raise ValueError(f\"Invalid field '{field}'. Must be expense_type, vendor_type, or vendor_name\")",
    "        self.field = field",
    "        self.banned_value = banned_value",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'BanRule'",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        \"\"\"Check if expense has a banned field value.\"\"\"",
    "        actual_value = expense.get(self.field, '')",
    "        ",
    "        if actual_value == self.banned_value:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.field} '{self.banned_value}' is not allowed\"",
    "            )",
    "        return None",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"",
    "    Rule that caps the maximum amount for any single expense.",
    "    ",
    "    Example:",
    "        >>> rule = MaxAmountRule(250.00)",
    "        >>> # Will flag any expense where amount > $250",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_amount: float):",
    "        \"\"\"",
    "        Initialize a max amount rule.",
    "        ",
    "        Args:",
    "            max_amount: Maximum allowed amount in USD",
    "        ",
    "        Raises:",
    "            ValueError: If max_amount is not positive",
    "        \"\"\"",
    "        if max_amount <= 0:",
    "            raise ValueError(f\"max_amount must be positive, got {max_amount}\")",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'MaxAmountRule'",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        \"\"\"Check if expense exceeds maximum amount.\"\"\"",
    "        try:",
    "            amount = Decimal(expense['amount_usd'])",
    "        except (KeyError, InvalidOperation) as e:",
    "            # Handle missing or invalid amount",
    "            return Violation(",
    "                expense_id=expense.get('expense_id', 'UNKNOWN'),",
    "                rule_name=self.get_name(),",
    "                reason=f\"Invalid or missing amount_usd: {e}\"",
    "            )",
    "        ",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"amount ${amount:.2f} exceeds maximum ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"",
    "    Rule that caps the amount for expenses at specific vendor types.",
    "    ",
    "    Only applies to expenses where vendor_type matches.",
    "    ",
    "    Example:",
    "        >>> rule = VendorTypeLimitRule('restaurant', 75.00)",
    "        >>> # Will flag restaurant expenses over $75",
    "    \"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: float):",
    "        \"\"\"",
    "        Initialize a vendor type limit rule.",
    "        ",
    "        Args:",
    "            vendor_type: The vendor type this rule applies to",
    "            max_amount: Maximum allowed amount for this vendor type",
    "        \"\"\"",
    "        if max_amount <= 0:",
    "            raise ValueError(f\"max_amount must be positive, got {max_amount}\")",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = Decimal(str(max_amount))",
    "    ",
    "    def get_name(self) -> str:",
    "        return 'VendorTypeLimitRule'",
    "    ",
    "    def evaluate(self, expense: Dict[str, str]) -> Optional[Violation]:",
    "        \"\"\"Check if expense at specific vendor type exceeds limit.\"\"\"",
    "        # Only apply to matching vendor types",
    "        if expense.get('vendor_type') != self.vendor_type:",
    "            return None",
    "        ",
    "        try:",
    "            amount = Decimal(expense['amount_usd'])",
    "        except (KeyError, InvalidOperation):",
    "            return None  # Can't evaluate without valid amount",
    "        ",
    "        if amount > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense['expense_id'],",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.vendor_type} expense ${amount:.2f} exceeds limit ${self.max_amount:.2f}\"",
    "            )",
    "        return None",
    "",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"",
    "    Engine for evaluating expenses against a set of rules.",
    "    ",
    "    This class orchestrates the evaluation process without knowing",
    "    the details of individual rule implementations (Strategy Pattern).",
    "    ",
    "    Example:",
    "        >>> engine = ExpenseRulesEngine()",
    "        >>> rules = [BanRule('expense_type', 'gambling'), MaxAmountRule(500)]",
    "        >>> expenses = [{'expense_id': 'E001', 'amount_usd': '100', ...}]",
    "        >>> violations = engine.evaluate_rules(rules, expenses)",
    "    \"\"\"",
    "    ",
    "    def evaluate_rules(",
    "        self,",
    "        rules: List[Rule],",
    "        expenses: List[Dict[str, str]]",
    "    ) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate all expenses against all rules.",
    "        ",
    "        Args:",
    "            rules: List of Rule objects to evaluate",
    "            expenses: List of expense dictionaries",
    "        ",
    "        Returns:",
    "            List of Violation objects for all rule violations found.",
    "            An expense can appear multiple times if it violates multiple rules.",
    "        ",
    "        Time Complexity: O(E \u00d7 R) where E = len(expenses), R = len(rules)",
    "        Space Complexity: O(V) where V = number of violations",
    "        \"\"\"",
    "        if not rules or not expenses:",
    "            return []",
    "        ",
    "        violations: List[Violation] = []",
    "        ",
    "        # Evaluate each expense against all rules",
    "        for expense in expenses:",
    "            for rule in rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation is not None:",
    "                    violations.append(violation)",
    "        ",
    "        return violations",
    "",
    "",
    "# =============================================================================",
    "# DEMO AND TESTING",
    "# =============================================================================",
    "",
    "if __name__ == '__main__':",
    "    print('=' * 60)",
    "    print('CORPORATE EXPENSE RULES ENGINE - DEMO')",
    "    print('=' * 60)",
    "    ",
    "    # Create rules",
    "    rules = [",
    "        BanRule('expense_type', 'airfare'),",
    "        BanRule('expense_type', 'entertainment'),",
    "        MaxAmountRule(250.00),",
    "        VendorTypeLimitRule('restaurant', 75.00)",
    "    ]",
    "    ",
    "    print('\\n\ud83d\udccb Rules configured:')",
    "    print('  1. BanRule: expense_type \"airfare\" not allowed')",
    "    print('  2. BanRule: expense_type \"entertainment\" not allowed')",
    "    print('  3. MaxAmountRule: No expense over $250')",
    "    print('  4. VendorTypeLimitRule: Restaurant expenses \u2264 $75')",
    "    ",
    "    # Create test expenses",
    "    expenses = [",
    "        {",
    "            'expense_id': 'E001',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '49.99',",
    "            'expense_type': 'client_hosting',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Outback Roadhouse'",
    "        },",
    "        {",
    "            'expense_id': 'E002',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '350.00',",
    "            'expense_type': 'airfare',",
    "            'vendor_type': 'airline',",
    "            'vendor_name': 'Delta Airlines'",
    "        },",
    "        {",
    "            'expense_id': 'E003',",
    "            'trip_id': 'T002',",
    "            'amount_usd': '85.00',",
    "            'expense_type': 'meals',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Fancy Restaurant'",
    "        },",
    "        {",
    "            'expense_id': 'E004',",
    "            'trip_id': 'T002',",
    "            'amount_usd': '75.00',",
    "            'expense_type': 'meals',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Chipotle'",
    "        }",
    "    ]",
    "    ",
    "    print('\\n\ud83d\udcb3 Expenses to evaluate:')",
    "    for exp in expenses:",
    "        print(f\"  {exp['expense_id']}: ${exp['amount_usd']} - {exp['expense_type']} at {exp['vendor_type']}\")",
    "    ",
    "    # Run evaluation",
    "    engine = ExpenseRulesEngine()",
    "    violations = engine.evaluate_rules(rules, expenses)",
    "    ",
    "    print('\\n\u26a0\ufe0f  Violations found:')",
    "    if not violations:",
    "        print('  No violations! All expenses comply with rules.')",
    "    else:",
    "        for v in violations:",
    "            print(f'  {v.expense_id} | {v.rule_name} | {v.reason}')",
    "    ",
    "    # Test boundary case",
    "    print('\\n' + '=' * 60)",
    "    print('BOUNDARY TEST: $75.00 exactly at restaurant')",
    "    print('=' * 60)",
    "    boundary_violations = engine.evaluate_rules(",
    "        [VendorTypeLimitRule('restaurant', 75.00)],",
    "        [{'expense_id': 'E004', 'amount_usd': '75.00', 'vendor_type': 'restaurant'}]",
    "    )",
    "    print(f'  Result: {\"PASS (no violation)\" if not boundary_violations else \"FAIL\"}')",
    "    print('  Reason: $75.00 \u2264 $75.00 limit (inclusive)')",
    "    ",
    "    print('\\n\u2705 Demo complete!')"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "/**",
    " * Corporate Expense Rules Engine",
    " * ",
    " * A flexible, extensible rules engine for validating corporate expenses.",
    " * Uses Strategy Pattern for rule evaluation.",
    " * ",
    " * Time Complexity: O(E \u00d7 R) where E = expenses, R = rules",
    " * Space Complexity: O(V) where V = violations",
    " */",
    "",
    "/**",
    " * Represents a rule violation for an expense.",
    " */",
    "class Violation {",
    "    private final String expenseId;",
    "    private final String ruleName;",
    "    private final String reason;",
    "    ",
    "    public Violation(String expenseId, String ruleName, String reason) {",
    "        this.expenseId = expenseId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "    }",
    "    ",
    "    public String getExpenseId() { return expenseId; }",
    "    public String getRuleName() { return ruleName; }",
    "    public String getReason() { return reason; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return expenseId + \" | \" + ruleName + \" | \" + reason;",
    "    }",
    "}",
    "",
    "/**",
    " * Abstract base class for all expense rules.",
    " * Implements the Strategy Pattern.",
    " */",
    "abstract class Rule {",
    "    /**",
    "     * Evaluate an expense against this rule.",
    "     * @param expense Map containing expense fields",
    "     * @return Optional<Violation> - present if rule violated",
    "     */",
    "    public abstract Optional<Violation> evaluate(Map<String, String> expense);",
    "    ",
    "    /**",
    "     * @return The name of this rule type",
    "     */",
    "    public abstract String getName();",
    "}",
    "",
    "/**",
    " * Rule that bans expenses with specific field values.",
    " */",
    "class BanRule extends Rule {",
    "    private final String field;",
    "    private final String bannedValue;",
    "    ",
    "    public BanRule(String field, String bannedValue) {",
    "        if (!Set.of(\"expense_type\", \"vendor_type\", \"vendor_name\").contains(field)) {",
    "            throw new IllegalArgumentException(\"Invalid field: \" + field);",
    "        }",
    "        this.field = field;",
    "        this.bannedValue = bannedValue;",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() {",
    "        return \"BanRule\";",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        String actualValue = expense.getOrDefault(field, \"\");",
    "        ",
    "        if (actualValue.equals(bannedValue)) {",
    "            return Optional.of(new Violation(",
    "                expense.get(\"expense_id\"),",
    "                getName(),",
    "                field + \" '\" + bannedValue + \"' is not allowed\"",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "}",
    "",
    "/**",
    " * Rule that caps the maximum amount for any single expense.",
    " */",
    "class MaxAmountRule extends Rule {",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public MaxAmountRule(double maxAmount) {",
    "        if (maxAmount <= 0) {",
    "            throw new IllegalArgumentException(\"maxAmount must be positive\");",
    "        }",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() {",
    "        return \"MaxAmountRule\";",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        try {",
    "            BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "            ",
    "            if (amount.compareTo(maxAmount) > 0) {",
    "                return Optional.of(new Violation(",
    "                    expense.get(\"expense_id\"),",
    "                    getName(),",
    "                    String.format(\"amount $%.2f exceeds maximum $%.2f\", amount, maxAmount)",
    "                ));",
    "            }",
    "        } catch (NumberFormatException | NullPointerException e) {",
    "            return Optional.of(new Violation(",
    "                expense.getOrDefault(\"expense_id\", \"UNKNOWN\"),",
    "                getName(),",
    "                \"Invalid or missing amount_usd\"",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "}",
    "",
    "/**",
    " * Rule that caps the amount for expenses at specific vendor types.",
    " */",
    "class VendorTypeLimitRule extends Rule {",
    "    private final String vendorType;",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public VendorTypeLimitRule(String vendorType, double maxAmount) {",
    "        if (maxAmount <= 0) {",
    "            throw new IllegalArgumentException(\"maxAmount must be positive\");",
    "        }",
    "        this.vendorType = vendorType;",
    "        this.maxAmount = BigDecimal.valueOf(maxAmount);",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() {",
    "        return \"VendorTypeLimitRule\";",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Map<String, String> expense) {",
    "        // Only apply to matching vendor types",
    "        if (!vendorType.equals(expense.get(\"vendor_type\"))) {",
    "            return Optional.empty();",
    "        }",
    "        ",
    "        try {",
    "            BigDecimal amount = new BigDecimal(expense.get(\"amount_usd\"));",
    "            ",
    "            if (amount.compareTo(maxAmount) > 0) {",
    "                return Optional.of(new Violation(",
    "                    expense.get(\"expense_id\"),",
    "                    getName(),",
    "                    String.format(\"%s expense $%.2f exceeds limit $%.2f\", vendorType, amount, maxAmount)",
    "                ));",
    "            }",
    "        } catch (NumberFormatException | NullPointerException e) {",
    "            return Optional.empty();",
    "        }",
    "        return Optional.empty();",
    "    }",
    "}",
    "",
    "/**",
    " * Engine for evaluating expenses against a set of rules.",
    " */",
    "class ExpenseRulesEngine {",
    "    ",
    "    /**",
    "     * Evaluate all expenses against all rules.",
    "     * ",
    "     * @param rules List of rules to evaluate",
    "     * @param expenses List of expense maps",
    "     * @return List of all violations found",
    "     */",
    "    public List<Violation> evaluateRules(",
    "            List<Rule> rules,",
    "            List<Map<String, String>> expenses) {",
    "        ",
    "        if (rules == null || rules.isEmpty() || expenses == null || expenses.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        List<Violation> violations = new ArrayList<>();",
    "        ",
    "        for (Map<String, String> expense : expenses) {",
    "            for (Rule rule : rules) {",
    "                rule.evaluate(expense).ifPresent(violations::add);",
    "            }",
    "        }",
    "        ",
    "        return violations;",
    "    }",
    "}",
    "",
    "/**",
    " * Main class for demonstration and testing.",
    " */",
    "public class ExpenseRulesDemo {",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"CORPORATE EXPENSE RULES ENGINE - DEMO\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Create rules",
    "        List<Rule> rules = List.of(",
    "            new BanRule(\"expense_type\", \"airfare\"),",
    "            new BanRule(\"expense_type\", \"entertainment\"),",
    "            new MaxAmountRule(250.00),",
    "            new VendorTypeLimitRule(\"restaurant\", 75.00)",
    "        );",
    "        ",
    "        System.out.println(\"\\n\ud83d\udccb Rules configured:\");",
    "        System.out.println(\"  1. BanRule: expense_type 'airfare' not allowed\");",
    "        System.out.println(\"  2. BanRule: expense_type 'entertainment' not allowed\");",
    "        System.out.println(\"  3. MaxAmountRule: No expense over $250\");",
    "        System.out.println(\"  4. VendorTypeLimitRule: Restaurant expenses \u2264 $75\");",
    "        ",
    "        // Create test expenses",
    "        List<Map<String, String>> expenses = List.of(",
    "            Map.of(",
    "                \"expense_id\", \"E001\",",
    "                \"amount_usd\", \"49.99\",",
    "                \"expense_type\", \"client_hosting\",",
    "                \"vendor_type\", \"restaurant\"",
    "            ),",
    "            Map.of(",
    "                \"expense_id\", \"E002\",",
    "                \"amount_usd\", \"350.00\",",
    "                \"expense_type\", \"airfare\",",
    "                \"vendor_type\", \"airline\"",
    "            ),",
    "            Map.of(",
    "                \"expense_id\", \"E003\",",
    "                \"amount_usd\", \"85.00\",",
    "                \"expense_type\", \"meals\",",
    "                \"vendor_type\", \"restaurant\"",
    "            )",
    "        );",
    "        ",
    "        System.out.println(\"\\n\ud83d\udcb3 Expenses to evaluate:\");",
    "        for (Map<String, String> exp : expenses) {",
    "            System.out.printf(\"  %s: $%s - %s at %s%n\",",
    "                exp.get(\"expense_id\"),",
    "                exp.get(\"amount_usd\"),",
    "                exp.get(\"expense_type\"),",
    "                exp.get(\"vendor_type\")",
    "            );",
    "        }",
    "        ",
    "        // Run evaluation",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "        List<Violation> violations = engine.evaluateRules(rules, expenses);",
    "        ",
    "        System.out.println(\"\\n\u26a0\ufe0f  Violations found:\");",
    "        if (violations.isEmpty()) {",
    "            System.out.println(\"  No violations! All expenses comply.\");",
    "        } else {",
    "            for (Violation v : violations) {",
    "                System.out.println(\"  \" + v);",
    "            }",
    "        }",
    "        ",
    "        System.out.println(\"\\n\u2705 Demo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-14",
      "section": "Module Docstring & Imports",
      "explanation": "We import `ABC` and `abstractmethod` for the abstract base class pattern, `dataclass` for clean data structures, and critically **`Decimal`** for precise monetary calculations. Using `float` for currency is a common interview mistake!"
    },
    {
      "lines": "17-34",
      "section": "Violation Dataclass",
      "explanation": "The `Violation` class is a **frozen dataclass** (immutable). It captures three essential pieces: `expense_id` (which expense), `rule_name` (which rule), and `reason` (why it failed). This clean design makes violations easy to report and test."
    },
    {
      "lines": "37-66",
      "section": "Abstract Rule Class",
      "explanation": "This is the **Strategy Pattern** interface. All rule types must implement `evaluate()` and `get_name()`. The engine will call these methods polymorphically without knowing the concrete rule type. This achieves **Open/Closed Principle** - new rules can be added without modifying the engine."
    },
    {
      "lines": "69-103",
      "section": "BanRule Implementation",
      "explanation": "BanRule blocks expenses by field value. Note the **input validation** in `__init__` (only allowed fields). The `evaluate()` method is simple: check if the expense's field matches the banned value. If yes, return a Violation; if no, return None."
    },
    {
      "lines": "106-149",
      "section": "MaxAmountRule Implementation",
      "explanation": "MaxAmountRule caps individual expense amounts. **Key detail**: we convert the string amount to `Decimal` for precise comparison. The `try/except` handles invalid amounts gracefully - a production-quality touch that impresses interviewers."
    },
    {
      "lines": "152-197",
      "section": "VendorTypeLimitRule Implementation",
      "explanation": "This rule only applies to specific vendor types. **Important pattern**: first check if this rule even applies (vendor type match), then evaluate the amount. This is a common pattern for conditional rules."
    },
    {
      "lines": "200-243",
      "section": "ExpenseRulesEngine",
      "explanation": "The engine orchestrates evaluation. It's **deliberately simple** - just nested loops calling `rule.evaluate()`. This is the beauty of Strategy Pattern: the engine doesn't know or care how each rule evaluates. Adding a new rule type requires **zero changes** to this class."
    },
    {
      "lines": "246-310",
      "section": "Demo & Testing",
      "explanation": "A complete runnable demo that tests multiple scenarios: normal expenses, banned types, amount limits, and boundary cases. **Always include a demo** - it shows the interviewer your code actually works and demonstrates the API usage."
    }
  ],
  "complexity_analysis": {
    "time": {
      "evaluate_rules": {
        "complexity": "O(E \u00d7 R)",
        "explanation": "For each of E expenses, we evaluate R rules. Each rule evaluation is O(1) - just field lookups and comparisons."
      },
      "per_rule_evaluate": {
        "complexity": "O(1)",
        "explanation": "Each rule does constant-time operations: dictionary lookup, string comparison, or numeric comparison."
      },
      "overall": "**O(E \u00d7 R)** where E = number of expenses (up to 1000), R = number of rules (up to 50). Worst case: 50,000 evaluations, which is very fast."
    },
    "space": {
      "complexity": "O(V)",
      "breakdown": "- **Rules storage**: O(R) - just references, minimal space\n- **Expenses**: O(E) - input, not our overhead\n- **Violations list**: O(V) - proportional to violations found\n- **Per-evaluation**: O(1) - no additional structures",
      "note": "In the worst case, every expense violates every rule, so V = E \u00d7 R. But typically V << E \u00d7 R."
    },
    "can_we_do_better": "Not significantly. We must evaluate each expense against each applicable rule. Some optimizations are possible (e.g., index rules by type, skip inapplicable rules early), but they add complexity without major gains for the given constraints."
  },
  "dry_run": {
    "example": "Rules: [BanRule(airfare), MaxAmountRule(250), VendorTypeLimitRule(restaurant,75)]\nExpenses: [E001:$49.99/restaurant, E002:$350/airfare, E003:$85/restaurant]",
    "trace_table": "| Expense | Rule | Check | Result | Violation |\n|---------|------|-------|--------|----------|\n| E001 ($49.99, client_hosting, restaurant) | BanRule(airfare) | expense_type='client_hosting' \u2260 'airfare' | \u2713 PASS | None |\n| E001 | MaxAmountRule(250) | 49.99 \u2264 250 | \u2713 PASS | None |\n| E001 | VendorTypeLimitRule(restaurant,75) | vendor_type='restaurant' \u2713, 49.99 \u2264 75 | \u2713 PASS | None |\n| E002 ($350, airfare, airline) | BanRule(airfare) | expense_type='airfare' == 'airfare' | \u2717 FAIL | **V1**: airfare not allowed |\n| E002 | MaxAmountRule(250) | 350 > 250 | \u2717 FAIL | **V2**: $350 > $250 |\n| E002 | VendorTypeLimitRule(restaurant,75) | vendor_type='airline' \u2260 'restaurant' | \u2713 N/A | None |\n| E003 ($85, meals, restaurant) | BanRule(airfare) | expense_type='meals' \u2260 'airfare' | \u2713 PASS | None |\n| E003 | MaxAmountRule(250) | 85 \u2264 250 | \u2713 PASS | None |\n| E003 | VendorTypeLimitRule(restaurant,75) | vendor_type='restaurant' \u2713, 85 > 75 | \u2717 FAIL | **V3**: $85 > $75 |",
    "final_answer": "3 violations: [V1: E002/BanRule/airfare banned, V2: E002/MaxAmountRule/$350>$250, V3: E003/VendorTypeLimitRule/$85>$75]"
  },
  "test_cases": [
    {
      "name": "Basic - Single expense passes all rules",
      "category": "Happy Path",
      "input": "rules=[MaxAmountRule(100)], expenses=[{expense_id:'E001', amount_usd:'50.00'}]",
      "expected": "[] (empty - no violations)",
      "explanation": "$50 < $100 limit, so no violation"
    },
    {
      "name": "Basic - Single expense fails single rule",
      "category": "Happy Path",
      "input": "rules=[MaxAmountRule(100)], expenses=[{expense_id:'E001', amount_usd:'150.00'}]",
      "expected": "[Violation(E001, MaxAmountRule, amount $150.00 exceeds maximum $100.00)]",
      "explanation": "$150 > $100 limit triggers violation"
    },
    {
      "name": "Multiple violations - Same expense fails multiple rules",
      "category": "Core Logic",
      "input": "rules=[BanRule(expense_type,airfare), MaxAmountRule(250)], expenses=[{expense_id:'E001', amount_usd:'350.00', expense_type:'airfare'}]",
      "expected": "2 violations: BanRule + MaxAmountRule",
      "explanation": "Both rules fail - must return BOTH violations, not just first"
    },
    {
      "name": "Boundary - Exactly at limit (inclusive)",
      "category": "Edge Case",
      "input": "rules=[MaxAmountRule(75)], expenses=[{expense_id:'E001', amount_usd:'75.00'}]",
      "expected": "[] (empty - no violations)",
      "explanation": "$75.00 is NOT greater than $75.00, so it passes. Limit is inclusive."
    },
    {
      "name": "Boundary - Just over limit",
      "category": "Edge Case",
      "input": "rules=[MaxAmountRule(75)], expenses=[{expense_id:'E001', amount_usd:'75.01'}]",
      "expected": "[Violation(E001, MaxAmountRule, amount $75.01 exceeds maximum $75.00)]",
      "explanation": "$75.01 > $75.00 by just one cent - tests decimal precision"
    },
    {
      "name": "VendorTypeLimit - Non-matching vendor type",
      "category": "Core Logic",
      "input": "rules=[VendorTypeLimitRule(restaurant,75)], expenses=[{expense_id:'E001', amount_usd:'500.00', vendor_type:'airline'}]",
      "expected": "[] (empty - no violations)",
      "explanation": "Rule only applies to restaurants; airline expenses are not checked by this rule"
    },
    {
      "name": "Empty rules list",
      "category": "Edge Case",
      "input": "rules=[], expenses=[{expense_id:'E001', amount_usd:'1000000.00'}]",
      "expected": "[] (empty)",
      "explanation": "No rules = no violations possible"
    },
    {
      "name": "Empty expenses list",
      "category": "Edge Case",
      "input": "rules=[MaxAmountRule(100)], expenses=[]",
      "expected": "[] (empty)",
      "explanation": "No expenses = nothing to evaluate"
    },
    {
      "name": "Decimal precision trap",
      "category": "Gotcha",
      "input": "rules=[MaxAmountRule(0.3)], expenses=[{expense_id:'E001', amount_usd:'0.1'}, {expense_id:'E002', amount_usd:'0.1'}, {expense_id:'E003', amount_usd:'0.1'}]",
      "expected": "All pass (0.1 \u2264 0.3 for each)",
      "gotcha": "Using float: 0.1 + 0.1 + 0.1 = 0.30000000000000004. Decimal avoids this."
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float/double for currency comparisons",
      "why_wrong": "Floating-point arithmetic is imprecise: `0.1 + 0.1 + 0.1 != 0.3` in float. This causes incorrect boundary comparisons.",
      "correct_approach": "Use `Decimal` (Python) or `BigDecimal` (Java) for all monetary calculations",
      "code_wrong": "amount = float(expense['amount_usd'])\nif amount > self.max_amount:  # float comparison",
      "code_correct": "amount = Decimal(expense['amount_usd'])\nif amount > self.max_amount:  # Decimal comparison"
    },
    {
      "mistake": "Short-circuiting after first violation per expense",
      "why_wrong": "The problem states one expense can violate multiple rules. Returning only the first violation loses important information.",
      "correct_approach": "Always evaluate ALL rules for each expense and collect ALL violations",
      "code_wrong": "for rule in rules:\n    if violation := rule.evaluate(expense):\n        violations.append(violation)\n        break  # WRONG! Stops after first violation",
      "code_correct": "for rule in rules:\n    if violation := rule.evaluate(expense):\n        violations.append(violation)  # No break - continue checking"
    },
    {
      "mistake": "Hardcoding rule types in the engine",
      "why_wrong": "Violates Open/Closed Principle. Adding new rule types requires modifying the engine.",
      "correct_approach": "Use polymorphism - engine calls rule.evaluate() without knowing the concrete type",
      "code_wrong": "for rule in rules:\n    if rule.type == 'ban':\n        # ban logic\n    elif rule.type == 'max_amount':\n        # max amount logic",
      "code_correct": "for rule in rules:\n    violation = rule.evaluate(expense)  # Polymorphic dispatch"
    },
    {
      "mistake": "Not validating input or handling missing fields",
      "why_wrong": "Real expense data may have missing or malformed fields. Crashing on bad data is unprofessional.",
      "correct_approach": "Use .get() with defaults, try/except for parsing, and graceful error handling",
      "code_wrong": "amount = Decimal(expense['amount_usd'])  # KeyError if missing",
      "code_correct": "try:\n    amount = Decimal(expense.get('amount_usd', '0'))\nexcept InvalidOperation:\n    # Handle gracefully"
    },
    {
      "mistake": "Using >= instead of > for limit comparisons",
      "why_wrong": "The problem says 'cannot exceed X', which typically means > not >=. $75.00 at a $75.00 limit should pass.",
      "correct_approach": "Use > for 'exceeds' comparisons, clarify with interviewer if unsure",
      "code_wrong": "if amount >= self.max_amount:  # Fails at exactly the limit",
      "code_correct": "if amount > self.max_amount:  # Passes at exactly the limit"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem! Before I start coding, I'd like to clarify a few things and discuss my approach. This looks like a **Rules Engine design problem** - I'm thinking Strategy Pattern would be a good fit here. Let me ask some questions first...",
    "clarifying_questions_to_ask": [
      "**Should rule evaluation order matter?** (Probably not, but good to confirm)",
      "**Are amounts always valid decimal strings, or should I handle malformed data?**",
      "**Is the comparison strictly greater than ($75.01 fails) or greater than or equal ($75.00 fails)?**",
      "**Can the same rule type appear multiple times with different parameters?** (e.g., multiple BanRules)",
      "**How should violations be ordered in the output?** (By expense, by rule, or doesn't matter?)",
      "**Should I prioritize extensibility or performance?** (Guides design decisions)"
    ],
    "what_to_mention_proactively": [
      "I'll use the **Strategy Pattern** - each rule type encapsulates its own evaluation logic",
      "I'll use **Decimal/BigDecimal** for currency to avoid floating-point precision issues",
      "The design follows **Open/Closed Principle** - adding new rules won't require modifying existing code",
      "Let me define the **Violation return type** first since it's central to the API",
      "I'll trace through an example after coding to verify correctness"
    ],
    "communication_during_coding": [
      "Now I'm defining the abstract Rule class - this is the Strategy interface...",
      "For BanRule, I'm checking if the field value matches the banned value...",
      "I'm using Decimal here to avoid float precision issues with currency...",
      "The engine is simple by design - it just iterates and delegates to rules...",
      "Let me add some input validation to handle edge cases..."
    ],
    "if_stuck": [
      "**Step back**: What's the core requirement? Evaluate expenses against rules.",
      "**Simplify**: Start with just MaxAmountRule, get that working, then add others",
      "**Draw it**: Sketch the class diagram - Rule interface, concrete implementations",
      "**Ask**: 'Can I simplify the return type for now and refine later?'"
    ],
    "time_management": "**0-5min**: Clarify requirements, discuss approach\n**5-10min**: Design class structure, define interfaces\n**10-30min**: Implement core classes (Rule, BanRule, MaxAmountRule, VendorTypeLimitRule)\n**30-40min**: Implement engine, test with examples\n**40-45min**: Handle edge cases, discuss extensions"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Rule Engine",
    "indicators": [
      "Multiple algorithm variants (different rule types)",
      "'Easy to add new types' requirement \u2192 extensibility needed",
      "Each type has same interface but different behavior",
      "Evaluation/validation against multiple criteria"
    ],
    "similar_problems": [
      "**LC 146 LRU Cache** - Different eviction strategies (Strategy Pattern)",
      "**Validation frameworks** - Bean Validation, express-validator",
      "**Payment processors** - Different payment method handlers",
      "**Filter systems** - Email spam filters with multiple rules",
      "**Authorization systems** - Multiple permission checks"
    ],
    "template": "```\n1. Define abstract Strategy (Rule) with common interface\n2. Implement concrete strategies (BanRule, MaxAmountRule, etc.)\n3. Create Context (Engine) that uses strategies polymorphically\n4. Iterate and delegate - Context doesn't know concrete types\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Trip-Level Aggregation** - Rules that limit total spending per trip. You'll need to aggregate expenses by trip_id and track running totals. Consider using a `HashMap<trip_id, total>` to accumulate amounts before checking limits.",
    "part_3_hint": "**Part 3: Rule Creation API** - A builder/factory pattern for creating rules from JSON/config. Think about how to deserialize rule specifications into Rule objects dynamically.",
    "data_structure_evolution": "**Part 1**: Rule interface + concrete classes \u2192 **Part 2**: Add trip aggregation with HashMap \u2192 **Part 3**: Add RuleFactory for dynamic rule creation"
  },
  "generated_at": "2026-01-14T15:06:58.635183",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}