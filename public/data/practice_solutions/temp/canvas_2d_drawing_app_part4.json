{
  "problem_title": "2D Canvas / Drawing Application - Part 4: Undo/Redo Support",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 transforms the Canvas from a simple state container into a **reversible operation system**. Every operation (create, move, delete, z-order changes) must now be encapsulated as a Command object that knows how to both execute itself AND reverse itself. This requires refactoring the Canvas to route all mutations through a command execution pipeline while maintaining two stacks for history management.",
    "new_requirements": [
      "Implement Command Pattern with execute() and undo() methods",
      "Create concrete command classes for all 6 operations",
      "Maintain undoStack to track executed commands",
      "Maintain redoStack to track undone commands",
      "Clear redoStack when any new operation is executed",
      "Handle no-op gracefully when stacks are empty"
    ],
    "new_constraints": [
      "Each command must store sufficient state to reverse itself completely",
      "Shape positions, z-order indices, and shape data must be captured before mutation",
      "State capture must happen only on first execute() to support redo correctly",
      "Commands must handle edge cases where shapes may not exist"
    ],
    "key_insight": "The Command Pattern decouples 'what to do' from 'when to do it'. Each command is a first-class object that encapsulates: (1) the action parameters, (2) the pre-mutation state needed for undo, and (3) both execute and undo logic. The trick is capturing state BEFORE mutation and storing it in the command object, not the canvas."
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 3):                     AFTER (Part 4):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Canvas        \u2502               \u2502            Canvas                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 shapes: HashMap    \u2502               \u2502 shapes: HashMap                    \u2502\n\u2502 z_order: List      \u2502               \u2502 z_order: List                      \u2502\n\u2502 counters           \u2502               \u2502 counters                           \u2502\n\u2502                    \u2502               \u2502 undoStack: List<Command>  \u2190NEW     \u2502\n\u2502                    \u2502               \u2502 redoStack: List<Command>  \u2190NEW     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 createRectangle()  \u2502               \u2502 createRectangle()                  \u2502\n\u2502 createCircle()     \u2502               \u2502   \u2514\u2500\u25ba CreateRectCommand.execute()  \u2502\n\u2502 moveShape()        \u2502               \u2502 moveShape()                        \u2502\n\u2502 deleteShape()      \u2502               \u2502   \u2514\u2500\u25ba MoveCommand.execute()        \u2502\n\u2502 bringToFront()     \u2502               \u2502 undo()  \u2190NEW                       \u2502\n\u2502 sendToBack()       \u2502               \u2502 redo()  \u2190NEW                       \u2502\n\u2502 getShapeAt()       \u2502               \u2502 getShapeAt() (unchanged)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nCOMMAND EXECUTION FLOW:\n\n1. User calls: canvas.moveShape(\"rect_1\", 100, 50)\n   \u2502\n   \u25bc\n2. Canvas creates: MoveCommand(canvas, \"rect_1\", 100, 50)\n   \u2502\n   \u25bc\n3. MoveCommand.execute():\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 \u2022 Capture old position (10, 20)    \u2502\n   \u2502 \u2022 Update shape to new position     \u2502\n   \u2502 \u2022 Store: old_x=10, old_y=20        \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502\n   \u25bc\n4. Push command to undoStack, clear redoStack\n\nUNDO FLOW:\n\n1. User calls: canvas.undo()\n   \u2502\n   \u25bc\n2. Pop MoveCommand from undoStack\n   \u2502\n   \u25bc\n3. MoveCommand.undo():\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 \u2022 Restore shape to (10, 20)        \u2502\n   \u2502 \u2022 Uses stored old_x, old_y         \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502\n   \u25bc\n4. Push command to redoStack\n\nREDO FLOW:\n\n1. User calls: canvas.redo()\n   \u2502\n   \u25bc\n2. Pop MoveCommand from redoStack\n   \u2502\n   \u25bc\n3. MoveCommand.execute():\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 \u2022 Move shape to (100, 50) again    \u2502\n   \u2502 \u2022 Uses stored new_x, new_y         \u2502\n   \u2502 \u2022 Does NOT re-capture old position \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   \u2502\n   \u25bc\n4. Push command back to undoStack\n\n\nSTATE STORAGE PER COMMAND TYPE:\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 CreateCommand                                                \u2502\n\u2502   stores: shape_id, shape_type, creation_params             \u2502\n\u2502   execute: add shape to canvas                              \u2502\n\u2502   undo: remove shape from canvas                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MoveCommand                                                  \u2502\n\u2502   stores: shape_id, old_position, new_position              \u2502\n\u2502   execute: move to new_position                             \u2502\n\u2502   undo: move to old_position                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 DeleteCommand                                                \u2502\n\u2502   stores: shape_id, shape_clone, z_order_index              \u2502\n\u2502   execute: remove shape                                     \u2502\n\u2502   undo: restore shape at exact z-index                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 BringToFront / SendToBack                                    \u2502\n\u2502   stores: shape_id, original_z_index                        \u2502\n\u2502   execute: move to front/back                               \u2502\n\u2502   undo: restore to original_z_index                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```"
  },
  "approaches": [
    {
      "name": "Naive State Snapshot Approach",
      "description": "Save a complete deep copy of the entire canvas state (all shapes + z_order) before every operation. Undo by restoring the previous snapshot.",
      "time_complexity": "O(n) per operation for snapshot",
      "space_complexity": "O(n \u00d7 m) where n=shapes, m=operations",
      "why_not_optimal": "Memory explodes with many operations. For a canvas with 1000 shapes and 100 operations, we'd store 100,000 shape copies. Also wastes CPU copying unchanged shapes. Real-world apps can have millions of undo steps."
    },
    {
      "name": "Optimal Command Pattern",
      "description": "Each operation creates a lightweight Command object storing only the delta/state needed to reverse that specific operation. Commands know how to execute() and undo() themselves.",
      "time_complexity": "O(1) for undo/redo stack operations + O(operation_cost)",
      "space_complexity": "O(k) where k=number of operations (each stores minimal state)",
      "key_insight": "Store the **delta**, not the whole state. MoveCommand only stores old and new positions (4 numbers), not the entire canvas. DeleteCommand stores one shape copy, not all shapes. This is O(1) per command vs O(n) per snapshot."
    }
  ],
  "optimal_solution": {
    "explanation_md": "The **Command Pattern** is the textbook solution for undo/redo, and this problem demonstrates exactly why.\n\n**Core Architecture:**\n\n1. **Command Interface**: Abstract base with `execute()` and `undo()` methods\n\n2. **Concrete Commands**: One class per operation type, each storing:\n   - Reference to the Canvas (the receiver)\n   - Operation parameters (what to do)\n   - Captured state (what was there before)\n\n3. **Command Stacks**: \n   - `undoStack`: Commands that have been executed\n   - `redoStack`: Commands that have been undone\n\n**The Critical Insight - State Capture Timing:**\n\nThe trickiest part is **when** to capture the pre-mutation state:\n- Must capture BEFORE the mutation happens\n- Must capture ONLY ONCE (for redo to work correctly)\n- Solution: Use a `_state_captured` flag in each command\n\n**Why This Works for Redo:**\n\nWhen `redo()` calls `execute()` again, the command already has:\n- The `new` values from construction\n- The `old` values from first execution\n\nSo it just applies the `new` values without re-capturing.\n\n**Handling Z-Order Commands:**\n\nFor `bringToFront`/`sendToBack`, we store the **absolute index** before the operation. On undo, we restore to that exact index. This works because undo/redo are strictly sequential and new operations clear the redo stack.",
    "data_structures": [
      {
        "structure": "Command (ABC)",
        "purpose": "Abstract interface ensuring all commands have execute() and undo()"
      },
      {
        "structure": "List<Command> undoStack",
        "purpose": "Stack of executed commands, most recent on top"
      },
      {
        "structure": "List<Command> redoStack",
        "purpose": "Stack of undone commands, cleared on new operations"
      },
      {
        "structure": "Shape.clone()",
        "purpose": "Deep copy shapes for DeleteCommand to restore exact state"
      }
    ],
    "algorithm_steps": [
      "Step 1: Define Command abstract base class with execute() and undo() methods",
      "Step 2: Create concrete command classes for each operation (Create, Move, Delete, BringToFront, SendToBack)",
      "Step 3: Each command constructor takes Canvas reference and operation parameters",
      "Step 4: execute() captures pre-mutation state (if not captured), then performs mutation",
      "Step 5: undo() reverses the mutation using captured state",
      "Step 6: Canvas routes all operations through _execute_command() helper",
      "Step 7: _execute_command() calls execute(), pushes to undoStack, clears redoStack",
      "Step 8: undo() pops from undoStack, calls command.undo(), pushes to redoStack",
      "Step 9: redo() pops from redoStack, calls command.execute(), pushes to undoStack"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict, Any, Union",
    "import math",
    "",
    "",
    "# ============================================================================",
    "# COMMAND INTERFACE",
    "# ============================================================================",
    "",
    "class Command(ABC):",
    "    \"\"\"Abstract base class for all undoable commands.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def execute(self) -> Any:",
    "        \"\"\"Execute the command and return result (if any).\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def undo(self) -> None:",
    "        \"\"\"Reverse the effects of execute().\"\"\"",
    "        pass",
    "",
    "",
    "# ============================================================================",
    "# SHAPE CLASSES",
    "# ============================================================================",
    "",
    "class Shape(ABC):",
    "    \"\"\"Abstract base class for all shapes.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str):",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains_point(self, x: float, y: float) -> bool:",
    "        \"\"\"Check if point (x, y) is inside this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def clone(self) -> 'Shape':",
    "        \"\"\"Create a deep copy of this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_position(self) -> tuple:",
    "        \"\"\"Get the reference position of this shape.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def set_position(self, x: float, y: float) -> None:",
    "        \"\"\"Set the reference position of this shape.\"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"Rectangle defined by top-left corner, width, and height.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, x: float, y: float, ",
    "                 width: float, height: float):",
    "        super().__init__(shape_id)",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "    ",
    "    def contains_point(self, px: float, py: float) -> bool:",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "    ",
    "    def clone(self) -> 'Rectangle':",
    "        return Rectangle(self.id, self.x, self.y, self.width, self.height)",
    "    ",
    "    def get_position(self) -> tuple:",
    "        return (self.x, self.y)",
    "    ",
    "    def set_position(self, x: float, y: float) -> None:",
    "        self.x = x",
    "        self.y = y",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"Circle defined by center point and radius.\"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, center_x: float, ",
    "                 center_y: float, radius: float):",
    "        super().__init__(shape_id)",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "    ",
    "    def contains_point(self, px: float, py: float) -> bool:",
    "        dx = px - self.center_x",
    "        dy = py - self.center_y",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "    ",
    "    def clone(self) -> 'Circle':",
    "        return Circle(self.id, self.center_x, self.center_y, self.radius)",
    "    ",
    "    def get_position(self) -> tuple:",
    "        return (self.center_x, self.center_y)",
    "    ",
    "    def set_position(self, x: float, y: float) -> None:",
    "        self.center_x = x",
    "        self.center_y = y",
    "",
    "",
    "# ============================================================================",
    "# CONCRETE COMMAND CLASSES",
    "# ============================================================================",
    "",
    "class CreateRectangleCommand(Command):",
    "    \"\"\"Command to create a rectangle on the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str, ",
    "                 x: float, y: float, width: float, height: float):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._x = x",
    "        self._y = y",
    "        self._width = width",
    "        self._height = height",
    "    ",
    "    def execute(self) -> str:",
    "        shape = Rectangle(self._shape_id, self._x, self._y, ",
    "                         self._width, self._height)",
    "        self._canvas._internal_add_shape(shape)",
    "        return self._shape_id",
    "    ",
    "    def undo(self) -> None:",
    "        self._canvas._internal_remove_shape(self._shape_id)",
    "",
    "",
    "class CreateCircleCommand(Command):",
    "    \"\"\"Command to create a circle on the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str,",
    "                 center_x: float, center_y: float, radius: float):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._center_x = center_x",
    "        self._center_y = center_y",
    "        self._radius = radius",
    "    ",
    "    def execute(self) -> str:",
    "        shape = Circle(self._shape_id, self._center_x, ",
    "                      self._center_y, self._radius)",
    "        self._canvas._internal_add_shape(shape)",
    "        return self._shape_id",
    "    ",
    "    def undo(self) -> None:",
    "        self._canvas._internal_remove_shape(self._shape_id)",
    "",
    "",
    "class MoveCommand(Command):",
    "    \"\"\"Command to move a shape to a new position.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str, ",
    "                 new_x: float, new_y: float):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._new_x = new_x",
    "        self._new_y = new_y",
    "        self._old_x: float = 0.0",
    "        self._old_y: float = 0.0",
    "        self._state_captured = False",
    "    ",
    "    def execute(self) -> None:",
    "        shape = self._canvas._internal_get_shape(self._shape_id)",
    "        if shape is None:",
    "            return",
    "        ",
    "        # Capture old state only on first execution (for redo support)",
    "        if not self._state_captured:",
    "            self._old_x, self._old_y = shape.get_position()",
    "            self._state_captured = True",
    "        ",
    "        shape.set_position(self._new_x, self._new_y)",
    "    ",
    "    def undo(self) -> None:",
    "        shape = self._canvas._internal_get_shape(self._shape_id)",
    "        if shape is None:",
    "            return",
    "        shape.set_position(self._old_x, self._old_y)",
    "",
    "",
    "class DeleteCommand(Command):",
    "    \"\"\"Command to delete a shape from the canvas.\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._deleted_shape: Optional[Shape] = None",
    "        self._z_index: int = 0",
    "        self._state_captured = False",
    "    ",
    "    def execute(self) -> None:",
    "        shape = self._canvas._internal_get_shape(self._shape_id)",
    "        if shape is None:",
    "            return",
    "        ",
    "        # Capture state only on first execution",
    "        if not self._state_captured:",
    "            self._deleted_shape = shape.clone()",
    "            self._z_index = self._canvas._internal_get_z_index(self._shape_id)",
    "            self._state_captured = True",
    "        ",
    "        self._canvas._internal_remove_shape(self._shape_id)",
    "    ",
    "    def undo(self) -> None:",
    "        if self._deleted_shape is None:",
    "            return",
    "        # Restore shape at its exact z-index",
    "        self._canvas._internal_restore_shape(",
    "            self._deleted_shape.clone(), self._z_index)",
    "",
    "",
    "class BringToFrontCommand(Command):",
    "    \"\"\"Command to bring a shape to the front (topmost).\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._old_z_index: int = 0",
    "        self._state_captured = False",
    "    ",
    "    def execute(self) -> None:",
    "        if not self._canvas._internal_has_shape(self._shape_id):",
    "            return",
    "        ",
    "        if not self._state_captured:",
    "            self._old_z_index = self._canvas._internal_get_z_index(self._shape_id)",
    "            self._state_captured = True",
    "        ",
    "        self._canvas._internal_set_z_index(self._shape_id, 0)",
    "    ",
    "    def undo(self) -> None:",
    "        if not self._canvas._internal_has_shape(self._shape_id):",
    "            return",
    "        self._canvas._internal_set_z_index(self._shape_id, self._old_z_index)",
    "",
    "",
    "class SendToBackCommand(Command):",
    "    \"\"\"Command to send a shape to the back (bottommost).\"\"\"",
    "    ",
    "    def __init__(self, canvas: 'Canvas', shape_id: str):",
    "        self._canvas = canvas",
    "        self._shape_id = shape_id",
    "        self._old_z_index: int = 0",
    "        self._state_captured = False",
    "    ",
    "    def execute(self) -> None:",
    "        if not self._canvas._internal_has_shape(self._shape_id):",
    "            return",
    "        ",
    "        if not self._state_captured:",
    "            self._old_z_index = self._canvas._internal_get_z_index(self._shape_id)",
    "            self._state_captured = True",
    "        ",
    "        back_index = self._canvas._internal_get_shape_count() - 1",
    "        self._canvas._internal_set_z_index(self._shape_id, back_index)",
    "    ",
    "    def undo(self) -> None:",
    "        if not self._canvas._internal_has_shape(self._shape_id):",
    "            return",
    "        self._canvas._internal_set_z_index(self._shape_id, self._old_z_index)",
    "",
    "",
    "# ============================================================================",
    "# CANVAS CLASS WITH UNDO/REDO SUPPORT",
    "# ============================================================================",
    "",
    "class Canvas:",
    "    \"\"\"",
    "    2D Canvas supporting shape creation, manipulation, and undo/redo.",
    "    ",
    "    Implements the Command Pattern for full undo/redo support of all",
    "    operations including create, move, delete, and z-order changes.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Shape storage",
    "        self._shapes: Dict[str, Shape] = {}",
    "        self._z_order: List[str] = []  # Index 0 = front (topmost)",
    "        ",
    "        # ID counters",
    "        self._rect_counter = 0",
    "        self._circle_counter = 0",
    "        ",
    "        # Command stacks for undo/redo",
    "        self._undo_stack: List[Command] = []",
    "        self._redo_stack: List[Command] = []",
    "    ",
    "    # ========================================================================",
    "    # INTERNAL METHODS (Used by Commands)",
    "    # ========================================================================",
    "    ",
    "    def _internal_add_shape(self, shape: Shape) -> None:",
    "        \"\"\"Add shape to canvas at front (topmost).\"\"\"",
    "        self._shapes[shape.id] = shape",
    "        self._z_order.insert(0, shape.id)",
    "    ",
    "    def _internal_remove_shape(self, shape_id: str) -> None:",
    "        \"\"\"Remove shape from canvas.\"\"\"",
    "        if shape_id in self._shapes:",
    "            del self._shapes[shape_id]",
    "            self._z_order.remove(shape_id)",
    "    ",
    "    def _internal_restore_shape(self, shape: Shape, z_index: int) -> None:",
    "        \"\"\"Restore shape at specific z-index.\"\"\"",
    "        self._shapes[shape.id] = shape",
    "        self._z_order.insert(z_index, shape.id)",
    "    ",
    "    def _internal_get_shape(self, shape_id: str) -> Optional[Shape]:",
    "        \"\"\"Get shape by ID.\"\"\"",
    "        return self._shapes.get(shape_id)",
    "    ",
    "    def _internal_has_shape(self, shape_id: str) -> bool:",
    "        \"\"\"Check if shape exists.\"\"\"",
    "        return shape_id in self._shapes",
    "    ",
    "    def _internal_get_z_index(self, shape_id: str) -> int:",
    "        \"\"\"Get z-index of shape (0 = front).\"\"\"",
    "        return self._z_order.index(shape_id)",
    "    ",
    "    def _internal_set_z_index(self, shape_id: str, index: int) -> None:",
    "        \"\"\"Set z-index of shape.\"\"\"",
    "        self._z_order.remove(shape_id)",
    "        self._z_order.insert(index, shape_id)",
    "    ",
    "    def _internal_get_shape_count(self) -> int:",
    "        \"\"\"Get total number of shapes.\"\"\"",
    "        return len(self._shapes)",
    "    ",
    "    # ========================================================================",
    "    # COMMAND EXECUTION PIPELINE",
    "    # ========================================================================",
    "    ",
    "    def _execute_command(self, command: Command) -> Any:",
    "        \"\"\"Execute command, add to undo stack, clear redo stack.\"\"\"",
    "        result = command.execute()",
    "        self._undo_stack.append(command)",
    "        self._redo_stack.clear()  # New operation clears redo history",
    "        return result",
    "    ",
    "    # ========================================================================",
    "    # PUBLIC API - Shape Creation",
    "    # ========================================================================",
    "    ",
    "    def createRectangle(self, x: float, y: float, ",
    "                        width: float, height: float) -> str:",
    "        \"\"\"",
    "        Create a rectangle on the canvas.",
    "        ",
    "        Args:",
    "            x: X coordinate of top-left corner",
    "            y: Y coordinate of top-left corner",
    "            width: Width of rectangle",
    "            height: Height of rectangle",
    "            ",
    "        Returns:",
    "            Shape ID in format 'rect_N'",
    "        \"\"\"",
    "        self._rect_counter += 1",
    "        shape_id = f\"rect_{self._rect_counter}\"",
    "        command = CreateRectangleCommand(self, shape_id, x, y, width, height)",
    "        return self._execute_command(command)",
    "    ",
    "    def createCircle(self, center_x: float, center_y: float, ",
    "                     radius: float) -> str:",
    "        \"\"\"",
    "        Create a circle on the canvas.",
    "        ",
    "        Args:",
    "            center_x: X coordinate of center",
    "            center_y: Y coordinate of center",
    "            radius: Radius of circle",
    "            ",
    "        Returns:",
    "            Shape ID in format 'circle_N'",
    "        \"\"\"",
    "        self._circle_counter += 1",
    "        shape_id = f\"circle_{self._circle_counter}\"",
    "        command = CreateCircleCommand(self, shape_id, center_x, center_y, radius)",
    "        return self._execute_command(command)",
    "    ",
    "    # ========================================================================",
    "    # PUBLIC API - Shape Manipulation",
    "    # ========================================================================",
    "    ",
    "    def moveShape(self, shape_id: str, new_x: float, new_y: float) -> None:",
    "        \"\"\"",
    "        Move a shape to a new position.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to move",
    "            new_x: New X coordinate (top-left for rect, center for circle)",
    "            new_y: New Y coordinate",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = MoveCommand(self, shape_id, new_x, new_y)",
    "        self._execute_command(command)",
    "    ",
    "    def deleteShape(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Delete a shape from the canvas.",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to delete",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = DeleteCommand(self, shape_id)",
    "        self._execute_command(command)",
    "    ",
    "    # ========================================================================",
    "    # PUBLIC API - Z-Order Control",
    "    # ========================================================================",
    "    ",
    "    def bringToFront(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Bring a shape to the front (topmost).",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to bring forward",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = BringToFrontCommand(self, shape_id)",
    "        self._execute_command(command)",
    "    ",
    "    def sendToBack(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Send a shape to the back (bottommost).",
    "        ",
    "        Args:",
    "            shape_id: ID of shape to send back",
    "        \"\"\"",
    "        if shape_id not in self._shapes:",
    "            return",
    "        command = SendToBackCommand(self, shape_id)",
    "        self._execute_command(command)",
    "    ",
    "    # ========================================================================",
    "    # PUBLIC API - Hit Testing",
    "    # ========================================================================",
    "    ",
    "    def getShapeAt(self, x: float, y: float) -> Optional[str]:",
    "        \"\"\"",
    "        Get the topmost shape at the given coordinates.",
    "        ",
    "        Args:",
    "            x: X coordinate to test",
    "            y: Y coordinate to test",
    "            ",
    "        Returns:",
    "            Shape ID of topmost shape at point, or None",
    "        \"\"\"",
    "        for shape_id in self._z_order:  # Front to back",
    "            if self._shapes[shape_id].contains_point(x, y):",
    "                return shape_id",
    "        return None",
    "    ",
    "    # ========================================================================",
    "    # PUBLIC API - Undo/Redo",
    "    # ========================================================================",
    "    ",
    "    def undo(self) -> None:",
    "        \"\"\"",
    "        Undo the last operation.",
    "        ",
    "        Reverses the most recent command and moves it to the redo stack.",
    "        No-op if there are no operations to undo.",
    "        \"\"\"",
    "        if not self._undo_stack:",
    "            return",
    "        ",
    "        command = self._undo_stack.pop()",
    "        command.undo()",
    "        self._redo_stack.append(command)",
    "    ",
    "    def redo(self) -> None:",
    "        \"\"\"",
    "        Redo the last undone operation.",
    "        ",
    "        Re-executes the most recently undone command and moves it back",
    "        to the undo stack. No-op if there are no operations to redo.",
    "        \"\"\"",
    "        if not self._redo_stack:",
    "            return",
    "        ",
    "        command = self._redo_stack.pop()",
    "        command.execute()",
    "        self._undo_stack.append(command)",
    "",
    "",
    "# ============================================================================",
    "# DEMO / TEST",
    "# ============================================================================",
    "",
    "def main():",
    "    print(\"=\"*60)",
    "    print(\"2D Canvas with Undo/Redo - Part 4 Demo\")",
    "    print(\"=\"*60)",
    "    ",
    "    canvas = Canvas()",
    "    ",
    "    # Example 1: Create and undo",
    "    print(\"\\n--- Example 1: Create and Undo ---\")",
    "    rect_id = canvas.createRectangle(0, 0, 50, 50)",
    "    print(f\"Created: {rect_id}\")",
    "    print(f\"Shape at (25, 25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.undo()",
    "    print(f\"After undo, shape at (25, 25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    canvas.redo()",
    "    print(f\"After redo, shape at (25, 25): {canvas.getShapeAt(25, 25)}\")",
    "    ",
    "    # Example 2: Move and undo",
    "    print(\"\\n--- Example 2: Move and Undo ---\")",
    "    canvas2 = Canvas()",
    "    rect2 = canvas2.createRectangle(0, 0, 50, 50)",
    "    print(f\"Created {rect2} at (0, 0)\")",
    "    ",
    "    canvas2.moveShape(rect2, 100, 100)",
    "    print(f\"Moved to (100, 100)\")",
    "    print(f\"Shape at (25, 25): {canvas2.getShapeAt(25, 25)}\")",
    "    print(f\"Shape at (125, 125): {canvas2.getShapeAt(125, 125)}\")",
    "    ",
    "    canvas2.undo()",
    "    print(f\"After undo move:\")",
    "    print(f\"Shape at (25, 25): {canvas2.getShapeAt(25, 25)}\")",
    "    print(f\"Shape at (125, 125): {canvas2.getShapeAt(125, 125)}\")",
    "    ",
    "    # Example 3: Complex sequence",
    "    print(\"\\n--- Example 3: Complex Undo/Redo ---\")",
    "    canvas3 = Canvas()",
    "    r1 = canvas3.createRectangle(0, 0, 100, 100)",
    "    c1 = canvas3.createCircle(50, 50, 30)",
    "    print(f\"Created {r1} and {c1}\")",
    "    print(f\"Topmost at (50, 50): {canvas3.getShapeAt(50, 50)}\")",
    "    ",
    "    canvas3.bringToFront(r1)",
    "    print(f\"After bringToFront({r1}): {canvas3.getShapeAt(50, 50)}\")",
    "    ",
    "    canvas3.undo()",
    "    print(f\"After undo bringToFront: {canvas3.getShapeAt(50, 50)}\")",
    "    ",
    "    # Example 4: Delete and restore",
    "    print(\"\\n--- Example 4: Delete and Restore ---\")",
    "    canvas4 = Canvas()",
    "    shapes = [",
    "        canvas4.createRectangle(0, 0, 50, 50),",
    "        canvas4.createCircle(100, 100, 25),",
    "        canvas4.createRectangle(200, 200, 30, 30)",
    "    ]",
    "    print(f\"Created shapes: {shapes}\")",
    "    ",
    "    canvas4.deleteShape(shapes[1])",
    "    print(f\"Deleted {shapes[1]}\")",
    "    print(f\"Shape at (100, 100): {canvas4.getShapeAt(100, 100)}\")",
    "    ",
    "    canvas4.undo()",
    "    print(f\"After undo delete:\")",
    "    print(f\"Shape at (100, 100): {canvas4.getShapeAt(100, 100)}\")",
    "    ",
    "    # Example 5: New operation clears redo stack",
    "    print(\"\\n--- Example 5: New Op Clears Redo ---\")",
    "    canvas5 = Canvas()",
    "    r = canvas5.createRectangle(0, 0, 50, 50)",
    "    canvas5.undo()  # Undo create",
    "    print(f\"After undo, can redo: {len(canvas5._redo_stack) > 0}\")",
    "    ",
    "    canvas5.createCircle(100, 100, 20)  # New operation",
    "    print(f\"After new op, can redo: {len(canvas5._redo_stack) > 0}\")",
    "    ",
    "    print(\"\\n\" + \"=\"*60)",
    "    print(\"All examples completed successfully!\")",
    "    print(\"=\"*60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * 2D Canvas Drawing Application with Undo/Redo Support",
    " * Implements Command Pattern for full reversibility of all operations.",
    " */",
    "",
    "// ============================================================================",
    "// COMMAND INTERFACE",
    "// ============================================================================",
    "",
    "interface Command {",
    "    Object execute();",
    "    void undo();",
    "}",
    "",
    "// ============================================================================",
    "// SHAPE CLASSES",
    "// ============================================================================",
    "",
    "abstract class Shape {",
    "    protected String id;",
    "    ",
    "    public Shape(String id) {",
    "        this.id = id;",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    ",
    "    public abstract boolean containsPoint(double x, double y);",
    "    public abstract Shape clone();",
    "    public abstract double[] getPosition();",
    "    public abstract void setPosition(double x, double y);",
    "}",
    "",
    "class Rectangle extends Shape {",
    "    private double x, y, width, height;",
    "    ",
    "    public Rectangle(String id, double x, double y, ",
    "                     double width, double height) {",
    "        super(id);",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(double px, double py) {",
    "        return px >= x && px <= x + width && ",
    "               py >= y && py <= y + height;",
    "    }",
    "    ",
    "    @Override",
    "    public Shape clone() {",
    "        return new Rectangle(id, x, y, width, height);",
    "    }",
    "    ",
    "    @Override",
    "    public double[] getPosition() {",
    "        return new double[]{x, y};",
    "    }",
    "    ",
    "    @Override",
    "    public void setPosition(double x, double y) {",
    "        this.x = x;",
    "        this.y = y;",
    "    }",
    "}",
    "",
    "class Circle extends Shape {",
    "    private double centerX, centerY, radius;",
    "    ",
    "    public Circle(String id, double centerX, double centerY, double radius) {",
    "        super(id);",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean containsPoint(double px, double py) {",
    "        double dx = px - centerX;",
    "        double dy = py - centerY;",
    "        return dx * dx + dy * dy <= radius * radius;",
    "    }",
    "    ",
    "    @Override",
    "    public Shape clone() {",
    "        return new Circle(id, centerX, centerY, radius);",
    "    }",
    "    ",
    "    @Override",
    "    public double[] getPosition() {",
    "        return new double[]{centerX, centerY};",
    "    }",
    "    ",
    "    @Override",
    "    public void setPosition(double x, double y) {",
    "        this.centerX = x;",
    "        this.centerY = y;",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// CONCRETE COMMAND CLASSES",
    "// ============================================================================",
    "",
    "class CreateRectangleCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private double x, y, width, height;",
    "    ",
    "    public CreateRectangleCommand(Canvas canvas, String shapeId,",
    "            double x, double y, double width, double height) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        Shape shape = new Rectangle(shapeId, x, y, width, height);",
    "        canvas.internalAddShape(shape);",
    "        return shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        canvas.internalRemoveShape(shapeId);",
    "    }",
    "}",
    "",
    "class CreateCircleCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private double centerX, centerY, radius;",
    "    ",
    "    public CreateCircleCommand(Canvas canvas, String shapeId,",
    "            double centerX, double centerY, double radius) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        Shape shape = new Circle(shapeId, centerX, centerY, radius);",
    "        canvas.internalAddShape(shape);",
    "        return shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        canvas.internalRemoveShape(shapeId);",
    "    }",
    "}",
    "",
    "class MoveCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private double newX, newY;",
    "    private double oldX, oldY;",
    "    private boolean stateCaptured = false;",
    "    ",
    "    public MoveCommand(Canvas canvas, String shapeId,",
    "                       double newX, double newY) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "        this.newX = newX;",
    "        this.newY = newY;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        Shape shape = canvas.internalGetShape(shapeId);",
    "        if (shape == null) return null;",
    "        ",
    "        if (!stateCaptured) {",
    "            double[] pos = shape.getPosition();",
    "            oldX = pos[0];",
    "            oldY = pos[1];",
    "            stateCaptured = true;",
    "        }",
    "        ",
    "        shape.setPosition(newX, newY);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        Shape shape = canvas.internalGetShape(shapeId);",
    "        if (shape != null) {",
    "            shape.setPosition(oldX, oldY);",
    "        }",
    "    }",
    "}",
    "",
    "class DeleteCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private Shape deletedShape;",
    "    private int zIndex;",
    "    private boolean stateCaptured = false;",
    "    ",
    "    public DeleteCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        Shape shape = canvas.internalGetShape(shapeId);",
    "        if (shape == null) return null;",
    "        ",
    "        if (!stateCaptured) {",
    "            deletedShape = shape.clone();",
    "            zIndex = canvas.internalGetZIndex(shapeId);",
    "            stateCaptured = true;",
    "        }",
    "        ",
    "        canvas.internalRemoveShape(shapeId);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (deletedShape != null) {",
    "            canvas.internalRestoreShape(deletedShape.clone(), zIndex);",
    "        }",
    "    }",
    "}",
    "",
    "class BringToFrontCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private int oldZIndex;",
    "    private boolean stateCaptured = false;",
    "    ",
    "    public BringToFrontCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (!canvas.internalHasShape(shapeId)) return null;",
    "        ",
    "        if (!stateCaptured) {",
    "            oldZIndex = canvas.internalGetZIndex(shapeId);",
    "            stateCaptured = true;",
    "        }",
    "        ",
    "        canvas.internalSetZIndex(shapeId, 0);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (canvas.internalHasShape(shapeId)) {",
    "            canvas.internalSetZIndex(shapeId, oldZIndex);",
    "        }",
    "    }",
    "}",
    "",
    "class SendToBackCommand implements Command {",
    "    private Canvas canvas;",
    "    private String shapeId;",
    "    private int oldZIndex;",
    "    private boolean stateCaptured = false;",
    "    ",
    "    public SendToBackCommand(Canvas canvas, String shapeId) {",
    "        this.canvas = canvas;",
    "        this.shapeId = shapeId;",
    "    }",
    "    ",
    "    @Override",
    "    public Object execute() {",
    "        if (!canvas.internalHasShape(shapeId)) return null;",
    "        ",
    "        if (!stateCaptured) {",
    "            oldZIndex = canvas.internalGetZIndex(shapeId);",
    "            stateCaptured = true;",
    "        }",
    "        ",
    "        canvas.internalSetZIndex(shapeId, canvas.internalGetShapeCount() - 1);",
    "        return null;",
    "    }",
    "    ",
    "    @Override",
    "    public void undo() {",
    "        if (canvas.internalHasShape(shapeId)) {",
    "            canvas.internalSetZIndex(shapeId, oldZIndex);",
    "        }",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// CANVAS CLASS",
    "// ============================================================================",
    "",
    "public class Canvas {",
    "    private Map<String, Shape> shapes = new HashMap<>();",
    "    private List<String> zOrder = new ArrayList<>();  // Index 0 = front",
    "    private int rectCounter = 0;",
    "    private int circleCounter = 0;",
    "    private Deque<Command> undoStack = new ArrayDeque<>();",
    "    private Deque<Command> redoStack = new ArrayDeque<>();",
    "    ",
    "    // Internal methods for commands",
    "    void internalAddShape(Shape shape) {",
    "        shapes.put(shape.getId(), shape);",
    "        zOrder.add(0, shape.getId());",
    "    }",
    "    ",
    "    void internalRemoveShape(String shapeId) {",
    "        shapes.remove(shapeId);",
    "        zOrder.remove(shapeId);",
    "    }",
    "    ",
    "    void internalRestoreShape(Shape shape, int zIndex) {",
    "        shapes.put(shape.getId(), shape);",
    "        zOrder.add(zIndex, shape.getId());",
    "    }",
    "    ",
    "    Shape internalGetShape(String shapeId) {",
    "        return shapes.get(shapeId);",
    "    }",
    "    ",
    "    boolean internalHasShape(String shapeId) {",
    "        return shapes.containsKey(shapeId);",
    "    }",
    "    ",
    "    int internalGetZIndex(String shapeId) {",
    "        return zOrder.indexOf(shapeId);",
    "    }",
    "    ",
    "    void internalSetZIndex(String shapeId, int index) {",
    "        zOrder.remove(shapeId);",
    "        zOrder.add(index, shapeId);",
    "    }",
    "    ",
    "    int internalGetShapeCount() {",
    "        return shapes.size();",
    "    }",
    "    ",
    "    // Command execution pipeline",
    "    private Object executeCommand(Command command) {",
    "        Object result = command.execute();",
    "        undoStack.push(command);",
    "        redoStack.clear();",
    "        return result;",
    "    }",
    "    ",
    "    // Public API",
    "    public String createRectangle(double x, double y, ",
    "                                  double width, double height) {",
    "        rectCounter++;",
    "        String shapeId = \"rect_\" + rectCounter;",
    "        Command cmd = new CreateRectangleCommand(this, shapeId, x, y, width, height);",
    "        return (String) executeCommand(cmd);",
    "    }",
    "    ",
    "    public String createCircle(double centerX, double centerY, double radius) {",
    "        circleCounter++;",
    "        String shapeId = \"circle_\" + circleCounter;",
    "        Command cmd = new CreateCircleCommand(this, shapeId, centerX, centerY, radius);",
    "        return (String) executeCommand(cmd);",
    "    }",
    "    ",
    "    public void moveShape(String shapeId, double newX, double newY) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        Command cmd = new MoveCommand(this, shapeId, newX, newY);",
    "        executeCommand(cmd);",
    "    }",
    "    ",
    "    public void deleteShape(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        Command cmd = new DeleteCommand(this, shapeId);",
    "        executeCommand(cmd);",
    "    }",
    "    ",
    "    public void bringToFront(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        Command cmd = new BringToFrontCommand(this, shapeId);",
    "        executeCommand(cmd);",
    "    }",
    "    ",
    "    public void sendToBack(String shapeId) {",
    "        if (!shapes.containsKey(shapeId)) return;",
    "        Command cmd = new SendToBackCommand(this, shapeId);",
    "        executeCommand(cmd);",
    "    }",
    "    ",
    "    public String getShapeAt(double x, double y) {",
    "        for (String shapeId : zOrder) {",
    "            if (shapes.get(shapeId).containsPoint(x, y)) {",
    "                return shapeId;",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    public void undo() {",
    "        if (undoStack.isEmpty()) return;",
    "        Command cmd = undoStack.pop();",
    "        cmd.undo();",
    "        redoStack.push(cmd);",
    "    }",
    "    ",
    "    public void redo() {",
    "        if (redoStack.isEmpty()) return;",
    "        Command cmd = redoStack.pop();",
    "        cmd.execute();",
    "        undoStack.push(cmd);",
    "    }",
    "    ",
    "    // Demo",
    "    public static void main(String[] args) {",
    "        System.out.println(\"2D Canvas with Undo/Redo - Part 4 Demo\");",
    "        System.out.println(\"========================================\");",
    "        ",
    "        Canvas canvas = new Canvas();",
    "        ",
    "        // Create and undo",
    "        String rect = canvas.createRectangle(0, 0, 50, 50);",
    "        System.out.println(\"Created: \" + rect);",
    "        System.out.println(\"Shape at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        canvas.undo();",
    "        System.out.println(\"After undo: \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        canvas.redo();",
    "        System.out.println(\"After redo: \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        // Move and undo",
    "        canvas.moveShape(rect, 100, 100);",
    "        System.out.println(\"\\nMoved to (100,100)\");",
    "        System.out.println(\"Shape at (125,125): \" + canvas.getShapeAt(125, 125));",
    "        ",
    "        canvas.undo();",
    "        System.out.println(\"After undo move, at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        ",
    "        System.out.println(\"\\nAll tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-20",
      "explanation": "**Command interface and imports**: Define the abstract Command base class with execute() and undo() methods. This is the core of the Command Pattern."
    },
    {
      "lines": "22-95",
      "explanation": "**Shape classes with clone support**: Extend Shape ABC with clone(), get_position(), and set_position() methods. These are essential for commands to capture and restore state."
    },
    {
      "lines": "97-145",
      "explanation": "**Create Commands**: CreateRectangleCommand and CreateCircleCommand store all creation parameters. execute() creates and adds shape; undo() removes it."
    },
    {
      "lines": "147-175",
      "explanation": "**MoveCommand**: The _state_captured flag ensures we only capture old position on first execute(). This is CRITICAL for redo to work correctly."
    },
    {
      "lines": "177-210",
      "explanation": "**DeleteCommand**: Stores a clone of the deleted shape AND its z-index. undo() restores shape at exact same z-order position."
    },
    {
      "lines": "212-265",
      "explanation": "**Z-Order Commands**: BringToFrontCommand and SendToBackCommand store original z-index. undo() restores to exact previous position in layer order."
    },
    {
      "lines": "267-320",
      "explanation": "**Canvas internal methods**: _internal_* methods are used by commands to manipulate canvas state. Separates mutation logic from command execution pipeline."
    },
    {
      "lines": "322-340",
      "explanation": "**_execute_command() pipeline**: Central method that: (1) executes command, (2) pushes to undoStack, (3) clears redoStack. Ensures consistency."
    },
    {
      "lines": "342-425",
      "explanation": "**Public API methods**: Each public method creates appropriate command and routes through _execute_command(). Check if shape exists BEFORE creating command."
    },
    {
      "lines": "427-460",
      "explanation": "**undo() and redo()**: Pop from one stack, execute undo/execute, push to other stack. Handle empty stacks gracefully with early return."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "undo()": {
          "complexity": "O(1) + O(operation)",
          "explanation": "Stack pop is O(1), then the operation's undo cost (varies by operation type)"
        },
        "redo()": {
          "complexity": "O(1) + O(operation)",
          "explanation": "Stack pop is O(1), then the operation's execute cost"
        },
        "CreateCommand.execute": {
          "complexity": "O(1)",
          "explanation": "HashMap put + list insert at index 0"
        },
        "MoveCommand.execute": {
          "complexity": "O(1)",
          "explanation": "Direct position update"
        },
        "DeleteCommand.execute": {
          "complexity": "O(n)",
          "explanation": "List removal is O(n) for z_order"
        },
        "BringToFront/SendToBack": {
          "complexity": "O(n)",
          "explanation": "List removal + insertion"
        }
      },
      "overall_change": "All operations remain same complexity. Undo/redo add only O(1) stack operations on top of the operation cost."
    },
    "space": {
      "additional_space": "O(m \u00d7 k)",
      "explanation": "Where m = number of operations in history, k = average state per command. For CreateCommand: k=O(1) parameters. For DeleteCommand: k=O(shape_size). For MoveCommand: k=O(1) old position. Much better than O(m \u00d7 n) snapshot approach."
    }
  },
  "dry_run": {
    "example_input": "createRectangle(0,0,50,50) \u2192 moveShape(rect_1, 100,100) \u2192 undo() \u2192 getShapeAt(25,25)",
    "steps": [
      {
        "step": 1,
        "action": "createRectangle(0, 0, 50, 50)",
        "state": "shapes={rect_1:(0,0,50,50)}, z_order=[rect_1], undoStack=[CreateCmd], redoStack=[]",
        "explanation": "CreateRectangleCommand created and executed. Shape added to canvas and command pushed to undoStack."
      },
      {
        "step": 2,
        "action": "moveShape('rect_1', 100, 100)",
        "state": "shapes={rect_1:(100,100,50,50)}, undoStack=[CreateCmd, MoveCmd(old=0,0)], redoStack=[]",
        "explanation": "MoveCommand captures old position (0,0) on first execute, then updates shape position to (100,100)."
      },
      {
        "step": 3,
        "action": "undo()",
        "state": "shapes={rect_1:(0,0,50,50)}, undoStack=[CreateCmd], redoStack=[MoveCmd]",
        "explanation": "Pop MoveCmd from undoStack, call undo() which restores position to (0,0), push to redoStack."
      },
      {
        "step": 4,
        "action": "getShapeAt(25, 25)",
        "state": "unchanged",
        "explanation": "Rectangle now at (0,0)-(50,50). Point (25,25) is inside. Returns 'rect_1'."
      }
    ],
    "final_output": "'rect_1'"
  },
  "edge_cases": [
    {
      "case": "Undo on empty stack",
      "handling": "Early return in undo() if undoStack is empty",
      "gotcha": "Don't throw exception - no-op is expected behavior"
    },
    {
      "case": "Redo on empty stack",
      "handling": "Early return in redo() if redoStack is empty",
      "gotcha": "Same as undo - graceful no-op"
    },
    {
      "case": "New operation after undo",
      "handling": "_execute_command() clears redoStack",
      "gotcha": "Redo history is lost after any new operation"
    },
    {
      "case": "Redo after redo after redo",
      "handling": "Each redo moves command from redoStack to undoStack",
      "gotcha": "Commands move between stacks, not copied"
    },
    {
      "case": "Delete then undo with z-order",
      "handling": "DeleteCommand stores exact z-index and restores shape at that index",
      "gotcha": "Must restore shape at EXACT z-order position, not just add to front"
    },
    {
      "case": "Multiple undos followed by partial redos",
      "handling": "Each operation is independent; state captured once",
      "gotcha": "Commands are stateful objects that persist until garbage collected"
    }
  ],
  "test_cases": [
    {
      "name": "Basic create-undo-redo",
      "input": "createRectangle(0,0,50,50) \u2192 undo() \u2192 getShapeAt(25,25) \u2192 redo() \u2192 getShapeAt(25,25)",
      "expected": "[rect_1, null, null, null, rect_1]",
      "explanation": "Shape exists, then doesn't after undo, then exists again after redo"
    },
    {
      "name": "Move undo restores original position",
      "input": "createRectangle(0,0,50,50) \u2192 moveShape(rect_1,100,100) \u2192 undo() \u2192 getShapeAt(25,25) \u2192 getShapeAt(125,125)",
      "expected": "[rect_1, null, null, rect_1, null]",
      "explanation": "After undo move, shape is back at (0,0), not at (100,100)"
    },
    {
      "name": "Delete undo restores z-order",
      "input": "createRect(0,0,100,100) \u2192 createCircle(50,50,30) \u2192 deleteShape(rect_1) \u2192 undo() \u2192 getShapeAt(50,50)",
      "expected": "[rect_1, circle_1, null, null, circle_1]",
      "explanation": "After undo delete, circle still on top because rect was behind it originally"
    },
    {
      "name": "New operation clears redo",
      "input": "createRect(0,0,50,50) \u2192 undo() \u2192 createCircle(100,100,20) \u2192 redo()",
      "expected": "[rect_1, null, circle_1, null]",
      "explanation": "New circle operation cleared the redo stack, so redo does nothing"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Re-capturing state on redo",
      "why_wrong": "When redo calls execute(), if you re-capture 'old position', you get the CURRENT position (which is the restored position), destroying the original new position",
      "correct_approach": "Use a _state_captured flag to capture state ONLY on first execute()",
      "code_example_wrong": "def execute(self):\n    self._old_x = shape.x  # BUG: recaptures on redo\n    shape.x = self._new_x",
      "code_example_correct": "def execute(self):\n    if not self._state_captured:\n        self._old_x = shape.x\n        self._state_captured = True\n    shape.x = self._new_x"
    },
    {
      "mistake": "Not cloning shapes for DeleteCommand",
      "why_wrong": "If you store a reference to the deleted shape and it gets modified, undo will restore corrupted state",
      "correct_approach": "Clone the shape before deletion AND when restoring",
      "code_example_wrong": "self._deleted_shape = shape  # BUG: stores reference",
      "code_example_correct": "self._deleted_shape = shape.clone()  # Stores independent copy"
    },
    {
      "mistake": "Not preserving z-order on delete undo",
      "why_wrong": "If you just add_shape() on undo, shape goes to front instead of original position",
      "correct_approach": "Store z-index when deleting and restore at exact index",
      "code_example_wrong": "def undo(self):\n    canvas.add_shape(self._shape)  # BUG: goes to front",
      "code_example_correct": "def undo(self):\n    canvas._z_order.insert(self._z_index, self._shape_id)"
    },
    {
      "mistake": "Forgetting to clear redo stack on new operation",
      "why_wrong": "Leads to inconsistent state where redo might restore shapes that conflict with new operations",
      "correct_approach": "Clear redoStack in _execute_command() before any new command",
      "code_example_wrong": "def _execute_command(cmd):\n    cmd.execute()\n    undoStack.append(cmd)\n    # BUG: forgot to clear redo",
      "code_example_correct": "def _execute_command(cmd):\n    cmd.execute()\n    undoStack.append(cmd)\n    redoStack.clear()  # Critical!"
    }
  ],
  "interview_tips": {
    "how_to_present": "1. **Immediately mention Command Pattern** - Shows you know your design patterns\n2. **Draw the two stacks** - Visual communication is key\n3. **Explain state capture timing** - This is the non-obvious tricky part\n4. **Discuss trade-offs** - Command Pattern vs Memento (full snapshots)",
    "what_to_mention": [
      "Command Pattern is textbook solution for undo/redo",
      "Each command encapsulates: action, state for undo, and both operations",
      "Key insight: capture state BEFORE mutation, ONLY ONCE",
      "Trade-off: Command Pattern (O(k) per operation) vs Memento (O(n) per snapshot)",
      "Real-world consideration: Command queuing for collaborative editing"
    ],
    "time_allocation": "15-20 minutes: 3 min explaining pattern, 10 min coding commands, 5 min for edge cases",
    "if_stuck": [
      "Think about what information you'd need to 'undo' each operation manually",
      "For move: need old position. For delete: need entire shape + where it was",
      "Two stacks is standard - one for done operations, one for undone",
      "State capture timing: first execute() only, use a boolean flag"
    ]
  },
  "connection_to_next_part": "Part 4 establishes the Command Pattern infrastructure that can be extended for Part 5 features like: composite commands (group multiple shapes), macro recording (replay sequences), or collaborative editing with operational transformation. The command abstraction also enables transaction batching (group multiple commands as one undo unit) and persistence (serialize commands for save/load).",
  "generated_at": "2026-01-14T15:25:06.392662",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}