{
  "problem_title": "Median of Two Sorted Arrays - Part 3: Median of K Sorted Arrays",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "We now need to find the median across **K sorted arrays** instead of just two. This fundamentally changes the problem because we can no longer use the elegant partition-based binary search from Part 2. With K arrays, we need either a K-way merge approach or a different binary search strategy that searches on the **value space** rather than partition positions.",
    "new_requirements": [
      "Handle arbitrary number K of sorted arrays",
      "Efficiently merge or search across all K arrays simultaneously",
      "Handle varying array sizes - arrays can have different lengths",
      "Handle empty arrays within the input"
    ],
    "new_constraints": [
      "K can be any positive integer (not limited to 2)",
      "Total elements N = sum of all array lengths",
      "Each individual array is sorted in ascending order",
      "Empty arrays should be gracefully handled"
    ],
    "key_insight": "The partition-based approach from Part 2 doesn't scale to K arrays. Instead, we use a **Min Heap for K-way merging** - maintaining the smallest unprocessed element from each array. We extract elements in sorted order until we reach the median position(s). This gives O(N log K) where K is the heap size."
  },
  "visual_explanation": {
    "before_after": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    PART 2 vs PART 3 COMPARISON                       \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  PART 2: Two Arrays                                                  \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                         \u2551\n\u2551  \u2502 Array1: [1,3,8] \u2502    \u2502 Array2: [7,9,10]\u2502                         \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2551\n\u2551           \u2502                    \u2502                                     \u2551\n\u2551           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2551\n\u2551                    \u25bc                                                 \u2551\n\u2551         Binary Search on Partition                                   \u2551\n\u2551         O(log(min(m,n))) - Very Fast!                               \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  PART 3: K Arrays                                                    \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2551\n\u2551  \u2502[1,5,9]  \u2502 \u2502[2,6,10] \u2502 \u2502[3,7,11] \u2502 \u2502  ...K   \u2502                    \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518                    \u2551\n\u2551       \u2502           \u2502           \u2502           \u2502                          \u2551\n\u2551       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2551\n\u2551                       \u2502                                              \u2551\n\u2551                       \u25bc                                              \u2551\n\u2551            \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557                                     \u2551\n\u2551            \u2551    MIN HEAP       \u2551                                     \u2551\n\u2551            \u2551   (K elements)    \u2551                                     \u2551\n\u2551            \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d                                     \u2551\n\u2551                       \u2502                                              \u2551\n\u2551           Extract min until median position                          \u2551\n\u2551                O(N log K)                                            \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                     K-WAY MERGE WITH MIN HEAP                             \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                                           \u2551\n\u2551  Input: 3 sorted arrays                                                   \u2551\n\u2551  arr0: [1, 5, 9]    arr1: [2, 6, 10]    arr2: [3, 7, 11]                 \u2551\n\u2551                                                                           \u2551\n\u2551  Step 0: Initialize heap with first element from each array              \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2551\n\u2551  \u2502  Heap: [(1,arr0,idx0), (2,arr1,idx0), (3,arr2,idx0)]       \u2502          \u2551\n\u2551  \u2502         \u25b2 minimum                                           \u2502          \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2551\n\u2551                                                                           \u2551\n\u2551  Total = 9 elements \u2192 Median at index 4 (0-indexed)                      \u2551\n\u2551                                                                           \u2551\n\u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2551\n\u2551  \u2502 count=0: pop(1), push(5,arr0,idx1)  \u2192 Extracted: [1]              \u2502   \u2551\n\u2551  \u2502          Heap: [2, 3, 5]                                          \u2502   \u2551\n\u2551  \u2502                                                                    \u2502   \u2551\n\u2551  \u2502 count=1: pop(2), push(6,arr1,idx1)  \u2192 Extracted: [1,2]            \u2502   \u2551\n\u2551  \u2502          Heap: [3, 5, 6]                                          \u2502   \u2551\n\u2551  \u2502                                                                    \u2502   \u2551\n\u2551  \u2502 count=2: pop(3), push(7,arr2,idx1)  \u2192 Extracted: [1,2,3]          \u2502   \u2551\n\u2551  \u2502          Heap: [5, 6, 7]                                          \u2502   \u2551\n\u2551  \u2502                                                                    \u2502   \u2551\n\u2551  \u2502 count=3: pop(5), push(9,arr0,idx2)  \u2192 Extracted: [1,2,3,5]        \u2502   \u2551\n\u2551  \u2502          Heap: [6, 7, 9]                                          \u2502   \u2551\n\u2551  \u2502                                                                    \u2502   \u2551\n\u2551  \u2502 count=4: pop(6) \u2190 THIS IS INDEX 4! \u2192 Extracted: [1,2,3,5,6]       \u2502   \u2551\n\u2551  \u2502          \u2605 MEDIAN FOUND: 6 \u2605                                      \u2502   \u2551\n\u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2551\n\u2551                                                                           \u2551\n\u2551  Result: 6.0                                                              \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive: Merge All Then Find Median",
      "description": "Merge all K arrays into one sorted array, then find the median by accessing the middle element(s).",
      "time_complexity": "O(N log N) or O(N) with merge",
      "space_complexity": "O(N)",
      "why_not_optimal": "Requires O(N) extra space and processes ALL elements even though we only need the median. For very large arrays, this wastes both time and memory."
    },
    {
      "name": "K-Way Merge with Min Heap (Optimal)",
      "description": "Use a min heap to maintain the smallest element from each of the K arrays. Extract minimum elements one by one until reaching the median position. Each extraction takes O(log K) and we do at most N/2 + 1 extractions.",
      "time_complexity": "O(N log K) worst case, O((N/2) log K) average",
      "space_complexity": "O(K)",
      "key_insight": "The heap always contains at most K elements (one from each array), so operations are O(log K). We stop as soon as we reach the median position - no need to process all elements."
    },
    {
      "name": "Binary Search on Value Space",
      "description": "Binary search on the value range [min, max]. For each candidate value, count elements <= that value across all arrays using binary search. Converge to the value at the median position.",
      "time_complexity": "O(K log N \u00d7 log(max-min))",
      "space_complexity": "O(1)",
      "key_insight": "If we're working with integers, binary search on the answer space works elegantly. However, it's trickier for ensuring we land on an actual array element."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## K-Way Merge with Min Heap\n\n### Core Insight\nWe don't need to fully merge all arrays - we only need to find the **median position(s)**. A **min heap** lets us efficiently extract elements in sorted order across all K arrays.\n\n### Algorithm\n1. **Initialize**: Create min heap with `(value, array_index, element_index)` tuples\n2. **Seed heap**: Add first element from each non-empty array\n3. **Extract until median**: Pop minimum, push next element from same array\n4. **Track median positions**: For total N elements:\n   - Odd N: median is at index `N/2`\n   - Even N: median is average of indices `(N-1)/2` and `N/2`\n\n### Why Min Heap Works\n- Heap property ensures **smallest element** is always at top\n- Each pop gives next element in global sorted order\n- Only K elements in heap at any time (one from each array)\n- Each operation is **O(log K)** not O(log N)\n\n### Key Implementation Details\n- Store **(value, array_index, element_index)** to track which array and position\n- After popping, check if that array has more elements\n- Handle both odd and even total counts correctly\n- **Stop early** once we've found the median - no need to continue",
    "data_structures": [
      {
        "structure": "Min Heap / Priority Queue",
        "purpose": "Maintains smallest unprocessed element across all K arrays, enables efficient K-way merge with O(log K) operations"
      },
      {
        "structure": "Tuple/Array",
        "purpose": "Each heap entry is (value, array_index, element_index) to track position for next element insertion"
      }
    ],
    "algorithm_steps": [
      "Step 1: Filter out empty arrays and calculate total element count N",
      "Step 2: Calculate median positions: mid1 = (N-1)/2 and mid2 = N/2",
      "Step 3: Initialize min heap with first element from each valid array as (value, arr_idx, 0)",
      "Step 4: Initialize count = 0 and result variables for storing median values",
      "Step 5: While count <= mid2 and heap not empty:",
      "  - Pop minimum element (value, arr_idx, elem_idx)",
      "  - If count == mid1, save value as result1",
      "  - If count == mid2, save value as result2",
      "  - If more elements exist in that array, push next element to heap",
      "  - Increment count",
      "Step 6: If N is odd, return result2; if even, return (result1 + result2) / 2"
    ]
  },
  "solution_python_lines": [
    "import heapq",
    "from typing import List, Tuple",
    "",
    "",
    "class MedianOfKSortedArrays:",
    "    \"\"\"",
    "    Finds the median of K sorted arrays using K-way merge with min heap.",
    "    ",
    "    Time Complexity: O(N log K) where N is total elements, K is number of arrays",
    "    Space Complexity: O(K) for the heap",
    "    \"\"\"",
    "    ",
    "    def findMedianOfKArrays(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"",
    "        Find median of K sorted arrays using min heap for K-way merge.",
    "        ",
    "        Args:",
    "            arrays: List of K sorted arrays",
    "            ",
    "        Returns:",
    "            Median value as float",
    "            ",
    "        Example:",
    "            >>> solver = MedianOfKSortedArrays()",
    "            >>> solver.findMedianOfKArrays([[1,5,9], [2,6,10], [3,7,11]])",
    "            6.0",
    "        \"\"\"",
    "        # Filter out empty arrays",
    "        valid_arrays = [arr for arr in arrays if arr]",
    "        ",
    "        if not valid_arrays:",
    "            return 0.0",
    "        ",
    "        # Calculate total elements",
    "        total = sum(len(arr) for arr in valid_arrays)",
    "        ",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        # Min heap: (value, array_index, element_index)",
    "        heap: List[Tuple[int, int, int]] = []",
    "        ",
    "        # Initialize heap with first element from each array",
    "        for i, arr in enumerate(valid_arrays):",
    "            heapq.heappush(heap, (arr[0], i, 0))",
    "        ",
    "        # Calculate median positions (0-indexed)",
    "        # For odd total: mid1 == mid2 (single middle element)",
    "        # For even total: mid1 and mid2 are the two middle elements",
    "        mid1 = (total - 1) // 2",
    "        mid2 = total // 2",
    "        ",
    "        result1 = 0",
    "        result2 = 0",
    "        count = 0",
    "        ",
    "        # Extract elements until we reach median position(s)",
    "        while heap and count <= mid2:",
    "            val, arr_idx, elem_idx = heapq.heappop(heap)",
    "            ",
    "            # Check if this is a median position",
    "            if count == mid1:",
    "                result1 = val",
    "            if count == mid2:",
    "                result2 = val",
    "            ",
    "            # Add next element from same array if available",
    "            if elem_idx + 1 < len(valid_arrays[arr_idx]):",
    "                next_val = valid_arrays[arr_idx][elem_idx + 1]",
    "                heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))",
    "            ",
    "            count += 1",
    "        ",
    "        # Return median based on odd/even total",
    "        if total % 2 == 1:",
    "            return float(result2)",
    "        else:",
    "            return (result1 + result2) / 2.0",
    "    ",
    "    def findMedianOfKArrays_binarySearch(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"",
    "        Alternative approach: Binary search on value space.",
    "        ",
    "        Time Complexity: O(K \u00d7 log(N) \u00d7 log(max-min))",
    "        Space Complexity: O(1)",
    "        \"\"\"",
    "        valid_arrays = [arr for arr in arrays if arr]",
    "        ",
    "        if not valid_arrays:",
    "            return 0.0",
    "        ",
    "        total = sum(len(arr) for arr in valid_arrays)",
    "        ",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        def count_less_or_equal(target: int) -> int:",
    "            \"\"\"Count elements <= target across all arrays using binary search.\"\"\"",
    "            count = 0",
    "            for arr in valid_arrays:",
    "                # Binary search for rightmost position where arr[i] <= target",
    "                left, right = 0, len(arr)",
    "                while left < right:",
    "                    mid = (left + right) // 2",
    "                    if arr[mid] <= target:",
    "                        left = mid + 1",
    "                    else:",
    "                        right = mid",
    "                count += left",
    "            return count",
    "        ",
    "        def find_kth_smallest(k: int) -> int:",
    "            \"\"\"Find the k-th smallest element (1-indexed).\"\"\"",
    "            lo = min(arr[0] for arr in valid_arrays)",
    "            hi = max(arr[-1] for arr in valid_arrays)",
    "            ",
    "            while lo < hi:",
    "                mid = (lo + hi) // 2",
    "                if count_less_or_equal(mid) < k:",
    "                    lo = mid + 1",
    "                else:",
    "                    hi = mid",
    "            return lo",
    "        ",
    "        if total % 2 == 1:",
    "            return float(find_kth_smallest((total + 1) // 2))",
    "        else:",
    "            k1 = find_kth_smallest(total // 2)",
    "            k2 = find_kth_smallest(total // 2 + 1)",
    "            return (k1 + k2) / 2.0",
    "",
    "",
    "def main():",
    "    \"\"\"Test the MedianOfKSortedArrays solution.\"\"\"",
    "    solver = MedianOfKSortedArrays()",
    "    ",
    "    print(\"=\"*60)",
    "    print(\"MEDIAN OF K SORTED ARRAYS - TEST CASES\")",
    "    print(\"=\"*60)",
    "    ",
    "    # Test Case 1: Odd total",
    "    arrays1 = [[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
    "    result1 = solver.findMedianOfKArrays(arrays1)",
    "    print(f\"\\nTest 1: {arrays1}\")",
    "    print(f\"Merged: [1,2,3,5,6,7,9,10,11]\")",
    "    print(f\"Expected: 6.0, Got: {result1}\")",
    "    assert result1 == 6.0, f\"Test 1 failed: expected 6.0, got {result1}\"",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Test Case 2: Even total",
    "    arrays2 = [[1, 2], [3, 4], [5, 6], [7, 8]]",
    "    result2 = solver.findMedianOfKArrays(arrays2)",
    "    print(f\"\\nTest 2: {arrays2}\")",
    "    print(f\"Merged: [1,2,3,4,5,6,7,8]\")",
    "    print(f\"Expected: 4.5, Got: {result2}\")",
    "    assert result2 == 4.5, f\"Test 2 failed: expected 4.5, got {result2}\"",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Test Case 3: Single array",
    "    arrays3 = [[1, 2, 3, 4, 5]]",
    "    result3 = solver.findMedianOfKArrays(arrays3)",
    "    print(f\"\\nTest 3: {arrays3}\")",
    "    print(f\"Expected: 3.0, Got: {result3}\")",
    "    assert result3 == 3.0",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Test Case 4: Arrays with different sizes",
    "    arrays4 = [[1], [2, 3, 4], [5, 6]]",
    "    result4 = solver.findMedianOfKArrays(arrays4)",
    "    print(f\"\\nTest 4: {arrays4}\")",
    "    print(f\"Merged: [1,2,3,4,5,6]\")",
    "    print(f\"Expected: 3.5, Got: {result4}\")",
    "    assert result4 == 3.5",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Test Case 5: With empty arrays",
    "    arrays5 = [[], [1, 2, 3], [], [4, 5], []]",
    "    result5 = solver.findMedianOfKArrays(arrays5)",
    "    print(f\"\\nTest 5: {arrays5}\")",
    "    print(f\"Valid: [1,2,3,4,5]\")",
    "    print(f\"Expected: 3.0, Got: {result5}\")",
    "    assert result5 == 3.0",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Test Case 6: All empty arrays",
    "    arrays6 = [[], [], []]",
    "    result6 = solver.findMedianOfKArrays(arrays6)",
    "    print(f\"\\nTest 6: {arrays6}\")",
    "    print(f\"Expected: 0.0, Got: {result6}\")",
    "    assert result6 == 0.0",
    "    print(\"\u2713 PASSED\")",
    "    ",
    "    # Compare with binary search approach",
    "    print(\"\\n\" + \"=\"*60)",
    "    print(\"COMPARING HEAP vs BINARY SEARCH APPROACHES\")",
    "    print(\"=\"*60)",
    "    ",
    "    for i, arrays in enumerate([arrays1, arrays2, arrays4], 1):",
    "        heap_result = solver.findMedianOfKArrays(arrays)",
    "        bs_result = solver.findMedianOfKArrays_binarySearch(arrays)",
    "        print(f\"Test {i}: Heap={heap_result}, BinarySearch={bs_result}\")",
    "        assert heap_result == bs_result, \"Results don't match!\"",
    "    print(\"\u2713 Both approaches give same results!\")",
    "    ",
    "    print(\"\\n\" + \"=\"*60)",
    "    print(\"ALL TESTS PASSED!\")",
    "    print(\"=\"*60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Finds the median of K sorted arrays using K-way merge with min heap.",
    " * ",
    " * Time Complexity: O(N log K) where N is total elements, K is number of arrays",
    " * Space Complexity: O(K) for the heap",
    " */",
    "public class MedianOfKSortedArrays {",
    "    ",
    "    /**",
    "     * Find median of K sorted arrays using min heap for K-way merge.",
    "     * ",
    "     * @param arrays Array of K sorted arrays",
    "     * @return Median value as double",
    "     */",
    "    public double findMedianOfKArrays(int[][] arrays) {",
    "        // Filter out null/empty arrays and calculate total",
    "        List<int[]> validArrays = new ArrayList<>();",
    "        int total = 0;",
    "        ",
    "        for (int[] arr : arrays) {",
    "            if (arr != null && arr.length > 0) {",
    "                validArrays.add(arr);",
    "                total += arr.length;",
    "            }",
    "        }",
    "        ",
    "        if (total == 0) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        // Min heap: int[]{value, array_index, element_index}",
    "        PriorityQueue<int[]> heap = new PriorityQueue<>(",
    "            (a, b) -> Integer.compare(a[0], b[0])",
    "        );",
    "        ",
    "        // Initialize heap with first element from each valid array",
    "        for (int i = 0; i < validArrays.size(); i++) {",
    "            heap.offer(new int[]{validArrays.get(i)[0], i, 0});",
    "        }",
    "        ",
    "        // Calculate median positions (0-indexed)",
    "        int mid1 = (total - 1) / 2;",
    "        int mid2 = total / 2;",
    "        ",
    "        int result1 = 0;",
    "        int result2 = 0;",
    "        int count = 0;",
    "        ",
    "        // Extract elements until we reach median position(s)",
    "        while (!heap.isEmpty() && count <= mid2) {",
    "            int[] curr = heap.poll();",
    "            int val = curr[0];",
    "            int arrIdx = curr[1];",
    "            int elemIdx = curr[2];",
    "            ",
    "            // Check if this is a median position",
    "            if (count == mid1) {",
    "                result1 = val;",
    "            }",
    "            if (count == mid2) {",
    "                result2 = val;",
    "            }",
    "            ",
    "            // Add next element from same array if available",
    "            if (elemIdx + 1 < validArrays.get(arrIdx).length) {",
    "                int nextVal = validArrays.get(arrIdx)[elemIdx + 1];",
    "                heap.offer(new int[]{nextVal, arrIdx, elemIdx + 1});",
    "            }",
    "            ",
    "            count++;",
    "        }",
    "        ",
    "        // Return median based on odd/even total",
    "        if (total % 2 == 1) {",
    "            return (double) result2;",
    "        } else {",
    "            return (result1 + result2) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Alternative approach: Binary search on value space.",
    "     * Time Complexity: O(K \u00d7 log(N) \u00d7 log(max-min))",
    "     */",
    "    public double findMedianOfKArraysBinarySearch(int[][] arrays) {",
    "        List<int[]> validArrays = new ArrayList<>();",
    "        int total = 0;",
    "        int minVal = Integer.MAX_VALUE;",
    "        int maxVal = Integer.MIN_VALUE;",
    "        ",
    "        for (int[] arr : arrays) {",
    "            if (arr != null && arr.length > 0) {",
    "                validArrays.add(arr);",
    "                total += arr.length;",
    "                minVal = Math.min(minVal, arr[0]);",
    "                maxVal = Math.max(maxVal, arr[arr.length - 1]);",
    "            }",
    "        }",
    "        ",
    "        if (total == 0) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        if (total % 2 == 1) {",
    "            return (double) findKthSmallest(validArrays, (total + 1) / 2, minVal, maxVal);",
    "        } else {",
    "            int k1 = findKthSmallest(validArrays, total / 2, minVal, maxVal);",
    "            int k2 = findKthSmallest(validArrays, total / 2 + 1, minVal, maxVal);",
    "            return (k1 + k2) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    private int findKthSmallest(List<int[]> arrays, int k, int lo, int hi) {",
    "        while (lo < hi) {",
    "            int mid = lo + (hi - lo) / 2;",
    "            if (countLessOrEqual(arrays, mid) < k) {",
    "                lo = mid + 1;",
    "            } else {",
    "                hi = mid;",
    "            }",
    "        }",
    "        return lo;",
    "    }",
    "    ",
    "    private int countLessOrEqual(List<int[]> arrays, int target) {",
    "        int count = 0;",
    "        for (int[] arr : arrays) {",
    "            count += upperBound(arr, target);",
    "        }",
    "        return count;",
    "    }",
    "    ",
    "    private int upperBound(int[] arr, int target) {",
    "        int left = 0, right = arr.length;",
    "        while (left < right) {",
    "            int mid = left + (right - left) / 2;",
    "            if (arr[mid] <= target) {",
    "                left = mid + 1;",
    "            } else {",
    "                right = mid;",
    "            }",
    "        }",
    "        return left;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        MedianOfKSortedArrays solver = new MedianOfKSortedArrays();",
    "        ",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"MEDIAN OF K SORTED ARRAYS - TEST CASES\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Test Case 1: Odd total",
    "        int[][] arrays1 = {{1, 5, 9}, {2, 6, 10}, {3, 7, 11}};",
    "        double result1 = solver.findMedianOfKArrays(arrays1);",
    "        System.out.println(\"\\nTest 1: [[1,5,9], [2,6,10], [3,7,11]]\");",
    "        System.out.println(\"Merged: [1,2,3,5,6,7,9,10,11]\");",
    "        System.out.println(\"Expected: 6.0, Got: \" + result1);",
    "        assert result1 == 6.0 : \"Test 1 failed\";",
    "        System.out.println(\"\u2713 PASSED\");",
    "        ",
    "        // Test Case 2: Even total",
    "        int[][] arrays2 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};",
    "        double result2 = solver.findMedianOfKArrays(arrays2);",
    "        System.out.println(\"\\nTest 2: [[1,2], [3,4], [5,6], [7,8]]\");",
    "        System.out.println(\"Merged: [1,2,3,4,5,6,7,8]\");",
    "        System.out.println(\"Expected: 4.5, Got: \" + result2);",
    "        assert result2 == 4.5 : \"Test 2 failed\";",
    "        System.out.println(\"\u2713 PASSED\");",
    "        ",
    "        // Test Case 3: Single array",
    "        int[][] arrays3 = {{1, 2, 3, 4, 5}};",
    "        double result3 = solver.findMedianOfKArrays(arrays3);",
    "        System.out.println(\"\\nTest 3: [[1,2,3,4,5]]\");",
    "        System.out.println(\"Expected: 3.0, Got: \" + result3);",
    "        assert result3 == 3.0 : \"Test 3 failed\";",
    "        System.out.println(\"\u2713 PASSED\");",
    "        ",
    "        // Test Case 4: With empty arrays",
    "        int[][] arrays4 = {{}, {1, 2, 3}, {}, {4, 5}, {}};",
    "        double result4 = solver.findMedianOfKArrays(arrays4);",
    "        System.out.println(\"\\nTest 4: [[], [1,2,3], [], [4,5], []]\");",
    "        System.out.println(\"Valid: [1,2,3,4,5]\");",
    "        System.out.println(\"Expected: 3.0, Got: \" + result4);",
    "        assert result4 == 3.0 : \"Test 4 failed\";",
    "        System.out.println(\"\u2713 PASSED\");",
    "        ",
    "        // Test comparison between approaches",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"COMPARING HEAP vs BINARY SEARCH APPROACHES\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        double heapResult = solver.findMedianOfKArrays(arrays1);",
    "        double bsResult = solver.findMedianOfKArraysBinarySearch(arrays1);",
    "        System.out.println(\"Test 1: Heap=\" + heapResult + \", BinarySearch=\" + bsResult);",
    "        assert heapResult == bsResult : \"Results don't match!\";",
    "        System.out.println(\"\u2713 Both approaches give same results!\");",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"ALL TESTS PASSED!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-10",
      "explanation": "**Imports and class documentation**: We use heapq for the min heap in Python, PriorityQueue in Java. The class docstring describes the approach and complexity."
    },
    {
      "lines": "13-28",
      "explanation": "**Method signature and input validation**: We filter out empty arrays first. This handles the edge case of null/empty arrays gracefully and simplifies the main logic."
    },
    {
      "lines": "30-42",
      "explanation": "**Heap initialization**: We create tuples of (value, array_index, element_index) for the heap. This allows us to track which array each element came from and what the next element would be."
    },
    {
      "lines": "44-48",
      "explanation": "**Median position calculation**: mid1 and mid2 are the 0-indexed positions of the median element(s). For odd totals, mid1 == mid2. For even totals, they differ by 1."
    },
    {
      "lines": "50-67",
      "explanation": "**Main extraction loop**: We pop the minimum element, check if it's at a median position, and push the next element from the same array. We stop as soon as we've found both median positions."
    },
    {
      "lines": "69-73",
      "explanation": "**Return median**: For odd totals, return the single middle element. For even totals, return the average of the two middle elements."
    },
    {
      "lines": "75-115",
      "explanation": "**Alternative binary search approach**: Searches on the value space instead of positions. Uses binary search within each array to count elements \u2264 a candidate value."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "findMedianOfKArrays": {
          "complexity": "O((N/2) \u00d7 log K)",
          "explanation": "We extract at most N/2 + 1 elements (until median position). Each heap operation (push/pop) takes O(log K) where K is the number of arrays. In the worst case, this is O(N log K)."
        },
        "findMedianOfKArrays_binarySearch": {
          "complexity": "O(K \u00d7 log N \u00d7 log(max-min))",
          "explanation": "We binary search on value range (log(max-min) iterations). For each candidate, we do K binary searches on arrays of size up to N/K, giving O(K \u00d7 log(N/K)) per iteration."
        }
      },
      "overall_change": "Part 2's O(log(min(m,n))) doesn't scale to K arrays. The heap approach is optimal for this generalization."
    },
    "space": {
      "additional_space": "O(K)",
      "explanation": "The heap contains at most K elements (one from each array). This is excellent - it doesn't grow with total elements N."
    }
  },
  "dry_run": {
    "example_input": "arrays = [[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
    "steps": [
      {
        "step": 1,
        "action": "Initialize",
        "state": "total=9, mid1=4, mid2=4, heap=[(1,0,0), (2,1,0), (3,2,0)]",
        "explanation": "9 elements total, median at index 4. Heap seeded with first element from each array."
      },
      {
        "step": 2,
        "action": "count=0: pop(1,0,0)",
        "state": "heap=[(2,1,0), (3,2,0), (5,0,1)]",
        "explanation": "Extract 1, push next from array 0 (which is 5). count=0 \u2260 mid1, continue."
      },
      {
        "step": 3,
        "action": "count=1: pop(2,1,0)",
        "state": "heap=[(3,2,0), (5,0,1), (6,1,1)]",
        "explanation": "Extract 2, push next from array 1 (which is 6). count=1 \u2260 mid1, continue."
      },
      {
        "step": 4,
        "action": "count=2: pop(3,2,0)",
        "state": "heap=[(5,0,1), (6,1,1), (7,2,1)]",
        "explanation": "Extract 3, push next from array 2 (which is 7). count=2 \u2260 mid1, continue."
      },
      {
        "step": 5,
        "action": "count=3: pop(5,0,1)",
        "state": "heap=[(6,1,1), (7,2,1), (9,0,2)]",
        "explanation": "Extract 5, push next from array 0 (which is 9). count=3 \u2260 mid1, continue."
      },
      {
        "step": 6,
        "action": "count=4: pop(6,1,1)",
        "state": "result1=6, result2=6",
        "explanation": "Extract 6. count=4 == mid1 == mid2! Save 6 as both result1 and result2. Loop ends."
      },
      {
        "step": 7,
        "action": "Return",
        "state": "total=9 is odd",
        "explanation": "Return result2 = 6.0"
      }
    ],
    "final_output": "6.0"
  },
  "edge_cases": [
    {
      "case": "All arrays empty",
      "handling": "Return 0.0 after filtering leaves no valid arrays",
      "gotcha": "Don't try to access elements before checking array validity"
    },
    {
      "case": "Some arrays empty",
      "handling": "Filter out empty arrays before processing, adjust total count accordingly",
      "gotcha": "Array indices in heap must map to valid (non-empty) arrays after filtering"
    },
    {
      "case": "Single array with one element",
      "handling": "Works correctly - median is that single element",
      "gotcha": "mid1 == mid2 == 0, so we correctly return the only element"
    },
    {
      "case": "K=1 (single array)",
      "handling": "Degenerates to finding median of one sorted array - heap still works",
      "gotcha": "Should still be efficient O(N/2) not O(N log 1) = O(N)"
    },
    {
      "case": "Arrays with duplicate values",
      "handling": "Heap handles duplicates correctly - they're extracted in order",
      "gotcha": "When counting positions, duplicates each count as separate elements"
    },
    {
      "case": "Very unequal array sizes",
      "handling": "No issue - heap naturally balances by only keeping one element per array",
      "gotcha": "Space is still O(K) not O(N)"
    }
  ],
  "test_cases": [
    {
      "name": "Basic odd total",
      "input": "[[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
      "expected": "6.0",
      "explanation": "9 elements, median is 5th element (index 4) = 6"
    },
    {
      "name": "Basic even total",
      "input": "[[1, 2], [3, 4], [5, 6], [7, 8]]",
      "expected": "4.5",
      "explanation": "8 elements, median is average of 4th and 5th = (4+5)/2 = 4.5"
    },
    {
      "name": "Single element arrays",
      "input": "[[5], [1], [3]]",
      "expected": "3.0",
      "explanation": "Merged: [1, 3, 5], median is 3"
    },
    {
      "name": "With empty arrays",
      "input": "[[], [1, 2, 3], [], [4, 5]]",
      "expected": "3.0",
      "explanation": "Valid arrays: [1,2,3,4,5], median is 3"
    },
    {
      "name": "Single array",
      "input": "[[1, 2, 3, 4, 5, 6]]",
      "expected": "3.5",
      "explanation": "6 elements, median is (3+4)/2 = 3.5"
    },
    {
      "name": "Two arrays (fallback to Part 2)",
      "input": "[[1, 3], [2]]",
      "expected": "2.0",
      "explanation": "Merged: [1, 2, 3], median is 2"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using 1-indexed positions instead of 0-indexed",
      "why_wrong": "Leads to off-by-one errors when calculating median positions",
      "correct_approach": "Consistently use 0-indexed: mid1 = (total-1)//2, mid2 = total//2",
      "code_example_wrong": "mid = total // 2  # Wrong for 0-indexed arrays",
      "code_example_correct": "mid1 = (total - 1) // 2  # First middle (0-indexed)\nmid2 = total // 2        # Second middle (0-indexed)"
    },
    {
      "mistake": "Not handling empty arrays in input",
      "why_wrong": "Causes IndexError when trying to access first element",
      "correct_approach": "Filter out empty arrays before processing",
      "code_example_wrong": "for i, arr in enumerate(arrays):\n    heap.push(arr[0], i, 0)  # Crashes on empty arr",
      "code_example_correct": "valid = [arr for arr in arrays if arr]\nfor i, arr in enumerate(valid):\n    heap.push(arr[0], i, 0)"
    },
    {
      "mistake": "Forgetting to push next element after popping",
      "why_wrong": "Results in only processing first elements, wrong median",
      "correct_approach": "After popping (val, arr_idx, elem_idx), push element at elem_idx+1 if exists",
      "code_example_wrong": "val, arr_idx, elem_idx = heappop(heap)\n# Missing: push next element",
      "code_example_correct": "val, arr_idx, elem_idx = heappop(heap)\nif elem_idx + 1 < len(valid[arr_idx]):\n    heappush(heap, (valid[arr_idx][elem_idx+1], arr_idx, elem_idx+1))"
    },
    {
      "mistake": "Storing array reference instead of index in heap",
      "why_wrong": "Can't efficiently find next element without knowing position",
      "correct_approach": "Store (value, array_index, element_index) tuple",
      "code_example_wrong": "heap.push((arr[0], arr))  # No way to get next element",
      "code_example_correct": "heap.push((arr[0], arr_idx, 0))  # Can access arr[1] later"
    },
    {
      "mistake": "Continuing loop after finding median",
      "why_wrong": "Wastes time processing unnecessary elements",
      "correct_approach": "Stop loop once count > mid2",
      "code_example_wrong": "while heap:  # Processes all N elements",
      "code_example_correct": "while heap and count <= mid2:  # Stops early"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining why the Part 2 partition approach doesn't scale. Mention that partitioning K arrays simultaneously has too many degrees of freedom. Then introduce the min heap as a natural way to do K-way merge, and explain we can stop early since we only need the median.",
    "what_to_mention": [
      "The heap maintains exactly K elements (one per array), giving O(log K) operations",
      "We stop at median position - no need to fully merge all N elements",
      "Time is O((N/2) log K) in practice, O(N log K) worst case",
      "Space is O(K), independent of total elements N",
      "Alternative binary search on value approach exists but is trickier to implement correctly"
    ],
    "time_allocation": "2 min: explain why Part 2 approach doesn't extend, 3 min: describe heap approach, 8 min: implement, 2 min: test/edge cases",
    "if_stuck": [
      "Think about how to efficiently find the minimum across K sorted arrays",
      "Consider: what data structure gives you the minimum in O(log K)?",
      "How would you merge K sorted lists? This is the same problem!",
      "You don't need ALL elements sorted, just up to the median position"
    ]
  },
  "connection_to_next_part": "If Part 4 introduces streaming data or dynamic arrays where elements are added over time, the heap approach could be extended to maintain a running median. Consider using two heaps (max heap for lower half, min heap for upper half) for O(log N) updates and O(1) median queries - this is the classic 'Find Median from Data Stream' problem.",
  "generated_at": "2026-01-14T15:13:36.648526",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}