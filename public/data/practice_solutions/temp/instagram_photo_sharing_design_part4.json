{
  "problem_title": "Design Instagram - Photo Sharing Platform - Part 4: Direct Messaging (DMs)",
  "part_number": 4,
  "builds_on": "Part 3: Search and Explore",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 4 introduces a completely new subsystem: real-time Direct Messaging. Unlike feed and search which are primarily read-heavy and can tolerate some latency, DMs require bidirectional real-time communication, strict message ordering, and guaranteed delivery. This fundamentally changes our architecture from request-response HTTP to persistent WebSocket connections, and introduces new challenges around connection management, offline handling, and message synchronization.",
    "new_requirements": [
      "Real-time bidirectional communication via WebSocket",
      "Message ordering guarantees within conversations",
      "Sub-100ms message delivery for online users",
      "Offline message queuing and sync on reconnect",
      "Read receipts and typing indicators",
      "Group chat support with efficient fan-out",
      "10M concurrent WebSocket connections",
      "Media sharing within conversations"
    ],
    "new_constraints": [
      "Message delivery latency < 100ms when online",
      "Support 10M concurrent WebSocket connections",
      "Strict ordering per conversation (sequence numbers)",
      "At-least-once delivery guarantee",
      "Handle network partitions and reconnections gracefully"
    ],
    "key_insight": "Decouple message persistence from delivery: Store the message first (guaranteeing durability), then push asynchronously. This ensures no message loss even if the push fails. Use Kafka partitioned by conversation_id to guarantee ordering, and maintain a session store mapping users to their WebSocket server for efficient routing."
  },
  "visual_explanation": {
    "before_after": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    BEFORE (Part 3): Request-Response                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                          \u2502\n\u2502   Client \u2500\u2500HTTP\u2500\u2500\u25ba API Gateway \u2500\u2500\u25ba Service \u2500\u2500\u25ba Database                 \u2502\n\u2502      \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500               \u2502\n\u2502                                                                          \u2502\n\u2502   \u2022 Stateless HTTP requests                                              \u2502\n\u2502   \u2022 Pull-based model (client polls for updates)                         \u2502\n\u2502   \u2022 No persistent connections                                            \u2502\n\u2502   \u2022 Latency: 100-500ms acceptable                                        \u2502\n\u2502                                                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    AFTER (Part 4): Real-Time WebSocket                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                          \u2502\n\u2502   Client \u25c4\u2550\u2550WebSocket\u2550\u2550\u25ba WS Gateway \u25c4\u2500\u2500\u25ba Message Service                \u2502\n\u2502              (persistent)     \u2502                  \u2502                       \u2502\n\u2502                               \u25bc                  \u25bc                       \u2502\n\u2502                         Session Store      Message DB                    \u2502\n\u2502                          (Redis)          (Cassandra)                    \u2502\n\u2502                               \u2502                  \u2502                       \u2502\n\u2502                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502\n\u2502                                      \u25bc                                   \u2502\n\u2502                                   Kafka                                  \u2502\n\u2502                            (Message Routing)                             \u2502\n\u2502                                                                          \u2502\n\u2502   \u2022 Persistent bidirectional connections                                 \u2502\n\u2502   \u2022 Push-based model (server pushes to client)                          \u2502\n\u2502   \u2022 Stateful connection management                                       \u2502\n\u2502   \u2022 Latency: <100ms required                                             \u2502\n\u2502                                                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       MESSAGE SEND FLOW (DETAILED)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  Sender (Alice)                    Backend                    Receiver (Bob)\n       \u2502                               \u2502                              \u2502\n       \u2502  1. SEND via WebSocket        \u2502                              \u2502\n       \u2502  {to: \"conv_123\",             \u2502                              \u2502\n       \u2502   text: \"Hello!\",             \u2502                              \u2502\n       \u2502   client_msg_id: \"xxx\"}       \u2502                              \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                              \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n       \u2502                    \u2502 2. VALIDATE & STORE \u2502                   \u2502\n       \u2502                    \u2502  \u2022 Check permissions\u2502                   \u2502\n       \u2502                    \u2502  \u2022 Assign server_id \u2502                   \u2502\n       \u2502                    \u2502  \u2022 Assign seq_num   \u2502                   \u2502\n       \u2502                    \u2502  \u2022 Write Cassandra  \u2502                   \u2502\n       \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502  3. ACK {msg_id, seq_num}     \u2502                              \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502                              \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n       \u2502                    \u2502 4. PUBLISH TO KAFKA \u2502                   \u2502\n       \u2502                    \u2502  partition = hash(  \u2502                   \u2502\n       \u2502                    \u2502    conversation_id) \u2502                   \u2502\n       \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n       \u2502                    \u2502 5. CONSUMER READS   \u2502                   \u2502\n       \u2502                    \u2502  \u2022 For each member: \u2502                   \u2502\n       \u2502                    \u2502    Check Redis for  \u2502                   \u2502\n       \u2502                    \u2502    WebSocket server \u2502                   \u2502\n       \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n       \u2502                    \u2502 6. ROUTE TO BOB     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n       \u2502                    \u2502  Bob online?        \u2502  NEW_MESSAGE      \u2502\n       \u2502                    \u2502  Y: Push via WS     \u2502  {msg_id, text,   \u2502\n       \u2502                    \u2502  N: Queue + Push    \u2502   sender, time}   \u2502\n       \u2502                    \u2502     notification    \u2502                   \u2502\n       \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n       \u2502                                                              \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502                               \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n       \u2502                               \u2502  7. DELIVERED ACK            \u2502\n       \u2502                               \u2502                              \u2502\n       \u2502  8. DELIVERY RECEIPT          \u2502                              \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502                              \u2502\n       \u2502  {msg_id, status: DELIVERED}  \u2502                              \u2502\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         OFFLINE SYNC FLOW                                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n  Bob (was offline)                 Backend\n       \u2502                               \u2502\n       \u2502  1. RECONNECT WebSocket       \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                               \u2502\n       \u2502  2. SYNC_REQUEST              \u2502\n       \u2502  {last_seq_per_conv: {        \u2502\n       \u2502    conv_123: 45,              \u2502\n       \u2502    conv_456: 12               \u2502\n       \u2502  }}                           \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                               \u2502\n       \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502                    \u2502 3. Query Cassandra  \u2502\n       \u2502                    \u2502  SELECT * FROM msgs \u2502\n       \u2502                    \u2502  WHERE conv_id = ?  \u2502\n       \u2502                    \u2502  AND seq > last_seq \u2502\n       \u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                               \u2502\n       \u2502  4. SYNC_RESPONSE             \u2502\n       \u2502  {messages: [...]}            \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502                               \u2502\n       \u2502  (Messages delivered in       \u2502\n       \u2502   sequence order)             \u2502\n\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     GROUP CHAT FAN-OUT                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Sender                  Message Service                Members\n       \u2502                          \u2502                           \u2502\n       \u2502  Send to group_123       \u2502                           \u2502\n       \u2502  (5 members)             \u2502                           \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                           \u2502\n       \u2502                          \u2502                           \u2502\n       \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n       \u2502              \u2502  Store once in DB     \u2502               \u2502\n       \u2502              \u2502  (single write)       \u2502               \u2502\n       \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n       \u2502                          \u2502                           \u2502\n       \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n       \u2502              \u2502  Fan-out to Kafka     \u2502               \u2502\n       \u2502              \u2502  (one event per       \u2502               \u2502\n       \u2502              \u2502   member, batched)    \u2502               \u2502\n       \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n       \u2502                          \u2502                           \u2502\n       \u2502                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502 Member 1\n       \u2502                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502 Member 2  \n       \u2502                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502 Member 3\n       \u2502                          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502 Member 4\n       \u2502                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502 Member 5\n       \u2502                          \u2502                           \u2502\n       \u2502         Optimization: Batch members on same          \u2502\n       \u2502         WS server into single internal call          \u2502\n\n```"
  },
  "approaches": [
    {
      "name": "Naive Polling-Based Extension",
      "description": "Extend the existing HTTP-based architecture by having clients poll for new messages every few seconds. Store messages in PostgreSQL with a simple messages table, and have clients periodically call getMessages() to check for updates.",
      "time_complexity": "O(n) per poll where n = number of conversations",
      "space_complexity": "O(m) where m = total messages",
      "why_not_optimal": "Polling introduces 1-5 second latency (not real-time), wastes bandwidth with empty responses, doesn't scale to millions of users (each user generates multiple requests per minute), and provides poor user experience for a messaging app. At 10M users polling every 3 seconds, that's 3.3M requests/second just for polling."
    },
    {
      "name": "Simple WebSocket Without Message Bus",
      "description": "Use WebSocket for real-time delivery but route messages directly between WebSocket servers. When a message arrives, look up the recipient's connection and push directly.",
      "time_complexity": "O(1) per message delivery",
      "space_complexity": "O(connections) for WebSocket state",
      "why_not_optimal": "Direct routing between servers creates tight coupling. If the recipient's WebSocket server is temporarily unreachable, messages are lost. No ordering guarantees. Difficult to replay/debug. Doesn't handle offline users well. Server restarts cause message loss."
    },
    {
      "name": "Optimal: Store-First + Async Push via Message Bus",
      "description": "Decouple persistence from delivery using a message bus (Kafka). On message send: (1) Validate and assign sequence number, (2) Store in Cassandra, (3) ACK to sender, (4) Publish to Kafka partitioned by conversation_id, (5) Consumers read and push to recipients via WebSocket or queue for offline. This provides durability, ordering, and scalability.",
      "time_complexity": "O(group_size) for group messages, O(1) for direct messages",
      "space_complexity": "O(m) for messages + O(c) for connections where c = concurrent users",
      "key_insight": "By storing first and pushing asynchronously, we guarantee no message loss. Kafka partitioning by conversation_id guarantees ordering. The session store (Redis) provides O(1) lookup from user_id to WebSocket server, enabling efficient routing even with 10M connections across hundreds of WebSocket servers."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal DM Architecture\n\n### Core Principles\n\n1. **Store-First, Push-Second**: Every message is first persisted to Cassandra before any delivery attempt. This guarantees durability.\n\n2. **Kafka as Message Bus**: Using Kafka partitioned by `conversation_id` ensures:\n   - **Ordering**: Messages within a conversation are processed in order\n   - **Durability**: Messages survive server crashes\n   - **Scalability**: Can add more consumers as load grows\n   - **Replay**: Can replay messages for debugging/recovery\n\n3. **Session Store Pattern**: Redis maintains a mapping of `user_id \u2192 websocket_server_id`. When delivering a message:\n   - Look up recipient in Redis O(1)\n   - Route to correct WebSocket server\n   - If no entry, user is offline \u2192 queue + push notification\n\n4. **Sequence Numbers**: Each conversation maintains a monotonically increasing sequence number. Clients track their last received sequence and can request missing messages on reconnect.\n\n### Data Model Design\n\n**Messages Table (Cassandra)**\n```\nPRIMARY KEY ((conversation_id), sequence_number)\n```\nThis clustering allows efficient range queries for syncing.\n\n**User Conversations Table**\n```\nPRIMARY KEY ((user_id), last_message_time DESC)\n```\nThis enables efficient inbox retrieval sorted by recency.\n\n### WebSocket Connection Management\n\n- **Heartbeat**: Ping every 30s to detect dead connections\n- **Reconnection**: Client maintains last `seq_num` per conversation\n- **Multiplexing**: Single connection handles all conversations\n- **Compression**: Enable per-message deflate for bandwidth savings\n\n### Read Receipts Implementation\n\n1. Client calls `markAsRead(conversation_id, message_id)`\n2. Update `user_conversations.last_read_message_id`\n3. Broadcast read receipt to other participants\n4. Batch read receipts to avoid excessive updates\n\n### Group Chat Optimization\n\n- **Small groups (\u226450)**: Fan-out on write (push to all members)\n- **Large groups (>50)**: Hybrid - store once, fan-out reads\n- **Member caching**: Cache group membership in Redis",
    "data_structures": [
      {
        "structure": "WebSocket Connection Pool",
        "purpose": "Maintains persistent bidirectional connections with clients for real-time push"
      },
      {
        "structure": "Redis Session Store",
        "purpose": "Maps user_id \u2192 WebSocket server for O(1) routing. Also stores presence (online/offline) and typing indicators"
      },
      {
        "structure": "Kafka Topics (partitioned)",
        "purpose": "Message bus for reliable, ordered delivery. Partitioned by conversation_id for ordering guarantees"
      },
      {
        "structure": "Cassandra Messages Table",
        "purpose": "Append-only message storage optimized for time-series writes and range queries. Partition by conversation_id, cluster by sequence_number"
      },
      {
        "structure": "Pending Messages Queue",
        "purpose": "Stores undelivered messages for offline users, processed on reconnection"
      },
      {
        "structure": "Sequence Number Generator",
        "purpose": "Per-conversation counter for ordering. Can use Redis INCR or Cassandra lightweight transactions"
      }
    ],
    "algorithm_steps": [
      "Step 1: Client establishes WebSocket connection \u2192 Server registers in Redis session store with TTL",
      "Step 2: On sendMessage: Validate sender is conversation member, assign sequence number atomically",
      "Step 3: Write message to Cassandra with conversation_id as partition key and seq_num as clustering key",
      "Step 4: Return ACK to sender immediately (message is now durable)",
      "Step 5: Publish MessageCreated event to Kafka partition = hash(conversation_id) % num_partitions",
      "Step 6: Kafka consumer reads event, looks up each recipient in Redis session store",
      "Step 7: For online recipients: Route to their WebSocket server, push message",
      "Step 8: For offline recipients: Add to pending_messages queue, send push notification",
      "Step 9: On WebSocket reconnect: Client sends last_seq_per_conversation, server queries Cassandra for missing messages",
      "Step 10: For read receipts: Batch updates, write to DB, broadcast to conversation members"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Instagram Direct Messaging System - Part 4",
    "Real-time messaging with WebSocket support, offline handling, and group chats.",
    "\"\"\"",
    "",
    "import asyncio",
    "import json",
    "import time",
    "import uuid",
    "import hashlib",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from enum import Enum",
    "from typing import Dict, List, Optional, Set, Callable, Any",
    "from collections import defaultdict",
    "from threading import Lock",
    "import heapq",
    "",
    "",
    "# ============================================================================",
    "# ENUMS AND DATA CLASSES",
    "# ============================================================================",
    "",
    "class MessageType(Enum):",
    "    TEXT = \"TEXT\"",
    "    IMAGE = \"IMAGE\"",
    "    VIDEO = \"VIDEO\"",
    "    SYSTEM = \"SYSTEM\"  # For join/leave notifications",
    "",
    "",
    "class MessageStatus(Enum):",
    "    SENT = \"SENT\"",
    "    DELIVERED = \"DELIVERED\"",
    "    READ = \"READ\"",
    "",
    "",
    "class ConversationType(Enum):",
    "    DIRECT = \"DIRECT\"",
    "    GROUP = \"GROUP\"",
    "",
    "",
    "@dataclass",
    "class Message:",
    "    \"\"\"Represents a single message in a conversation.\"\"\"",
    "    message_id: str",
    "    conversation_id: str",
    "    sender_id: str",
    "    message_type: MessageType",
    "    content: str  # Text or media URL",
    "    timestamp: int",
    "    sequence_number: int",
    "    status: MessageStatus = MessageStatus.SENT",
    "    client_message_id: Optional[str] = None  # For deduplication",
    "    ",
    "    def to_dict(self) -> Dict:",
    "        return {",
    "            \"message_id\": self.message_id,",
    "            \"conversation_id\": self.conversation_id,",
    "            \"sender_id\": self.sender_id,",
    "            \"type\": self.message_type.value,",
    "            \"content\": self.content,",
    "            \"timestamp\": self.timestamp,",
    "            \"sequence_number\": self.sequence_number,",
    "            \"status\": self.status.value",
    "        }",
    "",
    "",
    "@dataclass",
    "class Conversation:",
    "    \"\"\"Represents a conversation (direct or group).\"\"\"",
    "    conversation_id: str",
    "    conversation_type: ConversationType",
    "    participant_ids: List[str]",
    "    name: Optional[str] = None  # For group chats",
    "    created_at: int = 0",
    "    last_message_preview: str = \"\"",
    "    last_message_time: int = 0",
    "    last_sequence_number: int = 0",
    "    ",
    "    def to_dict(self) -> Dict:",
    "        return {",
    "            \"conversation_id\": self.conversation_id,",
    "            \"type\": self.conversation_type.value,",
    "            \"participants\": self.participant_ids,",
    "            \"name\": self.name,",
    "            \"last_message\": self.last_message_preview,",
    "            \"last_message_time\": self.last_message_time",
    "        }",
    "",
    "",
    "@dataclass",
    "class UserConversationState:",
    "    \"\"\"Tracks a user's state in a conversation.\"\"\"",
    "    user_id: str",
    "    conversation_id: str",
    "    last_read_sequence: int = 0",
    "    unread_count: int = 0",
    "    muted: bool = False",
    "    last_message_time: int = 0  # For sorting inbox",
    "",
    "",
    "@dataclass",
    "class WebSocketEvent:",
    "    \"\"\"Event sent over WebSocket connection.\"\"\"",
    "    event_type: str",
    "    payload: Dict",
    "    timestamp: int = field(default_factory=lambda: int(time.time() * 1000))",
    "",
    "",
    "# ============================================================================",
    "# STORAGE INTERFACES (Would be Cassandra/Redis in production)",
    "# ============================================================================",
    "",
    "class MessageStore:",
    "    \"\"\"",
    "    In-memory message store simulating Cassandra.",
    "    Production: Use Cassandra with partition key = conversation_id,",
    "                clustering key = sequence_number",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # conversation_id -> list of messages sorted by sequence",
    "        self._messages: Dict[str, List[Message]] = defaultdict(list)",
    "        self._lock = Lock()",
    "    ",
    "    def store_message(self, message: Message) -> None:",
    "        \"\"\"Store a message (append-only).\"\"\"",
    "        with self._lock:",
    "            self._messages[message.conversation_id].append(message)",
    "    ",
    "    def get_messages(",
    "        self,",
    "        conversation_id: str,",
    "        after_sequence: int = 0,",
    "        limit: int = 50",
    "    ) -> List[Message]:",
    "        \"\"\"Get messages after a sequence number (for sync).\"\"\"",
    "        messages = self._messages.get(conversation_id, [])",
    "        filtered = [m for m in messages if m.sequence_number > after_sequence]",
    "        return sorted(filtered, key=lambda m: m.sequence_number)[:limit]",
    "    ",
    "    def get_message(self, conversation_id: str, message_id: str) -> Optional[Message]:",
    "        \"\"\"Get a specific message.\"\"\"",
    "        for msg in self._messages.get(conversation_id, []):",
    "            if msg.message_id == message_id:",
    "                return msg",
    "        return None",
    "",
    "",
    "class ConversationStore:",
    "    \"\"\"In-memory conversation store.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._conversations: Dict[str, Conversation] = {}",
    "        self._user_conversations: Dict[str, Dict[str, UserConversationState]] = defaultdict(dict)",
    "        self._lock = Lock()",
    "    ",
    "    def create_conversation(self, conversation: Conversation) -> None:",
    "        with self._lock:",
    "            self._conversations[conversation.conversation_id] = conversation",
    "            for user_id in conversation.participant_ids:",
    "                self._user_conversations[user_id][conversation.conversation_id] = \\",
    "                    UserConversationState(",
    "                        user_id=user_id,",
    "                        conversation_id=conversation.conversation_id,",
    "                        last_message_time=conversation.created_at",
    "                    )",
    "    ",
    "    def get_conversation(self, conversation_id: str) -> Optional[Conversation]:",
    "        return self._conversations.get(conversation_id)",
    "    ",
    "    def get_user_conversations(self, user_id: str, limit: int = 20) -> List[Conversation]:",
    "        \"\"\"Get user's conversations sorted by last message time.\"\"\"",
    "        user_convs = self._user_conversations.get(user_id, {})",
    "        conv_ids = sorted(",
    "            user_convs.keys(),",
    "            key=lambda cid: user_convs[cid].last_message_time,",
    "            reverse=True",
    "        )[:limit]",
    "        return [self._conversations[cid] for cid in conv_ids if cid in self._conversations]",
    "    ",
    "    def update_conversation_last_message(",
    "        self,",
    "        conversation_id: str,",
    "        preview: str,",
    "        timestamp: int,",
    "        sequence: int",
    "    ) -> None:",
    "        \"\"\"Update last message info for conversation.\"\"\"",
    "        with self._lock:",
    "            conv = self._conversations.get(conversation_id)",
    "            if conv:",
    "                conv.last_message_preview = preview[:100]",
    "                conv.last_message_time = timestamp",
    "                conv.last_sequence_number = sequence",
    "                # Update user conversation states",
    "                for user_id in conv.participant_ids:",
    "                    if conversation_id in self._user_conversations[user_id]:",
    "                        self._user_conversations[user_id][conversation_id].last_message_time = timestamp",
    "    ",
    "    def get_user_state(self, user_id: str, conversation_id: str) -> Optional[UserConversationState]:",
    "        return self._user_conversations.get(user_id, {}).get(conversation_id)",
    "    ",
    "    def mark_read(self, user_id: str, conversation_id: str, sequence: int) -> None:",
    "        \"\"\"Mark messages as read up to sequence number.\"\"\"",
    "        with self._lock:",
    "            state = self._user_conversations.get(user_id, {}).get(conversation_id)",
    "            if state:",
    "                state.last_read_sequence = max(state.last_read_sequence, sequence)",
    "                state.unread_count = 0",
    "    ",
    "    def find_direct_conversation(self, user_id1: str, user_id2: str) -> Optional[str]:",
    "        \"\"\"Find existing direct conversation between two users.\"\"\"",
    "        for conv_id, conv in self._conversations.items():",
    "            if conv.conversation_type == ConversationType.DIRECT:",
    "                if set(conv.participant_ids) == {user_id1, user_id2}:",
    "                    return conv_id",
    "        return None",
    "",
    "",
    "class SessionStore:",
    "    \"\"\"",
    "    In-memory session store simulating Redis.",
    "    Maps user_id -> (websocket_server_id, connection_id)",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._sessions: Dict[str, Dict[str, Any]] = {}",
    "        self._presence: Dict[str, int] = {}  # user_id -> last_seen",
    "        self._lock = Lock()",
    "    ",
    "    def register_connection(",
    "        self,",
    "        user_id: str,",
    "        server_id: str,",
    "        connection_id: str",
    "    ) -> None:",
    "        \"\"\"Register a WebSocket connection.\"\"\"",
    "        with self._lock:",
    "            self._sessions[user_id] = {",
    "                \"server_id\": server_id,",
    "                \"connection_id\": connection_id,",
    "                \"connected_at\": int(time.time())",
    "            }",
    "            self._presence[user_id] = int(time.time())",
    "    ",
    "    def unregister_connection(self, user_id: str) -> None:",
    "        \"\"\"Remove a WebSocket connection.\"\"\"",
    "        with self._lock:",
    "            self._sessions.pop(user_id, None)",
    "            self._presence[user_id] = int(time.time())  # Mark last seen",
    "    ",
    "    def get_session(self, user_id: str) -> Optional[Dict]:",
    "        \"\"\"Get user's current session (None if offline).\"\"\"",
    "        return self._sessions.get(user_id)",
    "    ",
    "    def is_online(self, user_id: str) -> bool:",
    "        return user_id in self._sessions",
    "    ",
    "    def get_last_seen(self, user_id: str) -> Optional[int]:",
    "        return self._presence.get(user_id)",
    "",
    "",
    "# ============================================================================",
    "# MESSAGE BUS (Simulated Kafka)",
    "# ============================================================================",
    "",
    "class MessageBus:",
    "    \"\"\"",
    "    Simulated Kafka for message routing.",
    "    In production: Use actual Kafka with partitioning by conversation_id.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, num_partitions: int = 8):",
    "        self._num_partitions = num_partitions",
    "        self._partitions: Dict[int, List[Dict]] = {i: [] for i in range(num_partitions)}",
    "        self._consumers: List[Callable] = []",
    "        self._lock = Lock()",
    "    ",
    "    def _get_partition(self, conversation_id: str) -> int:",
    "        \"\"\"Consistent hashing to partition by conversation_id.\"\"\"",
    "        hash_val = int(hashlib.md5(conversation_id.encode()).hexdigest(), 16)",
    "        return hash_val % self._num_partitions",
    "    ",
    "    def publish(self, event_type: str, conversation_id: str, payload: Dict) -> None:",
    "        \"\"\"Publish event to partition.\"\"\"",
    "        partition = self._get_partition(conversation_id)",
    "        event = {",
    "            \"type\": event_type,",
    "            \"conversation_id\": conversation_id,",
    "            \"payload\": payload,",
    "            \"timestamp\": int(time.time() * 1000)",
    "        }",
    "        with self._lock:",
    "            self._partitions[partition].append(event)",
    "        # Immediately notify consumers (in production, consumers poll)",
    "        for consumer in self._consumers:",
    "            consumer(event)",
    "    ",
    "    def subscribe(self, callback: Callable) -> None:",
    "        \"\"\"Register a consumer callback.\"\"\"",
    "        self._consumers.append(callback)",
    "",
    "",
    "# ============================================================================",
    "# WEBSOCKET CONNECTION MANAGER",
    "# ============================================================================",
    "",
    "class WebSocketConnection:",
    "    \"\"\"Simulated WebSocket connection.\"\"\"",
    "    ",
    "    def __init__(self, connection_id: str, user_id: str):",
    "        self.connection_id = connection_id",
    "        self.user_id = user_id",
    "        self.connected_at = int(time.time())",
    "        self._message_queue: List[WebSocketEvent] = []",
    "    ",
    "    def send(self, event: WebSocketEvent) -> None:",
    "        \"\"\"Send event to client (simulated).\"\"\"",
    "        self._message_queue.append(event)",
    "    ",
    "    def get_pending_events(self) -> List[WebSocketEvent]:",
    "        \"\"\"Get and clear pending events (for testing).\"\"\"",
    "        events = self._message_queue.copy()",
    "        self._message_queue.clear()",
    "        return events",
    "",
    "",
    "class WebSocketGateway:",
    "    \"\"\"",
    "    Manages WebSocket connections for a single server.",
    "    In production: Each gateway server handles ~100K connections.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, server_id: str, session_store: SessionStore):",
    "        self.server_id = server_id",
    "        self._session_store = session_store",
    "        self._connections: Dict[str, WebSocketConnection] = {}  # user_id -> connection",
    "        self._lock = Lock()",
    "    ",
    "    def connect(self, user_id: str) -> WebSocketConnection:",
    "        \"\"\"Establish WebSocket connection.\"\"\"",
    "        connection_id = f\"conn_{uuid.uuid4().hex[:8]}\"",
    "        connection = WebSocketConnection(connection_id, user_id)",
    "        ",
    "        with self._lock:",
    "            # Close existing connection if any",
    "            if user_id in self._connections:",
    "                self.disconnect(user_id)",
    "            self._connections[user_id] = connection",
    "        ",
    "        # Register in session store",
    "        self._session_store.register_connection(",
    "            user_id, self.server_id, connection_id",
    "        )",
    "        ",
    "        return connection",
    "    ",
    "    def disconnect(self, user_id: str) -> None:",
    "        \"\"\"Close WebSocket connection.\"\"\"",
    "        with self._lock:",
    "            self._connections.pop(user_id, None)",
    "        self._session_store.unregister_connection(user_id)",
    "    ",
    "    def send_to_user(self, user_id: str, event: WebSocketEvent) -> bool:",
    "        \"\"\"Send event to a connected user. Returns False if not connected.\"\"\"",
    "        connection = self._connections.get(user_id)",
    "        if connection:",
    "            connection.send(event)",
    "            return True",
    "        return False",
    "    ",
    "    def get_connection(self, user_id: str) -> Optional[WebSocketConnection]:",
    "        return self._connections.get(user_id)",
    "",
    "",
    "# ============================================================================",
    "# SEQUENCE NUMBER GENERATOR",
    "# ============================================================================",
    "",
    "class SequenceGenerator:",
    "    \"\"\"",
    "    Generates monotonically increasing sequence numbers per conversation.",
    "    In production: Use Redis INCR or Cassandra LWT for atomicity.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._sequences: Dict[str, int] = defaultdict(int)",
    "        self._lock = Lock()",
    "    ",
    "    def next_sequence(self, conversation_id: str) -> int:",
    "        \"\"\"Get next sequence number for conversation.\"\"\"",
    "        with self._lock:",
    "            self._sequences[conversation_id] += 1",
    "            return self._sequences[conversation_id]",
    "    ",
    "    def get_current(self, conversation_id: str) -> int:",
    "        return self._sequences.get(conversation_id, 0)",
    "",
    "",
    "# ============================================================================",
    "# PUSH NOTIFICATION SERVICE (Simulated)",
    "# ============================================================================",
    "",
    "class PushNotificationService:",
    "    \"\"\"Simulated push notification service for offline users.\"\"\"",
    "    ",
    "    def __init__(self):",
    "        self._notifications: Dict[str, List[Dict]] = defaultdict(list)",
    "    ",
    "    def send_notification(",
    "        self,",
    "        user_id: str,",
    "        title: str,",
    "        body: str,",
    "        data: Dict",
    "    ) -> None:",
    "        \"\"\"Send push notification to offline user.\"\"\"",
    "        self._notifications[user_id].append({",
    "            \"title\": title,",
    "            \"body\": body,",
    "            \"data\": data,",
    "            \"timestamp\": int(time.time())",
    "        })",
    "        print(f\"\ud83d\udcf1 PUSH to {user_id}: {title} - {body}\")",
    "    ",
    "    def get_notifications(self, user_id: str) -> List[Dict]:",
    "        return self._notifications.get(user_id, [])",
    "",
    "",
    "# ============================================================================",
    "# MAIN DM SERVICE",
    "# ============================================================================",
    "",
    "class DirectMessagingService:",
    "    \"\"\"",
    "    Core Direct Messaging service.",
    "    Handles message sending, conversation management, and delivery.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Storage layers",
    "        self._message_store = MessageStore()",
    "        self._conversation_store = ConversationStore()",
    "        self._session_store = SessionStore()",
    "        self._sequence_generator = SequenceGenerator()",
    "        ",
    "        # Infrastructure",
    "        self._message_bus = MessageBus()",
    "        self._push_service = PushNotificationService()",
    "        ",
    "        # WebSocket gateway (single server for demo)",
    "        self._ws_gateway = WebSocketGateway(\"ws-server-1\", self._session_store)",
    "        ",
    "        # Deduplication cache (client_message_id -> message_id)",
    "        self._dedup_cache: Dict[str, str] = {}",
    "        ",
    "        # Subscribe to message bus",
    "        self._message_bus.subscribe(self._handle_message_event)",
    "    ",
    "    # ========================================================================",
    "    # CONVERSATION MANAGEMENT",
    "    # ========================================================================",
    "    ",
    "    def create_direct_conversation(",
    "        self,",
    "        user_id1: str,",
    "        user_id2: str",
    "    ) -> str:",
    "        \"\"\"",
    "        Create or get existing direct conversation between two users.",
    "        Returns conversation_id.",
    "        \"\"\"",
    "        # Check for existing conversation",
    "        existing = self._conversation_store.find_direct_conversation(user_id1, user_id2)",
    "        if existing:",
    "            return existing",
    "        ",
    "        # Create new conversation",
    "        conv_id = f\"conv_{uuid.uuid4().hex[:12]}\"",
    "        conversation = Conversation(",
    "            conversation_id=conv_id,",
    "            conversation_type=ConversationType.DIRECT,",
    "            participant_ids=[user_id1, user_id2],",
    "            created_at=int(time.time())",
    "        )",
    "        self._conversation_store.create_conversation(conversation)",
    "        ",
    "        print(f\"\u2705 Created direct conversation {conv_id} between {user_id1} and {user_id2}\")",
    "        return conv_id",
    "    ",
    "    def create_group_chat(",
    "        self,",
    "        creator_id: str,",
    "        member_ids: List[str],",
    "        name: str",
    "    ) -> str:",
    "        \"\"\"",
    "        Create a group chat.",
    "        ",
    "        Args:",
    "            creator_id: User creating the group",
    "            member_ids: List of members (creator included automatically)",
    "            name: Group name",
    "        ",
    "        Returns:",
    "            conversation_id",
    "        \"\"\"",
    "        # Ensure creator is in members",
    "        all_members = list(set([creator_id] + member_ids))",
    "        ",
    "        conv_id = f\"group_{uuid.uuid4().hex[:12]}\"",
    "        conversation = Conversation(",
    "            conversation_id=conv_id,",
    "            conversation_type=ConversationType.GROUP,",
    "            participant_ids=all_members,",
    "            name=name,",
    "            created_at=int(time.time())",
    "        )",
    "        self._conversation_store.create_conversation(conversation)",
    "        ",
    "        # Send system message about group creation",
    "        self._send_system_message(",
    "            conv_id,",
    "            f\"{creator_id} created group '{name}'\"",
    "        )",
    "        ",
    "        print(f\"\u2705 Created group '{name}' with {len(all_members)} members\")",
    "        return conv_id",
    "    ",
    "    # ========================================================================",
    "    # MESSAGE SENDING",
    "    # ========================================================================",
    "    ",
    "    def send_message(",
    "        self,",
    "        sender_id: str,",
    "        conversation_id: str,",
    "        message_type: MessageType,",
    "        content: str,",
    "        client_message_id: Optional[str] = None",
    "    ) -> str:",
    "        \"\"\"",
    "        Send a message to a conversation.",
    "        ",
    "        Flow:",
    "        1. Validate sender is a participant",
    "        2. Check for duplicate (idempotency)",
    "        3. Assign sequence number",
    "        4. Store message (durability first!)",
    "        5. Publish to message bus for async delivery",
    "        ",
    "        Args:",
    "            sender_id: ID of sender",
    "            conversation_id: Target conversation",
    "            message_type: TEXT, IMAGE, or VIDEO",
    "            content: Message content or media URL",
    "            client_message_id: Client-generated ID for deduplication",
    "        ",
    "        Returns:",
    "            Server-generated message_id",
    "        \"\"\"",
    "        # Step 1: Validate conversation and membership",
    "        conversation = self._conversation_store.get_conversation(conversation_id)",
    "        if not conversation:",
    "            raise ValueError(f\"Conversation {conversation_id} not found\")",
    "        ",
    "        if sender_id not in conversation.participant_ids:",
    "            raise PermissionError(f\"User {sender_id} is not in conversation\")",
    "        ",
    "        # Step 2: Deduplication check",
    "        if client_message_id and client_message_id in self._dedup_cache:",
    "            return self._dedup_cache[client_message_id]",
    "        ",
    "        # Step 3: Generate message ID and sequence number",
    "        message_id = f\"msg_{uuid.uuid4().hex[:12]}\"",
    "        sequence = self._sequence_generator.next_sequence(conversation_id)",
    "        timestamp = int(time.time() * 1000)",
    "        ",
    "        # Step 4: Create and store message",
    "        message = Message(",
    "            message_id=message_id,",
    "            conversation_id=conversation_id,",
    "            sender_id=sender_id,",
    "            message_type=message_type,",
    "            content=content,",
    "            timestamp=timestamp,",
    "            sequence_number=sequence,",
    "            client_message_id=client_message_id",
    "        )",
    "        self._message_store.store_message(message)",
    "        ",
    "        # Update dedup cache",
    "        if client_message_id:",
    "            self._dedup_cache[client_message_id] = message_id",
    "        ",
    "        # Update conversation metadata",
    "        preview = content[:100] if message_type == MessageType.TEXT else f\"[{message_type.value}]\"",
    "        self._conversation_store.update_conversation_last_message(",
    "            conversation_id, preview, timestamp, sequence",
    "        )",
    "        ",
    "        # Step 5: Publish to message bus for async delivery",
    "        self._message_bus.publish(",
    "            event_type=\"MESSAGE_CREATED\",",
    "            conversation_id=conversation_id,",
    "            payload={",
    "                \"message\": message.to_dict(),",
    "                \"participants\": conversation.participant_ids",
    "            }",
    "        )",
    "        ",
    "        print(f\"\ud83d\udce8 Message {message_id} sent by {sender_id} (seq={sequence})\")",
    "        return message_id",
    "    ",
    "    def _send_system_message(self, conversation_id: str, content: str) -> None:",
    "        \"\"\"Send a system message (for group events).\"\"\"",
    "        conversation = self._conversation_store.get_conversation(conversation_id)",
    "        if not conversation:",
    "            return",
    "        ",
    "        message_id = f\"sys_{uuid.uuid4().hex[:12]}\"",
    "        sequence = self._sequence_generator.next_sequence(conversation_id)",
    "        timestamp = int(time.time() * 1000)",
    "        ",
    "        message = Message(",
    "            message_id=message_id,",
    "            conversation_id=conversation_id,",
    "            sender_id=\"SYSTEM\",",
    "            message_type=MessageType.SYSTEM,",
    "            content=content,",
    "            timestamp=timestamp,",
    "            sequence_number=sequence",
    "        )",
    "        self._message_store.store_message(message)",
    "    ",
    "    # ========================================================================",
    "    # MESSAGE DELIVERY (Kafka Consumer Handler)",
    "    # ========================================================================",
    "    ",
    "    def _handle_message_event(self, event: Dict) -> None:",
    "        \"\"\"",
    "        Handle message event from Kafka.",
    "        Routes to online users via WebSocket, queues for offline users.",
    "        \"\"\"",
    "        if event[\"type\"] != \"MESSAGE_CREATED\":",
    "            return",
    "        ",
    "        message_data = event[\"payload\"][\"message\"]",
    "        participants = event[\"payload\"][\"participants\"]",
    "        sender_id = message_data[\"sender_id\"]",
    "        ",
    "        # Deliver to all participants except sender",
    "        for user_id in participants:",
    "            if user_id == sender_id:",
    "                continue",
    "            ",
    "            self._deliver_to_user(user_id, message_data)",
    "    ",
    "    def _deliver_to_user(self, user_id: str, message_data: Dict) -> None:",
    "        \"\"\"Deliver message to a specific user.\"\"\"",
    "        session = self._session_store.get_session(user_id)",
    "        ",
    "        if session:",
    "            # User is online - push via WebSocket",
    "            event = WebSocketEvent(",
    "                event_type=\"NEW_MESSAGE\",",
    "                payload=message_data",
    "            )",
    "            delivered = self._ws_gateway.send_to_user(user_id, event)",
    "            if delivered:",
    "                print(f\"  \u2713 Delivered to {user_id} via WebSocket\")",
    "        else:",
    "            # User is offline - send push notification",
    "            self._push_service.send_notification(",
    "                user_id=user_id,",
    "                title=f\"New message from {message_data['sender_id']}\",",
    "                body=message_data.get('content', '')[:50],",
    "                data={\"conversation_id\": message_data['conversation_id']}",
    "            )",
    "    ",
    "    # ========================================================================",
    "    # MESSAGE RETRIEVAL",
    "    # ========================================================================",
    "    ",
    "    def get_conversations(self, user_id: str, limit: int = 20) -> List[Conversation]:",
    "        \"\"\"",
    "        Get user's conversations sorted by last message time.",
    "        ",
    "        Args:",
    "            user_id: The user requesting conversations",
    "            limit: Maximum conversations to return",
    "        ",
    "        Returns:",
    "            List of Conversation objects, most recent first",
    "        \"\"\"",
    "        return self._conversation_store.get_user_conversations(user_id, limit)",
    "    ",
    "    def get_messages(",
    "        self,",
    "        user_id: str,",
    "        conversation_id: str,",
    "        after_sequence: int = 0,",
    "        limit: int = 50",
    "    ) -> List[Message]:",
    "        \"\"\"",
    "        Get messages from a conversation.",
    "        ",
    "        Args:",
    "            user_id: User requesting messages (for authorization)",
    "            conversation_id: Target conversation",
    "            after_sequence: Return messages after this sequence (for sync)",
    "            limit: Maximum messages to return",
    "        ",
    "        Returns:",
    "            List of Message objects in sequence order",
    "        \"\"\"",
    "        # Validate user is in conversation",
    "        conversation = self._conversation_store.get_conversation(conversation_id)",
    "        if not conversation or user_id not in conversation.participant_ids:",
    "            raise PermissionError(\"Access denied to conversation\")",
    "        ",
    "        return self._message_store.get_messages(",
    "            conversation_id, after_sequence, limit",
    "        )",
    "    ",
    "    # ========================================================================",
    "    # READ RECEIPTS",
    "    # ========================================================================",
    "    ",
    "    def mark_as_read(",
    "        self,",
    "        user_id: str,",
    "        conversation_id: str,",
    "        message_id: str",
    "    ) -> None:",
    "        \"\"\"",
    "        Mark messages as read up to the specified message.",
    "        ",
    "        Args:",
    "            user_id: User marking as read",
    "            conversation_id: Target conversation",
    "            message_id: Last read message",
    "        \"\"\"",
    "        # Get message to find sequence number",
    "        message = self._message_store.get_message(conversation_id, message_id)",
    "        if not message:",
    "            return",
    "        ",
    "        # Update user's read position",
    "        self._conversation_store.mark_read(",
    "            user_id, conversation_id, message.sequence_number",
    "        )",
    "        ",
    "        # Broadcast read receipt to other participants",
    "        conversation = self._conversation_store.get_conversation(conversation_id)",
    "        if conversation:",
    "            for participant_id in conversation.participant_ids:",
    "                if participant_id != user_id:",
    "                    event = WebSocketEvent(",
    "                        event_type=\"READ_RECEIPT\",",
    "                        payload={",
    "                            \"conversation_id\": conversation_id,",
    "                            \"reader_id\": user_id,",
    "                            \"message_id\": message_id,",
    "                            \"sequence_number\": message.sequence_number",
    "                        }",
    "                    )",
    "                    self._ws_gateway.send_to_user(participant_id, event)",
    "        ",
    "        print(f\"\u2713 {user_id} marked {conversation_id} read up to {message_id}\")",
    "    ",
    "    # ========================================================================",
    "    # WEBSOCKET CONNECTION MANAGEMENT",
    "    # ========================================================================",
    "    ",
    "    def connect_user(self, user_id: str) -> WebSocketConnection:",
    "        \"\"\"Establish WebSocket connection for a user.\"\"\"",
    "        return self._ws_gateway.connect(user_id)",
    "    ",
    "    def disconnect_user(self, user_id: str) -> None:",
    "        \"\"\"Disconnect user's WebSocket.\"\"\"",
    "        self._ws_gateway.disconnect(user_id)",
    "    ",
    "    def sync_on_reconnect(",
    "        self,",
    "        user_id: str,",
    "        last_sequences: Dict[str, int]",
    "    ) -> Dict[str, List[Message]]:",
    "        \"\"\"",
    "        Sync messages on reconnect.",
    "        ",
    "        Args:",
    "            user_id: Reconnecting user",
    "            last_sequences: Dict of conversation_id -> last received sequence",
    "        ",
    "        Returns:",
    "            Dict of conversation_id -> list of missed messages",
    "        \"\"\"",
    "        missed_messages = {}",
    "        ",
    "        for conv_id, last_seq in last_sequences.items():",
    "            try:",
    "                messages = self.get_messages(",
    "                    user_id, conv_id, after_sequence=last_seq, limit=100",
    "                )",
    "                if messages:",
    "                    missed_messages[conv_id] = messages",
    "            except PermissionError:",
    "                continue",
    "        ",
    "        return missed_messages",
    "    ",
    "    # ========================================================================",
    "    # TYPING INDICATORS",
    "    # ========================================================================",
    "    ",
    "    def send_typing_indicator(",
    "        self,",
    "        user_id: str,",
    "        conversation_id: str,",
    "        is_typing: bool",
    "    ) -> None:",
    "        \"\"\"Broadcast typing indicator to conversation participants.\"\"\"",
    "        conversation = self._conversation_store.get_conversation(conversation_id)",
    "        if not conversation:",
    "            return",
    "        ",
    "        for participant_id in conversation.participant_ids:",
    "            if participant_id != user_id:",
    "                event = WebSocketEvent(",
    "                    event_type=\"TYPING_INDICATOR\",",
    "                    payload={",
    "                        \"conversation_id\": conversation_id,",
    "                        \"user_id\": user_id,",
    "                        \"is_typing\": is_typing",
    "                    }",
    "                )",
    "                self._ws_gateway.send_to_user(participant_id, event)",
    "",
    "",
    "# ============================================================================",
    "# DEMO AND TESTING",
    "# ============================================================================",
    "",
    "def run_dm_demo():",
    "    \"\"\"Demonstrate DM system functionality.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"   INSTAGRAM DIRECT MESSAGING DEMO\")",
    "    print(\"=\" * 70)",
    "    print()",
    "    ",
    "    dm_service = DirectMessagingService()",
    "    ",
    "    # ======================================================================",
    "    # Demo 1: Direct Conversation",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 1: Direct Conversation\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Create conversation between Alice and Bob",
    "    conv_id = dm_service.create_direct_conversation(\"alice\", \"bob\")",
    "    ",
    "    # Connect both users",
    "    alice_conn = dm_service.connect_user(\"alice\")",
    "    bob_conn = dm_service.connect_user(\"bob\")",
    "    print(f\"\ud83d\udfe2 Alice and Bob connected via WebSocket\")",
    "    print()",
    "    ",
    "    # Alice sends a message",
    "    msg1_id = dm_service.send_message(",
    "        sender_id=\"alice\",",
    "        conversation_id=conv_id,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Hey Bob! How are you?\"",
    "    )",
    "    ",
    "    # Check Bob received the message",
    "    bob_events = bob_conn.get_pending_events()",
    "    print(f\"Bob received {len(bob_events)} event(s):\")",
    "    for event in bob_events:",
    "        print(f\"  - {event.event_type}: {event.payload.get('content', '')}\")",
    "    print()",
    "    ",
    "    # Bob replies",
    "    msg2_id = dm_service.send_message(",
    "        sender_id=\"bob\",",
    "        conversation_id=conv_id,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Hi Alice! I'm doing great, thanks!\"",
    "    )",
    "    ",
    "    # Alice receives the reply",
    "    alice_events = alice_conn.get_pending_events()",
    "    print(f\"Alice received {len(alice_events)} event(s):\")",
    "    for event in alice_events:",
    "        print(f\"  - {event.event_type}: {event.payload.get('content', '')}\")",
    "    print()",
    "    ",
    "    # Bob marks as read",
    "    dm_service.mark_as_read(\"bob\", conv_id, msg1_id)",
    "    print()",
    "    ",
    "    # ======================================================================",
    "    # Demo 2: Offline Message Delivery",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 2: Offline Message Delivery\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Charlie is offline",
    "    conv_charlie = dm_service.create_direct_conversation(\"alice\", \"charlie\")",
    "    ",
    "    # Alice sends message to offline Charlie",
    "    dm_service.send_message(",
    "        sender_id=\"alice\",",
    "        conversation_id=conv_charlie,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Hey Charlie, are you there?\"",
    "    )",
    "    print(\"(Charlie receives push notification since offline)\")",
    "    print()",
    "    ",
    "    # ======================================================================",
    "    # Demo 3: Group Chat",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 3: Group Chat\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Create group chat",
    "    group_id = dm_service.create_group_chat(",
    "        creator_id=\"alice\",",
    "        member_ids=[\"bob\", \"charlie\", \"dave\"],",
    "        name=\"Weekend Hiking\"",
    "    )",
    "    ",
    "    # Connect Dave for real-time messages",
    "    dave_conn = dm_service.connect_user(\"dave\")",
    "    ",
    "    # Alice sends message to group",
    "    dm_service.send_message(",
    "        sender_id=\"alice\",",
    "        conversation_id=group_id,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Who's up for hiking this Saturday?\"",
    "    )",
    "    ",
    "    # Check who received it",
    "    dave_events = dave_conn.get_pending_events()",
    "    print(f\"Dave received {len(dave_events)} event(s) in group chat\")",
    "    print()",
    "    ",
    "    # ======================================================================",
    "    # Demo 4: Message Retrieval",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 4: Message Retrieval\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Get Alice's conversations",
    "    conversations = dm_service.get_conversations(\"alice\")",
    "    print(f\"Alice has {len(conversations)} conversation(s):\")",
    "    for conv in conversations:",
    "        print(f\"  - {conv.conversation_id}: {conv.last_message_preview}\")",
    "    print()",
    "    ",
    "    # Get messages from first conversation",
    "    messages = dm_service.get_messages(\"alice\", conv_id)",
    "    print(f\"Messages in conversation with Bob:\")",
    "    for msg in messages:",
    "        print(f\"  [{msg.sequence_number}] {msg.sender_id}: {msg.content}\")",
    "    print()",
    "    ",
    "    # ======================================================================",
    "    # Demo 5: Sync on Reconnect",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 5: Sync on Reconnect\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Disconnect Bob",
    "    dm_service.disconnect_user(\"bob\")",
    "    print(\"\ud83d\udd34 Bob disconnected\")",
    "    ",
    "    # Alice sends more messages while Bob is offline",
    "    dm_service.send_message(",
    "        sender_id=\"alice\",",
    "        conversation_id=conv_id,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Bob? You still there?\"",
    "    )",
    "    dm_service.send_message(",
    "        sender_id=\"alice\",",
    "        conversation_id=conv_id,",
    "        message_type=MessageType.TEXT,",
    "        content=\"Let me know when you're back!\"",
    "    )",
    "    ",
    "    # Bob reconnects and syncs",
    "    bob_conn = dm_service.connect_user(\"bob\")",
    "    print(\"\ud83d\udfe2 Bob reconnected\")",
    "    ",
    "    # Sync with last known sequences",
    "    missed = dm_service.sync_on_reconnect(",
    "        user_id=\"bob\",",
    "        last_sequences={conv_id: 2}  # Bob last saw seq=2",
    "    )",
    "    ",
    "    print(f\"Bob missed {len(missed.get(conv_id, []))} message(s):\")",
    "    for msg in missed.get(conv_id, []):",
    "        print(f\"  [{msg.sequence_number}] {msg.sender_id}: {msg.content}\")",
    "    print()",
    "    ",
    "    # ======================================================================",
    "    # Demo 6: Typing Indicator",
    "    # ======================================================================",
    "    print(\"\ud83d\udcf1 DEMO 6: Typing Indicator\")",
    "    print(\"-\" * 40)",
    "    ",
    "    dm_service.send_typing_indicator(\"alice\", conv_id, True)",
    "    bob_events = bob_conn.get_pending_events()",
    "    if bob_events:",
    "        print(f\"Bob sees: {bob_events[0].payload}\")",
    "    print()",
    "    ",
    "    print(\"=\" * 70)",
    "    print(\"   DEMO COMPLETE\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_dm_demo()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.util.concurrent.atomic.*;",
    "import java.util.stream.*;",
    "import java.security.MessageDigest;",
    "",
    "/**",
    " * Instagram Direct Messaging System - Part 4",
    " * Real-time messaging with WebSocket support, offline handling, and group chats.",
    " */",
    "public class DirectMessagingSystem {",
    "",
    "    // ========================================================================",
    "    // ENUMS",
    "    // ========================================================================",
    "    ",
    "    enum MessageType { TEXT, IMAGE, VIDEO, SYSTEM }",
    "    enum MessageStatus { SENT, DELIVERED, READ }",
    "    enum ConversationType { DIRECT, GROUP }",
    "",
    "    // ========================================================================",
    "    // DATA CLASSES",
    "    // ========================================================================",
    "    ",
    "    static class Message {",
    "        String messageId;",
    "        String conversationId;",
    "        String senderId;",
    "        MessageType messageType;",
    "        String content;",
    "        long timestamp;",
    "        int sequenceNumber;",
    "        MessageStatus status;",
    "        String clientMessageId;",
    "        ",
    "        Message(String messageId, String conversationId, String senderId,",
    "                MessageType type, String content, long timestamp, int seq) {",
    "            this.messageId = messageId;",
    "            this.conversationId = conversationId;",
    "            this.senderId = senderId;",
    "            this.messageType = type;",
    "            this.content = content;",
    "            this.timestamp = timestamp;",
    "            this.sequenceNumber = seq;",
    "            this.status = MessageStatus.SENT;",
    "        }",
    "        ",
    "        Map<String, Object> toMap() {",
    "            Map<String, Object> map = new HashMap<>();",
    "            map.put(\"message_id\", messageId);",
    "            map.put(\"conversation_id\", conversationId);",
    "            map.put(\"sender_id\", senderId);",
    "            map.put(\"type\", messageType.name());",
    "            map.put(\"content\", content);",
    "            map.put(\"timestamp\", timestamp);",
    "            map.put(\"sequence_number\", sequenceNumber);",
    "            return map;",
    "        }",
    "    }",
    "    ",
    "    static class Conversation {",
    "        String conversationId;",
    "        ConversationType type;",
    "        List<String> participantIds;",
    "        String name;",
    "        long createdAt;",
    "        String lastMessagePreview;",
    "        long lastMessageTime;",
    "        int lastSequenceNumber;",
    "        ",
    "        Conversation(String id, ConversationType type, List<String> participants) {",
    "            this.conversationId = id;",
    "            this.type = type;",
    "            this.participantIds = new ArrayList<>(participants);",
    "            this.createdAt = System.currentTimeMillis();",
    "        }",
    "    }",
    "    ",
    "    static class UserConversationState {",
    "        String userId;",
    "        String conversationId;",
    "        int lastReadSequence;",
    "        int unreadCount;",
    "        long lastMessageTime;",
    "        ",
    "        UserConversationState(String userId, String convId) {",
    "            this.userId = userId;",
    "            this.conversationId = convId;",
    "        }",
    "    }",
    "    ",
    "    static class WebSocketEvent {",
    "        String eventType;",
    "        Map<String, Object> payload;",
    "        long timestamp;",
    "        ",
    "        WebSocketEvent(String type, Map<String, Object> payload) {",
    "            this.eventType = type;",
    "            this.payload = payload;",
    "            this.timestamp = System.currentTimeMillis();",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // STORAGE CLASSES",
    "    // ========================================================================",
    "    ",
    "    static class MessageStore {",
    "        private final ConcurrentMap<String, List<Message>> messages = new ConcurrentHashMap<>();",
    "        ",
    "        void storeMessage(Message message) {",
    "            messages.computeIfAbsent(message.conversationId, k -> ",
    "                Collections.synchronizedList(new ArrayList<>())).add(message);",
    "        }",
    "        ",
    "        List<Message> getMessages(String convId, int afterSeq, int limit) {",
    "            List<Message> convMessages = messages.getOrDefault(convId, Collections.emptyList());",
    "            return convMessages.stream()",
    "                .filter(m -> m.sequenceNumber > afterSeq)",
    "                .sorted(Comparator.comparingInt(m -> m.sequenceNumber))",
    "                .limit(limit)",
    "                .collect(Collectors.toList());",
    "        }",
    "        ",
    "        Message getMessage(String convId, String messageId) {",
    "            return messages.getOrDefault(convId, Collections.emptyList()).stream()",
    "                .filter(m -> m.messageId.equals(messageId))",
    "                .findFirst().orElse(null);",
    "        }",
    "    }",
    "    ",
    "    static class ConversationStore {",
    "        private final ConcurrentMap<String, Conversation> conversations = new ConcurrentHashMap<>();",
    "        private final ConcurrentMap<String, ConcurrentMap<String, UserConversationState>> ",
    "            userConversations = new ConcurrentHashMap<>();",
    "        ",
    "        void createConversation(Conversation conv) {",
    "            conversations.put(conv.conversationId, conv);",
    "            for (String userId : conv.participantIds) {",
    "                userConversations.computeIfAbsent(userId, k -> new ConcurrentHashMap<>())",
    "                    .put(conv.conversationId, new UserConversationState(userId, conv.conversationId));",
    "            }",
    "        }",
    "        ",
    "        Conversation getConversation(String convId) {",
    "            return conversations.get(convId);",
    "        }",
    "        ",
    "        List<Conversation> getUserConversations(String userId, int limit) {",
    "            ConcurrentMap<String, UserConversationState> userConvs = ",
    "                userConversations.getOrDefault(userId, new ConcurrentHashMap<>());",
    "            return userConvs.values().stream()",
    "                .sorted((a, b) -> Long.compare(b.lastMessageTime, a.lastMessageTime))",
    "                .limit(limit)",
    "                .map(uc -> conversations.get(uc.conversationId))",
    "                .filter(Objects::nonNull)",
    "                .collect(Collectors.toList());",
    "        }",
    "        ",
    "        void updateLastMessage(String convId, String preview, long time, int seq) {",
    "            Conversation conv = conversations.get(convId);",
    "            if (conv != null) {",
    "                conv.lastMessagePreview = preview.length() > 100 ? preview.substring(0, 100) : preview;",
    "                conv.lastMessageTime = time;",
    "                conv.lastSequenceNumber = seq;",
    "                for (String userId : conv.participantIds) {",
    "                    ConcurrentMap<String, UserConversationState> userConvs = ",
    "                        userConversations.get(userId);",
    "                    if (userConvs != null && userConvs.containsKey(convId)) {",
    "                        userConvs.get(convId).lastMessageTime = time;",
    "                    }",
    "                }",
    "            }",
    "        }",
    "        ",
    "        void markRead(String userId, String convId, int sequence) {",
    "            ConcurrentMap<String, UserConversationState> userConvs = userConversations.get(userId);",
    "            if (userConvs != null && userConvs.containsKey(convId)) {",
    "                UserConversationState state = userConvs.get(convId);",
    "                state.lastReadSequence = Math.max(state.lastReadSequence, sequence);",
    "                state.unreadCount = 0;",
    "            }",
    "        }",
    "        ",
    "        String findDirectConversation(String user1, String user2) {",
    "            Set<String> pair = Set.of(user1, user2);",
    "            return conversations.values().stream()",
    "                .filter(c -> c.type == ConversationType.DIRECT)",
    "                .filter(c -> new HashSet<>(c.participantIds).equals(pair))",
    "                .map(c -> c.conversationId)",
    "                .findFirst().orElse(null);",
    "        }",
    "    }",
    "    ",
    "    static class SessionStore {",
    "        private final ConcurrentMap<String, Map<String, Object>> sessions = new ConcurrentHashMap<>();",
    "        private final ConcurrentMap<String, Long> presence = new ConcurrentHashMap<>();",
    "        ",
    "        void registerConnection(String userId, String serverId, String connId) {",
    "            Map<String, Object> session = new HashMap<>();",
    "            session.put(\"server_id\", serverId);",
    "            session.put(\"connection_id\", connId);",
    "            session.put(\"connected_at\", System.currentTimeMillis());",
    "            sessions.put(userId, session);",
    "            presence.put(userId, System.currentTimeMillis());",
    "        }",
    "        ",
    "        void unregisterConnection(String userId) {",
    "            sessions.remove(userId);",
    "            presence.put(userId, System.currentTimeMillis());",
    "        }",
    "        ",
    "        Map<String, Object> getSession(String userId) {",
    "            return sessions.get(userId);",
    "        }",
    "        ",
    "        boolean isOnline(String userId) {",
    "            return sessions.containsKey(userId);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // WEBSOCKET GATEWAY",
    "    // ========================================================================",
    "    ",
    "    static class WebSocketConnection {",
    "        String connectionId;",
    "        String userId;",
    "        Queue<WebSocketEvent> messageQueue = new ConcurrentLinkedQueue<>();",
    "        ",
    "        WebSocketConnection(String connId, String userId) {",
    "            this.connectionId = connId;",
    "            this.userId = userId;",
    "        }",
    "        ",
    "        void send(WebSocketEvent event) {",
    "            messageQueue.offer(event);",
    "        }",
    "        ",
    "        List<WebSocketEvent> getPendingEvents() {",
    "            List<WebSocketEvent> events = new ArrayList<>();",
    "            WebSocketEvent event;",
    "            while ((event = messageQueue.poll()) != null) {",
    "                events.add(event);",
    "            }",
    "            return events;",
    "        }",
    "    }",
    "    ",
    "    static class WebSocketGateway {",
    "        private final String serverId;",
    "        private final SessionStore sessionStore;",
    "        private final ConcurrentMap<String, WebSocketConnection> connections = new ConcurrentHashMap<>();",
    "        ",
    "        WebSocketGateway(String serverId, SessionStore sessionStore) {",
    "            this.serverId = serverId;",
    "            this.sessionStore = sessionStore;",
    "        }",
    "        ",
    "        WebSocketConnection connect(String userId) {",
    "            String connId = \"conn_\" + UUID.randomUUID().toString().substring(0, 8);",
    "            WebSocketConnection conn = new WebSocketConnection(connId, userId);",
    "            connections.put(userId, conn);",
    "            sessionStore.registerConnection(userId, serverId, connId);",
    "            return conn;",
    "        }",
    "        ",
    "        void disconnect(String userId) {",
    "            connections.remove(userId);",
    "            sessionStore.unregisterConnection(userId);",
    "        }",
    "        ",
    "        boolean sendToUser(String userId, WebSocketEvent event) {",
    "            WebSocketConnection conn = connections.get(userId);",
    "            if (conn != null) {",
    "                conn.send(event);",
    "                return true;",
    "            }",
    "            return false;",
    "        }",
    "        ",
    "        WebSocketConnection getConnection(String userId) {",
    "            return connections.get(userId);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // SEQUENCE GENERATOR",
    "    // ========================================================================",
    "    ",
    "    static class SequenceGenerator {",
    "        private final ConcurrentMap<String, AtomicInteger> sequences = new ConcurrentHashMap<>();",
    "        ",
    "        int nextSequence(String conversationId) {",
    "            return sequences.computeIfAbsent(conversationId, k -> new AtomicInteger(0))",
    "                .incrementAndGet();",
    "        }",
    "        ",
    "        int getCurrent(String conversationId) {",
    "            AtomicInteger seq = sequences.get(conversationId);",
    "            return seq != null ? seq.get() : 0;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // MAIN DM SERVICE",
    "    // ========================================================================",
    "    ",
    "    static class DirectMessagingService {",
    "        private final MessageStore messageStore = new MessageStore();",
    "        private final ConversationStore conversationStore = new ConversationStore();",
    "        private final SessionStore sessionStore = new SessionStore();",
    "        private final SequenceGenerator sequenceGenerator = new SequenceGenerator();",
    "        private final WebSocketGateway wsGateway;",
    "        private final ConcurrentMap<String, String> dedupCache = new ConcurrentHashMap<>();",
    "        ",
    "        DirectMessagingService() {",
    "            this.wsGateway = new WebSocketGateway(\"ws-server-1\", sessionStore);",
    "        }",
    "        ",
    "        // ====================================================================",
    "        // CONVERSATION MANAGEMENT",
    "        // ====================================================================",
    "        ",
    "        String createDirectConversation(String userId1, String userId2) {",
    "            String existing = conversationStore.findDirectConversation(userId1, userId2);",
    "            if (existing != null) return existing;",
    "            ",
    "            String convId = \"conv_\" + UUID.randomUUID().toString().substring(0, 12);",
    "            Conversation conv = new Conversation(convId, ConversationType.DIRECT,",
    "                Arrays.asList(userId1, userId2));",
    "            conversationStore.createConversation(conv);",
    "            ",
    "            System.out.printf(\"\u2705 Created direct conversation %s between %s and %s%n\",",
    "                convId, userId1, userId2);",
    "            return convId;",
    "        }",
    "        ",
    "        String createGroupChat(String creatorId, List<String> memberIds, String name) {",
    "            Set<String> allMembers = new HashSet<>(memberIds);",
    "            allMembers.add(creatorId);",
    "            ",
    "            String convId = \"group_\" + UUID.randomUUID().toString().substring(0, 12);",
    "            Conversation conv = new Conversation(convId, ConversationType.GROUP,",
    "                new ArrayList<>(allMembers));",
    "            conv.name = name;",
    "            conversationStore.createConversation(conv);",
    "            ",
    "            System.out.printf(\"\u2705 Created group '%s' with %d members%n\", name, allMembers.size());",
    "            return convId;",
    "        }",
    "        ",
    "        // ====================================================================",
    "        // MESSAGE SENDING",
    "        // ====================================================================",
    "        ",
    "        String sendMessage(String senderId, String conversationId,",
    "                          MessageType type, String content) {",
    "            Conversation conv = conversationStore.getConversation(conversationId);",
    "            if (conv == null) throw new IllegalArgumentException(\"Conversation not found\");",
    "            if (!conv.participantIds.contains(senderId))",
    "                throw new SecurityException(\"Not a participant\");",
    "            ",
    "            String messageId = \"msg_\" + UUID.randomUUID().toString().substring(0, 12);",
    "            int sequence = sequenceGenerator.nextSequence(conversationId);",
    "            long timestamp = System.currentTimeMillis();",
    "            ",
    "            Message message = new Message(messageId, conversationId, senderId,",
    "                type, content, timestamp, sequence);",
    "            messageStore.storeMessage(message);",
    "            ",
    "            String preview = type == MessageType.TEXT ? content : \"[\" + type + \"]\";",
    "            conversationStore.updateLastMessage(conversationId, preview, timestamp, sequence);",
    "            ",
    "            // Deliver to all participants except sender",
    "            for (String userId : conv.participantIds) {",
    "                if (!userId.equals(senderId)) {",
    "                    deliverToUser(userId, message);",
    "                }",
    "            }",
    "            ",
    "            System.out.printf(\"\ud83d\udce8 Message %s sent by %s (seq=%d)%n\",",
    "                messageId, senderId, sequence);",
    "            return messageId;",
    "        }",
    "        ",
    "        private void deliverToUser(String userId, Message message) {",
    "            Map<String, Object> session = sessionStore.getSession(userId);",
    "            if (session != null) {",
    "                WebSocketEvent event = new WebSocketEvent(\"NEW_MESSAGE\", message.toMap());",
    "                boolean delivered = wsGateway.sendToUser(userId, event);",
    "                if (delivered) {",
    "                    System.out.printf(\"  \u2713 Delivered to %s via WebSocket%n\", userId);",
    "                }",
    "            } else {",
    "                System.out.printf(\"  \ud83d\udcf1 PUSH to %s: New message from %s%n\",",
    "                    userId, message.senderId);",
    "            }",
    "        }",
    "        ",
    "        // ====================================================================",
    "        // MESSAGE RETRIEVAL",
    "        // ====================================================================",
    "        ",
    "        List<Conversation> getConversations(String userId, int limit) {",
    "            return conversationStore.getUserConversations(userId, limit);",
    "        }",
    "        ",
    "        List<Message> getMessages(String userId, String convId,",
    "                                  int afterSequence, int limit) {",
    "            Conversation conv = conversationStore.getConversation(convId);",
    "            if (conv == null || !conv.participantIds.contains(userId))",
    "                throw new SecurityException(\"Access denied\");",
    "            return messageStore.getMessages(convId, afterSequence, limit);",
    "        }",
    "        ",
    "        // ====================================================================",
    "        // READ RECEIPTS",
    "        // ====================================================================",
    "        ",
    "        void markAsRead(String userId, String conversationId, String messageId) {",
    "            Message message = messageStore.getMessage(conversationId, messageId);",
    "            if (message == null) return;",
    "            ",
    "            conversationStore.markRead(userId, conversationId, message.sequenceNumber);",
    "            ",
    "            Conversation conv = conversationStore.getConversation(conversationId);",
    "            if (conv != null) {",
    "                Map<String, Object> payload = new HashMap<>();",
    "                payload.put(\"conversation_id\", conversationId);",
    "                payload.put(\"reader_id\", userId);",
    "                payload.put(\"message_id\", messageId);",
    "                ",
    "                for (String participantId : conv.participantIds) {",
    "                    if (!participantId.equals(userId)) {",
    "                        wsGateway.sendToUser(participantId,",
    "                            new WebSocketEvent(\"READ_RECEIPT\", payload));",
    "                    }",
    "                }",
    "            }",
    "            System.out.printf(\"\u2713 %s marked %s read up to %s%n\",",
    "                userId, conversationId, messageId);",
    "        }",
    "        ",
    "        // ====================================================================",
    "        // CONNECTION MANAGEMENT",
    "        // ====================================================================",
    "        ",
    "        WebSocketConnection connectUser(String userId) {",
    "            return wsGateway.connect(userId);",
    "        }",
    "        ",
    "        void disconnectUser(String userId) {",
    "            wsGateway.disconnect(userId);",
    "        }",
    "        ",
    "        Map<String, List<Message>> syncOnReconnect(String userId,",
    "                                                    Map<String, Integer> lastSequences) {",
    "            Map<String, List<Message>> missed = new HashMap<>();",
    "            for (Map.Entry<String, Integer> entry : lastSequences.entrySet()) {",
    "                try {",
    "                    List<Message> messages = getMessages(userId, entry.getKey(),",
    "                        entry.getValue(), 100);",
    "                    if (!messages.isEmpty()) {",
    "                        missed.put(entry.getKey(), messages);",
    "                    }",
    "                } catch (SecurityException e) {",
    "                    // Skip inaccessible conversations",
    "                }",
    "            }",
    "            return missed;",
    "        }",
    "        ",
    "        void sendTypingIndicator(String userId, String conversationId, boolean isTyping) {",
    "            Conversation conv = conversationStore.getConversation(conversationId);",
    "            if (conv == null) return;",
    "            ",
    "            Map<String, Object> payload = new HashMap<>();",
    "            payload.put(\"conversation_id\", conversationId);",
    "            payload.put(\"user_id\", userId);",
    "            payload.put(\"is_typing\", isTyping);",
    "            ",
    "            for (String participantId : conv.participantIds) {",
    "                if (!participantId.equals(userId)) {",
    "                    wsGateway.sendToUser(participantId,",
    "                        new WebSocketEvent(\"TYPING_INDICATOR\", payload));",
    "                }",
    "            }",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // DEMO",
    "    // ========================================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"   INSTAGRAM DIRECT MESSAGING DEMO (Java)\");",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println();",
    "        ",
    "        DirectMessagingService dmService = new DirectMessagingService();",
    "        ",
    "        // Demo 1: Direct Conversation",
    "        System.out.println(\"\ud83d\udcf1 DEMO 1: Direct Conversation\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        String convId = dmService.createDirectConversation(\"alice\", \"bob\");",
    "        WebSocketConnection aliceConn = dmService.connectUser(\"alice\");",
    "        WebSocketConnection bobConn = dmService.connectUser(\"bob\");",
    "        System.out.println(\"\ud83d\udfe2 Alice and Bob connected via WebSocket\\n\");",
    "        ",
    "        String msg1Id = dmService.sendMessage(\"alice\", convId,",
    "            MessageType.TEXT, \"Hey Bob! How are you?\");",
    "        ",
    "        List<WebSocketEvent> bobEvents = bobConn.getPendingEvents();",
    "        System.out.printf(\"Bob received %d event(s):%n\", bobEvents.size());",
    "        for (WebSocketEvent event : bobEvents) {",
    "            System.out.printf(\"  - %s: %s%n\", event.eventType, event.payload.get(\"content\"));",
    "        }",
    "        System.out.println();",
    "        ",
    "        // Bob replies",
    "        dmService.sendMessage(\"bob\", convId,",
    "            MessageType.TEXT, \"Hi Alice! I'm doing great!\");",
    "        ",
    "        List<WebSocketEvent> aliceEvents = aliceConn.getPendingEvents();",
    "        System.out.printf(\"Alice received %d event(s)%n\", aliceEvents.size());",
    "        System.out.println();",
    "        ",
    "        // Mark as read",
    "        dmService.markAsRead(\"bob\", convId, msg1Id);",
    "        System.out.println();",
    "        ",
    "        // Demo 2: Group Chat",
    "        System.out.println(\"\ud83d\udcf1 DEMO 2: Group Chat\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        String groupId = dmService.createGroupChat(\"alice\",",
    "            Arrays.asList(\"bob\", \"charlie\", \"dave\"), \"Weekend Hiking\");",
    "        ",
    "        WebSocketConnection daveConn = dmService.connectUser(\"dave\");",
    "        ",
    "        dmService.sendMessage(\"alice\", groupId,",
    "            MessageType.TEXT, \"Who's up for hiking this Saturday?\");",
    "        ",
    "        List<WebSocketEvent> daveEvents = daveConn.getPendingEvents();",
    "        System.out.printf(\"Dave received %d event(s) in group chat%n\", daveEvents.size());",
    "        System.out.println();",
    "        ",
    "        // Demo 3: Message Retrieval",
    "        System.out.println(\"\ud83d\udcf1 DEMO 3: Message Retrieval\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        List<Conversation> conversations = dmService.getConversations(\"alice\", 20);",
    "        System.out.printf(\"Alice has %d conversation(s)%n\", conversations.size());",
    "        ",
    "        List<Message> messages = dmService.getMessages(\"alice\", convId, 0, 50);",
    "        System.out.println(\"Messages in conversation with Bob:\");",
    "        for (Message msg : messages) {",
    "            System.out.printf(\"  [%d] %s: %s%n\",",
    "                msg.sequenceNumber, msg.senderId, msg.content);",
    "        }",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"   DEMO COMPLETE\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "explanation": "Imports and module docstring. We use dataclasses for clean data models, enums for type safety, and typing for static analysis."
    },
    {
      "lines": "17-90",
      "explanation": "Core data classes: Message (with sequence number for ordering), Conversation (supporting both direct and group types), UserConversationState (for tracking read position), and WebSocketEvent (for real-time push)."
    },
    {
      "lines": "95-150",
      "explanation": "MessageStore simulates Cassandra. Messages are stored per conversation and can be queried by sequence number for efficient sync. In production, partition by conversation_id and cluster by sequence."
    },
    {
      "lines": "153-230",
      "explanation": "ConversationStore manages conversations and per-user state. Supports finding direct conversations, updating last message, and marking messages as read. The user_conversations map enables efficient inbox retrieval."
    },
    {
      "lines": "233-280",
      "explanation": "SessionStore simulates Redis for connection tracking. Maps user_id to WebSocket server for routing. Tracks presence for online/offline status."
    },
    {
      "lines": "283-330",
      "explanation": "MessageBus simulates Kafka. Uses consistent hashing on conversation_id for partition assignment, ensuring ordering. In production, this would be actual Kafka with consumer groups."
    },
    {
      "lines": "335-400",
      "explanation": "WebSocketConnection and WebSocketGateway manage persistent connections. The gateway registers connections in the session store and provides send_to_user for pushing events."
    },
    {
      "lines": "405-440",
      "explanation": "SequenceGenerator provides per-conversation monotonically increasing sequence numbers. Critical for message ordering and sync. In production, use Redis INCR or Cassandra LWT."
    },
    {
      "lines": "445-650",
      "explanation": "DirectMessagingService is the core service. Implements create_direct_conversation, create_group_chat, send_message (the store-first-push-second pattern), message retrieval, read receipts, and sync_on_reconnect."
    },
    {
      "lines": "520-580",
      "explanation": "send_message implements the key flow: validate, dedup, assign sequence, store to DB (durability first!), update conversation metadata, then publish to message bus for async delivery."
    },
    {
      "lines": "590-620",
      "explanation": "_handle_message_event is the Kafka consumer handler. For each participant except sender, delivers via WebSocket if online, or queues push notification if offline."
    },
    {
      "lines": "660-720",
      "explanation": "mark_as_read updates the user's read position and broadcasts read receipts to other participants. sync_on_reconnect fetches missed messages for a reconnecting client."
    },
    {
      "lines": "750-900",
      "explanation": "run_dm_demo demonstrates all features: direct conversations, offline delivery, group chats, message retrieval, sync on reconnect, and typing indicators."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "sendMessage": {
          "complexity": "O(G)",
          "explanation": "G = group size. Must fan out to all participants. For direct messages, G=2 so effectively O(1)."
        },
        "getConversations": {
          "complexity": "O(C log C)",
          "explanation": "C = number of conversations. Sorting by last message time. With proper indexing/caching, can be O(C)."
        },
        "getMessages": {
          "complexity": "O(L)",
          "explanation": "L = limit/page size. Cassandra range query on clustered sequence numbers is efficient."
        },
        "markAsRead": {
          "complexity": "O(G)",
          "explanation": "Must broadcast read receipt to G-1 other participants."
        },
        "syncOnReconnect": {
          "complexity": "O(K * L)",
          "explanation": "K = number of conversations to sync, L = messages per conversation to fetch."
        }
      },
      "overall_change": "Shifts from pure request-response to event-driven with O(1) message routing via session store lookup."
    },
    "space": {
      "additional_space": "O(M + C + S)",
      "explanation": "M = total messages stored, C = conversations with metadata, S = active sessions/connections. WebSocket connections are stateful but bounded by concurrent users. Kafka maintains message log temporarily. Session store is O(concurrent users)."
    }
  },
  "dry_run": {
    "example_input": "Alice sends 'Hello!' to a conversation with Bob who is online",
    "steps": [
      {
        "step": 1,
        "action": "API receives sendMessage(alice, conv_123, TEXT, 'Hello!')",
        "state": "Validate alice is in conv_123",
        "explanation": "Authorization check on conversation membership"
      },
      {
        "step": 2,
        "action": "Check dedup cache for client_message_id",
        "state": "Not found, proceed",
        "explanation": "Idempotency check for retried messages"
      },
      {
        "step": 3,
        "action": "sequence = sequenceGenerator.next(conv_123)",
        "state": "sequence = 1",
        "explanation": "Atomically get next sequence number for ordering"
      },
      {
        "step": 4,
        "action": "Create Message object with all fields",
        "state": "msg_abc123 created",
        "explanation": "Build message with timestamp, sequence, etc."
      },
      {
        "step": 5,
        "action": "messageStore.store_message(msg)",
        "state": "Message persisted",
        "explanation": "CRITICAL: Durability first! Message is now safe."
      },
      {
        "step": 6,
        "action": "Return message_id to sender (ACK)",
        "state": "alice receives msg_abc123",
        "explanation": "Fast response - async delivery follows"
      },
      {
        "step": 7,
        "action": "messageBus.publish(MESSAGE_CREATED, conv_123, {...})",
        "state": "Event in Kafka partition 3",
        "explanation": "Partition by conv_id ensures ordering"
      },
      {
        "step": 8,
        "action": "Consumer reads event, iterates participants",
        "state": "[alice, bob], skip sender",
        "explanation": "Fan out to recipients"
      },
      {
        "step": 9,
        "action": "sessionStore.get_session(bob)",
        "state": "Returns {server: ws-1, conn: conn_xyz}",
        "explanation": "O(1) lookup in Redis"
      },
      {
        "step": 10,
        "action": "Route to ws-1, push NEW_MESSAGE event",
        "state": "WebSocket.send() called",
        "explanation": "Push to bob's open connection"
      },
      {
        "step": 11,
        "action": "Bob's client receives event",
        "state": "Message displayed in UI",
        "explanation": "Real-time delivery complete < 100ms"
      }
    ],
    "final_output": "Alice gets message_id immediately. Bob receives real-time push. Total latency < 100ms for online users."
  },
  "edge_cases": [
    {
      "case": "Duplicate message (client retry)",
      "handling": "Use client_message_id as idempotency key. Cache message_id mapping. Return existing message_id on duplicate.",
      "gotcha": "Must check dedup before assigning sequence number, otherwise you get sequence gaps."
    },
    {
      "case": "Recipient goes offline mid-delivery",
      "handling": "Session store lookup fails \u2192 queue message + send push notification. Message already persisted so no loss.",
      "gotcha": "Race condition: check session just before push. If connection dropped, message queued."
    },
    {
      "case": "Large group (1000+ members)",
      "handling": "Batch delivery events. Consider fan-out-on-read for very large groups. Use separate 'announcement' topic.",
      "gotcha": "Don't hold up sender waiting for all deliveries. ACK immediately after persistence."
    },
    {
      "case": "Message ordering across reconnects",
      "handling": "Client sends last_sequence_per_conversation on reconnect. Server queries for messages with sequence > last_seen.",
      "gotcha": "Client must persist last received sequence locally to avoid gaps."
    },
    {
      "case": "WebSocket server crashes",
      "handling": "Clients reconnect to different server. New server queries session store. Sync missed messages via getMessages with after_sequence.",
      "gotcha": "Must clean up stale session store entries (use TTL + heartbeat)."
    },
    {
      "case": "Conversation created but no messages yet",
      "handling": "Handle empty message list gracefully. Show conversation with no preview.",
      "gotcha": "last_sequence_number = 0 is valid starting state."
    }
  ],
  "test_cases": [
    {
      "name": "Direct message delivery to online user",
      "input": "createDirectConversation(alice, bob), connect(alice), connect(bob), sendMessage(alice, conv_1, TEXT, 'Hi')",
      "expected": "Bob receives NEW_MESSAGE event with content 'Hi' within 100ms",
      "explanation": "Tests the happy path of real-time delivery"
    },
    {
      "name": "Message to offline user triggers push",
      "input": "createDirectConversation(alice, charlie), sendMessage(alice, conv_2, TEXT, 'Hello')",
      "expected": "Push notification sent to charlie with message preview",
      "explanation": "Tests offline handling path"
    },
    {
      "name": "Group chat fan-out",
      "input": "createGroupChat(alice, [bob, charlie, dave], 'Team'), connect(bob), sendMessage(alice, group_1, TEXT, 'Meeting!')",
      "expected": "Bob (online) gets WebSocket push; charlie, dave (offline) get push notifications",
      "explanation": "Tests mixed online/offline group delivery"
    },
    {
      "name": "Message ordering with sequence numbers",
      "input": "sendMessage(alice, conv_1, 'First'), sendMessage(alice, conv_1, 'Second'), sendMessage(alice, conv_1, 'Third')",
      "expected": "Messages have sequence_number 1, 2, 3 respectively; retrieved in order",
      "explanation": "Tests sequence number assignment and ordering"
    },
    {
      "name": "Sync on reconnect",
      "input": "disconnect(bob), sendMessage(alice, conv_1, 'Missed1'), sendMessage(alice, conv_1, 'Missed2'), connect(bob), syncOnReconnect(bob, {conv_1: 2})",
      "expected": "Returns messages with sequence > 2 (Missed1, Missed2)",
      "explanation": "Tests offline sync mechanism"
    },
    {
      "name": "Read receipt broadcast",
      "input": "markAsRead(bob, conv_1, msg_3)",
      "expected": "Alice receives READ_RECEIPT event with reader_id=bob, message_id=msg_3",
      "explanation": "Tests read receipt propagation"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Pushing message before persisting to database",
      "why_wrong": "If the push succeeds but the write fails, the message is lost. Or if the server crashes after push but before write, message disappears.",
      "correct_approach": "Always write to durable storage first (Cassandra), then ACK to sender, then async push. This is the 'store-first, push-second' pattern.",
      "code_example_wrong": "# WRONG: Push before persist\nwebsocket.send(message)\ndb.save(message)",
      "code_example_correct": "# CORRECT: Persist first\ndb.save(message)  # Durability guaranteed\nack_to_sender()   # Fast response\nkafka.publish(message)  # Async delivery"
    },
    {
      "mistake": "Using HTTP polling instead of WebSocket",
      "why_wrong": "Polling creates massive server load (10M users \u00d7 1 poll/sec = 10M requests/sec), wastes bandwidth, and introduces latency (average = poll_interval/2).",
      "correct_approach": "Use WebSocket for persistent bidirectional connections. Server pushes messages instantly. Connection count is high but manageable with proper infrastructure.",
      "code_example_wrong": "// WRONG: Polling\nwhile (true) {\n  messages = http.get('/messages?since=' + lastId);\n  sleep(1000);\n}",
      "code_example_correct": "// CORRECT: WebSocket\nwebsocket.connect();\nwebsocket.onMessage((event) => {\n  displayMessage(event.payload);\n});"
    },
    {
      "mistake": "Not partitioning Kafka by conversation_id",
      "why_wrong": "Without proper partitioning, messages in the same conversation may be processed by different consumers in different order, breaking message ordering.",
      "correct_approach": "Partition by conversation_id so all messages in a conversation go to the same partition, processed by the same consumer in order.",
      "code_example_wrong": "# WRONG: Random partition\nkafka.send(topic, message)",
      "code_example_correct": "# CORRECT: Partition by conversation\npartition = hash(conversation_id) % num_partitions\nkafka.send(topic, message, partition_key=conversation_id)"
    },
    {
      "mistake": "Forgetting idempotency for message sends",
      "why_wrong": "Mobile networks are unreliable. Client may retry if no ACK received. Without idempotency, you get duplicate messages.",
      "correct_approach": "Client generates unique client_message_id. Server caches mapping to server_message_id. On retry, return existing message_id.",
      "code_example_wrong": "# WRONG: No dedup\ndef send_message(sender_id, conv_id, content):\n    return create_new_message()  # Always creates new",
      "code_example_correct": "# CORRECT: Idempotent\ndef send_message(sender_id, conv_id, content, client_msg_id):\n    if client_msg_id in dedup_cache:\n        return dedup_cache[client_msg_id]\n    msg_id = create_new_message()\n    dedup_cache[client_msg_id] = msg_id\n    return msg_id"
    },
    {
      "mistake": "Blocking sender waiting for delivery to all recipients",
      "why_wrong": "In group chats with many members or slow connections, this creates unacceptable latency for the sender.",
      "correct_approach": "ACK to sender as soon as message is persisted. Delivery is async. Sender sees 'sent' immediately, then 'delivered' updates come later.",
      "code_example_wrong": "# WRONG: Wait for all deliveries\nfor recipient in recipients:\n    await deliver_to_user(recipient)  # Blocks!\nreturn success",
      "code_example_correct": "# CORRECT: Async delivery\ndb.save(message)  # Persist\nkafka.publish(message)  # Async delivery\nreturn message_id  # Immediate response"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by clarifying the real-time requirements (<100ms latency, 10M concurrent connections). Immediately mention WebSocket as the delivery mechanism. Draw the high-level architecture with WebSocket Gateway, Message Service, Kafka, and Cassandra. Emphasize the 'store-first, push-second' principle early - this shows you understand reliability. Discuss Kafka partitioning for ordering. Address offline handling with push notifications and sync on reconnect.",
    "what_to_mention": [
      "WebSocket for bidirectional real-time communication (not polling!)",
      "Store-first, push-second pattern for reliability",
      "Kafka partitioned by conversation_id for ordering guarantees",
      "Session store (Redis) for O(1) user-to-server routing",
      "Sequence numbers for message ordering and sync",
      "Cassandra for append-only message storage (time-series optimized)",
      "Offline handling: pending queue + push notifications",
      "Group chat fan-out strategy (write once, fan-out delivery)",
      "Idempotency with client_message_id for retry handling"
    ],
    "time_allocation": "Spend 3-4 minutes on requirements clarification and high-level design. 5-6 minutes on the message send flow (the core). 3-4 minutes on offline handling and sync. 2-3 minutes on group chats. Leave time for trade-offs and scaling discussion.",
    "if_stuck": [
      "Think about what happens if the server crashes mid-operation - leads to store-first pattern",
      "Consider how to find which server holds a user's connection - leads to session store",
      "Think about message ordering - leads to sequence numbers and Kafka partitioning",
      "Consider reconnection - leads to sync mechanism with last_sequence"
    ]
  },
  "connection_to_next_part": "Part 4 establishes a robust real-time messaging infrastructure with WebSocket connections and a message bus. This foundation could extend to Part 5 features like: (1) Video/Voice Calls using WebRTC signaling over the same WebSocket, (2) Live Streaming with chat using the same pub/sub infrastructure, (3) Reactions and message editing using the same delivery mechanism, or (4) Instagram Notes (status updates) leveraging the presence system. The session store and message bus are versatile building blocks for any real-time feature.",
  "generated_at": "2026-01-14T15:28:50.827263",
  "_meta": {
    "problem_id": "instagram_photo_sharing_design",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}