{
  "problem_title": "2D Canvas / Drawing Application",
  "difficulty": "medium",
  "category": "Frontend/LLD",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP design problem** that models a simplified drawing application. The core challenge is implementing **polymorphic shapes** with different containment logic and handling **z-ordering** for overlapping shapes. This tests both object-oriented design skills and basic computational geometry.",
    "pattern_recognition": "**OOP Design + Polymorphism + Geometry + Reverse Iteration**\n\n- Abstract Shape class with polymorphic `contains()` method\n- List for maintaining creation order (z-order)\n- HashMap for potential O(1) lookup by ID (useful for follow-ups)\n- Point-in-shape hit testing algorithms",
    "key_constraints": [
      "**O(1) for create operations** - Simple append to list, no complex data structures needed",
      "**O(n) for getShapeAt** - Must check all shapes in worst case, but iterate newest-first for topmost",
      "**Boundary points are INSIDE** - Use inclusive bounds (<=, not <) - common mistake!",
      "**Z-order = creation order** - Last created shape is on top, iterate in reverse",
      "**Integer coordinates** - No floating point precision issues for coordinates (but watch circle radius squared)"
    ],
    "clarifying_questions": [
      "**Are boundary points inside shapes?** - Yes, use inclusive bounds (<=). Critical for correctness!",
      "**What ID format should I use?** - Use 'rect_1', 'circle_1' with incrementing counters",
      "**Can shapes have zero area?** - Constraints say width/height/radius >= 1, so no degenerate shapes",
      "**Are coordinates always positive?** - Yes, 0 \u2264 x, y \u2264 10^4 per constraints",
      "**How to handle no shape at point?** - Return null/None, not empty string",
      "**Should I use sqrt for circle containment?** - No! Use squared distance to avoid precision issues",
      "**Will there be follow-ups involving deletion/movement?** - Yes, design for extensibility"
    ],
    "edge_cases_to_consider": [
      "Point exactly on rectangle boundary (corner, edge)",
      "Point exactly on circle boundary (distance = radius)",
      "Query point with no shapes containing it \u2192 return null",
      "Single shape on canvas",
      "Many overlapping shapes at same point",
      "Circle at origin with point at exact radius distance",
      "Large coordinate values near upper bound (10^4)"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   CANVAS SYSTEM                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                     \u2502\n\u2502    Coordinate System:                               \u2502\n\u2502    (0,0)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba X+                   \u2502\n\u2502      \u2502                                              \u2502\n\u2502      \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 Rectangle                     \u2502\n\u2502      \u2502   \u2502 (x,y)    \u2502 - top-left corner             \u2502\n\u2502      \u2502   \u2502    \u25cf\u2500\u2500\u2500\u2500\u2500\u2502\u2192 width                        \u2502\n\u2502      \u2502   \u2502    \u2502     \u2502                               \u2502\n\u2502      \u2502   \u2502    \u2193     \u2502 height                        \u2502\n\u2502      \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n\u2502      \u2502                                              \u2502\n\u2502      \u2502         \u25cb Circle                             \u2502\n\u2502      \u2502        /\u2502\\  - center (cx, cy)                \u2502\n\u2502      \u2502       r \u2502 r - radius                         \u2502\n\u2502      \u2502        \\\u2502/                                   \u2502\n\u2502      \u25bc                                              \u2502\n\u2502      Y+                                             \u2502\n\u2502                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              INTERNAL DATA STRUCTURES               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                     \u2502\n\u2502  shapes: List<Shape> (maintains z-order)            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Index 0: rect_1   (bottom - created first)  \u2502    \u2502\n\u2502  \u2502 Index 1: circle_1 (middle)                  \u2502    \u2502\n\u2502  \u2502 Index 2: rect_2   (top - created last)      \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                     \u2502\n\u2502  shapeMap: HashMap<String, Shape>                   \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 \"rect_1\"   \u2192 Rectangle(10,10,40,30)         \u2502    \u2502\n\u2502  \u2502 \"circle_1\" \u2192 Circle(60,30,20)               \u2502    \u2502\n\u2502  \u2502 \"rect_2\"   \u2192 Rectangle(30,25,50,40)         \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                                     \u2502\n\u2502  rectCount: 2                                       \u2502\n\u2502  circleCount: 1                                     \u2502\n\u2502                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "**createRectangle/createCircle**: Create shape object, generate unique ID, append to list",
        "visualization": "```\nshapes: [rect_1]\n           \u2193\nshapes: [rect_1, circle_1]    \u2190 append to end\n           \u2193\nshapes: [rect_1, circle_1, rect_2]\n```",
        "key_point": "Appending maintains z-order automatically - O(1) operation"
      },
      {
        "step": 2,
        "description": "**getShapeAt**: Iterate shapes in REVERSE order (newest to oldest)",
        "visualization": "```\nQuery point (35, 30):\n\nIteration order:\n  1. Check rect_2   \u2190 Start here (index 2, top)\n  2. Check circle_1 \u2190 If not found\n  3. Check rect_1   \u2190 Last resort (index 0, bottom)\n\nReturn FIRST match (topmost shape containing point)\n```",
        "key_point": "Reverse iteration ensures topmost (most recent) shape wins"
      },
      {
        "step": 3,
        "description": "**Rectangle containment**: Check if point within bounds (inclusive)",
        "visualization": "```\n(x,y)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500(x+width,y)\n  \u2502                      \u2502\n  \u2502   Point (px,py)      \u2502\n  \u2502   Check:             \u2502\n  \u2502   x \u2264 px \u2264 x+width   \u2502\n  \u2502   y \u2264 py \u2264 y+height  \u2502\n  \u2502                      \u2502\n(x,y+height)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500(x+width,y+height)\n```",
        "key_point": "Use \u2264 (inclusive) for boundary points!"
      },
      {
        "step": 4,
        "description": "**Circle containment**: Check squared distance \u2264 squared radius",
        "visualization": "```\n         r\n      \u2190\u2500\u2500\u2500\u2500\u2500\u2192\n       \u256d\u2500\u2500\u2500\u256e\n      \u2571  \u2502  \u2572   Point (px,py)\n     \u2502 \u25cf \u2502   \u25cf\u2190\u2500 distance = \u221a((px-cx)\u00b2 + (py-cy)\u00b2)\n      \u2572  \u2502  \u2571\n       \u2570\u2500\u2500\u2500\u256f\n     (cx,cy)\n\nContains if: (px-cx)\u00b2 + (py-cy)\u00b2 \u2264 r\u00b2\n```",
        "key_point": "Avoid sqrt()! Compare squared values for precision and speed"
      }
    ],
    "dry_run_table": "| Step | Operation | Action | shapes List | Result |\n|------|-----------|--------|-------------|--------|\n| 1 | Canvas() | Initialize | [] | - |\n| 2 | createRectangle(10,10,40,30) | Create rect at (10,10) | [rect_1] | \"rect_1\" |\n| 3 | createCircle(60,30,20) | Create circle at (60,30) | [rect_1, circle_1] | \"circle_1\" |\n| 4 | createRectangle(30,25,50,40) | Create rect at (30,25) | [rect_1, circle_1, rect_2] | \"rect_2\" |\n| 5 | getShapeAt(35,30) | Check rect_2\u2192contains? YES | - | **\"rect_2\"** |\n| 6 | getShapeAt(15,15) | Check rect_2\u2192NO, circle_1\u2192NO, rect_1\u2192YES | - | **\"rect_1\"** |\n| 7 | getShapeAt(80,50) | Check rect_2\u2192NO, circle_1\u2192YES (dist=20) | - | **\"circle_1\"** |\n| 8 | getShapeAt(0,0) | All shapes\u2192NO | - | **null** |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'different shape types with common operations'**, I think of **polymorphism** - an abstract Shape class with a `contains()` method that each shape type implements differently",
      "**When I see 'topmost shape wins'**, I think of **z-ordering** - shapes created later are on top. This means I need to maintain creation order, which a simple list provides naturally",
      "**When I see 'return topmost shape at point'**, I realize I should iterate in **reverse order** (newest to oldest) and return the first match - this gives me the topmost shape automatically",
      "**When I see 'point on boundary is inside'**, I know to use **inclusive bounds** (<=) not exclusive (<) - this is a common mistake!",
      "**When I see 'circle containment'**, I immediately think: avoid sqrt()! Use `dx*dx + dy*dy <= r*r` for both **precision** and **performance**",
      "**When I see 'follow-up parts mention delete/move'**, I should design for **extensibility** - using a HashMap for O(1) lookup by ID will help later even if not needed now"
    ],
    "key_insight": "**The key insight is that z-order = creation order, so a simple list with reverse iteration solves the 'topmost shape' problem elegantly.** No need for complex z-index tracking or priority queues. The list index IS the z-order.",
    "why_this_works": "By iterating shapes in reverse creation order (newest first), the first shape that contains the query point is guaranteed to be the topmost one. This works because:\n\n1. We append new shapes to the end of the list \u2192 later shapes have higher indices\n2. Higher index = higher z-order = visually on top\n3. Reverse iteration checks higher z-order shapes first\n4. First hit = topmost shape containing point\n\nThis is O(n) in the worst case but optimal for this problem since we must check shape containment."
  },
  "approaches": [
    {
      "name": "Brute Force Forward Iteration",
      "description": "Iterate shapes from first to last, track the last shape containing the point",
      "pseudocode": "def get_shape_at(x, y):\n    result = None\n    for shape in shapes:  # Forward iteration\n        if shape.contains(x, y):\n            result = shape.id  # Keep overwriting\n    return result",
      "time_complexity": "O(n) per query",
      "space_complexity": "O(n) for shapes",
      "pros": [
        "Simple to understand",
        "Correct result"
      ],
      "cons": [
        "Always iterates ALL shapes even if topmost found early",
        "Unnecessary work"
      ],
      "when_to_use": "Never in practice - reverse iteration is strictly better"
    },
    {
      "name": "Optimal: Reverse Iteration with Early Exit",
      "description": "Iterate shapes from newest to oldest, return immediately on first hit",
      "pseudocode": "def get_shape_at(x, y):\n    for shape in reversed(shapes):  # Newest first\n        if shape.contains(x, y):\n            return shape.id  # Early exit!\n    return None",
      "time_complexity": "O(n) worst case, but O(1) best case with early exit",
      "space_complexity": "O(n) for shapes",
      "pros": [
        "Early exit when topmost found",
        "Cleaner logic",
        "Optimal for typical use"
      ],
      "cons": [
        "None - this is optimal for unsorted shapes"
      ],
      "key_insight": "Return IMMEDIATELY on first hit - no need to check remaining shapes"
    },
    {
      "name": "Alternative: Spatial Indexing (Overkill for this problem)",
      "description": "Use quadtree or R-tree for spatial queries",
      "pseudocode": "# Build spatial index\n# Query: find shapes in region, then check containment\n# More complex, better for many shapes/queries",
      "time_complexity": "O(log n) average for queries with good distribution",
      "space_complexity": "O(n) plus index overhead",
      "pros": [
        "Faster queries for very large shape counts"
      ],
      "cons": [
        "Overkill for \u22641000 shapes",
        "Complex implementation",
        "Interview time pressure"
      ],
      "when_to_use": "Only if interviewer asks about scaling to millions of shapes"
    }
  ],
  "optimal_solution": {
    "name": "Polymorphic Shapes with Reverse Iteration",
    "explanation_md": "## Approach\n\nThe solution uses **object-oriented design** with an abstract `Shape` base class and concrete `Rectangle` and `Circle` subclasses. Each shape implements its own `contains()` method.\n\n### Core Design Decisions\n\n1. **Abstract Shape Class**: Defines interface with `id` and `contains()` method\n2. **List for Z-Order**: Shapes stored in creation order - index = z-order\n3. **Reverse Iteration**: Check newest shapes first for efficient topmost detection\n4. **Squared Distance for Circles**: Avoid `sqrt()` for precision and performance\n\n### Why This Works\n\n- **Polymorphism** allows unified handling of different shape types\n- **Creation order list** naturally maintains z-order without extra bookkeeping\n- **Reverse iteration with early exit** finds topmost shape efficiently\n- **Inclusive bounds** correctly handle boundary points\n\n### Future-Proofing\n\nThe HashMap (`shapeMap`) isn't strictly needed for Part 1, but:\n- Part 2 (move shape) needs O(1) lookup by ID\n- Part 3 (delete shape) needs O(1) lookup by ID\n- Adding it now shows design foresight",
    "data_structures": [
      {
        "structure": "**List<Shape>** shapes",
        "purpose": "Maintains creation order (z-order). Append is O(1). Reverse iteration for queries."
      },
      {
        "structure": "**HashMap<String, Shape>** shapeMap",
        "purpose": "O(1) lookup by ID. Essential for move/delete in follow-ups."
      },
      {
        "structure": "**int rectCount, circleCount**",
        "purpose": "Generate unique IDs: 'rect_1', 'rect_2', 'circle_1', etc."
      }
    ],
    "algorithm_steps": [
      "1. **Initialize Canvas**: Empty shapes list, empty shapeMap, counters at 0",
      "2. **createRectangle**: Increment rectCount, create Rectangle with 'rect_N' ID, append to list, add to map, return ID",
      "3. **createCircle**: Increment circleCount, create Circle with 'circle_N' ID, append to list, add to map, return ID",
      "4. **getShapeAt**: Iterate shapes in REVERSE order, call contains() on each, return FIRST match's ID (or null)"
    ],
    "why_decimal": "Not applicable for this problem - we use integers for coordinates. However, for circle containment, we use squared comparison (r\u00b2 vs dist\u00b2) to avoid floating-point precision issues."
  },
  "solution_python_lines": [
    "\"\"\"",
    "2D Canvas Drawing Application",
    "",
    "A simplified Paint-like application that manages shapes on a 2D canvas",
    "with support for creation, hit testing, and z-ordering.",
    "",
    "Author: Interview Preparation Guide",
    "Time Complexity: O(1) for create, O(n) for queries",
    "Space Complexity: O(n) where n = number of shapes",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from typing import Optional, List, Dict",
    "",
    "",
    "class Shape(ABC):",
    "    \"\"\"",
    "    Abstract base class for all shapes.",
    "    ",
    "    Each shape has a unique ID and must implement containment checking.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str) -> None:",
    "        \"\"\"",
    "        Initialize shape with unique identifier.",
    "        ",
    "        Args:",
    "            shape_id: Unique identifier (e.g., 'rect_1', 'circle_1')",
    "        \"\"\"",
    "        self.id = shape_id",
    "    ",
    "    @abstractmethod",
    "    def contains(self, x: int, y: int) -> bool:",
    "        \"\"\"",
    "        Check if point (x, y) is inside this shape.",
    "        ",
    "        Args:",
    "            x: X coordinate of query point",
    "            y: Y coordinate of query point",
    "            ",
    "        Returns:",
    "            True if point is inside or on boundary, False otherwise",
    "        \"\"\"",
    "        pass",
    "",
    "",
    "class Rectangle(Shape):",
    "    \"\"\"",
    "    Rectangle shape defined by top-left corner and dimensions.",
    "    ",
    "    Attributes:",
    "        x: X coordinate of top-left corner",
    "        y: Y coordinate of top-left corner",
    "        width: Width of rectangle",
    "        height: Height of rectangle",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, x: int, y: int, ",
    "                 width: int, height: int) -> None:",
    "        \"\"\"",
    "        Create rectangle with given position and dimensions.",
    "        ",
    "        Args:",
    "            shape_id: Unique identifier",
    "            x: X coordinate of top-left corner",
    "            y: Y coordinate of top-left corner",
    "            width: Width of rectangle (must be >= 1)",
    "            height: Height of rectangle (must be >= 1)",
    "        \"\"\"",
    "        super().__init__(shape_id)",
    "        self.x = x",
    "        self.y = y",
    "        self.width = width",
    "        self.height = height",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        \"\"\"",
    "        Check if point is inside rectangle (inclusive bounds).",
    "        ",
    "        Uses bounds check: x <= px <= x+width AND y <= py <= y+height",
    "        ",
    "        Args:",
    "            px: X coordinate of query point",
    "            py: Y coordinate of query point",
    "            ",
    "        Returns:",
    "            True if point is inside or on boundary",
    "            ",
    "        Example:",
    "            >>> rect = Rectangle('rect_1', 0, 0, 10, 10)",
    "            >>> rect.contains(5, 5)   # Inside",
    "            True",
    "            >>> rect.contains(10, 10) # On corner (boundary)",
    "            True",
    "            >>> rect.contains(11, 5)  # Outside",
    "            False",
    "        \"\"\"",
    "        return (self.x <= px <= self.x + self.width and",
    "                self.y <= py <= self.y + self.height)",
    "",
    "",
    "class Circle(Shape):",
    "    \"\"\"",
    "    Circle shape defined by center point and radius.",
    "    ",
    "    Attributes:",
    "        center_x: X coordinate of center",
    "        center_y: Y coordinate of center",
    "        radius: Radius of circle",
    "    \"\"\"",
    "    ",
    "    def __init__(self, shape_id: str, center_x: int, ",
    "                 center_y: int, radius: int) -> None:",
    "        \"\"\"",
    "        Create circle with given center and radius.",
    "        ",
    "        Args:",
    "            shape_id: Unique identifier",
    "            center_x: X coordinate of center",
    "            center_y: Y coordinate of center",
    "            radius: Radius of circle (must be >= 1)",
    "        \"\"\"",
    "        super().__init__(shape_id)",
    "        self.center_x = center_x",
    "        self.center_y = center_y",
    "        self.radius = radius",
    "    ",
    "    def contains(self, px: int, py: int) -> bool:",
    "        \"\"\"",
    "        Check if point is inside circle using squared distance.",
    "        ",
    "        Avoids sqrt() for precision: (px-cx)\u00b2 + (py-cy)\u00b2 <= r\u00b2",
    "        ",
    "        Args:",
    "            px: X coordinate of query point",
    "            py: Y coordinate of query point",
    "            ",
    "        Returns:",
    "            True if point is inside or on boundary",
    "            ",
    "        Example:",
    "            >>> circle = Circle('circle_1', 0, 0, 5)",
    "            >>> circle.contains(0, 0)   # Center",
    "            True",
    "            >>> circle.contains(3, 4)   # On boundary (3\u00b2 + 4\u00b2 = 25 = 5\u00b2)",
    "            True",
    "            >>> circle.contains(4, 4)   # Outside (4\u00b2 + 4\u00b2 = 32 > 25)",
    "            False",
    "        \"\"\"",
    "        dx = px - self.center_x",
    "        dy = py - self.center_y",
    "        # Use squared comparison to avoid sqrt() precision issues",
    "        return dx * dx + dy * dy <= self.radius * self.radius",
    "",
    "",
    "class Canvas:",
    "    \"\"\"",
    "    2D Canvas that manages shapes with z-ordering support.",
    "    ",
    "    Shapes created later appear on top of shapes created earlier.",
    "    Supports rectangles and circles with hit testing.",
    "    ",
    "    Attributes:",
    "        shapes: List of shapes in creation order (z-order)",
    "        shape_map: Dictionary for O(1) lookup by ID",
    "        rect_count: Counter for rectangle ID generation",
    "        circle_count: Counter for circle ID generation",
    "        ",
    "    Example:",
    "        >>> canvas = Canvas()",
    "        >>> canvas.create_rectangle(0, 0, 100, 100)",
    "        'rect_1'",
    "        >>> canvas.create_circle(50, 50, 30)",
    "        'circle_1'",
    "        >>> canvas.get_shape_at(50, 50)  # Both contain, circle on top",
    "        'circle_1'",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize empty canvas with no shapes.\"\"\"",
    "        self._shapes: List[Shape] = []",
    "        self._shape_map: Dict[str, Shape] = {}",
    "        self._rect_count: int = 0",
    "        self._circle_count: int = 0",
    "    ",
    "    def create_rectangle(self, x: int, y: int, ",
    "                         width: int, height: int) -> str:",
    "        \"\"\"",
    "        Create a rectangle on the canvas.",
    "        ",
    "        Args:",
    "            x: X coordinate of top-left corner",
    "            y: Y coordinate of top-left corner",
    "            width: Width of rectangle",
    "            height: Height of rectangle",
    "            ",
    "        Returns:",
    "            Unique shape identifier (e.g., 'rect_1')",
    "            ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        self._rect_count += 1",
    "        shape_id = f'rect_{self._rect_count}'",
    "        rectangle = Rectangle(shape_id, x, y, width, height)",
    "        self._shapes.append(rectangle)",
    "        self._shape_map[shape_id] = rectangle",
    "        return shape_id",
    "    ",
    "    def create_circle(self, center_x: int, center_y: int, ",
    "                      radius: int) -> str:",
    "        \"\"\"",
    "        Create a circle on the canvas.",
    "        ",
    "        Args:",
    "            center_x: X coordinate of center",
    "            center_y: Y coordinate of center",
    "            radius: Radius of circle",
    "            ",
    "        Returns:",
    "            Unique shape identifier (e.g., 'circle_1')",
    "            ",
    "        Time Complexity: O(1)",
    "        \"\"\"",
    "        self._circle_count += 1",
    "        shape_id = f'circle_{self._circle_count}'",
    "        circle = Circle(shape_id, center_x, center_y, radius)",
    "        self._shapes.append(circle)",
    "        self._shape_map[shape_id] = circle",
    "        return shape_id",
    "    ",
    "    def get_shape_at(self, x: int, y: int) -> Optional[str]:",
    "        \"\"\"",
    "        Get the topmost shape at the given point.",
    "        ",
    "        Iterates shapes in reverse creation order (newest first)",
    "        and returns the first shape containing the point.",
    "        ",
    "        Args:",
    "            x: X coordinate of query point",
    "            y: Y coordinate of query point",
    "            ",
    "        Returns:",
    "            ID of topmost shape containing point, or None if no shape",
    "            ",
    "        Time Complexity: O(n) where n = number of shapes",
    "        \"\"\"",
    "        # Iterate in reverse order (newest/topmost first)",
    "        for shape in reversed(self._shapes):",
    "            if shape.contains(x, y):",
    "                return shape.id  # Early exit on first hit",
    "        return None",
    "",
    "",
    "def main() -> None:",
    "    \"\"\"Demonstrate Canvas functionality with test cases.\"\"\"",
    "    print('=' * 60)",
    "    print('2D Canvas Drawing Application - Demo')",
    "    print('=' * 60)",
    "    ",
    "    # Example 1: Basic Shape Creation and Query",
    "    print('\\n--- Example 1: Basic Creation ---')",
    "    canvas = Canvas()",
    "    ",
    "    r1 = canvas.create_rectangle(10, 10, 40, 30)",
    "    print(f'Created rectangle: {r1}')",
    "    ",
    "    c1 = canvas.create_circle(60, 30, 20)",
    "    print(f'Created circle: {c1}')",
    "    ",
    "    result = canvas.get_shape_at(25, 25)",
    "    print(f'Shape at (25,25): {result}')  # rect_1",
    "    ",
    "    result = canvas.get_shape_at(60, 30)",
    "    print(f'Shape at (60,30): {result}')  # circle_1",
    "    ",
    "    # Example 2: Overlapping Shapes",
    "    print('\\n--- Example 2: Overlapping Shapes ---')",
    "    canvas2 = Canvas()",
    "    ",
    "    canvas2.create_rectangle(0, 0, 50, 50)",
    "    print('Created rect_1 at (0,0) 50x50')",
    "    ",
    "    canvas2.create_rectangle(25, 25, 50, 50)",
    "    print('Created rect_2 at (25,25) 50x50 (overlaps rect_1)')",
    "    ",
    "    result = canvas2.get_shape_at(30, 30)",
    "    print(f'Shape at (30,30) [overlap]: {result}')  # rect_2 (on top)",
    "    ",
    "    result = canvas2.get_shape_at(10, 10)",
    "    print(f'Shape at (10,10) [only rect_1]: {result}')  # rect_1",
    "    ",
    "    # Example 3: Boundary Testing",
    "    print('\\n--- Example 3: Boundary Testing ---')",
    "    canvas3 = Canvas()",
    "    ",
    "    canvas3.create_circle(0, 0, 5)",
    "    print('Created circle at (0,0) radius 5')",
    "    ",
    "    # Point (3,4) is exactly on boundary: 3\u00b2 + 4\u00b2 = 25 = 5\u00b2",
    "    result = canvas3.get_shape_at(3, 4)",
    "    print(f'Shape at (3,4) [on boundary]: {result}')  # circle_1",
    "    ",
    "    # Point (4,4) is outside: 4\u00b2 + 4\u00b2 = 32 > 25",
    "    result = canvas3.get_shape_at(4, 4)",
    "    print(f'Shape at (4,4) [outside]: {result}')  # None",
    "    ",
    "    # Example 4: Empty Query",
    "    print('\\n--- Example 4: Empty Query ---')",
    "    result = canvas.get_shape_at(0, 0)",
    "    print(f'Shape at (0,0) [empty]: {result}')  # None",
    "    ",
    "    print('\\n' + '=' * 60)",
    "    print('All tests passed!')",
    "    print('=' * 60)",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * 2D Canvas Drawing Application",
    " * ",
    " * A simplified Paint-like application that manages shapes on a 2D canvas",
    " * with support for creation, hit testing, and z-ordering.",
    " * ",
    " * @author Interview Preparation Guide",
    " */",
    "",
    "/**",
    " * Abstract base class for all shapes.",
    " */",
    "abstract class Shape {",
    "    protected final String id;",
    "    ",
    "    public Shape(String id) {",
    "        this.id = id;",
    "    }",
    "    ",
    "    public String getId() {",
    "        return id;",
    "    }",
    "    ",
    "    /**",
    "     * Check if point (x, y) is inside this shape.",
    "     * @param x X coordinate of query point",
    "     * @param y Y coordinate of query point",
    "     * @return true if point is inside or on boundary",
    "     */",
    "    public abstract boolean contains(int x, int y);",
    "}",
    "",
    "/**",
    " * Rectangle shape defined by top-left corner and dimensions.",
    " */",
    "class Rectangle extends Shape {",
    "    private final int x, y, width, height;",
    "    ",
    "    public Rectangle(String id, int x, int y, int width, int height) {",
    "        super(id);",
    "        this.x = x;",
    "        this.y = y;",
    "        this.width = width;",
    "        this.height = height;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        // Inclusive bounds check",
    "        return px >= x && px <= x + width &&",
    "               py >= y && py <= y + height;",
    "    }",
    "}",
    "",
    "/**",
    " * Circle shape defined by center point and radius.",
    " */",
    "class Circle extends Shape {",
    "    private final int centerX, centerY, radius;",
    "    ",
    "    public Circle(String id, int centerX, int centerY, int radius) {",
    "        super(id);",
    "        this.centerX = centerX;",
    "        this.centerY = centerY;",
    "        this.radius = radius;",
    "    }",
    "    ",
    "    @Override",
    "    public boolean contains(int px, int py) {",
    "        // Use squared distance to avoid sqrt() precision issues",
    "        long dx = px - centerX;",
    "        long dy = py - centerY;",
    "        long radiusSquared = (long) radius * radius;",
    "        return dx * dx + dy * dy <= radiusSquared;",
    "    }",
    "}",
    "",
    "/**",
    " * 2D Canvas that manages shapes with z-ordering support.",
    " * Shapes created later appear on top of shapes created earlier.",
    " */",
    "public class Canvas {",
    "    private final List<Shape> shapes;",
    "    private final Map<String, Shape> shapeMap;",
    "    private int rectCount;",
    "    private int circleCount;",
    "    ",
    "    public Canvas() {",
    "        this.shapes = new ArrayList<>();",
    "        this.shapeMap = new HashMap<>();",
    "        this.rectCount = 0;",
    "        this.circleCount = 0;",
    "    }",
    "    ",
    "    /**",
    "     * Create a rectangle on the canvas.",
    "     * @param x X coordinate of top-left corner",
    "     * @param y Y coordinate of top-left corner",
    "     * @param width Width of rectangle",
    "     * @param height Height of rectangle",
    "     * @return Unique shape identifier (e.g., 'rect_1')",
    "     */",
    "    public String createRectangle(int x, int y, int width, int height) {",
    "        rectCount++;",
    "        String shapeId = \"rect_\" + rectCount;",
    "        Rectangle rect = new Rectangle(shapeId, x, y, width, height);",
    "        shapes.add(rect);",
    "        shapeMap.put(shapeId, rect);",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Create a circle on the canvas.",
    "     * @param centerX X coordinate of center",
    "     * @param centerY Y coordinate of center",
    "     * @param radius Radius of circle",
    "     * @return Unique shape identifier (e.g., 'circle_1')",
    "     */",
    "    public String createCircle(int centerX, int centerY, int radius) {",
    "        circleCount++;",
    "        String shapeId = \"circle_\" + circleCount;",
    "        Circle circle = new Circle(shapeId, centerX, centerY, radius);",
    "        shapes.add(circle);",
    "        shapeMap.put(shapeId, circle);",
    "        return shapeId;",
    "    }",
    "    ",
    "    /**",
    "     * Get the topmost shape at the given point.",
    "     * @param x X coordinate of query point",
    "     * @param y Y coordinate of query point",
    "     * @return ID of topmost shape, or null if no shape contains point",
    "     */",
    "    public String getShapeAt(int x, int y) {",
    "        // Iterate in reverse order (newest/topmost first)",
    "        for (int i = shapes.size() - 1; i >= 0; i--) {",
    "            Shape shape = shapes.get(i);",
    "            if (shape.contains(x, y)) {",
    "                return shape.getId();  // Early exit",
    "            }",
    "        }",
    "        return null;",
    "    }",
    "    ",
    "    /**",
    "     * Demo and test the Canvas functionality.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"2D Canvas Drawing Application - Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Example 1: Basic Shape Creation",
    "        System.out.println(\"\\n--- Example 1: Basic Creation ---\");",
    "        Canvas canvas = new Canvas();",
    "        ",
    "        String r1 = canvas.createRectangle(10, 10, 40, 30);",
    "        System.out.println(\"Created rectangle: \" + r1);",
    "        ",
    "        String c1 = canvas.createCircle(60, 30, 20);",
    "        System.out.println(\"Created circle: \" + c1);",
    "        ",
    "        System.out.println(\"Shape at (25,25): \" + canvas.getShapeAt(25, 25));",
    "        System.out.println(\"Shape at (60,30): \" + canvas.getShapeAt(60, 30));",
    "        ",
    "        // Example 2: Overlapping Shapes",
    "        System.out.println(\"\\n--- Example 2: Overlapping ---\");",
    "        Canvas canvas2 = new Canvas();",
    "        canvas2.createRectangle(0, 0, 50, 50);",
    "        canvas2.createRectangle(25, 25, 50, 50);",
    "        ",
    "        System.out.println(\"Shape at (30,30): \" + canvas2.getShapeAt(30, 30));",
    "        System.out.println(\"Shape at (10,10): \" + canvas2.getShapeAt(10, 10));",
    "        ",
    "        // Example 3: Boundary Testing",
    "        System.out.println(\"\\n--- Example 3: Boundary ---\");",
    "        Canvas canvas3 = new Canvas();",
    "        canvas3.createCircle(0, 0, 5);",
    "        ",
    "        System.out.println(\"Shape at (3,4): \" + canvas3.getShapeAt(3, 4));",
    "        System.out.println(\"Shape at (4,4): \" + canvas3.getShapeAt(4, 4));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"All tests passed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-14",
      "section": "Imports and Module Docstring",
      "explanation": "We import `ABC` and `abstractmethod` for creating the abstract Shape class, `Optional` for nullable returns, and `List`/`Dict` for type hints. The module docstring explains the purpose and complexity."
    },
    {
      "lines": "16-41",
      "section": "Shape Abstract Base Class",
      "explanation": "The `Shape` class is abstract (cannot be instantiated directly). It stores a unique `id` and defines an abstract `contains()` method that subclasses must implement. This enables **polymorphism** - we can treat all shapes uniformly while each has its own containment logic."
    },
    {
      "lines": "44-88",
      "section": "Rectangle Class",
      "explanation": "Rectangle stores position (x, y) and dimensions (width, height). The `contains()` method checks if the query point is within bounds using **inclusive** comparison (<=). The docstring includes examples showing boundary behavior."
    },
    {
      "lines": "91-136",
      "section": "Circle Class",
      "explanation": "Circle stores center coordinates and radius. The `contains()` method uses **squared distance comparison** (`dx*dx + dy*dy <= r*r`) instead of `sqrt()`. This is both faster and avoids floating-point precision issues. A point at exactly distance `r` from center is considered inside."
    },
    {
      "lines": "139-188",
      "section": "Canvas Class - Initialization",
      "explanation": "Canvas maintains: (1) `_shapes` list for z-order, (2) `_shape_map` dict for O(1) lookup by ID (used in follow-ups), (3) counters for generating unique IDs. Using underscore prefix indicates these are private/internal."
    },
    {
      "lines": "190-224",
      "section": "create_rectangle Method",
      "explanation": "Increments counter, generates ID like 'rect_1', creates Rectangle object, appends to list (maintaining z-order), stores in map, and returns ID. All O(1) operations."
    },
    {
      "lines": "226-260",
      "section": "create_circle Method",
      "explanation": "Same pattern as rectangle - increment counter, generate 'circle_N' ID, create Circle, append to list, store in map, return ID. Note separate counters for each shape type."
    },
    {
      "lines": "262-285",
      "section": "get_shape_at Method - THE KEY ALGORITHM",
      "explanation": "**This is the most important method!** We use `reversed()` to iterate from newest to oldest shape. The first shape whose `contains()` returns True is the topmost one - we return immediately (early exit). If no shape contains the point, we return None."
    },
    {
      "lines": "288-340",
      "section": "main() Demo Function",
      "explanation": "Comprehensive demo showing: (1) Basic creation and query, (2) Overlapping shapes with topmost wins, (3) Boundary testing for circles, (4) Empty point queries. This serves as both documentation and test suite."
    }
  ],
  "complexity_analysis": {
    "time": {
      "create_rectangle": {
        "complexity": "O(1)",
        "explanation": "Increment counter, create object, append to list, insert to HashMap - all O(1) operations"
      },
      "create_circle": {
        "complexity": "O(1)",
        "explanation": "Same as createRectangle - constant time operations"
      },
      "get_shape_at": {
        "complexity": "O(n)",
        "explanation": "Must potentially check all n shapes. Best case O(1) if topmost shape contains point (early exit)."
      },
      "overall": "create* operations are O(1), getShapeAt is O(n) worst case"
    },
    "space": {
      "complexity": "O(n) where n = number of shapes",
      "breakdown": "- **List<Shape>**: O(n) to store all shapes\n- **HashMap<String, Shape>**: O(n) for ID lookup (technically 2n pointers but same big-O)\n- **Counters**: O(1) constant\n- **Per Shape**: O(1) - just a few integer fields",
      "note": "The HashMap is slightly redundant for Part 1 but essential for Part 2 (move) and Part 3 (delete)"
    },
    "can_we_do_better": "For Part 1, no - we need O(n) storage and O(n) hit testing in worst case. Could use spatial indexing (quadtree/R-tree) for O(log n) queries with many shapes, but overkill for \u22641000 shapes per constraints."
  },
  "dry_run": {
    "example": "Canvas(), createRectangle(0,0,50,50), createRectangle(25,25,50,50), getShapeAt(30,30), getShapeAt(10,10)",
    "trace_table": "| Step | Operation | shapes List | shapeMap | rectCount | Result |\n|------|-----------|-------------|----------|-----------|--------|\n| 1 | Canvas() | [] | {} | 0 | - |\n| 2 | createRectangle(0,0,50,50) | [rect_1:(0,0,50,50)] | {rect_1\u2192...} | 1 | \"rect_1\" |\n| 3 | createRectangle(25,25,50,50) | [rect_1, rect_2:(25,25,50,50)] | {rect_1, rect_2} | 2 | \"rect_2\" |\n| 4 | getShapeAt(30,30) | Check rect_2: 25\u226430\u226475 \u2713, 25\u226430\u226475 \u2713 | - | - | **\"rect_2\"** |\n| 5 | getShapeAt(10,10) | Check rect_2: 25\u226410? \u2717, Check rect_1: 0\u226410\u226450 \u2713 | - | - | **\"rect_1\"** |",
    "final_answer": "Query (30,30) returns 'rect_2' (topmost), Query (10,10) returns 'rect_1' (only one contains it)"
  },
  "test_cases": [
    {
      "name": "Basic - Single rectangle query",
      "category": "Happy Path",
      "input": "createRectangle(0,0,100,100), getShapeAt(50,50)",
      "expected": "rect_1",
      "explanation": "Point (50,50) is clearly inside rectangle spanning (0,0) to (100,100)"
    },
    {
      "name": "Basic - Single circle query",
      "category": "Happy Path",
      "input": "createCircle(50,50,30), getShapeAt(50,50)",
      "expected": "circle_1",
      "explanation": "Query at circle center - distance 0 is definitely \u2264 radius 30"
    },
    {
      "name": "Overlapping - Topmost wins",
      "category": "Z-Order",
      "input": "createRectangle(0,0,50,50), createRectangle(25,25,50,50), getShapeAt(30,30)",
      "expected": "rect_2",
      "explanation": "Both rectangles contain (30,30), but rect_2 was created last so it's on top"
    },
    {
      "name": "Rectangle boundary - corner",
      "category": "Edge Case",
      "input": "createRectangle(10,10,40,30), getShapeAt(10,10)",
      "expected": "rect_1",
      "explanation": "Point at top-left corner - should be INSIDE (inclusive bounds)"
    },
    {
      "name": "Rectangle boundary - edge",
      "category": "Edge Case",
      "input": "createRectangle(10,10,40,30), getShapeAt(50,25)",
      "expected": "rect_1",
      "explanation": "Point on right edge (x=10+40=50) - should be INSIDE"
    },
    {
      "name": "Circle boundary - exactly on edge",
      "category": "Edge Case",
      "input": "createCircle(0,0,5), getShapeAt(3,4)",
      "expected": "circle_1",
      "explanation": "Distance = \u221a(9+16) = 5 = radius. Point ON boundary is INSIDE. Classic 3-4-5 triangle."
    },
    {
      "name": "Circle boundary - just outside",
      "category": "Edge Case",
      "input": "createCircle(0,0,5), getShapeAt(4,4)",
      "expected": "null",
      "explanation": "Distance\u00b2 = 32 > 25 = r\u00b2. Point is outside circle."
    },
    {
      "name": "Empty point",
      "category": "Edge Case",
      "input": "createRectangle(100,100,20,20), getShapeAt(50,50)",
      "expected": "null",
      "explanation": "Point (50,50) is nowhere near the rectangle at (100,100)"
    },
    {
      "name": "Three overlapping shapes",
      "category": "Complex",
      "input": "createRectangle(0,0,100,100), createCircle(50,50,40), createRectangle(40,40,30,30), getShapeAt(50,50)",
      "expected": "rect_2",
      "explanation": "All three contain (50,50). rect_2 created last, so it's on top."
    },
    {
      "name": "Circle and rectangle overlap",
      "category": "Complex",
      "input": "createCircle(50,50,30), createRectangle(40,40,30,30), getShapeAt(80,50)",
      "expected": "circle_1",
      "explanation": "Point (80,50) is outside rectangle but inside circle (distance=30=radius)"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Wrong z-order iteration (forward instead of reverse)",
      "why_wrong": "Forward iteration finds the BOTTOM shape, not the TOP shape. Shapes created later should be on top.",
      "correct_approach": "Iterate in REVERSE order and return on FIRST match",
      "code_wrong": "for shape in self.shapes:  # Wrong!\n    if shape.contains(x, y):\n        result = shape  # Overwrites, gets last\nreturn result",
      "code_correct": "for shape in reversed(self.shapes):  # Correct!\n    if shape.contains(x, y):\n        return shape.id  # First match = topmost"
    },
    {
      "mistake": "Exclusive boundary check (using < instead of <=)",
      "why_wrong": "Problem states: 'Points on boundary are considered INSIDE'. Using < excludes boundary points.",
      "correct_approach": "Use <= for all boundary comparisons",
      "code_wrong": "return (self.x < px < self.x + self.width and\n        self.y < py < self.y + self.height)",
      "code_correct": "return (self.x <= px <= self.x + self.width and\n        self.y <= py <= self.y + self.height)"
    },
    {
      "mistake": "Using sqrt() for circle containment",
      "why_wrong": "1) sqrt() is slower than multiplication. 2) Can introduce floating-point precision errors. 3) Unnecessary.",
      "correct_approach": "Compare squared distance to squared radius",
      "code_wrong": "import math\ndist = math.sqrt(dx*dx + dy*dy)\nreturn dist <= self.radius",
      "code_correct": "# No sqrt needed!\nreturn dx*dx + dy*dy <= self.radius * self.radius"
    },
    {
      "mistake": "Integer overflow in circle distance calculation (Java)",
      "why_wrong": "With max radius 10\u00b3 and coordinates 10\u2074, dx can be ~10\u2074, and dx\u00b2 can be ~10\u2078. Two such values added is ~2\u00d710\u2078, which fits in int, but safer to use long.",
      "correct_approach": "Use long for intermediate calculations in Java",
      "code_wrong": "int dx = px - centerX;\nint dist2 = dx*dx + dy*dy;  // Risk of overflow",
      "code_correct": "long dx = px - centerX;\nlong dist2 = dx*dx + dy*dy;  // Safe"
    },
    {
      "mistake": "Not returning null for empty queries",
      "why_wrong": "Returning empty string, -1, or throwing exception is wrong. Problem specifies null/None for no shape found.",
      "correct_approach": "Return null (Java) or None (Python) explicitly",
      "code_wrong": "return \"\"  # or return -1",
      "code_correct": "return None  # Python\nreturn null;  // Java"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem. Before I start coding, let me make sure I understand the requirements correctly and ask a few clarifying questions...",
    "clarifying_questions_to_ask": [
      "**Are boundary points inside shapes?** - Confirms need for inclusive bounds (<=)",
      "**What ID format should I use?** - Clarifies 'rect_1', 'circle_1' convention",
      "**Should getShapeAt return null or empty string for no match?** - Confirms return type",
      "**Are there follow-up parts?** - Helps design for extensibility (HashMap for ID lookup)",
      "**What precision is needed for circle containment?** - Confirms squared comparison is fine",
      "**Can shapes be deleted or moved later?** - Hints at follow-up design needs"
    ],
    "what_to_mention_proactively": [
      "I'll use an **abstract Shape class** with polymorphic contains() for clean OOP design",
      "I'll maintain shapes in a **list for z-order** - index = creation order",
      "For getShapeAt, I'll iterate in **reverse order** to find topmost shape first",
      "For circle containment, I'll use **squared distance** to avoid sqrt() precision issues",
      "I'll add a **HashMap for ID lookup** even if not needed now - it helps with follow-ups",
      "Let me trace through an example after coding to verify correctness"
    ],
    "communication_during_coding": [
      "I'm defining Shape as abstract because we need different contains() implementations",
      "The Rectangle contains check uses inclusive bounds (<=) since boundary points are inside",
      "For Circle, I'm using dx*dx + dy*dy <= r*r to avoid sqrt()",
      "Appending to list gives us O(1) creation while maintaining z-order",
      "The reversed() iteration ensures we find the topmost shape first"
    ],
    "if_stuck": [
      "**Think about z-order**: Which shape should be returned if multiple overlap? The topmost (most recently created)",
      "**Draw it out**: Sketch overlapping shapes and mark which is on top",
      "**Simplify**: Get one shape type working before adding the second",
      "**Ask for hints**: 'Would reverse iteration help here?'"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Discuss approach and data structures | 10-25min: Implement solution | 25-35min: Test with examples | 35-45min: Handle follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "OOP Design with Polymorphism + Hit Testing",
    "indicators": [
      "Different object types with common interface (Shape.contains())",
      "Need to find 'topmost' or 'nearest' object at a point",
      "Objects have spatial properties (position, dimensions)",
      "Z-ordering or layering requirement"
    ],
    "similar_problems": [
      "**LC 850 - Rectangle Area II**: Area calculation with overlapping rectangles",
      "**LC 223 - Rectangle Area**: Two rectangle overlap area",
      "**Design Browser History**: Stack-based navigation (similar undo/redo pattern for Part 4)",
      "**Design LRU Cache**: HashMap + LinkedList for O(1) operations",
      "**Meeting Rooms II**: Interval overlap counting (similar to Part 3)"
    ],
    "template": "1. Create abstract base class with common interface\n2. Implement concrete classes with specific logic\n3. Store objects in ordered collection\n4. Query by iterating (forward/reverse) based on priority rules"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2 adds moveShape(shapeId, newX, newY)**. You'll need O(1) lookup by ID - this is why we added the HashMap. Update shape coordinates and HashMap remains valid. Consider: should z-order change on move? Usually no.",
    "part_3_hint": "**Part 3 adds deleteShape(shapeId) and bringToFront/sendToBack(shapeId)**. Delete requires removing from both list and HashMap. For z-order changes, you need to reposition in the list - O(n) unless you use a different data structure (doubly-linked list with HashMap to nodes).",
    "part_4_hint": "**Part 4 adds undo/redo**. Classic **Command Pattern** - store operations as objects. Each create/move/delete becomes a Command with execute() and undo(). Use two stacks: undoStack and redoStack.",
    "data_structure_evolution": "Part 1: List + HashMap \u2192 Part 2: Same (update coordinates) \u2192 Part 3: Consider DoublyLinkedList for O(1) reordering \u2192 Part 4: Add Command pattern with undo/redo stacks"
  },
  "generated_at": "2026-01-14T15:22:42.886321",
  "_meta": {
    "problem_id": "canvas_2d_drawing_app",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}