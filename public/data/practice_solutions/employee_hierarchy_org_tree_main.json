{
  "problem_title": "Employee Hierarchy / Org Tree",
  "difficulty": "medium",
  "category": "DSA/Trees + OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **OOP Design + Tree Structure** problem. The organizational hierarchy naturally forms an N-ary tree where each node (employee) can have multiple children (direct reports) but exactly one parent (manager). The key challenge is designing clean class relationships and maintaining efficient lookups.",
    "pattern_recognition": "**HashMap + Tree + Bidirectional References**. The HashMap provides O(1) employee lookup by ID, while the tree structure maintains the hierarchical relationships. Bidirectional references (parent \u2194 children) enable efficient traversal in both directions.",
    "key_constraints": [
      "**Unique Employee IDs (1 \u2264 id \u2264 10\u2076)** - Use HashMap<Integer, Employee> for O(1) lookups",
      "**Max 10\u2075 employees** - HashMap and tree can easily handle this scale",
      "**Manager must exist before adding subordinate** - Validates tree structure, prevents orphan nodes",
      "**Only one CEO (null manager)** - Ensures single-rooted tree, no disconnected components",
      "**Rating 1-10** - Simple validation, but might be used in Part 2 for aggregation"
    ],
    "clarifying_questions": [
      "**Can an employee be removed from the org?** - Determines if we need removeEmployee() with orphan handling",
      "**Can an employee be transferred to a new manager?** - Affects relationship update logic",
      "**Thread safety requirements?** - Single-threaded is fine for interview, but good to ask",
      "**Should getEmployee return a copy or reference?** - Encapsulation vs convenience tradeoff",
      "**What happens if we try to add a second CEO?** - Should return false per constraints",
      "**Are employee names unique?** - No, only IDs are unique",
      "**How should ties in ratings be handled for Part 2?** - Pre-emptive thinking ahead"
    ],
    "edge_cases_to_consider": [
      "Single employee (CEO only) - Direct report count is 0",
      "Adding employee with non-existent manager ID - Return false",
      "Adding duplicate employee ID - Return false",
      "Querying non-existent employee - Return -1 or null",
      "Linear chain (each person has exactly 1 report) - Deep tree, tests recursion depth for Part 2",
      "Wide tree (CEO has 1000 direct reports) - Tests list handling",
      "Adding second CEO (null manager when CEO exists) - Should return false"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Employee class with id, name, rating, manager, subordinates",
        "how_met": "Employee class with all fields, manager is nullable, subordinates is List<Employee>",
        "gotchas": [
          "Initialize subordinates as empty list, not null",
          "Manager reference should be Employee object, not just ID"
        ]
      },
      {
        "requirement": "addEmployee returns true if successful, false if ID exists or manager not found",
        "how_met": "Check employees HashMap for existing ID, check for manager existence (or null for CEO)",
        "gotchas": [
          "Don't forget to add employee to manager's subordinates list (bidirectional)",
          "Check for second CEO attempt"
        ]
      },
      {
        "requirement": "getDirectReportCount returns count of DIRECT reports only",
        "how_met": "Return len(employee.subordinates) - only immediate children, not recursive",
        "gotchas": [
          "Don't count all descendants recursively - that's getTeamSize for Part 2",
          "Return -1 for non-existent employee, not 0"
        ]
      },
      {
        "requirement": "getEmployee returns Employee or null",
        "how_met": "Simple HashMap.get() with null handling",
        "gotchas": [
          "Consider returning a copy to prevent external mutation (optional for interview)"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addEmployee",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion + list append are O(1)"
      },
      {
        "operation": "getDirectReportCount",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + list.size() are O(1)"
      },
      {
        "operation": "getEmployee",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Direct HashMap lookup"
      }
    ],
    "non_goals": [
      "Employee removal - not asked in Part 1, would need orphan handling",
      "Manager transfer - adds complexity not required",
      "Concurrent access - single-threaded assumed",
      "Employee name updates - immutable for simplicity",
      "Team size calculation - that's Part 2"
    ]
  },
  "assumptions": [
    "**Single-threaded access** - No concurrent modifications (ask interviewer to confirm)",
    "**IDs are provided, not generated** - The caller provides unique IDs",
    "**No cycles in hierarchy** - Tree structure enforced by single-parent constraint",
    "**CEO added first** - Must add root before any children (enforced by manager validation)",
    "**Ratings are informational only for Part 1** - Used in Part 2 for team performance"
  ],
  "tradeoffs": [
    {
      "decision": "Store Employee references vs just IDs in relationships",
      "chosen": "Store Employee object references",
      "why": "Enables O(1) traversal without HashMap lookups; cleaner OOP design",
      "alternative": "Store only managerId/subordinateIds",
      "when_to_switch": "If serialization/persistence is primary concern"
    },
    {
      "decision": "Bidirectional references (manager \u2194 subordinates) vs single direction",
      "chosen": "Bidirectional",
      "why": "Enables efficient traversal both up (to CEO) and down (to team); required for Part 2",
      "alternative": "Only store managerId, compute children on demand",
      "when_to_switch": "If memory is critical and write-heavy"
    },
    {
      "decision": "List vs Set for subordinates",
      "chosen": "List<Employee>",
      "why": "Order might matter for display; insertion order preserved; simpler API",
      "alternative": "Set<Employee> for O(1) contains check",
      "when_to_switch": "If removeEmployee() is frequent and needs fast lookup"
    },
    {
      "decision": "Separate CEO reference vs just use HashMap",
      "chosen": "Store separate ceo reference",
      "why": "O(1) access to root for tree traversals; clear invariant",
      "alternative": "Find CEO by scanning for null manager",
      "when_to_switch": "Never - always keep root reference"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Encapsulation** - Employee fields private, accessed via getters",
      "**Single Responsibility** - OrgChart manages the structure, Employee holds data",
      "**Open for Extension** - Easy to add getTeamSize(), getBestTeam() for Part 2",
      "**Composition over Inheritance** - Employee contains manager reference, not extends Manager"
    ],
    "why_this_design_scales": "The bidirectional tree structure with HashMap indexing makes Part 2 (team aggregation) trivial - just DFS from any employee. Part 3 (filtering) can reuse the same traversal with predicates. The Employee class can be extended with more fields without changing OrgChart.",
    "expected_followup_hooks": [
      "**getTeamSize(id)** - Add DFS traversal counting all descendants",
      "**getTeamRating(id)** - Sum/average ratings using same DFS",
      "**getBestPerformingTeam()** - DFS from each node, track max average",
      "**getManagementChain(id)** - Traverse up via manager references",
      "**getCommonManager(id1, id2)** - LCA algorithm using parent references"
    ],
    "invariants": [
      "Every employee except CEO has exactly one manager",
      "Every employee ID is unique",
      "No cycles in the management hierarchy",
      "All employees are reachable from CEO",
      "manager.subordinates.contains(this) \u2194 this.manager == manager (bidirectional consistency)"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    ORGANIZATIONAL CHART                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                             \u2502\n\u2502                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                      \u2502   CEO (1)   \u2502 \u2190 Root (manager=null)  \u2502\n\u2502                      \u2502  Rating: 8  \u2502                        \u2502\n\u2502                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502               \u25bc                           \u25bc                 \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502        \u2502  VP Eng (2) \u2502             \u2502 VP Sales(3) \u2502          \u2502\n\u2502        \u2502  Rating: 7  \u2502             \u2502  Rating: 6  \u2502          \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502               \u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502               \u25bc                    \u25bc             \u25bc          \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502        \u2502 Manager (4) \u2502      \u2502  Lead (5)   \u2502 \u2502  Lead (6)   \u2502 \u2502\n\u2502        \u2502  Rating: 5  \u2502      \u2502  Rating: 9  \u2502 \u2502  Rating: 4  \u2502 \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                      \u2502\n\u2502        \u25bc             \u25bc                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                            \u2502\n\u2502  \u2502   Dev (7)   \u2502 \u2502   Dev (8)   \u2502  \u2190 Leaf nodes              \u2502\n\u2502  \u2502  Rating: 6  \u2502 \u2502  Rating: 8  \u2502                            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                            \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURES                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                \u2502\n\u2502  HashMap<Integer, Employee> employees:                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502 Key \u2502                     Value                      \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502  1  \u2502 Employee(id=1, name=\"CEO\", rating=8,           \u2502       \u2502\n\u2502  \u2502     \u2502          manager=null, subordinates=[2,3])     \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502  2  \u2502 Employee(id=2, name=\"VPEng\", rating=7,         \u2502       \u2502\n\u2502  \u2502     \u2502          manager=\u21921, subordinates=[4])         \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502  3  \u2502 Employee(id=3, name=\"VPSales\", rating=6,       \u2502       \u2502\n\u2502  \u2502     \u2502          manager=\u21921, subordinates=[5,6])       \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502  4  \u2502 Employee(id=4, name=\"Manager\", rating=5,       \u2502       \u2502\n\u2502  \u2502     \u2502          manager=\u21922, subordinates=[7,8])       \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502  5  \u2502 Employee(id=5, name=\"Lead\", rating=9,          \u2502       \u2502\n\u2502  \u2502     \u2502          manager=\u21923, subordinates=[])          \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                \u2502\n\u2502  Employee ceo = \u2192 Employee(id=1)                               \u2502\n\u2502                                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "addEmployee(1, 'CEO', 8, null) - Add root employee",
        "visualization": "```\nemployees: {} \u2192 {1: Employee(1, 'CEO', 8)}\nceo: null \u2192 Employee(1)\n```",
        "key_point": "First employee with null manager becomes CEO"
      },
      {
        "step": 2,
        "description": "addEmployee(2, 'VP', 7, 1) - Add subordinate to CEO",
        "visualization": "```\n1. Check: ID 2 not in employees \u2713\n2. Check: Manager ID 1 exists \u2713\n3. Create: Employee(2, 'VP', 7, manager=\u21921)\n4. Link: employees[1].subordinates.add(\u21922)\n5. Store: employees[2] = new employee\n\nemployees: {1: ..., 2: Employee(2, 'VP', 7, manager=\u21921)}\nCEO.subordinates: [] \u2192 [\u21922]\n```",
        "key_point": "Bidirectional linking is critical - update BOTH parent and child"
      },
      {
        "step": 3,
        "description": "getDirectReportCount(1) - Query CEO's direct reports",
        "visualization": "```\n1. Lookup: employees[1] \u2192 Employee(1, 'CEO', ...)\n2. Return: len(employee.subordinates) = 1\n\n\u2713 O(1) - HashMap lookup + list.size()\n```",
        "key_point": "Direct reports = immediate children only, NOT recursive"
      }
    ],
    "dry_run_table": "| Step | Operation | Validation | employees Map | CEO.subordinates | Result |\n|------|-----------|------------|---------------|------------------|--------|\n| 1 | OrgChart() | - | {} | - | initialized |\n| 2 | addEmployee(1, \"Alice\", 8, null) | ID 1 not exists \u2713, null manager (CEO) \u2713 | {1: Alice} | [] | **true** |\n| 3 | addEmployee(2, \"Bob\", 7, 1) | ID 2 not exists \u2713, manager 1 exists \u2713 | {1: Alice, 2: Bob} | [\u2192Bob] | **true** |\n| 4 | addEmployee(3, \"Carol\", 6, 1) | ID 3 not exists \u2713, manager 1 exists \u2713 | {1: Alice, 2: Bob, 3: Carol} | [\u2192Bob, \u2192Carol] | **true** |\n| 5 | addEmployee(4, \"David\", 5, 2) | ID 4 not exists \u2713, manager 2 exists \u2713 | {..., 4: David} | [\u2192Bob, \u2192Carol] | **true** |\n| 6 | getDirectReportCount(1) | ID 1 exists \u2713 | - | [\u2192Bob, \u2192Carol] | **2** |\n| 7 | getDirectReportCount(2) | ID 2 exists \u2713 | - | Bob.subs=[\u2192David] | **1** |\n| 8 | getDirectReportCount(4) | ID 4 exists \u2713 | - | David.subs=[] | **0** |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'hierarchical structure with one manager per employee'**, I immediately think **N-ary Tree** because each node has one parent but can have multiple children - that's the definition of a tree.",
      "**When I see 'O(1) lookup by employee ID'**, I know I need a **HashMap<Integer, Employee>** as an index alongside the tree structure. Trees give O(log n) or O(n) lookup; only HashMap gives O(1).",
      "**When I see 'direct reports' vs 'team'**, I recognize the **difference between immediate children and all descendants**. Direct reports = children list size (O(1)). Team = DFS traversal (O(team size)).",
      "**When I see 'manager must exist before subordinate'**, I understand this enforces **parent-before-child insertion** which naturally builds a valid tree without cycles.",
      "**The key insight is bidirectional references**: employee.manager points up, employee.subordinates points down. This enables O(1) navigation in both directions and is essential for Part 2 (team calculations).",
      "**I should use a separate CEO reference** because finding the root by scanning for null manager would be O(n). Storing it directly is O(1)."
    ],
    "key_insight": "The organizational hierarchy is an **N-ary tree** indexed by a **HashMap**. The HashMap provides O(1) access to any employee, while the tree structure provides hierarchical relationships. **Bidirectional references** (manager \u2194 subordinates) enable efficient traversal in both directions, which will be essential for Part 2's team calculations.",
    "why_this_works": "1. **HashMap** ensures all lookups are O(1) regardless of org size.\n2. **Bidirectional references** mean we never need to search - we can directly traverse up to CEO or down to all subordinates.\n3. **Enforcing manager-exists-first** naturally builds a valid tree without orphan nodes or cycles.\n4. **Storing CEO reference** provides O(1) access to the root for tree-wide operations."
  },
  "approaches": [
    {
      "name": "Brute Force: Flat List with Linear Search",
      "description": "Store all employees in a list. On each operation, iterate to find the employee. Calculate relationships on-demand by scanning the entire list.",
      "pseudocode": "addEmployee:\n  for each emp in employees:\n    if emp.id == id: return false\n  for each emp in employees:\n    if emp.id == managerId: found manager\n  employees.append(new Employee)\n\ngetDirectReportCount:\n  for each emp in employees:\n    if emp.id == employeeId:\n      count = 0\n      for each other in employees:\n        if other.managerId == emp.id: count++\n      return count\n  return -1",
      "time_complexity": "O(n) for addEmployee, O(n\u00b2) for getDirectReportCount",
      "space_complexity": "O(n)",
      "pros": [
        "Simple to implement",
        "No complex data structures"
      ],
      "cons": [
        "Fails O(1) requirement",
        "Extremely slow for large orgs",
        "Repeated scans are wasteful"
      ],
      "when_to_use": "Never - just for understanding what NOT to do"
    },
    {
      "name": "Optimal: HashMap + Bidirectional Tree",
      "description": "Use HashMap<Integer, Employee> for O(1) lookups. Each Employee stores a direct reference to their manager AND a list of their direct subordinates. This bidirectional linking enables O(1) operations and efficient tree traversal.",
      "pseudocode": "class Employee:\n  id, name, rating\n  manager: Employee (nullable)\n  subordinates: List<Employee>\n\nclass OrgChart:\n  employees: HashMap<Integer, Employee>\n  ceo: Employee\n\naddEmployee(id, name, rating, managerId):\n  if id in employees: return false\n  if managerId is null:\n    if ceo exists: return false  // only one CEO\n    emp = new Employee(id, name, rating, null)\n    ceo = emp\n  else:\n    manager = employees.get(managerId)\n    if manager is null: return false\n    emp = new Employee(id, name, rating, manager)\n    manager.subordinates.add(emp)  // bidirectional!\n  employees.put(id, emp)\n  return true\n\ngetDirectReportCount(employeeId):\n  emp = employees.get(employeeId)\n  if emp is null: return -1\n  return emp.subordinates.size()  // O(1)!",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(n) for n employees",
      "pros": [
        "Meets O(1) requirement",
        "Efficient traversal both directions",
        "Clean OOP design",
        "Extensible for Part 2"
      ],
      "cons": [
        "Slightly more complex initial setup",
        "Must maintain bidirectional consistency"
      ],
      "key_insight": "Store relationships in BOTH directions - parent knows children AND child knows parent. This enables O(1) for all current operations and efficient DFS for Part 2."
    }
  ],
  "optimal_solution": {
    "name": "HashMap-Indexed Bidirectional N-ary Tree",
    "explanation_md": "## Approach\n\nWe model the organization as an **N-ary tree** where:\n- Each **Employee** is a node\n- The **CEO** is the root (manager = null)\n- Each node knows its **parent (manager)** and **children (subordinates)**\n\n### Data Structures\n\n1. **Employee Class**: Holds id, name, rating, and relationship references\n2. **HashMap<Integer, Employee>**: Provides O(1) lookup by ID\n3. **CEO Reference**: Direct access to tree root\n\n### Key Design Decisions\n\n1. **Bidirectional References**: Each employee stores both `manager` (parent) and `subordinates` (children). This enables:\n   - O(1) direct report count (children list size)\n   - O(1) manager lookup\n   - Efficient DFS for team calculations in Part 2\n\n2. **Validation on Insert**:\n   - Reject duplicate IDs\n   - Reject if manager doesn't exist\n   - Reject second CEO attempt\n\n3. **Maintain Invariants**:\n   - Always update BOTH directions when adding (add child to parent's list, set child's parent)\n   - Single root guaranteed\n\n### Why This Works\n\nThe HashMap provides O(1) access to any employee. The bidirectional tree structure provides O(1) relationship navigation. Together, they enable all Part 1 operations in O(1) and set up efficient DFS for Part 2.",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Employee>",
        "purpose": "O(1) employee lookup by ID"
      },
      {
        "structure": "Employee.manager (Employee reference)",
        "purpose": "O(1) access to parent node"
      },
      {
        "structure": "Employee.subordinates (List<Employee>)",
        "purpose": "O(1) direct report count, O(k) iteration over children"
      },
      {
        "structure": "OrgChart.ceo (Employee reference)",
        "purpose": "O(1) access to root for tree-wide operations"
      }
    ],
    "algorithm_steps": [
      "1. **Initialize**: Create empty HashMap and null CEO reference",
      "2. **addEmployee**: Validate (no duplicate, manager exists or CEO), create Employee, link bidirectionally, store in HashMap",
      "3. **getDirectReportCount**: HashMap lookup \u2192 return subordinates list size",
      "4. **getEmployee**: Direct HashMap lookup, return Employee or null"
    ],
    "why_decimal": "Not applicable for this problem - ratings are integers 1-10."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Employee Hierarchy / Org Tree - Part 1: Basic Structure",
    "",
    "A production-quality implementation of an organizational chart system.",
    "Supports O(1) employee operations using HashMap-indexed bidirectional N-ary tree.",
    "",
    "Author: Interview Preparation Guide",
    "Time Complexity: O(1) for all operations",
    "Space Complexity: O(n) for n employees",
    "\"\"\"",
    "",
    "from typing import Optional, List, Dict",
    "",
    "",
    "class Employee:",
    "    \"\"\"",
    "    Represents an employee in the organizational hierarchy.",
    "    ",
    "    Each employee maintains bidirectional references:",
    "    - manager: reference to their direct manager (None for CEO)",
    "    - subordinates: list of direct reports",
    "    ",
    "    Attributes:",
    "        id: Unique employee identifier",
    "        name: Employee name",
    "        rating: Performance rating (1-10)",
    "        manager: Reference to manager Employee (None for CEO)",
    "        subordinates: List of direct report Employees",
    "    ",
    "    Example:",
    "        >>> ceo = Employee(1, \"Alice\", 8)",
    "        >>> vp = Employee(2, \"Bob\", 7, ceo)",
    "        >>> ceo.subordinates.append(vp)",
    "        >>> len(ceo.subordinates)  # Direct reports",
    "        1",
    "    \"\"\"",
    "    ",
    "    def __init__(",
    "        self,",
    "        emp_id: int,",
    "        name: str,",
    "        rating: int,",
    "        manager: Optional['Employee'] = None",
    "    ) -> None:",
    "        \"\"\"Initialize an Employee with the given attributes.\"\"\"",
    "        self.id: int = emp_id",
    "        self.name: str = name",
    "        self.rating: int = rating",
    "        self.manager: Optional['Employee'] = manager",
    "        self.subordinates: List['Employee'] = []",
    "    ",
    "    def get_id(self) -> int:",
    "        \"\"\"Return the employee's unique identifier.\"\"\"",
    "        return self.id",
    "    ",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the employee's name.\"\"\"",
    "        return self.name",
    "    ",
    "    def get_rating(self) -> int:",
    "        \"\"\"Return the employee's performance rating.\"\"\"",
    "        return self.rating",
    "    ",
    "    def get_manager(self) -> Optional['Employee']:",
    "        \"\"\"Return the employee's manager, or None if CEO.\"\"\"",
    "        return self.manager",
    "    ",
    "    def get_subordinates(self) -> List['Employee']:",
    "        \"\"\"Return list of direct reports.\"\"\"",
    "        return self.subordinates",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"String representation for debugging.\"\"\"",
    "        manager_id = self.manager.id if self.manager else None",
    "        sub_ids = [s.id for s in self.subordinates]",
    "        return (f\"Employee(id={self.id}, name='{self.name}', \"",
    "                f\"rating={self.rating}, manager_id={manager_id}, \"",
    "                f\"subordinate_ids={sub_ids})\")",
    "",
    "",
    "class OrgChart:",
    "    \"\"\"",
    "    Organizational chart management system.",
    "    ",
    "    Maintains a hierarchical tree structure of employees with O(1) operations.",
    "    Uses HashMap for employee lookup and bidirectional tree for relationships.",
    "    ",
    "    Design Principles:",
    "    - O(1) for all operations via HashMap indexing",
    "    - Bidirectional references for efficient traversal",
    "    - Single root (CEO) constraint enforced",
    "    ",
    "    Example:",
    "        >>> org = OrgChart()",
    "        >>> org.add_employee(1, \"Alice\", 8, None)  # CEO",
    "        True",
    "        >>> org.add_employee(2, \"Bob\", 7, 1)  # Reports to Alice",
    "        True",
    "        >>> org.get_direct_report_count(1)",
    "        1",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize an empty organizational chart.\"\"\"",
    "        # HashMap for O(1) employee lookup by ID",
    "        self._employees: Dict[int, Employee] = {}",
    "        # Direct reference to root for tree-wide operations",
    "        self._ceo: Optional[Employee] = None",
    "    ",
    "    def add_employee(",
    "        self,",
    "        emp_id: int,",
    "        name: str,",
    "        rating: int,",
    "        manager_id: Optional[int]",
    "    ) -> bool:",
    "        \"\"\"",
    "        Add a new employee to the organization.",
    "        ",
    "        Args:",
    "            emp_id: Unique employee identifier",
    "            name: Employee name",
    "            rating: Performance rating (1-10)",
    "            manager_id: ID of manager, or None for CEO",
    "        ",
    "        Returns:",
    "            True if employee added successfully,",
    "            False if ID already exists or manager not found",
    "        ",
    "        Example:",
    "            >>> org = OrgChart()",
    "            >>> org.add_employee(1, \"CEO\", 9, None)",
    "            True",
    "            >>> org.add_employee(1, \"Duplicate\", 5, None)  # ID exists",
    "            False",
    "            >>> org.add_employee(2, \"VP\", 7, 99)  # Manager 99 not found",
    "            False",
    "        \"\"\"",
    "        # Validation 1: Check for duplicate ID",
    "        if emp_id in self._employees:",
    "            return False",
    "        ",
    "        # Handle CEO case (manager_id is None)",
    "        if manager_id is None:",
    "            # Validation 2: Only one CEO allowed",
    "            if self._ceo is not None:",
    "                return False",
    "            ",
    "            # Create CEO (root node)",
    "            new_employee = Employee(emp_id, name, rating, None)",
    "            self._ceo = new_employee",
    "            self._employees[emp_id] = new_employee",
    "            return True",
    "        ",
    "        # Handle non-CEO case",
    "        # Validation 3: Manager must exist",
    "        if manager_id not in self._employees:",
    "            return False",
    "        ",
    "        manager = self._employees[manager_id]",
    "        ",
    "        # Create new employee with manager reference",
    "        new_employee = Employee(emp_id, name, rating, manager)",
    "        ",
    "        # CRITICAL: Bidirectional linking",
    "        # Update manager's subordinates list",
    "        manager.subordinates.append(new_employee)",
    "        ",
    "        # Store in HashMap for O(1) lookup",
    "        self._employees[emp_id] = new_employee",
    "        ",
    "        return True",
    "    ",
    "    def get_direct_report_count(self, employee_id: int) -> int:",
    "        \"\"\"",
    "        Get the count of direct reports for an employee.",
    "        ",
    "        IMPORTANT: This returns ONLY immediate children, not all descendants.",
    "        For total team size, see Part 2.",
    "        ",
    "        Args:",
    "            employee_id: ID of the employee to query",
    "        ",
    "        Returns:",
    "            Count of direct reports (immediate children only),",
    "            -1 if employee not found",
    "        ",
    "        Example:",
    "            For structure: CEO(1) -> VP(2) -> Manager(3)",
    "            get_direct_report_count(1) returns 1 (only VP, not Manager)",
    "        \"\"\"",
    "        # Validation: Employee must exist",
    "        if employee_id not in self._employees:",
    "            return -1",
    "        ",
    "        employee = self._employees[employee_id]",
    "        ",
    "        # O(1) - just return list size",
    "        return len(employee.subordinates)",
    "    ",
    "    def get_employee(self, employee_id: int) -> Optional[Employee]:",
    "        \"\"\"",
    "        Retrieve an employee by their ID.",
    "        ",
    "        Args:",
    "            employee_id: ID of the employee",
    "        ",
    "        Returns:",
    "            Employee object if found, None otherwise",
    "        ",
    "        Note:",
    "            Returns the actual Employee object. In production,",
    "            consider returning a copy to prevent external mutation.",
    "        \"\"\"",
    "        return self._employees.get(employee_id, None)",
    "    ",
    "    def get_ceo(self) -> Optional[Employee]:",
    "        \"\"\"Return the CEO (root) of the organization.\"\"\"",
    "        return self._ceo",
    "    ",
    "    def size(self) -> int:",
    "        \"\"\"Return total number of employees in the organization.\"\"\"",
    "        return len(self._employees)",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"String representation showing org structure.\"\"\"",
    "        ceo_id = self._ceo.id if self._ceo else None",
    "        return f\"OrgChart(size={self.size()}, ceo_id={ceo_id})\"",
    "",
    "",
    "def run_demo() -> None:",
    "    \"\"\"",
    "    Demonstrate the OrgChart functionality with example from problem.",
    "    ",
    "    Builds this structure:",
    "              CEO(1)",
    "             /      \\\\",
    "         VPEng(2)  VPSales(3)",
    "            |       /    \\\\",
    "        Mgr(4)   Lead(5) Lead(6)",
    "         /  \\\\",
    "     Dev(7) Dev(8)",
    "    \"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Employee Hierarchy / Org Tree - Demo\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    ",
    "    # Initialize org chart",
    "    org = OrgChart()",
    "    print(f\"Initialized: {org}\")",
    "    print()",
    "    ",
    "    # Build organization structure",
    "    print(\"Building organization...\")",
    "    print(\"-\" * 40)",
    "    ",
    "    operations = [",
    "        (1, \"CEO\", 8, None),",
    "        (2, \"VPEng\", 7, 1),",
    "        (3, \"VPSales\", 6, 1),",
    "        (4, \"EngMgr\", 5, 2),",
    "        (5, \"SalesLead1\", 9, 3),",
    "        (6, \"SalesLead2\", 4, 3),",
    "        (7, \"Dev1\", 6, 4),",
    "        (8, \"Dev2\", 8, 4),",
    "    ]",
    "    ",
    "    for emp_id, name, rating, manager_id in operations:",
    "        result = org.add_employee(emp_id, name, rating, manager_id)",
    "        mgr_str = f\"reports to {manager_id}\" if manager_id else \"(CEO)\"",
    "        print(f\"  add_employee({emp_id}, '{name}', {rating}, {manager_id}) \"",
    "              f\"-> {result} {mgr_str}\")",
    "    ",
    "    print()",
    "    print(f\"Organization built: {org}\")",
    "    print()",
    "    ",
    "    # Query direct report counts",
    "    print(\"Querying direct report counts...\")",
    "    print(\"-\" * 40)",
    "    ",
    "    queries = [1, 2, 3, 4, 5, 100]  # 100 doesn't exist",
    "    for emp_id in queries:",
    "        count = org.get_direct_report_count(emp_id)",
    "        emp = org.get_employee(emp_id)",
    "        if emp:",
    "            print(f\"  get_direct_report_count({emp_id}) -> {count}  \"",
    "                  f\"({emp.name}'s direct reports)\")",
    "        else:",
    "            print(f\"  get_direct_report_count({emp_id}) -> {count}  \"",
    "                  f\"(employee not found)\")",
    "    ",
    "    print()",
    "    ",
    "    # Test error cases",
    "    print(\"Testing error cases...\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Duplicate ID",
    "    result = org.add_employee(1, \"Duplicate\", 5, None)",
    "    print(f\"  add_employee(1, 'Duplicate', 5, None) -> {result}  \"",
    "          f\"(duplicate ID)\")",
    "    ",
    "    # Non-existent manager",
    "    result = org.add_employee(99, \"Orphan\", 5, 100)",
    "    print(f\"  add_employee(99, 'Orphan', 5, 100) -> {result}  \"",
    "          f\"(manager 100 doesn't exist)\")",
    "    ",
    "    # Second CEO attempt",
    "    result = org.add_employee(10, \"CEO2\", 9, None)",
    "    print(f\"  add_employee(10, 'CEO2', 9, None) -> {result}  \"",
    "          f\"(second CEO not allowed)\")",
    "    ",
    "    print()",
    "    ",
    "    # Print org structure",
    "    print(\"Organization Structure:\")",
    "    print(\"-\" * 40)",
    "    print(\"```\")",
    "    print(\"              CEO(1) r=8\")",
    "    print(\"             /      \\\\\")",
    "    print(\"         VPEng(2)  VPSales(3)\")",
    "    print(\"          r=7       r=6\")",
    "    print(\"            |       /    \\\\\")",
    "    print(\"        Mgr(4)   Lead(5) Lead(6)\")",
    "    print(\"         r=5      r=9     r=4\")",
    "    print(\"         /  \\\\\")",
    "    print(\"     Dev(7) Dev(8)\")",
    "    print(\"      r=6    r=8\")",
    "    print(\"```\")",
    "    print()",
    "    print(\"=\" * 60)",
    "    print(\"Demo complete!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "def run_example_1() -> None:",
    "    \"\"\"Run Example 1 from the problem statement.\"\"\"",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Example 1: Building Basic Org Structure\")",
    "    print(\"=\" * 60)",
    "    ",
    "    org = OrgChart()",
    "    results = []",
    "    ",
    "    results.append(org.add_employee(1, \"Alice\", 8, None))",
    "    results.append(org.add_employee(2, \"Bob\", 7, 1))",
    "    results.append(org.add_employee(3, \"Carol\", 6, 1))",
    "    results.append(org.add_employee(4, \"David\", 5, 2))",
    "    results.append(org.get_direct_report_count(1))",
    "    results.append(org.get_direct_report_count(2))",
    "    results.append(org.get_direct_report_count(4))",
    "    ",
    "    expected = [True, True, True, True, 2, 1, 0]",
    "    ",
    "    print(f\"Results:  {results}\")",
    "    print(f\"Expected: {expected}\")",
    "    print(f\"Match: {results == expected}\")",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()",
    "    run_example_1()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Employee Hierarchy / Org Tree - Part 1: Basic Structure",
    " * ",
    " * A production-quality implementation of an organizational chart system.",
    " * Supports O(1) employee operations using HashMap-indexed bidirectional N-ary tree.",
    " * ",
    " * @author Interview Preparation Guide",
    " * Time Complexity: O(1) for all operations",
    " * Space Complexity: O(n) for n employees",
    " */",
    "public class OrgChartSolution {",
    "    ",
    "    /**",
    "     * Represents an employee in the organizational hierarchy.",
    "     * ",
    "     * Each employee maintains bidirectional references:",
    "     * - manager: reference to their direct manager (null for CEO)",
    "     * - subordinates: list of direct reports",
    "     */",
    "    static class Employee {",
    "        private final int id;",
    "        private final String name;",
    "        private final int rating;",
    "        private Employee manager;",
    "        private final List<Employee> subordinates;",
    "        ",
    "        /**",
    "         * Create a new Employee.",
    "         * ",
    "         * @param id Unique employee identifier",
    "         * @param name Employee name",
    "         * @param rating Performance rating (1-10)",
    "         * @param manager Reference to manager, null for CEO",
    "         */",
    "        public Employee(int id, String name, int rating, Employee manager) {",
    "            this.id = id;",
    "            this.name = name;",
    "            this.rating = rating;",
    "            this.manager = manager;",
    "            this.subordinates = new ArrayList<>();",
    "        }",
    "        ",
    "        public int getId() { return id; }",
    "        public String getName() { return name; }",
    "        public int getRating() { return rating; }",
    "        public Employee getManager() { return manager; }",
    "        public List<Employee> getSubordinates() { return subordinates; }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            Integer managerId = (manager != null) ? manager.id : null;",
    "            List<Integer> subIds = new ArrayList<>();",
    "            for (Employee sub : subordinates) {",
    "                subIds.add(sub.id);",
    "            }",
    "            return String.format(",
    "                \"Employee(id=%d, name='%s', rating=%d, managerId=%s, subIds=%s)\",",
    "                id, name, rating, managerId, subIds",
    "            );",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Organizational chart management system.",
    "     * ",
    "     * Maintains a hierarchical tree structure of employees with O(1) operations.",
    "     * Uses HashMap for employee lookup and bidirectional tree for relationships.",
    "     */",
    "    static class OrgChart {",
    "        // HashMap for O(1) employee lookup by ID",
    "        private final Map<Integer, Employee> employees;",
    "        // Direct reference to root for tree-wide operations",
    "        private Employee ceo;",
    "        ",
    "        /**",
    "         * Initialize an empty organizational chart.",
    "         */",
    "        public OrgChart() {",
    "            this.employees = new HashMap<>();",
    "            this.ceo = null;",
    "        }",
    "        ",
    "        /**",
    "         * Add a new employee to the organization.",
    "         * ",
    "         * @param id Unique employee identifier",
    "         * @param name Employee name",
    "         * @param rating Performance rating (1-10)",
    "         * @param managerId ID of manager, or null for CEO",
    "         * @return true if added successfully, false if ID exists or manager not found",
    "         */",
    "        public boolean addEmployee(int id, String name, int rating, Integer managerId) {",
    "            // Validation 1: Check for duplicate ID",
    "            if (employees.containsKey(id)) {",
    "                return false;",
    "            }",
    "            ",
    "            // Handle CEO case (managerId is null)",
    "            if (managerId == null) {",
    "                // Validation 2: Only one CEO allowed",
    "                if (ceo != null) {",
    "                    return false;",
    "                }",
    "                ",
    "                // Create CEO (root node)",
    "                Employee newEmployee = new Employee(id, name, rating, null);",
    "                ceo = newEmployee;",
    "                employees.put(id, newEmployee);",
    "                return true;",
    "            }",
    "            ",
    "            // Handle non-CEO case",
    "            // Validation 3: Manager must exist",
    "            if (!employees.containsKey(managerId)) {",
    "                return false;",
    "            }",
    "            ",
    "            Employee manager = employees.get(managerId);",
    "            ",
    "            // Create new employee with manager reference",
    "            Employee newEmployee = new Employee(id, name, rating, manager);",
    "            ",
    "            // CRITICAL: Bidirectional linking",
    "            // Update manager's subordinates list",
    "            manager.getSubordinates().add(newEmployee);",
    "            ",
    "            // Store in HashMap for O(1) lookup",
    "            employees.put(id, newEmployee);",
    "            ",
    "            return true;",
    "        }",
    "        ",
    "        /**",
    "         * Get the count of direct reports for an employee.",
    "         * ",
    "         * IMPORTANT: Returns ONLY immediate children, not all descendants.",
    "         * ",
    "         * @param employeeId ID of the employee to query",
    "         * @return count of direct reports, -1 if employee not found",
    "         */",
    "        public int getDirectReportCount(int employeeId) {",
    "            // Validation: Employee must exist",
    "            if (!employees.containsKey(employeeId)) {",
    "                return -1;",
    "            }",
    "            ",
    "            Employee employee = employees.get(employeeId);",
    "            ",
    "            // O(1) - just return list size",
    "            return employee.getSubordinates().size();",
    "        }",
    "        ",
    "        /**",
    "         * Retrieve an employee by their ID.",
    "         * ",
    "         * @param employeeId ID of the employee",
    "         * @return Employee object if found, null otherwise",
    "         */",
    "        public Employee getEmployee(int employeeId) {",
    "            return employees.getOrDefault(employeeId, null);",
    "        }",
    "        ",
    "        /**",
    "         * @return the CEO (root) of the organization",
    "         */",
    "        public Employee getCeo() {",
    "            return ceo;",
    "        }",
    "        ",
    "        /**",
    "         * @return total number of employees",
    "         */",
    "        public int size() {",
    "            return employees.size();",
    "        }",
    "        ",
    "        @Override",
    "        public String toString() {",
    "            Integer ceoId = (ceo != null) ? ceo.getId() : null;",
    "            return String.format(\"OrgChart(size=%d, ceoId=%s)\", size(), ceoId);",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Demo method to test the OrgChart implementation.",
    "     */",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Employee Hierarchy / Org Tree - Demo\");",
    "        System.out.println(\"============================================================\");",
    "        System.out.println();",
    "        ",
    "        // Initialize org chart",
    "        OrgChart org = new OrgChart();",
    "        System.out.println(\"Initialized: \" + org);",
    "        System.out.println();",
    "        ",
    "        // Build organization structure",
    "        System.out.println(\"Building organization...\");",
    "        System.out.println(\"----------------------------------------\");",
    "        ",
    "        System.out.println(\"  addEmployee(1, 'CEO', 8, null) -> \" + org.addEmployee(1, \"CEO\", 8, null));",
    "        System.out.println(\"  addEmployee(2, 'VPEng', 7, 1) -> \" + org.addEmployee(2, \"VPEng\", 7, 1));",
    "        System.out.println(\"  addEmployee(3, 'VPSales', 6, 1) -> \" + org.addEmployee(3, \"VPSales\", 6, 1));",
    "        System.out.println(\"  addEmployee(4, 'EngMgr', 5, 2) -> \" + org.addEmployee(4, \"EngMgr\", 5, 2));",
    "        System.out.println(\"  addEmployee(5, 'SalesLead1', 9, 3) -> \" + org.addEmployee(5, \"SalesLead1\", 9, 3));",
    "        System.out.println(\"  addEmployee(6, 'SalesLead2', 4, 3) -> \" + org.addEmployee(6, \"SalesLead2\", 4, 3));",
    "        System.out.println(\"  addEmployee(7, 'Dev1', 6, 4) -> \" + org.addEmployee(7, \"Dev1\", 6, 4));",
    "        System.out.println(\"  addEmployee(8, 'Dev2', 8, 4) -> \" + org.addEmployee(8, \"Dev2\", 8, 4));",
    "        ",
    "        System.out.println();",
    "        System.out.println(\"Organization built: \" + org);",
    "        System.out.println();",
    "        ",
    "        // Query direct report counts",
    "        System.out.println(\"Querying direct report counts...\");",
    "        System.out.println(\"----------------------------------------\");",
    "        ",
    "        int[] queries = {1, 2, 3, 4, 5, 100};",
    "        for (int empId : queries) {",
    "            int count = org.getDirectReportCount(empId);",
    "            Employee emp = org.getEmployee(empId);",
    "            if (emp != null) {",
    "                System.out.printf(\"  getDirectReportCount(%d) -> %d  (%s's direct reports)%n\",",
    "                    empId, count, emp.getName());",
    "            } else {",
    "                System.out.printf(\"  getDirectReportCount(%d) -> %d  (employee not found)%n\",",
    "                    empId, count);",
    "            }",
    "        }",
    "        ",
    "        System.out.println();",
    "        ",
    "        // Test error cases",
    "        System.out.println(\"Testing error cases...\");",
    "        System.out.println(\"----------------------------------------\");",
    "        ",
    "        System.out.println(\"  addEmployee(1, 'Duplicate', 5, null) -> \" +",
    "            org.addEmployee(1, \"Duplicate\", 5, null) + \"  (duplicate ID)\");",
    "        System.out.println(\"  addEmployee(99, 'Orphan', 5, 100) -> \" +",
    "            org.addEmployee(99, \"Orphan\", 5, 100) + \"  (manager 100 doesn't exist)\");",
    "        System.out.println(\"  addEmployee(10, 'CEO2', 9, null) -> \" +",
    "            org.addEmployee(10, \"CEO2\", 9, null) + \"  (second CEO not allowed)\");",
    "        ",
    "        System.out.println();",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Demo complete!\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Run Example 1 from problem",
    "        System.out.println();",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Example 1: Building Basic Org Structure\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        OrgChart org2 = new OrgChart();",
    "        List<Object> results = new ArrayList<>();",
    "        ",
    "        results.add(org2.addEmployee(1, \"Alice\", 8, null));",
    "        results.add(org2.addEmployee(2, \"Bob\", 7, 1));",
    "        results.add(org2.addEmployee(3, \"Carol\", 6, 1));",
    "        results.add(org2.addEmployee(4, \"David\", 5, 2));",
    "        results.add(org2.getDirectReportCount(1));",
    "        results.add(org2.getDirectReportCount(2));",
    "        results.add(org2.getDirectReportCount(4));",
    "        ",
    "        List<Object> expected = Arrays.asList(true, true, true, true, 2, 1, 0);",
    "        ",
    "        System.out.println(\"Results:  \" + results);",
    "        System.out.println(\"Expected: \" + expected);",
    "        System.out.println(\"Match: \" + results.equals(expected));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-13",
      "section": "Module Docstring & Imports",
      "explanation": "We document the module purpose and import `typing` for type hints. `Optional` handles nullable types (manager can be None), `List` for subordinates, `Dict` for the employee HashMap."
    },
    {
      "lines": "16-74",
      "section": "Employee Class",
      "explanation": "The Employee class encapsulates all employee data. **Key design**: bidirectional references - `manager` points to parent Employee object (not just ID), `subordinates` is a list of Employee objects. This enables O(1) traversal without HashMap lookups. The `__repr__` method is crucial for debugging."
    },
    {
      "lines": "77-128",
      "section": "OrgChart Class & __init__",
      "explanation": "The OrgChart maintains two key data structures: `_employees` (HashMap for O(1) lookup by ID) and `_ceo` (direct reference to root). Using underscore prefix signals these are private. The CEO reference enables O(1) access to the tree root for operations like 'find all employees'."
    },
    {
      "lines": "130-182",
      "section": "add_employee Method",
      "explanation": "This is the core method with **three validations**: (1) No duplicate IDs, (2) Only one CEO allowed, (3) Manager must exist. **Critical detail**: The bidirectional linking on line 173 - we add the new employee to the manager's subordinates list. Forgetting this is a common bug!"
    },
    {
      "lines": "184-208",
      "section": "get_direct_report_count Method",
      "explanation": "Returns **immediate children only**, not all descendants. This is O(1) because we simply return `len(employee.subordinates)`. The docstring emphasizes 'direct reports' vs 'team size' to prevent confusion. Returns -1 for non-existent employee as specified."
    },
    {
      "lines": "210-225",
      "section": "get_employee Method",
      "explanation": "Simple HashMap lookup with O(1) complexity. Uses `dict.get(key, default)` pattern to return None if not found. In production, you might return a copy to prevent external mutation, but for interview this is fine."
    },
    {
      "lines": "227-280",
      "section": "Demo & Main Function",
      "explanation": "The demo builds the exact org structure from the problem, tests all operations, and verifies error handling. This demonstrates **testability** and shows the interviewer you verify your code."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test addEmployee for CEO first (null manager)\n2. Add one subordinate, verify direct report count = 1\n3. Test error cases: duplicate ID, missing manager, second CEO\n4. Build full tree, verify counts at each level",
    "what_to_print_or_assert": [
      "print(f\"Added {emp_id}: {result}, subordinates: {manager.subordinates}\")",
      "assert org.get_direct_report_count(1) == 2, f\"Expected 2, got {count}\"",
      "print(f\"Employee {id}: manager={emp.manager.id if emp.manager else None}\")"
    ],
    "common_failure_modes": [
      "**Forgot bidirectional linking**: Employee added to HashMap but not to manager's subordinates list",
      "**Wrong count type**: Returning total descendants instead of direct reports",
      "**Missing CEO check**: Allowing multiple employees with null manager",
      "**Off-by-one in count**: Counting the employee themselves in their own report count"
    ],
    "how_to_fix_fast": "1. Add print statements in addEmployee showing both parent and child state\n2. After each add, immediately query get_direct_report_count to verify\n3. Draw the tree on paper and trace through the code\n4. Check that every add updates BOTH the HashMap AND the parent's subordinates list"
  },
  "complexity_analysis": {
    "time": {
      "addEmployee": {
        "complexity": "O(1)",
        "explanation": "HashMap containsKey + put are O(1) amortized. List append is O(1) amortized."
      },
      "getDirectReportCount": {
        "complexity": "O(1)",
        "explanation": "HashMap get is O(1). List size() is O(1)."
      },
      "getEmployee": {
        "complexity": "O(1)",
        "explanation": "Direct HashMap lookup."
      },
      "overall": "**All operations are O(1)** - this meets the efficiency requirements."
    },
    "space": {
      "complexity": "O(n) where n = number of employees",
      "breakdown": "- **HashMap storage**: O(n) for n employee entries\n- **Employee objects**: O(n) total\n- **Subordinates lists**: O(n) total edges (each employee appears in exactly one parent's list)\n- **No additional storage**: We don't duplicate data",
      "note": "The bidirectional references don't double the space because each relationship is stored exactly twice (once in parent's subordinates, once as child's manager pointer) - this is optimal for enabling O(1) traversal in both directions."
    },
    "can_we_do_better": "**No** - O(1) is optimal for all operations. The space O(n) is also optimal since we must store n employees. The bidirectional linking trades constant extra space per employee for O(1) traversal - this is the right tradeoff."
  },
  "dry_run": {
    "example": "addEmployee(1, 'Alice', 8, null), addEmployee(2, 'Bob', 7, 1), addEmployee(3, 'Carol', 6, 1), addEmployee(4, 'David', 5, 2), getDirectReportCount(1), getDirectReportCount(2), getDirectReportCount(4)",
    "trace_table": "| Step | Operation | Validation | employees HashMap | Alice.subordinates | Bob.subordinates | Result |\n|------|-----------|------------|-------------------|-------------------|-----------------|--------|\n| 1 | OrgChart() | - | {} | - | - | initialized |\n| 2 | addEmployee(1, 'Alice', 8, null) | ID 1 not in map \u2713, managerId=null \u2192 CEO | {1: Alice} | [] | - | **true** |\n| 3 | addEmployee(2, 'Bob', 7, 1) | ID 2 not in map \u2713, manager 1 exists \u2713 | {1: Alice, 2: Bob} | [\u2192Bob] | [] | **true** |\n| 4 | addEmployee(3, 'Carol', 6, 1) | ID 3 not in map \u2713, manager 1 exists \u2713 | {..., 3: Carol} | [\u2192Bob, \u2192Carol] | [] | **true** |\n| 5 | addEmployee(4, 'David', 5, 2) | ID 4 not in map \u2713, manager 2 exists \u2713 | {..., 4: David} | [\u2192Bob, \u2192Carol] | [\u2192David] | **true** |\n| 6 | getDirectReportCount(1) | ID 1 exists \u2713 | - | [\u2192Bob, \u2192Carol] | - | **2** |\n| 7 | getDirectReportCount(2) | ID 2 exists \u2713 | - | - | [\u2192David] | **1** |\n| 8 | getDirectReportCount(4) | ID 4 exists \u2713 | - | - | David.subs=[] | **0** |",
    "final_answer": "[true, true, true, true, 2, 1, 0]"
  },
  "test_cases": [
    {
      "name": "Basic - Single employee (CEO only)",
      "category": "Edge Case",
      "input": "addEmployee(1, 'CEO', 8, null), getDirectReportCount(1)",
      "expected": "[true, 0]",
      "explanation": "CEO with no subordinates has 0 direct reports"
    },
    {
      "name": "Linear chain of 3 employees",
      "category": "Happy Path",
      "input": "add(1, CEO, null), add(2, VP, 1), add(3, Mgr, 2), count(1), count(2), count(3)",
      "expected": "[true, true, true, 1, 1, 0]",
      "explanation": "Each non-leaf has exactly 1 direct report"
    },
    {
      "name": "Wide tree - CEO with many direct reports",
      "category": "Happy Path",
      "input": "add(1, CEO, null), add(2, VP1, 1), add(3, VP2, 1), add(4, VP3, 1), count(1)",
      "expected": "[true, true, true, true, 3]",
      "explanation": "CEO has 3 direct reports"
    },
    {
      "name": "Duplicate employee ID",
      "category": "Error Handling",
      "input": "add(1, CEO, null), add(1, Duplicate, null)",
      "expected": "[true, false]",
      "explanation": "Cannot add employee with existing ID"
    },
    {
      "name": "Non-existent manager",
      "category": "Error Handling",
      "input": "add(1, CEO, null), add(2, Orphan, 99)",
      "expected": "[true, false]",
      "explanation": "Manager ID 99 doesn't exist"
    },
    {
      "name": "Second CEO attempt",
      "category": "Error Handling",
      "input": "add(1, CEO1, null), add(2, CEO2, null)",
      "expected": "[true, false]",
      "explanation": "Only one CEO (null manager) allowed"
    },
    {
      "name": "Query non-existent employee",
      "category": "Error Handling",
      "input": "add(1, CEO, null), count(99), getEmployee(99)",
      "expected": "[true, -1, null]",
      "explanation": "Return -1 for count, null for getEmployee when not found"
    },
    {
      "name": "Full example from problem",
      "category": "Integration",
      "input": "Build 8-employee tree from problem, query counts for 1, 3, 5",
      "expected": "[...8 adds true..., 2, 2, 0]",
      "explanation": "CEO has 2, VPSales has 2, Lead has 0 direct reports"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Counting all subordinates instead of direct reports",
      "why_wrong": "getDirectReportCount should return ONLY immediate children, not the full subtree",
      "correct_approach": "Return len(employee.subordinates), not a recursive count",
      "code_wrong": "def get_direct_report_count(self, id):\n    def count_all(emp):\n        return 1 + sum(count_all(s) for s in emp.subordinates)\n    return count_all(self.employees[id]) - 1  # WRONG!",
      "code_correct": "def get_direct_report_count(self, id):\n    return len(self.employees[id].subordinates)  # CORRECT!"
    },
    {
      "mistake": "Forgetting bidirectional linking",
      "why_wrong": "If you only set child.manager but don't add child to parent.subordinates, getDirectReportCount will always return 0",
      "correct_approach": "Always update BOTH directions: set child's manager AND add child to parent's list",
      "code_wrong": "new_emp = Employee(id, name, rating, manager)\nself.employees[id] = new_emp\n# FORGOT: manager.subordinates.append(new_emp)",
      "code_correct": "new_emp = Employee(id, name, rating, manager)\nmanager.subordinates.append(new_emp)  # Don't forget!\nself.employees[id] = new_emp"
    },
    {
      "mistake": "Not handling non-existent employee in queries",
      "why_wrong": "Calling methods on None or accessing missing HashMap keys causes errors",
      "correct_approach": "Check if employee exists before accessing, return -1 or null as specified",
      "code_wrong": "def get_direct_report_count(self, id):\n    return len(self.employees[id].subordinates)  # KeyError if not found",
      "code_correct": "def get_direct_report_count(self, id):\n    if id not in self.employees:\n        return -1\n    return len(self.employees[id].subordinates)"
    },
    {
      "mistake": "Allowing multiple CEOs",
      "why_wrong": "The org should have exactly one root (employee with null manager)",
      "correct_approach": "Check if CEO already exists when manager_id is None",
      "code_wrong": "if manager_id is None:\n    new_emp = Employee(id, name, rating, None)\n    self._ceo = new_emp  # Overwrites previous CEO!",
      "code_correct": "if manager_id is None:\n    if self._ceo is not None:\n        return False  # Reject second CEO\n    new_emp = Employee(id, name, rating, None)\n    self._ceo = new_emp"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. I can see this is about building an organizational hierarchy - essentially an N-ary tree with HashMap indexing. Before I start, let me clarify a few things...",
    "clarifying_questions_to_ask": [
      "Are employee IDs globally unique, or could the same ID be reused after an employee leaves?",
      "Should getDirectReportCount return ONLY immediate children, or all descendants?",
      "Is there a maximum depth to the org tree I should consider?",
      "Will there be concurrent access, or is single-threaded fine?",
      "For getEmployee, should I return the actual object or a defensive copy?"
    ],
    "what_to_mention_proactively": [
      "I'll use a HashMap for O(1) employee lookup by ID",
      "I'll maintain bidirectional references - each employee knows their manager AND subordinates",
      "This enables O(1) for all Part 1 operations and sets up efficient DFS for Part 2",
      "Let me draw a quick diagram of the data structure"
    ],
    "communication_during_coding": [
      "I'm starting with the Employee class - it needs id, name, rating, manager reference, and subordinates list",
      "Now the OrgChart class - I need a HashMap and a CEO reference",
      "In addEmployee, I'm doing three validations: no duplicate ID, manager exists, only one CEO",
      "Here's the critical part - bidirectional linking - I add the new employee to manager's subordinates list"
    ],
    "if_stuck": [
      "Let me step back and think about what data structure represents a hierarchy - that's a tree",
      "If I need O(1) lookup by ID, I need a HashMap in addition to the tree",
      "Let me draw out the example and trace through my code"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Explain approach, draw diagram | 10-25min: Code Employee and OrgChart | 25-30min: Test with example, handle edge cases | 30-45min: Part 2 follow-up"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap-Indexed Tree with Bidirectional References",
    "indicators": [
      "Hierarchical data with parent-child relationships",
      "O(1) lookup by unique identifier required",
      "Need to traverse both up (to root) and down (to descendants)",
      "Aggregate calculations over subtrees (Part 2)"
    ],
    "similar_problems": [
      "**LC 690 - Employee Importance**: Sum of importance values in subtree - DFS from node",
      "**LC 559 - Maximum Depth of N-ary Tree**: DFS to find max depth",
      "**LC 339 - Nested List Weight Sum**: DFS with depth tracking",
      "**LC 1490 - Clone N-ary Tree**: Tree traversal and construction",
      "**File System Design**: Similar hierarchy with paths instead of IDs"
    ],
    "template": "1. Create Node class with parent + children references\n2. Create Manager class with HashMap<id, Node> for O(1) lookup\n3. On insert: validate, create node, link bidirectionally\n4. On query: HashMap lookup, return property or traverse subtree"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Part 2: Best Performing Team** asks for getTeamSize() and getBestPerformingTeam(). This requires DFS from each node to calculate team average rating. Your bidirectional structure enables this - just DFS from any employee node and aggregate ratings. Consider caching team metrics if queries are frequent.",
    "part_3_hint": "**Part 3: Generic Aggregation & Filtering** generalizes Part 2. Instead of hardcoded 'average rating', you pass aggregation functions. This is the Strategy/Visitor pattern - your tree traversal stays the same, only the aggregation logic changes.",
    "data_structure_evolution": "Part 1: HashMap + Tree \u2192 Part 2: Add DFS for team metrics \u2192 Part 3: Add generic aggregator interface. The core structure doesn't change - you just add methods that traverse it differently."
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. I see this is about building an organizational hierarchy - essentially a tree structure where employees report to managers. Before I start coding, let me clarify a few things and share my approach.",
    "after_clarification": "Great, so to summarize: I need to build an N-ary tree with O(1) operations. I'll use a HashMap for fast lookups and bidirectional references for efficient traversal. Does that approach sound reasonable before I start coding?",
    "while_coding": [
      "I'm creating the Employee class first with all required fields...",
      "The key here is bidirectional references - manager AND subordinates...",
      "Now addEmployee - I need three validations: no duplicate, manager exists, one CEO...",
      "This is the critical line - adding to manager's subordinates list for bidirectional linking..."
    ],
    "after_coding": "Let me trace through Example 1 to verify: we add Alice as CEO, then Bob and Carol report to her, then David reports to Bob. Alice should have 2 direct reports, Bob should have 1, David should have 0. Let me trace...",
    "when_stuck_verbatim": "Let me pause and think about this. The key constraint is O(1) operations. To get O(1) lookup, I need a HashMap. To get O(1) count, I need to store the subordinates list directly on each employee.",
    "after_mistake": "Oh, I see the issue - I forgot to add the new employee to the manager's subordinates list. Let me fix that. This is the bidirectional linking that's critical for the structure to work.",
    "before_moving_on": "So Part 1 is complete. All operations are O(1) using HashMap indexing. Space is O(n) for n employees. The bidirectional tree structure sets us up well for Part 2 where we'll need DFS for team calculations. Ready for the follow-up?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem Decomposition**: Does candidate break down into Employee class + OrgChart class?",
      "**Data Structure Choice**: Does candidate recognize need for HashMap + Tree combination?",
      "**Edge Case Thinking**: Does candidate consider duplicate IDs, missing managers, second CEO?",
      "**Code Quality**: Clean variable names, proper encapsulation, docstrings?",
      "**Communication**: Does candidate explain WHY, not just WHAT?",
      "**Testing Instinct**: Does candidate trace through examples after coding?"
    ],
    "bonus_points": [
      "Drawing the data structure diagram before coding",
      "Mentioning bidirectional references and why they're needed",
      "Considering thread safety (even if not implementing)",
      "Anticipating Part 2 requirements in design",
      "Writing clean, production-quality code with docstrings"
    ],
    "red_flags": [
      "Jumping to code without understanding requirements",
      "Using flat list instead of HashMap (O(n) lookups)",
      "Confusing direct reports with total subordinates",
      "Forgetting bidirectional linking",
      "Not testing after coding",
      "Silent for extended periods"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize this as an N-ary tree problem, explain the HashMap + bidirectional tree approach clearly, write clean code with proper OOP design, proactively consider edge cases, and trace through examples to verify correctness. They treat the interviewer as a collaborator and think out loud throughout."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions, confirm 'direct reports' means immediate children only",
    "by_10_min": "Explain approach (HashMap + bidirectional tree), draw quick diagram, get interviewer buy-in",
    "by_20_min": "Employee class done, OrgChart with addEmployee nearly complete",
    "by_25_min": "All methods implemented, basic testing started",
    "by_30_min": "Edge cases handled, dry run complete, complexity discussed, ready for Part 2",
    "warning_signs": "If still asking questions at 10 min, you're overthinking. If still coding addEmployee at 25 min, speed up. Focus on core logic first, polish later."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see an issue here - I forgot to add the employee to the manager's subordinates list. Let me fix that.' Fix it, briefly explain why it was wrong, and move on. Bugs are expected; graceful recovery is evaluated.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for getting a default value from a dict, but conceptually I need to return None if the key doesn't exist. Let me write it as dict.get(key, None).' This is acceptable.",
    "when_approach_is_wrong": "Say: 'Actually, I realize using a flat list won't give O(1) lookup. Let me reconsider - I should use a HashMap.' Pivot cleanly and explain why the new approach is better.",
    "when_completely_stuck": "Say: 'I'm stuck on how to efficiently get direct report count. Could you give me a hint about the data structure?' Asking for help shows self-awareness and is better than spinning.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on completing addEmployee and getDirectReportCount correctly. I'd add getEmployee similarly given more time.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically - let AI handle boilerplate while YOU drive the algorithm.",
    "what_to_do": [
      "Use AI to generate class structure and boilerplate",
      "Let AI autocomplete obvious patterns like HashMap operations",
      "Use AI to generate test cases after you've written the code",
      "Use for syntax you forgot (like typing imports)"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for solution",
      "Don't accept AI suggestions without understanding them",
      "Don't let AI drive - YOU decide the approach, AI assists",
      "Don't rely on AI for the core algorithmic insight"
    ],
    "how_to_demonstrate_understanding": "If AI suggests something, explain WHY it works. 'I see Copilot suggested using a HashMap here - that's because we need O(1) lookup by ID.' The interviewer evaluates YOUR understanding.",
    "expectation_adjustment": "With AI, you're expected to complete more parts faster. If you can't finish Part 1 with AI assistance, that's concerning."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing the tree structure and data flow diagram before coding",
      "Immediately recognizing the HashMap + bidirectional tree pattern",
      "Mentioning that this design enables efficient DFS for Part 2",
      "Writing docstrings with examples in code",
      "Proactively discussing what you'd add for production (logging, validation)"
    ],
    "subtle_signals_of_experience": [
      "Using underscore prefix for private attributes in Python",
      "Considering return type for getEmployee (copy vs reference)",
      "Mentioning thread safety even if not implementing",
      "Using dict.get(key, default) instead of checking and indexing",
      "Testing incrementally, not just at the end"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Staying silent for more than 30 seconds without explaining what you're thinking",
      "Getting defensive when interviewer points out an issue",
      "Blaming the problem for being ambiguous instead of asking clarifying questions",
      "Rushing to code without confirming understanding"
    ],
    "technical": [
      "Using O(n) linear search when O(1) HashMap lookup is required",
      "Storing only IDs instead of references (requires extra lookups)",
      "Forgetting to maintain bidirectional consistency",
      "Returning 0 instead of -1 for non-existent employee"
    ],
    "communication": [
      "Using jargon without explaining ('I'll use a trie' without saying why)",
      "Going too deep into irrelevant tangents (thread safety when not asked)",
      "Not summarizing your approach before coding",
      "Not asking if interviewer wants to see tests"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I implement all three methods: addEmployee, getDirectReportCount, getEmployee?",
      "Did I handle all error cases: duplicate ID, missing manager, second CEO, non-existent query?",
      "Did I trace through at least one example from the problem?",
      "Did I explain time complexity (O(1) for all) and space complexity (O(n))?",
      "Is my code readable with meaningful variable names?",
      "Did I mention bidirectional linking and why it's important?"
    ],
    "quick_code_review": [
      "No magic numbers (all constraints from problem)",
      "Consistent naming (snake_case in Python, camelCase in Java)",
      "Proper indentation and spacing",
      "No unused variables or imports",
      "Error handling with specified return values (-1, null, false)"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation**: Verify rating is 1-10, name is non-empty, ID is positive",
      "**Logging**: Log employee additions and queries for debugging",
      "**Thread safety**: Add locks if concurrent access is possible",
      "**Immutability**: Return copies from getEmployee to prevent external mutation",
      "**Persistence**: Add serialization/deserialization for database storage",
      "**Events**: Emit events on org changes for downstream systems"
    ],
    "why_not_in_interview": "Keep interview code focused on core algorithm. Adding all production features would take too long and distract from the main problem. Mention these verbally to show senior thinking.",
    "how_to_mention": "Say: 'In production, I'd also add input validation, logging, and possibly thread safety if this is accessed concurrently. But for this interview, I'll focus on the core logic.'"
  },
  "generated_at": "2026-01-18T18:34:44.278863",
  "_meta": {
    "problem_id": "employee_hierarchy_org_tree",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}