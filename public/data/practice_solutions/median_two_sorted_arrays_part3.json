{
  "problem_title": "Median of Two Sorted Arrays - Part 3: Median of K Sorted Arrays",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Instead of finding the k-th element in exactly 2 sorted arrays, we now need to find the **median** across **k sorted arrays**. The partition-based binary search approach from Part 2 becomes impractical because partitioning k arrays simultaneously has exponential complexity. We need a fundamentally different strategy: either (1) K-way merge using a min-heap, or (2) Binary search on the answer value space.",
    "new_requirements": [
      "Handle arbitrary number (k) of sorted arrays instead of just 2",
      "Return the median (not k-th element) - requires handling odd/even total count",
      "Must efficiently merge or query across all k arrays simultaneously"
    ],
    "new_constraints": [
      "Any of the k arrays may be empty",
      "k can be large, making O(k^2) approaches infeasible",
      "Total elements N can be very large"
    ],
    "key_insight": "The **min-heap** approach gives us the next smallest element in O(log k) time, allowing us to efficiently find the median position. Alternatively, **binary search on value** lets us count elements \u2264 a threshold across all arrays in O(k log m) time, enabling O(k log(max-min) log m) solution."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Handle k sorted arrays",
        "how_met": "Min-heap tracks (value, array_idx, elem_idx) tuples for efficient k-way merge",
        "gotchas": [
          "Empty arrays must be filtered out before adding to heap"
        ]
      },
      {
        "requirement": "Return correct median",
        "how_met": "Extract total//2 + 1 elements, handle odd/even cases separately",
        "gotchas": [
          "Off-by-one errors in counting positions",
          "Even case needs TWO middle elements"
        ]
      },
      {
        "requirement": "Efficient time complexity",
        "how_met": "O(N log k) using heap, where N is total elements",
        "gotchas": [
          "Don't merge all arrays first (O(N log N))",
          "Each heap operation is O(log k), not O(1)"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "findMedianOfKArrays (heap)",
        "target": "O(N log k)",
        "achieved": "O((N/2) log k)",
        "why": "Extract ~N/2 elements, each extraction/insertion is O(log k)"
      },
      {
        "operation": "findMedianOfKArrays (binary search)",
        "target": "O(k log(range) log(maxLen))",
        "achieved": "O(k log(max-min) log m)",
        "why": "Binary search on value range, count via binary search in each array"
      }
    ],
    "non_goals": [
      "Modifying the input arrays",
      "Supporting streaming/dynamic updates",
      "Handling unsorted arrays"
    ]
  },
  "assumptions": [
    "Arrays contain integers (for binary search on value approach)",
    "Arrays are already sorted in ascending order",
    "At least one array is non-empty (otherwise return 0.0)",
    "No duplicate handling required beyond standard sorted array behavior"
  ],
  "tradeoffs": [
    {
      "decision": "Min-Heap vs Binary Search on Value",
      "chosen": "Min-Heap (primary solution)",
      "why": "Simpler to implement correctly, works with any comparable values, handles all edge cases naturally",
      "alternative": "Binary Search on Value",
      "when_to_switch": "When arrays are very large but value range is small, or when we need to answer multiple median queries on same arrays"
    },
    {
      "decision": "Early termination vs Full merge",
      "chosen": "Early termination at median position",
      "why": "Only extract N/2 elements instead of N, cutting time in half",
      "alternative": "Full merge then index",
      "when_to_switch": "Never - full merge wastes time and space"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Method signature: findMedianOfKArrays(int[][] arrays)",
      "Return type: double for median",
      "Handling of empty arrays"
    ],
    "what_to_change": [
      "Introduced heap data structure for k-way merge",
      "New helper methods for counting elements"
    ],
    "interfaces_and_boundaries": "The solution is self-contained. For Part 4 (if adding streaming updates), we'd need to change from one-time computation to maintaining a data structure",
    "invariants": [
      "Heap always contains at most k elements (one per array)",
      "Elements extracted from heap are in sorted order",
      "Count of extracted elements always matches expected position"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 2): Two Arrays Only\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nnums1: [1, 3, 5, 7]\nnums2: [2, 4, 6, 8]\n        \u2193\n   Binary search on partition\n        \u2193\n   O(log(min(m,n)))\n\nAFTER (Part 3): K Arrays\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\narr0: [1, 5, 9]    \u2500\u2500\u2510\narr1: [2, 6, 10]   \u2500\u2500\u253c\u2500\u2500\u25b6 Min-Heap \u2500\u2500\u25b6 Extract median\narr2: [3, 7, 11]   \u2500\u2500\u2518    (size k)\n\nHeap maintains smallest from each array\nExtract N/2 + 1 times to find median\n```",
    "algorithm_flow": "```\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551           K-WAY MERGE USING MIN-HEAP                         \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551                                                              \u2551\n\u2551  Arrays:  [1,5,9]  [2,6,10]  [3,7,11]                       \u2551\n\u2551              \u2502         \u2502          \u2502                          \u2551\n\u2551              \u25bc         \u25bc          \u25bc                          \u2551\n\u2551         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                      \u2551\n\u2551  Init:  \u2502   Min-Heap: [1, 2, 3]       \u2502 (first elements)    \u2551\n\u2551         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2551\n\u2551                                                              \u2551\n\u2551  Extract 1: pop 1, push 5 \u2192 Heap: [2, 3, 5]                 \u2551\n\u2551  Extract 2: pop 2, push 6 \u2192 Heap: [3, 5, 6]                 \u2551\n\u2551  Extract 3: pop 3, push 7 \u2192 Heap: [5, 6, 7]                 \u2551\n\u2551  Extract 4: pop 5, push 9 \u2192 Heap: [6, 7, 9]                 \u2551\n\u2551  Extract 5: pop 6 \u2190 This is median! (9 elements, pos 4)     \u2551\n\u2551                                                              \u2551\n\u2551  Total=9 (odd) \u2192 Median = 6                                  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n```"
  },
  "approaches": [
    {
      "name": "Naive: Merge All Then Sort",
      "description": "Concatenate all arrays into one, sort, find median",
      "time_complexity": "O(N log N)",
      "space_complexity": "O(N)",
      "why_not_optimal": "Doesn't leverage that arrays are already sorted. Wasteful when k is small."
    },
    {
      "name": "K-way Merge with Min-Heap (Optimal for General Case)",
      "description": "Use min-heap to efficiently find the next smallest element across all k arrays. Extract elements until reaching median position.",
      "time_complexity": "O(N/2 * log k) \u2248 O(N log k)",
      "space_complexity": "O(k)",
      "key_insight": "Min-heap always gives us the globally smallest remaining element in O(log k) time"
    },
    {
      "name": "Binary Search on Value Space",
      "description": "Binary search on possible median values. For each candidate, count elements \u2264 candidate using binary search in each array.",
      "time_complexity": "O(k * log(max-min) * log(maxArrayLen))",
      "space_complexity": "O(1)",
      "key_insight": "Good when value range is small but total elements are huge"
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: K-way Merge with Min-Heap\n\n### Core Idea\nWe maintain a **min-heap** of size at most k, where each entry represents the \"frontier\" of one array - the smallest element not yet extracted.\n\n### Algorithm\n1. **Initialize**: Push the first element of each non-empty array into the heap as `(value, array_index, element_index)`\n2. **Extract**: Pop the minimum element from heap. This is the next element in the merged sorted order.\n3. **Replenish**: Push the next element from the same array (if exists) into the heap\n4. **Repeat**: Continue until we've extracted `total // 2 + 1` elements\n5. **Return**: For odd total, return the last extracted element. For even total, return average of last two.\n\n### Why This Works\n- The heap invariant guarantees we always extract the **globally smallest** remaining element\n- Each array contributes at most one element to the heap at any time \u2192 O(k) space\n- Each extraction and insertion is O(log k)\n- We only extract ~N/2 elements, not all N\n\n### Complexity\n- **Time**: O((N/2) \u00d7 log k) = O(N log k)\n- **Space**: O(k) for the heap",
    "data_structures": [
      {
        "structure": "Min-Heap / Priority Queue",
        "purpose": "Efficiently track the smallest element across k arrays, enabling O(log k) extraction of global minimum"
      }
    ],
    "algorithm_steps": [
      "Step 1: Filter out empty arrays and calculate total element count",
      "Step 2: Initialize min-heap with (value, array_idx, elem_idx) for first element of each array",
      "Step 3: Loop total//2 + 1 times, extracting minimum and pushing next from same array",
      "Step 4: Track previous and current values during extraction",
      "Step 5: Return curr_val for odd total, (prev_val + curr_val)/2 for even total"
    ]
  },
  "solution_python_lines": [
    "import heapq",
    "from typing import List, Tuple",
    "",
    "",
    "class MedianOfKSortedArrays:",
    "    \"\"\"",
    "    Part 3: Find the median of K sorted arrays.",
    "    ",
    "    Two approaches implemented:",
    "    1. K-way merge using Min-Heap: O(N log k) time, O(k) space",
    "    2. Binary search on value: O(k log(range) log(maxLen)) time, O(1) space",
    "    \"\"\"",
    "    ",
    "    def findMedianOfKArrays(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"",
    "        Find median using k-way merge with min-heap.",
    "        ",
    "        Args:",
    "            arrays: List of k sorted arrays",
    "            ",
    "        Returns:",
    "            Median value as float",
    "            ",
    "        Time Complexity: O(N log k) where N is total elements",
    "        Space Complexity: O(k) for the heap",
    "        \"\"\"",
    "        # Filter out empty arrays",
    "        arrays = [arr for arr in arrays if arr]",
    "        if not arrays:",
    "            return 0.0",
    "        ",
    "        total = sum(len(arr) for arr in arrays)",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        # Min-heap: (value, array_index, element_index)",
    "        heap: List[Tuple[int, int, int]] = []",
    "        for i, arr in enumerate(arrays):",
    "            heapq.heappush(heap, (arr[0], i, 0))",
    "        ",
    "        prev_val: int = 0",
    "        curr_val: int = 0",
    "        ",
    "        # Extract total // 2 + 1 elements to reach median",
    "        for count in range(total // 2 + 1):",
    "            prev_val = curr_val",
    "            curr_val, arr_idx, elem_idx = heapq.heappop(heap)",
    "            ",
    "            # Push next element from same array if available",
    "            if elem_idx + 1 < len(arrays[arr_idx]):",
    "                next_val = arrays[arr_idx][elem_idx + 1]",
    "                heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))",
    "        ",
    "        # Return median based on odd/even total",
    "        if total % 2 == 1:",
    "            return float(curr_val)",
    "        else:",
    "            return (prev_val + curr_val) / 2.0",
    "    ",
    "    def findMedianOfKArrays_binarySearch(self, arrays: List[List[int]]) -> float:",
    "        \"\"\"",
    "        Alternative approach: Binary search on value space.",
    "        ",
    "        Useful when value range is small but total elements are huge.",
    "        ",
    "        Time Complexity: O(k * log(max-min) * log(maxLen))",
    "        Space Complexity: O(1)",
    "        \"\"\"",
    "        import bisect",
    "        ",
    "        arrays = [arr for arr in arrays if arr]",
    "        if not arrays:",
    "            return 0.0",
    "        ",
    "        total = sum(len(arr) for arr in arrays)",
    "        if total == 0:",
    "            return 0.0",
    "        ",
    "        # Find min and max values across all arrays",
    "        min_val = min(arr[0] for arr in arrays)",
    "        max_val = max(arr[-1] for arr in arrays)",
    "        ",
    "        def count_less_equal(val: int) -> int:",
    "            \"\"\"Count elements <= val across all arrays using binary search.\"\"\"",
    "            count = 0",
    "            for arr in arrays:",
    "                count += bisect.bisect_right(arr, val)",
    "            return count",
    "        ",
    "        def find_kth(k: int) -> int:",
    "            \"\"\"Find k-th smallest element (1-indexed) using binary search.\"\"\"",
    "            lo, hi = min_val, max_val",
    "            while lo < hi:",
    "                mid = lo + (hi - lo) // 2",
    "                if count_less_equal(mid) < k:",
    "                    lo = mid + 1",
    "                else:",
    "                    hi = mid",
    "            return lo",
    "        ",
    "        # Find median position(s)",
    "        if total % 2 == 1:",
    "            return float(find_kth(total // 2 + 1))",
    "        else:",
    "            left = find_kth(total // 2)",
    "            right = find_kth(total // 2 + 1)",
    "            return (left + right) / 2.0",
    "",
    "",
    "def main():",
    "    \"\"\"Test the MedianOfKSortedArrays solution.\"\"\"",
    "    solution = MedianOfKSortedArrays()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"Part 3: Median of K Sorted Arrays\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Test Case 1: Odd total elements",
    "    arrays1 = [[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
    "    print(\"\\nTest 1: Odd total elements\")",
    "    print(f\"Arrays: {arrays1}\")",
    "    print(f\"Merged sorted: [1, 2, 3, 5, 6, 7, 9, 10, 11]\")",
    "    result1 = solution.findMedianOfKArrays(arrays1)",
    "    print(f\"Median (heap): {result1}\")",
    "    result1_bs = solution.findMedianOfKArrays_binarySearch(arrays1)",
    "    print(f\"Median (binary search): {result1_bs}\")",
    "    assert result1 == 6.0, f\"Expected 6.0, got {result1}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    # Test Case 2: Even total elements",
    "    arrays2 = [[1, 2], [3, 4], [5, 6], [7, 8]]",
    "    print(\"\\nTest 2: Even total elements\")",
    "    print(f\"Arrays: {arrays2}\")",
    "    print(f\"Merged sorted: [1, 2, 3, 4, 5, 6, 7, 8]\")",
    "    result2 = solution.findMedianOfKArrays(arrays2)",
    "    print(f\"Median (heap): {result2}\")",
    "    result2_bs = solution.findMedianOfKArrays_binarySearch(arrays2)",
    "    print(f\"Median (binary search): {result2_bs}\")",
    "    assert result2 == 4.5, f\"Expected 4.5, got {result2}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    # Test Case 3: Arrays with different sizes",
    "    arrays3 = [[1, 2, 3], [4], [5, 6]]",
    "    print(\"\\nTest 3: Different sized arrays\")",
    "    print(f\"Arrays: {arrays3}\")",
    "    print(f\"Merged sorted: [1, 2, 3, 4, 5, 6]\")",
    "    result3 = solution.findMedianOfKArrays(arrays3)",
    "    print(f\"Median: {result3}\")",
    "    assert result3 == 3.5, f\"Expected 3.5, got {result3}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    # Test Case 4: Single array",
    "    arrays4 = [[1, 2, 3, 4, 5]]",
    "    print(\"\\nTest 4: Single array\")",
    "    print(f\"Arrays: {arrays4}\")",
    "    result4 = solution.findMedianOfKArrays(arrays4)",
    "    print(f\"Median: {result4}\")",
    "    assert result4 == 3.0, f\"Expected 3.0, got {result4}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    # Test Case 5: Empty arrays mixed in",
    "    arrays5 = [[], [1, 3], [], [2, 4], []]",
    "    print(\"\\nTest 5: Empty arrays mixed in\")",
    "    print(f\"Arrays: {arrays5}\")",
    "    result5 = solution.findMedianOfKArrays(arrays5)",
    "    print(f\"Median: {result5}\")",
    "    assert result5 == 2.5, f\"Expected 2.5, got {result5}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    # Test Case 6: Single element per array",
    "    arrays6 = [[5], [1], [3], [7], [9]]",
    "    print(\"\\nTest 6: Single element per array\")",
    "    print(f\"Arrays: {arrays6}\")",
    "    print(f\"Merged sorted: [1, 3, 5, 7, 9]\")",
    "    result6 = solution.findMedianOfKArrays(arrays6)",
    "    print(f\"Median: {result6}\")",
    "    assert result6 == 5.0, f\"Expected 5.0, got {result6}\"",
    "    print(\"\u2713 Passed\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All tests passed! \u2713\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Part 3: Find the median of K sorted arrays.",
    " * ",
    " * Two approaches implemented:",
    " * 1. K-way merge using Min-Heap: O(N log k) time, O(k) space",
    " * 2. Binary search on value: O(k log(range) log(maxLen)) time, O(1) space",
    " */",
    "public class MedianOfKSortedArrays {",
    "    ",
    "    /**",
    "     * Find median using k-way merge with min-heap.",
    "     * ",
    "     * @param arrays List of k sorted arrays",
    "     * @return Median value as double",
    "     * ",
    "     * Time Complexity: O(N log k) where N is total elements",
    "     * Space Complexity: O(k) for the heap",
    "     */",
    "    public double findMedianOfKArrays(int[][] arrays) {",
    "        // Filter out null and empty arrays",
    "        List<int[]> nonEmpty = new ArrayList<>();",
    "        int total = 0;",
    "        for (int[] arr : arrays) {",
    "            if (arr != null && arr.length > 0) {",
    "                nonEmpty.add(arr);",
    "                total += arr.length;",
    "            }",
    "        }",
    "        ",
    "        if (total == 0) return 0.0;",
    "        ",
    "        // Min-heap: [value, array_index, element_index]",
    "        PriorityQueue<int[]> heap = new PriorityQueue<>(",
    "            (a, b) -> Integer.compare(a[0], b[0])",
    "        );",
    "        ",
    "        // Initialize heap with first element of each array",
    "        for (int i = 0; i < nonEmpty.size(); i++) {",
    "            heap.offer(new int[]{nonEmpty.get(i)[0], i, 0});",
    "        }",
    "        ",
    "        int prevVal = 0;",
    "        int currVal = 0;",
    "        ",
    "        // Extract total/2 + 1 elements to reach median",
    "        for (int count = 0; count <= total / 2; count++) {",
    "            prevVal = currVal;",
    "            int[] top = heap.poll();",
    "            currVal = top[0];",
    "            int arrIdx = top[1];",
    "            int elemIdx = top[2];",
    "            ",
    "            // Push next element from same array if available",
    "            if (elemIdx + 1 < nonEmpty.get(arrIdx).length) {",
    "                int nextVal = nonEmpty.get(arrIdx)[elemIdx + 1];",
    "                heap.offer(new int[]{nextVal, arrIdx, elemIdx + 1});",
    "            }",
    "        }",
    "        ",
    "        // Return median based on odd/even total",
    "        if (total % 2 == 1) {",
    "            return (double) currVal;",
    "        } else {",
    "            return (prevVal + currVal) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    /**",
    "     * Alternative approach: Binary search on value space.",
    "     * Useful when value range is small but total elements are huge.",
    "     */",
    "    public double findMedianOfKArrays_binarySearch(int[][] arrays) {",
    "        List<int[]> nonEmpty = new ArrayList<>();",
    "        int total = 0;",
    "        int minVal = Integer.MAX_VALUE;",
    "        int maxVal = Integer.MIN_VALUE;",
    "        ",
    "        for (int[] arr : arrays) {",
    "            if (arr != null && arr.length > 0) {",
    "                nonEmpty.add(arr);",
    "                total += arr.length;",
    "                minVal = Math.min(minVal, arr[0]);",
    "                maxVal = Math.max(maxVal, arr[arr.length - 1]);",
    "            }",
    "        }",
    "        ",
    "        if (total == 0) return 0.0;",
    "        ",
    "        final List<int[]> finalArrays = nonEmpty;",
    "        ",
    "        if (total % 2 == 1) {",
    "            return (double) findKth(finalArrays, minVal, maxVal, total / 2 + 1);",
    "        } else {",
    "            int left = findKth(finalArrays, minVal, maxVal, total / 2);",
    "            int right = findKth(finalArrays, minVal, maxVal, total / 2 + 1);",
    "            return (left + right) / 2.0;",
    "        }",
    "    }",
    "    ",
    "    private int findKth(List<int[]> arrays, int lo, int hi, int k) {",
    "        while (lo < hi) {",
    "            int mid = lo + (hi - lo) / 2;",
    "            if (countLessEqual(arrays, mid) < k) {",
    "                lo = mid + 1;",
    "            } else {",
    "                hi = mid;",
    "            }",
    "        }",
    "        return lo;",
    "    }",
    "    ",
    "    private int countLessEqual(List<int[]> arrays, int val) {",
    "        int count = 0;",
    "        for (int[] arr : arrays) {",
    "            count += upperBound(arr, val);",
    "        }",
    "        return count;",
    "    }",
    "    ",
    "    private int upperBound(int[] arr, int val) {",
    "        int lo = 0, hi = arr.length;",
    "        while (lo < hi) {",
    "            int mid = lo + (hi - lo) / 2;",
    "            if (arr[mid] <= val) {",
    "                lo = mid + 1;",
    "            } else {",
    "                hi = mid;",
    "            }",
    "        }",
    "        return lo;",
    "    }",
    "    ",
    "    public static void main(String[] args) {",
    "        MedianOfKSortedArrays solution = new MedianOfKSortedArrays();",
    "        ",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"Part 3: Median of K Sorted Arrays\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Test Case 1: Odd total elements",
    "        int[][] arrays1 = {{1, 5, 9}, {2, 6, 10}, {3, 7, 11}};",
    "        System.out.println(\"\\nTest 1: Odd total elements\");",
    "        System.out.println(\"Arrays: [[1,5,9], [2,6,10], [3,7,11]]\");",
    "        System.out.println(\"Merged sorted: [1,2,3,5,6,7,9,10,11]\");",
    "        double result1 = solution.findMedianOfKArrays(arrays1);",
    "        System.out.println(\"Median (heap): \" + result1);",
    "        assert result1 == 6.0 : \"Expected 6.0, got \" + result1;",
    "        System.out.println(\"\u2713 Passed\");",
    "        ",
    "        // Test Case 2: Even total elements",
    "        int[][] arrays2 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};",
    "        System.out.println(\"\\nTest 2: Even total elements\");",
    "        System.out.println(\"Arrays: [[1,2], [3,4], [5,6], [7,8]]\");",
    "        double result2 = solution.findMedianOfKArrays(arrays2);",
    "        System.out.println(\"Median (heap): \" + result2);",
    "        assert result2 == 4.5 : \"Expected 4.5, got \" + result2;",
    "        System.out.println(\"\u2713 Passed\");",
    "        ",
    "        // Test Case 3: Different sized arrays",
    "        int[][] arrays3 = {{1, 2, 3}, {4}, {5, 6}};",
    "        System.out.println(\"\\nTest 3: Different sized arrays\");",
    "        double result3 = solution.findMedianOfKArrays(arrays3);",
    "        System.out.println(\"Median: \" + result3);",
    "        assert result3 == 3.5 : \"Expected 3.5, got \" + result3;",
    "        System.out.println(\"\u2713 Passed\");",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"All tests passed! \u2713\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-4",
      "explanation": "Import heapq for min-heap operations and type hints for clean signatures"
    },
    {
      "lines": "14-27",
      "explanation": "Main method signature with comprehensive docstring explaining inputs, outputs, and complexity"
    },
    {
      "lines": "28-34",
      "explanation": "**Edge case handling**: Filter empty arrays and handle edge case of no elements"
    },
    {
      "lines": "36-39",
      "explanation": "**Heap initialization**: Push first element of each array as (value, array_idx, elem_idx) tuple"
    },
    {
      "lines": "41-50",
      "explanation": "**Core k-way merge loop**: Extract minimum, push replacement from same array. Loop runs total//2 + 1 times"
    },
    {
      "lines": "52-56",
      "explanation": "**Return median**: Handle odd/even cases differently - single value vs average of two"
    },
    {
      "lines": "58-98",
      "explanation": "**Alternative binary search approach**: Binary search on value space with count helper function"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "findMedianOfKArrays (heap)": {
          "complexity": "O(N log k)",
          "explanation": "Extract ~N/2 elements from heap, each extraction/insertion is O(log k)"
        },
        "findMedianOfKArrays (binary search)": {
          "complexity": "O(k \u00d7 log(max-min) \u00d7 log(maxLen))",
          "explanation": "Binary search on value range, each iteration counts via k binary searches"
        }
      },
      "overall_change": "Part 2 was O(log(min(m,n))) for 2 arrays. Part 3 with k arrays requires O(N log k) or O(k log(range) log(maxLen))"
    },
    "space": {
      "additional_space": "O(k)",
      "explanation": "Heap stores at most k elements (one frontier element per array)"
    }
  },
  "dry_run": {
    "example_input": "arrays = [[1, 5, 9], [2, 6, 10], [3, 7, 11]], total = 9",
    "steps": [
      {
        "step": 1,
        "action": "Initialize heap with first elements",
        "state": "heap = [(1,0,0), (2,1,0), (3,2,0)]",
        "explanation": "Each tuple is (value, array_index, element_index)"
      },
      {
        "step": 2,
        "action": "count=0: Extract min, push next",
        "state": "pop (1,0,0), push (5,0,1), heap = [(2,1,0), (3,2,0), (5,0,1)], prev=0, curr=1",
        "explanation": "Extracted 1, added next element 5 from array 0"
      },
      {
        "step": 3,
        "action": "count=1: Extract min, push next",
        "state": "pop (2,1,0), push (6,1,1), heap = [(3,2,0), (5,0,1), (6,1,1)], prev=1, curr=2",
        "explanation": "Extracted 2, added next element 6 from array 1"
      },
      {
        "step": 4,
        "action": "count=2: Extract min, push next",
        "state": "pop (3,2,0), push (7,2,1), heap = [(5,0,1), (6,1,1), (7,2,1)], prev=2, curr=3",
        "explanation": "Extracted 3, added next element 7 from array 2"
      },
      {
        "step": 5,
        "action": "count=3: Extract min, push next",
        "state": "pop (5,0,1), push (9,0,2), heap = [(6,1,1), (7,2,1), (9,0,2)], prev=3, curr=5",
        "explanation": "Extracted 5, added next element 9 from array 0"
      },
      {
        "step": 6,
        "action": "count=4: Extract min (median position!)",
        "state": "pop (6,1,1), push (10,1,2), prev=5, curr=6",
        "explanation": "Extracted 6. This is position 4 (0-indexed), the median for 9 elements"
      },
      {
        "step": 7,
        "action": "Return result",
        "state": "total=9 is odd, return curr_val=6.0",
        "explanation": "Odd count means single middle value"
      }
    ],
    "final_output": "6.0"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single array [[1,2,3]] \u2192 should return 2.0",
      "Two elements [[1], [2]] \u2192 should return 1.5",
      "All empty [[], [], []] \u2192 should return 0.0"
    ],
    "likely_bugs": [
      "Off-by-one in loop count (should be total//2 + 1 iterations)",
      "Forgetting to track prev_val for even total case",
      "Not filtering empty arrays before heap initialization",
      "Using wrong index (array_index vs element_index) when pushing to heap"
    ],
    "recommended_logs_or_asserts": [
      "assert len(heap) <= len(arrays), 'Heap grew too large'",
      "print(f'Extract {count}: val={curr_val}, heap_size={len(heap)}')",
      "assert extracted elements are in sorted order"
    ],
    "how_to_localize": "1. Print extraction sequence and verify it's sorted. 2. Check loop terminates at correct count. 3. Verify prev/curr tracking for even case."
  },
  "edge_cases": [
    {
      "case": "All arrays empty",
      "handling": "Return 0.0 after filtering",
      "gotcha": "Must check AFTER filtering, not before"
    },
    {
      "case": "Single element total",
      "handling": "Loop runs once, returns that element",
      "gotcha": "Don't divide by 2 for single element"
    },
    {
      "case": "Arrays with vastly different sizes",
      "handling": "Heap naturally handles this - small arrays exhaust early",
      "gotcha": "Check bounds before pushing next element"
    },
    {
      "case": "Duplicate values across arrays",
      "handling": "Heap handles duplicates correctly",
      "gotcha": "Binary search approach needs careful upper_bound"
    },
    {
      "case": "Very large k (many arrays)",
      "handling": "Heap operations remain O(log k)",
      "gotcha": "Initial heap build is O(k log k)"
    }
  ],
  "test_cases": [
    {
      "name": "Basic odd total",
      "input": "[[1, 5, 9], [2, 6, 10], [3, 7, 11]]",
      "expected": "6.0",
      "explanation": "9 elements, median at position 4 (0-indexed)"
    },
    {
      "name": "Basic even total",
      "input": "[[1, 2], [3, 4], [5, 6], [7, 8]]",
      "expected": "4.5",
      "explanation": "8 elements, median = (4+5)/2"
    },
    {
      "name": "Mixed empty arrays",
      "input": "[[], [1, 3], [], [2, 4], []]",
      "expected": "2.5",
      "explanation": "Filter empties, 4 elements remain"
    },
    {
      "name": "Single large array",
      "input": "[[1, 2, 3, 4, 5, 6, 7]]",
      "expected": "4.0",
      "explanation": "Single array, median is middle element"
    },
    {
      "name": "Single element arrays",
      "input": "[[5], [1], [3], [7], [9]]",
      "expected": "5.0",
      "explanation": "5 elements, sorted: [1,3,5,7,9], median=5"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Incorrect loop count for median position",
      "why_wrong": "For n elements, median position is n//2 for odd, need both n//2-1 and n//2 for even",
      "correct_approach": "Loop total//2 + 1 times, track both prev and curr values",
      "code_example_wrong": "for count in range(total // 2):  # Wrong: misses the median",
      "code_example_correct": "for count in range(total // 2 + 1):  # Correct: includes median position"
    },
    {
      "mistake": "Not handling even total case",
      "why_wrong": "Returns single value instead of average of two middle values",
      "correct_approach": "Track both prev_val and curr_val, average them for even total",
      "code_example_wrong": "return float(curr_val)  # Wrong for even total",
      "code_example_correct": "return (prev_val + curr_val) / 2.0 if total % 2 == 0 else float(curr_val)"
    },
    {
      "mistake": "Index out of bounds when pushing to heap",
      "why_wrong": "Trying to access beyond array length",
      "correct_approach": "Always check elem_idx + 1 < len(arr) before pushing",
      "code_example_wrong": "heap.push((arr[elem_idx + 1], arr_idx, elem_idx + 1))  # No bounds check!",
      "code_example_correct": "if elem_idx + 1 < len(arrays[arr_idx]): heapq.heappush(heap, ...)"
    },
    {
      "mistake": "Not filtering empty arrays",
      "why_wrong": "Empty arrays cause index errors when initializing heap",
      "correct_approach": "Filter arrays = [arr for arr in arrays if arr] at the start",
      "code_example_wrong": "for i, arr in enumerate(arrays): heap.push((arr[0], i, 0))",
      "code_example_correct": "arrays = [arr for arr in arrays if arr]\\nfor i, arr in enumerate(arrays): ..."
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by acknowledging that Part 2's partition approach doesn't scale to k arrays. Explain the two main approaches (heap vs binary search on value) and justify choosing heap for cleaner implementation. Walk through the algorithm step by step with a small example.",
    "what_to_mention": [
      "Why partition-based approach from Part 2 doesn't work for k arrays",
      "Time-space tradeoff between heap and binary search approaches",
      "How heap maintains the k-way merge invariant",
      "Early termination - only extract N/2 elements"
    ],
    "time_allocation": "2 min to explain approach, 8-10 min to implement, 2-3 min to test",
    "if_stuck": [
      "Think about how merge sort merges two arrays - extend to k arrays",
      "What data structure gives you the minimum across k elements efficiently?",
      "You don't need to merge ALL elements - just enough to find median"
    ]
  },
  "connection_to_next_part": "Part 4 might add streaming updates or weighted medians. The heap-based approach can be extended to support dynamic insertions by maintaining sorted lists per array, though the complexity increases. For weighted medians, we'd need to track cumulative weights in our heap tuples.",
  "communication_script": {
    "transition_from_previous": "Great, so Part 2 gave us O(log(min(m,n))) for two arrays using partition-based binary search. For Part 3 with k arrays, that approach becomes O(k!) in the worst case because we'd need to search all partition combinations. Let me explain a more scalable approach...",
    "explaining_changes": "The key change is moving from binary search on partitions to a k-way merge using a min-heap. The heap lets us efficiently find the globally smallest element across all k arrays in O(log k) time. We only need to extract about N/2 elements to find the median, giving us O(N log k) total.",
    "while_extending_code": [
      "I'm replacing the binary search with a min-heap initialization...",
      "Each heap entry is a tuple: value for comparison, array index to track source, element index to find next...",
      "The extraction loop runs until we reach the median position..."
    ],
    "after_completing": "This handles Part 3 with O(N log k) time and O(k) space. The heap approach is robust for any k and handles edge cases like empty arrays naturally. Ready for the next part?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_3_min": "Understand that partition approach doesn't scale, decide on heap-based k-way merge",
    "by_8_min": "Have heap initialization and extraction loop implemented",
    "by_12_min": "Handle odd/even median cases, filter empty arrays",
    "by_15_min": "Test with examples, verify edge cases",
    "warning_signs": "If still explaining approach at 5 min, start coding. If heap logic unclear at 10 min, ask for hints."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "Part 3 is largely independent from Part 2's implementation. If Part 2 had bugs, you can still implement the heap approach fresh.",
    "if_new_requirement_unclear": "Ask: 'Just to confirm - all arrays are already sorted, and I need to return the median of ALL elements combined, correct?'",
    "if_running_behind": "Focus on the heap approach only. Skip the binary search alternative. Mention edge cases verbally but prioritize working code."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing this as a k-way merge problem",
      "Explaining why Part 2's approach doesn't scale (partition combinations)",
      "Mentioning both heap and binary search on value approaches with tradeoffs",
      "Noting early termination optimization (extract N/2, not N elements)",
      "Discussing how this relates to external sort merge phase"
    ]
  },
  "pattern_recognition": {
    "pattern": "K-way Merge using Min-Heap",
    "indicators": [
      "Multiple sorted sequences that need to be combined",
      "Need to process elements in global sorted order",
      "Finding k-th smallest across multiple sources"
    ],
    "similar_problems": [
      "LC 23 - Merge K Sorted Lists",
      "LC 378 - Kth Smallest Element in a Sorted Matrix",
      "LC 373 - Find K Pairs with Smallest Sums",
      "External Sort Merge Phase"
    ],
    "template": "```python\\nimport heapq\\n# Initialize heap with first element from each source\\nheap = [(source[0], source_idx, 0) for source_idx, source in enumerate(sources) if source]\\nheapq.heapify(heap)\\n\\nwhile heap:\\n    val, src_idx, elem_idx = heapq.heappop(heap)\\n    # Process val...\\n    if elem_idx + 1 < len(sources[src_idx]):\\n        heapq.heappush(heap, (sources[src_idx][elem_idx + 1], src_idx, elem_idx + 1))\\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'k sorted arrays' and need global ordering, I immediately think k-way merge",
      "why": "This is a classic pattern - merge sort's merge phase extended to k sources"
    },
    {
      "step": 2,
      "thought": "Part 2's partition approach requires searching O(k) dimensions simultaneously",
      "why": "With k arrays, we'd need to try all combinations of partitions - exponential"
    },
    {
      "step": 3,
      "thought": "Min-heap maintains 'frontier' of each array efficiently",
      "why": "Heap gives O(log k) for extracting global minimum across k candidates"
    },
    {
      "step": 4,
      "thought": "We only need N/2 extractions, not N",
      "why": "Median is in the middle - no need to merge entire arrays"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you recognize when a simpler approach doesn't scale?",
      "Do you know the k-way merge pattern?",
      "Can you handle the median's odd/even cases correctly?",
      "Is your code clean with proper edge case handling?"
    ],
    "bonus_points": [
      "Explaining the tradeoff between heap and binary search on value",
      "Mentioning connection to external sort",
      "Discussing what happens with very large k",
      "Proactively handling empty arrays"
    ],
    "red_flags": [
      "Trying to force the Part 2 partition approach",
      "Forgetting to handle even total case",
      "Not checking array bounds when pushing to heap",
      "O(N log N) solution by merging all then sorting"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate heap boilerplate quickly",
      "Let AI help with Python's heapq syntax (push vs offer)",
      "Have AI generate test cases for edge conditions"
    ],
    "what_not_to_do": [
      "Don't let AI choose between heap vs binary search without understanding tradeoffs",
      "Verify the loop count logic manually - AI often gets off-by-one wrong",
      "Check that tuple structure (val, arr_idx, elem_idx) is consistent"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping into code without explaining why Part 2's approach doesn't work",
      "Not drawing/tracing the heap state while explaining",
      "Giving up when heap extraction count seems off"
    ],
    "technical": [
      "Using O(N log N) merge-all-then-sort approach",
      "Confusing array index with element index in heap tuples",
      "Forgetting to handle empty arrays"
    ],
    "communication": [
      "Not explaining the heap invariant",
      "Skipping the complexity analysis",
      "Not mentioning why we stop at N/2 extractions"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does the loop run exactly total//2 + 1 times?",
      "Is prev_val being tracked correctly for even case?",
      "Are empty arrays filtered before heap initialization?",
      "Is bounds check done before pushing to heap?",
      "Did I trace through both odd and even examples?"
    ],
    "quick_code_review": [
      "Imports: heapq for Python, PriorityQueue for Java",
      "Type hints on method signatures",
      "Consistent tuple structure: (value, array_idx, elem_idx)",
      "Return type is float/double"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Input validation for null/invalid arrays",
      "Logging for debugging median computation",
      "Metrics for heap size and extraction count",
      "Support for floating-point values in arrays"
    ],
    "why_not_in_interview": "Core algorithm is the focus; these are implementation details that can be discussed verbally",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging, and potentially support for different numeric types, but let me focus on the core algorithm here.'"
  },
  "generated_at": "2026-01-18T18:41:33.231914",
  "_meta": {
    "problem_id": "median_two_sorted_arrays",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}