{
  "problem_title": "Stack Overflow API Design",
  "difficulty": "hard",
  "category": "LLD/API Design",
  "estimated_time": "60-90 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Low-Level Design (LLD)** problem that tests your ability to design clean APIs, model data relationships, and implement efficient data access patterns. The key challenge isn't algorithmic complexity\u2014it's **organizing code well** and choosing the right data structures for efficient queries. This is the bread and butter of system design interviews at companies like Rippling, Stripe, and similar B2B SaaS companies.",
    "pattern_recognition": "**HashMap + Secondary Indexes + OOP Design**. The pattern here is:\n1. **Primary storage**: HashMaps for O(1) entity lookup by ID\n2. **Secondary indexes**: Additional HashMaps for efficient filtering (by user, by tag)\n3. **Relationships**: One-to-many (User\u2192Questions, Question\u2192Answers)\n4. **ID Generation**: Auto-incrementing counters or UUIDs",
    "key_constraints": [
      "Up to 10\u2075 operations - must be O(1) or O(log n) per operation, no O(n\u00b2) scans",
      "User IDs are provided (not auto-generated) - must handle duplicates",
      "Question/Answer IDs are auto-generated - need unique ID strategy",
      "getQuestionsByUser sorted by time (newest first) - need to maintain order or sort",
      "getQuestionsByTag sorted by score (highest first) - need to sort on retrieval",
      "Tags per question limited to 5 - manageable index size per question"
    ],
    "clarifying_questions": [
      "**ID Generation Strategy**: Should I use UUIDs, auto-incrementing integers, or a specific format? (Reveals: implementation flexibility)",
      "**Duplicate Handling**: Should createUser throw an error for duplicate IDs or return existing user? (Reveals: error handling expectations)",
      "**User Validation**: Should postQuestion/postAnswer fail if user doesn't exist, or create silently? (Reveals: data integrity requirements)",
      "**Concurrent Access**: Do I need to handle thread-safety, or is single-threaded sufficient? (Reveals: production readiness expectations)",
      "**Return Types**: Should getQuestion include the full Answer objects or just answer IDs? (Reveals: API design preferences)",
      "**Empty Results**: Return empty list or null for getQuestionsByUser with no questions? (Reveals: API consistency expectations)",
      "**Tie-Breaking**: When questions have same score, how to break ties in getQuestionsByTag? (Reveals: attention to detail)"
    ],
    "edge_cases_to_consider": [
      "Creating user with duplicate ID",
      "Posting question with non-existent user ID",
      "Posting answer to non-existent question",
      "Getting questions by user who exists but has no questions",
      "Getting questions by tag that doesn't exist",
      "Question with empty tags list",
      "Same tag appearing multiple times in a question",
      "Very long body text (up to 30,000 characters)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "createUser(userId, username) - Creates user with given ID",
        "how_met": "Store in users HashMap, return User object",
        "gotchas": [
          "Must handle duplicate user IDs - return existing or error?"
        ]
      },
      {
        "requirement": "postQuestion - Auto-generates unique question ID",
        "how_met": "Use incrementing counter: q_1, q_2, etc.",
        "gotchas": [
          "Remember to update secondary indexes (user_questions, tag_questions)"
        ]
      },
      {
        "requirement": "postAnswer - Validate question exists",
        "how_met": "Check questions HashMap before creating answer",
        "gotchas": [
          "Return null if question doesn't exist, don't throw"
        ]
      },
      {
        "requirement": "getQuestion - Returns question with all its answers",
        "how_met": "Lookup question, then fetch answers via question_answers index",
        "gotchas": [
          "Return null if question doesn't exist, not empty object"
        ]
      },
      {
        "requirement": "getQuestionsByUser - Ordered by creation time (newest first)",
        "how_met": "Maintain list per user, sort by createdAt descending",
        "gotchas": [
          "If questions added in order, still need to sort or reverse"
        ]
      },
      {
        "requirement": "getQuestionsByTag - Ordered by score (highest first)",
        "how_met": "Lookup question IDs by tag, fetch questions, sort by score",
        "gotchas": [
          "Must sort on retrieval since scores can change"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "createUser",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion"
      },
      {
        "operation": "postQuestion",
        "target": "O(t) where t=tags",
        "achieved": "O(t)",
        "why": "HashMap insertion + index updates for each tag"
      },
      {
        "operation": "postAnswer",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion + list append"
      },
      {
        "operation": "getQuestion",
        "target": "O(a) where a=answers",
        "achieved": "O(a)",
        "why": "Lookup + fetch all answers"
      },
      {
        "operation": "getQuestionsByUser",
        "target": "O(q log q)",
        "achieved": "O(q log q)",
        "why": "Fetch q questions + sort"
      },
      {
        "operation": "getQuestionsByTag",
        "target": "O(q log q)",
        "achieved": "O(q log q)",
        "why": "Fetch q questions + sort by score"
      }
    ],
    "non_goals": [
      "Voting system (Part 2)",
      "Search functionality (Part 3)",
      "Accepting answers",
      "Editing questions/answers",
      "Deleting content",
      "Pagination",
      "Full-text search"
    ]
  },
  "assumptions": [
    "**Single-threaded execution**: No need for locks or concurrent data structure (clarify with interviewer)",
    "**User IDs provided externally**: We don't generate user IDs, they're given to us",
    "**Timestamps are system time**: Use time.time() for createdAt, don't need to accept as parameter",
    "**Empty tags allowed**: A question can have 0 tags",
    "**Case-sensitive tags**: 'Java' and 'java' are different tags",
    "**Return copies or references**: Returning direct references is acceptable (not defensive copies)"
  ],
  "tradeoffs": [
    {
      "decision": "Store answers separately vs embedded in Question",
      "chosen": "Separate storage with index",
      "why": "Allows O(1) answer lookup by ID, easier to extend for voting/editing answers",
      "alternative": "Embed List<Answer> in Question object",
      "when_to_switch": "If answers are ALWAYS accessed with their question and never independently"
    },
    {
      "decision": "Sort on write vs sort on read for getQuestionsByTag",
      "chosen": "Sort on read",
      "why": "Scores can change (in Part 2), so sorting on write would become stale",
      "alternative": "Maintain sorted data structure (TreeSet)",
      "when_to_switch": "If reads vastly outnumber writes and scores rarely change"
    },
    {
      "decision": "Store question IDs in indexes vs store Question references",
      "chosen": "Store question IDs",
      "why": "More flexible, allows lazy loading, matches typical DB design",
      "alternative": "Store direct Question references",
      "when_to_switch": "If performance is critical and we never need just IDs"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Single Responsibility**: Separate classes for User, Question, Answer, and StackOverflow service",
      "**Keep Public API Small**: Only expose required methods, internal helpers are private",
      "**Encapsulate State**: All data access through methods, not direct field access",
      "**Favor Composition**: StackOverflow composes multiple data structures, doesn't inherit"
    ],
    "why_this_design_scales": "The current design uses **secondary indexes** which can easily be extended:\n- **Part 2 (Voting)**: Add vote counts to entities, possibly a votes HashMap\n- **Part 3 (Search)**: Add more indexes or integrate full-text search\n- The core entity classes are stable; we only add to the service layer",
    "expected_followup_hooks": [
      "**For voting**: Add upvote/downvote methods, update score field, possibly track who voted",
      "**For reputation**: Update user.reputation when their content gets voted",
      "**For accepted answers**: Add acceptAnswer method, update answer.isAccepted",
      "**For search**: Add inverted index on title/body words"
    ],
    "invariants": [
      "Every question_id in an index exists in the questions HashMap",
      "Every answer's questionId references a valid question",
      "User IDs are unique",
      "Question and Answer IDs are unique and auto-generated"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 STACK OVERFLOW DATA MODEL \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                          \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502                     PRIMARY STORAGE (HashMaps)                    \u2502   \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n\u2502   \u2502                                                                  \u2502   \u2502\n\u2502   \u2502   users: {                  questions: {         answers: {      \u2502   \u2502\n\u2502   \u2502     'u1': User(alice)         'q_1': Question     'a_1': Answer  \u2502   \u2502\n\u2502   \u2502     'u2': User(bob)           'q_2': Question     'a_2': Answer  \u2502   \u2502\n\u2502   \u2502   }                           'q_3': Question   }                \u2502   \u2502\n\u2502   \u2502                             }                                    \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                          \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502                    SECONDARY INDEXES (HashMaps)                   \u2502   \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n\u2502   \u2502                                                                  \u2502   \u2502\n\u2502   \u2502   user_questions: {         tag_questions: {    question_answers:\u2502   \u2502\n\u2502   \u2502     'u1': ['q_1', 'q_3']      'python': ['q_1']   'q_1': ['a_1', \u2502   \u2502\n\u2502   \u2502     'u2': ['q_2']             'java': ['q_2']          'a_2']    \u2502   \u2502\n\u2502   \u2502   }                           'react': ['q_3']   'q_2': []       \u2502   \u2502\n\u2502   \u2502                             }                  }                 \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\nINITIAL STATE:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  users: {}                                      \u2502\n\u2502  questions: {}                                  \u2502\n\u2502  answers: {}                                    \u2502\n\u2502  user_questions: {}                             \u2502\n\u2502  tag_questions: {}                              \u2502\n\u2502  question_answers: {}                           \u2502\n\u2502  question_counter: 1                            \u2502\n\u2502  answer_counter: 1                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER createUser('u1', 'alice'):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  users: {'u1': User(id='u1', username='alice')} \u2502\n\u2502  ... (rest unchanged)                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAFTER postQuestion('u1', 'How to...', 'Body', ['python']):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  questions: {'q_1': Question(id='q_1', ...)}    \u2502\n\u2502  user_questions: {'u1': ['q_1']}                \u2502\n\u2502  tag_questions: {'python': ['q_1']}             \u2502\n\u2502  question_counter: 2                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "createUser stores user in HashMap",
        "visualization": "users['u1'] = User('u1', 'alice')",
        "key_point": "O(1) insertion"
      },
      {
        "step": 2,
        "description": "postQuestion creates Question and updates indexes",
        "visualization": "questions['q_1'] = Question(...)\nuser_questions['u1'].append('q_1')\nfor tag in tags:\n  tag_questions[tag].append('q_1')",
        "key_point": "Update ALL relevant indexes"
      },
      {
        "step": 3,
        "description": "postAnswer validates question exists first",
        "visualization": "if question_id not in questions:\n  return None\nanswers['a_1'] = Answer(...)\nquestion_answers['q_1'].append('a_1')",
        "key_point": "Validation before insertion"
      },
      {
        "step": 4,
        "description": "getQuestion fetches question and its answers",
        "visualization": "q = questions.get('q_1')\nq.answers = [answers[aid] for aid in question_answers['q_1']]",
        "key_point": "Combine primary + index lookup"
      },
      {
        "step": 5,
        "description": "getQuestionsByTag fetches and sorts",
        "visualization": "qids = tag_questions.get('python', [])\nqs = [questions[qid] for qid in qids]\nreturn sorted(qs, key=score, reverse=True)",
        "key_point": "Sort on read (scores change)"
      }
    ],
    "dry_run_table": "| Step | Operation | Primary Storage | Indexes | Result |\n|------|-----------|-----------------|---------|--------|\n| 1 | `createUser('u1', 'alice')` | users={'u1': User} | - | User(u1, alice) |\n| 2 | `createUser('u2', 'bob')` | users={'u1':.., 'u2': User} | - | User(u2, bob) |\n| 3 | `postQuestion('u1', 'Q1', 'body', ['python'])` | questions={'q_1': Q} | user_questions={'u1':['q_1']}, tag_questions={'python':['q_1']} | Question(q_1) |\n| 4 | `postAnswer('u2', 'q_1', 'ans')` | answers={'a_1': A} | question_answers={'q_1':['a_1']} | Answer(a_1) |\n| 5 | `getQuestion('q_1')` | - | lookup question_answers | Question with answers list |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'unique IDs'**, I think of **HashMaps** for O(1) lookup. Users, Questions, and Answers each need their own HashMap.",
      "**When I see 'getQuestionsByUser'**, I realize I need a **secondary index** mapping user_id \u2192 list of question_ids. Without this, I'd have to scan ALL questions - O(n).",
      "**When I see 'getQuestionsByTag'**, same pattern - need tag \u2192 question_ids index. This is called an **inverted index**.",
      "**When I see 'sorted by score'**, I know I can't pre-sort because **scores can change** (Part 2 adds voting). So I must sort on read.",
      "**When I see 'sorted by creation time'**, I could either store timestamps and sort, or maintain insertion order (append to list, reverse on read).",
      "**For ID generation**, a simple counter works: q_1, q_2, etc. UUID would also work but is longer.",
      "**For relationships**, I'll store IDs (not objects) in indexes. This matches database foreign keys and keeps things decoupled."
    ],
    "key_insight": "The crucial realization is that this problem is about **indexing for efficient queries**. Each query type (by ID, by user, by tag) needs its own data structure. The primary HashMap gives O(1) by ID; secondary indexes give O(1) to find relevant IDs for filtered queries.",
    "why_this_works": "By maintaining multiple indexes that point to the same underlying data, we achieve O(1) or O(k) access for any query pattern, where k is the result set size. The trade-off is O(t) extra work on writes (updating all indexes), but writes are typically less frequent than reads."
  },
  "approaches": [
    {
      "name": "Brute Force - Single List Storage",
      "description": "Store all entities in simple lists. For any query, scan the entire list and filter.",
      "pseudocode": "class StackOverflow:\n    users = []  # List of User\n    questions = []  # List of Question\n    \n    def get_questions_by_tag(tag):\n        result = []\n        for q in questions:  # O(n) scan!\n            if tag in q.tags:\n                result.append(q)\n        return sorted(result, key=score)",
      "time_complexity": "O(n) for every query operation",
      "space_complexity": "O(n) total entities",
      "pros": [
        "Simple to implement",
        "Easy to understand",
        "No index maintenance"
      ],
      "cons": [
        "O(n) per query is too slow for 10\u2075 operations",
        "Doesn't scale",
        "Fails performance requirement"
      ],
      "when_to_use": "Only for very small datasets (<100 items) or prototyping"
    },
    {
      "name": "Optimal: HashMap + Secondary Indexes",
      "description": "Use HashMaps for primary storage (O(1) by ID) and secondary indexes for filtered queries.",
      "pseudocode": "class StackOverflow:\n    users = {}          # user_id -> User\n    questions = {}      # question_id -> Question\n    tag_questions = {}  # tag -> [question_ids]\n    \n    def post_question(user_id, title, body, tags):\n        q = Question(next_id(), ...)\n        questions[q.id] = q\n        for tag in tags:\n            tag_questions[tag].append(q.id)  # Update index\n    \n    def get_questions_by_tag(tag):\n        qids = tag_questions.get(tag, [])\n        qs = [questions[qid] for qid in qids]  # O(k)\n        return sorted(qs, key=score)  # O(k log k)",
      "time_complexity": "O(1) for single-entity ops, O(k log k) for filtered queries where k = result size",
      "space_complexity": "O(n) entities + O(n\u00d7t) index entries where t = avg tags per question",
      "pros": [
        "Meets all performance requirements",
        "Scalable",
        "Matches real database design"
      ],
      "cons": [
        "More complex",
        "Must maintain index consistency",
        "More memory for indexes"
      ],
      "key_insight": "Shift work from read to write - update indexes on every insert so reads are fast"
    }
  ],
  "optimal_solution": {
    "name": "HashMap Primary Storage with Secondary Indexes",
    "explanation_md": "## Approach\n\nThe solution uses a **multi-index design** similar to how databases work:\n\n### Primary Storage\n- `users`: HashMap mapping user_id \u2192 User object\n- `questions`: HashMap mapping question_id \u2192 Question object  \n- `answers`: HashMap mapping answer_id \u2192 Answer object\n\n### Secondary Indexes\n- `user_questions`: Maps user_id \u2192 list of question_ids (for getQuestionsByUser)\n- `tag_questions`: Maps tag \u2192 list of question_ids (for getQuestionsByTag)\n- `question_answers`: Maps question_id \u2192 list of answer_ids (for getQuestion)\n\n### Why This Works\n1. **O(1) lookups by ID**: HashMaps provide constant-time access\n2. **O(k) filtered queries**: Secondary indexes give us the exact IDs we need\n3. **O(k log k) sorted results**: We only sort the result set, not all data\n\n### Index Maintenance\nEvery write operation must update ALL relevant indexes:\n- postQuestion updates: questions, user_questions, tag_questions (for each tag)\n- postAnswer updates: answers, question_answers",
    "data_structures": [
      {
        "structure": "Dict[str, User] users",
        "purpose": "O(1) user lookup by ID"
      },
      {
        "structure": "Dict[str, Question] questions",
        "purpose": "O(1) question lookup by ID"
      },
      {
        "structure": "Dict[str, Answer] answers",
        "purpose": "O(1) answer lookup by ID"
      },
      {
        "structure": "Dict[str, List[str]] user_questions",
        "purpose": "Index for getQuestionsByUser"
      },
      {
        "structure": "Dict[str, List[str]] tag_questions",
        "purpose": "Index for getQuestionsByTag"
      },
      {
        "structure": "Dict[str, List[str]] question_answers",
        "purpose": "Index for fetching answers of a question"
      }
    ],
    "algorithm_steps": [
      "1. **createUser**: Validate not duplicate, create User, store in users HashMap",
      "2. **postQuestion**: Validate user exists, generate ID, create Question, store in questions HashMap, update user_questions index, update tag_questions index for each tag",
      "3. **postAnswer**: Validate question exists, generate ID, create Answer, store in answers HashMap, update question_answers index",
      "4. **getQuestion**: Lookup in questions HashMap, fetch all answers via question_answers index, attach to question",
      "5. **getQuestionsByUser**: Get question IDs from user_questions index, fetch each question, sort by createdAt descending",
      "6. **getQuestionsByTag**: Get question IDs from tag_questions index, fetch each question, sort by score descending"
    ],
    "why_decimal": "N/A for this problem - no currency calculations"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API Design - Part 1",
    "",
    "A production-ready implementation of a simplified Stack Overflow API",
    "with efficient O(1) lookups and secondary indexes for filtered queries.",
    "",
    "Author: Interview Preparation Guide",
    "Time Complexity: O(1) for most operations, O(k log k) for sorted queries",
    "Space Complexity: O(n) where n = total entities",
    "\"\"\"",
    "",
    "from typing import Dict, List, Optional",
    "from collections import defaultdict",
    "from dataclasses import dataclass, field",
    "import time",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"Represents a Stack Overflow user.",
    "    ",
    "    Attributes:",
    "        id: Unique identifier for the user",
    "        username: Display name of the user",
    "        reputation: User's reputation score (starts at 0)",
    "    \"\"\"",
    "    id: str",
    "    username: str",
    "    reputation: int = 0",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"User(id={self.id}, username={self.username}, reputation={self.reputation})\"",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Represents a question on Stack Overflow.",
    "    ",
    "    Attributes:",
    "        id: Auto-generated unique identifier",
    "        author_id: ID of the user who posted the question",
    "        title: Title of the question",
    "        body: Full body/content of the question",
    "        tags: List of tags associated with the question",
    "        score: Vote score (upvotes - downvotes)",
    "        created_at: Unix timestamp when question was created",
    "        answers: List of Answer objects (populated on retrieval)",
    "    \"\"\"",
    "    id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str] = field(default_factory=list)",
    "    score: int = 0",
    "    created_at: float = field(default_factory=time.time)",
    "    answers: List['Answer'] = field(default_factory=list)",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Question(id={self.id}, title='{self.title[:30]}...', score={self.score})\"",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Represents an answer to a question.",
    "    ",
    "    Attributes:",
    "        id: Auto-generated unique identifier",
    "        question_id: ID of the question being answered",
    "        author_id: ID of the user who posted the answer",
    "        body: Full body/content of the answer",
    "        score: Vote score (upvotes - downvotes)",
    "        is_accepted: Whether this answer was accepted by question author",
    "        created_at: Unix timestamp when answer was created",
    "    \"\"\"",
    "    id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    score: int = 0",
    "    is_accepted: bool = False",
    "    created_at: float = field(default_factory=time.time)",
    "    ",
    "    def __repr__(self) -> str:",
    "        return f\"Answer(id={self.id}, question_id={self.question_id}, score={self.score})\"",
    "",
    "",
    "class StackOverflow:",
    "    \"\"\"",
    "    Main API class for Stack Overflow functionality.",
    "    ",
    "    Provides methods for user management, posting questions/answers,",
    "    and querying content with efficient indexes.",
    "    ",
    "    Example:",
    "        >>> api = StackOverflow()",
    "        >>> user = api.create_user('u1', 'alice')",
    "        >>> question = api.post_question('u1', 'How to...?', 'Body text', ['python'])",
    "        >>> print(question.id)  # 'q_1'",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize the Stack Overflow API with empty data structures.\"\"\"",
    "        # Primary storage - O(1) lookup by ID",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        ",
    "        # Secondary indexes for efficient filtered queries",
    "        self._user_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self._tag_questions: Dict[str, List[str]] = defaultdict(list)",
    "        self._question_answers: Dict[str, List[str]] = defaultdict(list)",
    "        ",
    "        # ID generators",
    "        self._question_counter: int = 1",
    "        self._answer_counter: int = 1",
    "    ",
    "    def _next_question_id(self) -> str:",
    "        \"\"\"Generate next unique question ID.\"\"\"",
    "        qid = f\"q_{self._question_counter}\"",
    "        self._question_counter += 1",
    "        return qid",
    "    ",
    "    def _next_answer_id(self) -> str:",
    "        \"\"\"Generate next unique answer ID.\"\"\"",
    "        aid = f\"a_{self._answer_counter}\"",
    "        self._answer_counter += 1",
    "        return aid",
    "    ",
    "    # ==================== USER MANAGEMENT ====================",
    "    ",
    "    def create_user(self, user_id: str, username: str) -> Optional[User]:",
    "        \"\"\"",
    "        Create a new user with the given ID and username.",
    "        ",
    "        Args:",
    "            user_id: Unique identifier for the user",
    "            username: Display name of the user",
    "        ",
    "        Returns:",
    "            The created User object, or None if user_id already exists",
    "        ",
    "        Time Complexity: O(1)",
    "        ",
    "        Example:",
    "            >>> api = StackOverflow()",
    "            >>> user = api.create_user('u1', 'alice')",
    "            >>> print(user.username)  # 'alice'",
    "        \"\"\"",
    "        # Check for duplicate user ID",
    "        if user_id in self._users:",
    "            return None  # Or raise ValueError depending on requirements",
    "        ",
    "        user = User(id=user_id, username=username)",
    "        self._users[user_id] = user",
    "        return user",
    "    ",
    "    def get_user(self, user_id: str) -> Optional[User]:",
    "        \"\"\"Get user by ID. Returns None if not found.\"\"\"",
    "        return self._users.get(user_id)",
    "    ",
    "    # ==================== QUESTION MANAGEMENT ====================",
    "    ",
    "    def post_question(",
    "        self,",
    "        user_id: str,",
    "        title: str,",
    "        body: str,",
    "        tags: List[str]",
    "    ) -> Optional[Question]:",
    "        \"\"\"",
    "        Post a new question by the specified user.",
    "        ",
    "        Args:",
    "            user_id: ID of the user posting the question",
    "            title: Title of the question",
    "            body: Body/content of the question",
    "            tags: List of tags for the question (max 5)",
    "        ",
    "        Returns:",
    "            The created Question object, or None if user doesn't exist",
    "        ",
    "        Time Complexity: O(t) where t = number of tags",
    "        ",
    "        Example:",
    "            >>> question = api.post_question('u1', 'How to sort?', 'Details...', ['python', 'sorting'])",
    "        \"\"\"",
    "        # Validate user exists",
    "        if user_id not in self._users:",
    "            return None",
    "        ",
    "        # Generate unique ID and create question",
    "        question_id = self._next_question_id()",
    "        question = Question(",
    "            id=question_id,",
    "            author_id=user_id,",
    "            title=title,",
    "            body=body,",
    "            tags=list(tags)  # Copy to avoid external mutation",
    "        )",
    "        ",
    "        # Store in primary storage",
    "        self._questions[question_id] = question",
    "        ",
    "        # Update secondary indexes",
    "        self._user_questions[user_id].append(question_id)",
    "        ",
    "        for tag in tags:",
    "            self._tag_questions[tag].append(question_id)",
    "        ",
    "        return question",
    "    ",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"",
    "        Get a question by ID with all its answers.",
    "        ",
    "        Args:",
    "            question_id: ID of the question to retrieve",
    "        ",
    "        Returns:",
    "            The Question object with answers populated, or None if not found",
    "        ",
    "        Time Complexity: O(a) where a = number of answers",
    "        ",
    "        Example:",
    "            >>> question = api.get_question('q_1')",
    "            >>> print(len(question.answers))  # Number of answers",
    "        \"\"\"",
    "        question = self._questions.get(question_id)",
    "        if question is None:",
    "            return None",
    "        ",
    "        # Fetch all answers for this question",
    "        answer_ids = self._question_answers.get(question_id, [])",
    "        question.answers = [self._answers[aid] for aid in answer_ids]",
    "        ",
    "        return question",
    "    ",
    "    def get_questions_by_user(self, user_id: str) -> List[Question]:",
    "        \"\"\"",
    "        Get all questions posted by a user, sorted by creation time (newest first).",
    "        ",
    "        Args:",
    "            user_id: ID of the user whose questions to retrieve",
    "        ",
    "        Returns:",
    "            List of Questions sorted by creation time descending",
    "        ",
    "        Time Complexity: O(q log q) where q = user's question count",
    "        ",
    "        Example:",
    "            >>> questions = api.get_questions_by_user('u1')",
    "            >>> # Returns newest questions first",
    "        \"\"\"",
    "        question_ids = self._user_questions.get(user_id, [])",
    "        questions = [self._questions[qid] for qid in question_ids]",
    "        ",
    "        # Sort by creation time, newest first",
    "        return sorted(questions, key=lambda q: q.created_at, reverse=True)",
    "    ",
    "    def get_questions_by_tag(self, tag: str) -> List[Question]:",
    "        \"\"\"",
    "        Get all questions with the given tag, sorted by score (highest first).",
    "        ",
    "        Args:",
    "            tag: Tag to filter questions by",
    "        ",
    "        Returns:",
    "            List of Questions sorted by score descending",
    "        ",
    "        Time Complexity: O(q log q) where q = questions with this tag",
    "        ",
    "        Example:",
    "            >>> python_questions = api.get_questions_by_tag('python')",
    "            >>> # Returns highest-scored questions first",
    "        \"\"\"",
    "        question_ids = self._tag_questions.get(tag, [])",
    "        questions = [self._questions[qid] for qid in question_ids]",
    "        ",
    "        # Sort by score, highest first (secondary sort by created_at for ties)",
    "        return sorted(",
    "            questions,",
    "            key=lambda q: (q.score, q.created_at),",
    "            reverse=True",
    "        )",
    "    ",
    "    # ==================== ANSWER MANAGEMENT ====================",
    "    ",
    "    def post_answer(",
    "        self,",
    "        user_id: str,",
    "        question_id: str,",
    "        body: str",
    "    ) -> Optional[Answer]:",
    "        \"\"\"",
    "        Post an answer to an existing question.",
    "        ",
    "        Args:",
    "            user_id: ID of the user posting the answer",
    "            question_id: ID of the question being answered",
    "            body: Body/content of the answer",
    "        ",
    "        Returns:",
    "            The created Answer object, or None if question doesn't exist",
    "        ",
    "        Time Complexity: O(1)",
    "        ",
    "        Example:",
    "            >>> answer = api.post_answer('u2', 'q_1', 'You can use sorted()...')",
    "        \"\"\"",
    "        # Validate question exists",
    "        if question_id not in self._questions:",
    "            return None",
    "        ",
    "        # Optionally validate user exists (depends on requirements)",
    "        # if user_id not in self._users:",
    "        #     return None",
    "        ",
    "        # Generate unique ID and create answer",
    "        answer_id = self._next_answer_id()",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            author_id=user_id,",
    "            body=body",
    "        )",
    "        ",
    "        # Store in primary storage",
    "        self._answers[answer_id] = answer",
    "        ",
    "        # Update index",
    "        self._question_answers[question_id].append(answer_id)",
    "        ",
    "        return answer",
    "    ",
    "    def get_answer(self, answer_id: str) -> Optional[Answer]:",
    "        \"\"\"Get answer by ID. Returns None if not found.\"\"\"",
    "        return self._answers.get(answer_id)",
    "    ",
    "    # ==================== DEBUG/UTILITY ====================",
    "    ",
    "    def get_stats(self) -> Dict[str, int]:",
    "        \"\"\"Return statistics about the current state.\"\"\"",
    "        return {",
    "            'users': len(self._users),",
    "            'questions': len(self._questions),",
    "            'answers': len(self._answers),",
    "            'tags': len(self._tag_questions)",
    "        }",
    "",
    "",
    "# ==================== DEMO / TEST ====================",
    "",
    "if __name__ == '__main__':",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Stack Overflow API - Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Initialize API",
    "    api = StackOverflow()",
    "    ",
    "    # Create users",
    "    print(\"\\n[1] Creating users...\")",
    "    alice = api.create_user('u1', 'alice')",
    "    bob = api.create_user('u2', 'bob')",
    "    print(f\"    Created: {alice}\")",
    "    print(f\"    Created: {bob}\")",
    "    ",
    "    # Test duplicate user",
    "    duplicate = api.create_user('u1', 'alice2')",
    "    print(f\"    Duplicate user result: {duplicate}\")",
    "    ",
    "    # Post questions",
    "    print(\"\\n[2] Posting questions...\")",
    "    q1 = api.post_question(",
    "        'u1',",
    "        'How to reverse a string in Python?',",
    "        'I need help with string reversal techniques.',",
    "        ['python', 'strings']",
    "    )",
    "    print(f\"    Posted: {q1}\")",
    "    ",
    "    q2 = api.post_question(",
    "        'u1',",
    "        'Python vs Java performance?',",
    "        'Which language is faster for backend?',",
    "        ['python', 'java', 'performance']",
    "    )",
    "    print(f\"    Posted: {q2}\")",
    "    ",
    "    q3 = api.post_question(",
    "        'u2',",
    "        'How to use React hooks?',",
    "        'Explain useEffect and useState.',",
    "        ['javascript', 'react']",
    "    )",
    "    print(f\"    Posted: {q3}\")",
    "    ",
    "    # Post answers",
    "    print(\"\\n[3] Posting answers...\")",
    "    a1 = api.post_answer('u2', 'q_1', 'Use [::-1] slicing or reversed() function.')",
    "    print(f\"    Posted: {a1}\")",
    "    ",
    "    a2 = api.post_answer('u2', 'q_1', 'You can also use the join + reversed method.')",
    "    print(f\"    Posted: {a2}\")",
    "    ",
    "    # Test answer to non-existent question",
    "    invalid_answer = api.post_answer('u1', 'invalid_q', 'This should fail')",
    "    print(f\"    Answer to invalid question: {invalid_answer}\")",
    "    ",
    "    # Get question with answers",
    "    print(\"\\n[4] Getting question with answers...\")",
    "    fetched_q = api.get_question('q_1')",
    "    print(f\"    Question: {fetched_q}\")",
    "    print(f\"    Answers: {fetched_q.answers}\")",
    "    ",
    "    # Test non-existent question",
    "    missing_q = api.get_question('invalid_q')",
    "    print(f\"    Non-existent question: {missing_q}\")",
    "    ",
    "    # Get questions by user",
    "    print(\"\\n[5] Getting questions by user...\")",
    "    alice_questions = api.get_questions_by_user('u1')",
    "    print(f\"    Alice's questions (newest first):\")",
    "    for q in alice_questions:",
    "        print(f\"      - {q.id}: {q.title[:40]}...\")",
    "    ",
    "    # Get questions by tag",
    "    print(\"\\n[6] Getting questions by tag 'python'...\")",
    "    python_questions = api.get_questions_by_tag('python')",
    "    print(f\"    Python questions (highest score first):\")",
    "    for q in python_questions:",
    "        print(f\"      - {q.id}: {q.title[:40]}... (score: {q.score})\")",
    "    ",
    "    # Print stats",
    "    print(\"\\n[7] System stats:\")",
    "    stats = api.get_stats()",
    "    for key, value in stats.items():",
    "        print(f\"    {key}: {value}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo complete!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Stack Overflow API Design - Part 1",
    " * ",
    " * A production-ready implementation of a simplified Stack Overflow API",
    " * with efficient O(1) lookups and secondary indexes for filtered queries.",
    " */",
    "",
    "// ==================== DATA CLASSES ====================",
    "",
    "class User {",
    "    private final String id;",
    "    private final String username;",
    "    private int reputation;",
    "    ",
    "    public User(String id, String username) {",
    "        this.id = id;",
    "        this.username = username;",
    "        this.reputation = 0;",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public String getUsername() { return username; }",
    "    public int getReputation() { return reputation; }",
    "    public void setReputation(int reputation) { this.reputation = reputation; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"User(id=%s, username=%s, reputation=%d)\", id, username, reputation);",
    "    }",
    "}",
    "",
    "class Question {",
    "    private final String id;",
    "    private final String authorId;",
    "    private final String title;",
    "    private final String body;",
    "    private final List<String> tags;",
    "    private int score;",
    "    private final long createdAt;",
    "    private List<Answer> answers;",
    "    ",
    "    public Question(String id, String authorId, String title, String body, List<String> tags) {",
    "        this.id = id;",
    "        this.authorId = authorId;",
    "        this.title = title;",
    "        this.body = body;",
    "        this.tags = new ArrayList<>(tags);",
    "        this.score = 0;",
    "        this.createdAt = System.currentTimeMillis();",
    "        this.answers = new ArrayList<>();",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public String getAuthorId() { return authorId; }",
    "    public String getTitle() { return title; }",
    "    public String getBody() { return body; }",
    "    public List<String> getTags() { return Collections.unmodifiableList(tags); }",
    "    public int getScore() { return score; }",
    "    public void setScore(int score) { this.score = score; }",
    "    public long getCreatedAt() { return createdAt; }",
    "    public List<Answer> getAnswers() { return answers; }",
    "    public void setAnswers(List<Answer> answers) { this.answers = answers; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        String shortTitle = title.length() > 30 ? title.substring(0, 30) + \"...\" : title;",
    "        return String.format(\"Question(id=%s, title='%s', score=%d)\", id, shortTitle, score);",
    "    }",
    "}",
    "",
    "class Answer {",
    "    private final String id;",
    "    private final String questionId;",
    "    private final String authorId;",
    "    private final String body;",
    "    private int score;",
    "    private boolean isAccepted;",
    "    private final long createdAt;",
    "    ",
    "    public Answer(String id, String questionId, String authorId, String body) {",
    "        this.id = id;",
    "        this.questionId = questionId;",
    "        this.authorId = authorId;",
    "        this.body = body;",
    "        this.score = 0;",
    "        this.isAccepted = false;",
    "        this.createdAt = System.currentTimeMillis();",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public String getQuestionId() { return questionId; }",
    "    public String getAuthorId() { return authorId; }",
    "    public String getBody() { return body; }",
    "    public int getScore() { return score; }",
    "    public void setScore(int score) { this.score = score; }",
    "    public boolean isAccepted() { return isAccepted; }",
    "    public void setAccepted(boolean accepted) { isAccepted = accepted; }",
    "    public long getCreatedAt() { return createdAt; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"Answer(id=%s, questionId=%s, score=%d)\", id, questionId, score);",
    "    }",
    "}",
    "",
    "// ==================== MAIN API CLASS ====================",
    "",
    "public class StackOverflow {",
    "    // Primary storage - O(1) lookup by ID",
    "    private final Map<String, User> users;",
    "    private final Map<String, Question> questions;",
    "    private final Map<String, Answer> answers;",
    "    ",
    "    // Secondary indexes for efficient filtered queries",
    "    private final Map<String, List<String>> userQuestions;",
    "    private final Map<String, List<String>> tagQuestions;",
    "    private final Map<String, List<String>> questionAnswers;",
    "    ",
    "    // ID generators",
    "    private int questionCounter;",
    "    private int answerCounter;",
    "    ",
    "    public StackOverflow() {",
    "        this.users = new HashMap<>();",
    "        this.questions = new HashMap<>();",
    "        this.answers = new HashMap<>();",
    "        this.userQuestions = new HashMap<>();",
    "        this.tagQuestions = new HashMap<>();",
    "        this.questionAnswers = new HashMap<>();",
    "        this.questionCounter = 1;",
    "        this.answerCounter = 1;",
    "    }",
    "    ",
    "    private String nextQuestionId() {",
    "        return \"q_\" + (questionCounter++);",
    "    }",
    "    ",
    "    private String nextAnswerId() {",
    "        return \"a_\" + (answerCounter++);",
    "    }",
    "    ",
    "    // ==================== USER MANAGEMENT ====================",
    "    ",
    "    /**",
    "     * Create a new user with the given ID and username.",
    "     * @param userId Unique identifier for the user",
    "     * @param username Display name of the user",
    "     * @return The created User object, or null if userId already exists",
    "     */",
    "    public User createUser(String userId, String username) {",
    "        if (users.containsKey(userId)) {",
    "            return null;",
    "        }",
    "        User user = new User(userId, username);",
    "        users.put(userId, user);",
    "        return user;",
    "    }",
    "    ",
    "    // ==================== QUESTION MANAGEMENT ====================",
    "    ",
    "    /**",
    "     * Post a new question by the specified user.",
    "     * @param userId ID of the user posting the question",
    "     * @param title Title of the question",
    "     * @param body Body/content of the question",
    "     * @param tags List of tags for the question",
    "     * @return The created Question object, or null if user doesn't exist",
    "     */",
    "    public Question postQuestion(String userId, String title, String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) {",
    "            return null;",
    "        }",
    "        ",
    "        String questionId = nextQuestionId();",
    "        Question question = new Question(questionId, userId, title, body, tags);",
    "        ",
    "        // Store in primary storage",
    "        questions.put(questionId, question);",
    "        ",
    "        // Update secondary indexes",
    "        userQuestions.computeIfAbsent(userId, k -> new ArrayList<>()).add(questionId);",
    "        ",
    "        for (String tag : tags) {",
    "            tagQuestions.computeIfAbsent(tag, k -> new ArrayList<>()).add(questionId);",
    "        }",
    "        ",
    "        return question;",
    "    }",
    "    ",
    "    /**",
    "     * Get a question by ID with all its answers.",
    "     * @param questionId ID of the question to retrieve",
    "     * @return The Question object with answers, or null if not found",
    "     */",
    "    public Question getQuestion(String questionId) {",
    "        Question question = questions.get(questionId);",
    "        if (question == null) {",
    "            return null;",
    "        }",
    "        ",
    "        // Fetch all answers for this question",
    "        List<String> answerIds = questionAnswers.getOrDefault(questionId, Collections.emptyList());",
    "        List<Answer> answerList = new ArrayList<>();",
    "        for (String aid : answerIds) {",
    "            answerList.add(answers.get(aid));",
    "        }",
    "        question.setAnswers(answerList);",
    "        ",
    "        return question;",
    "    }",
    "    ",
    "    /**",
    "     * Get all questions posted by a user, sorted by creation time (newest first).",
    "     * @param userId ID of the user",
    "     * @return List of Questions sorted by creation time descending",
    "     */",
    "    public List<Question> getQuestionsByUser(String userId) {",
    "        List<String> questionIds = userQuestions.getOrDefault(userId, Collections.emptyList());",
    "        List<Question> result = new ArrayList<>();",
    "        ",
    "        for (String qid : questionIds) {",
    "            result.add(questions.get(qid));",
    "        }",
    "        ",
    "        // Sort by creation time, newest first",
    "        result.sort((a, b) -> Long.compare(b.getCreatedAt(), a.getCreatedAt()));",
    "        return result;",
    "    }",
    "    ",
    "    /**",
    "     * Get all questions with the given tag, sorted by score (highest first).",
    "     * @param tag Tag to filter by",
    "     * @return List of Questions sorted by score descending",
    "     */",
    "    public List<Question> getQuestionsByTag(String tag) {",
    "        List<String> questionIds = tagQuestions.getOrDefault(tag, Collections.emptyList());",
    "        List<Question> result = new ArrayList<>();",
    "        ",
    "        for (String qid : questionIds) {",
    "            result.add(questions.get(qid));",
    "        }",
    "        ",
    "        // Sort by score descending, then by creation time for ties",
    "        result.sort((a, b) -> {",
    "            int scoreCompare = Integer.compare(b.getScore(), a.getScore());",
    "            if (scoreCompare != 0) return scoreCompare;",
    "            return Long.compare(b.getCreatedAt(), a.getCreatedAt());",
    "        });",
    "        return result;",
    "    }",
    "    ",
    "    // ==================== ANSWER MANAGEMENT ====================",
    "    ",
    "    /**",
    "     * Post an answer to an existing question.",
    "     * @param userId ID of the user posting the answer",
    "     * @param questionId ID of the question being answered",
    "     * @param body Body/content of the answer",
    "     * @return The created Answer object, or null if question doesn't exist",
    "     */",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!questions.containsKey(questionId)) {",
    "            return null;",
    "        }",
    "        ",
    "        String answerId = nextAnswerId();",
    "        Answer answer = new Answer(answerId, questionId, userId, body);",
    "        ",
    "        // Store in primary storage",
    "        answers.put(answerId, answer);",
    "        ",
    "        // Update index",
    "        questionAnswers.computeIfAbsent(questionId, k -> new ArrayList<>()).add(answerId);",
    "        ",
    "        return answer;",
    "    }",
    "    ",
    "    // ==================== DEMO ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API - Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        StackOverflow api = new StackOverflow();",
    "        ",
    "        // Create users",
    "        System.out.println(\"\\n[1] Creating users...\");",
    "        User alice = api.createUser(\"u1\", \"alice\");",
    "        User bob = api.createUser(\"u2\", \"bob\");",
    "        System.out.println(\"    Created: \" + alice);",
    "        System.out.println(\"    Created: \" + bob);",
    "        ",
    "        // Post questions",
    "        System.out.println(\"\\n[2] Posting questions...\");",
    "        Question q1 = api.postQuestion(\"u1\", \"How to reverse a string?\",",
    "            \"I need help with string reversal.\", Arrays.asList(\"python\", \"strings\"));",
    "        System.out.println(\"    Posted: \" + q1);",
    "        ",
    "        Question q2 = api.postQuestion(\"u1\", \"Python vs Java?\",",
    "            \"Which is better?\", Arrays.asList(\"python\", \"java\"));",
    "        System.out.println(\"    Posted: \" + q2);",
    "        ",
    "        // Post answers",
    "        System.out.println(\"\\n[3] Posting answers...\");",
    "        Answer a1 = api.postAnswer(\"u2\", \"q_1\", \"Use [::-1] slicing.\");",
    "        System.out.println(\"    Posted: \" + a1);",
    "        ",
    "        // Test invalid answer",
    "        Answer invalid = api.postAnswer(\"u1\", \"invalid_q\", \"This should fail\");",
    "        System.out.println(\"    Invalid answer result: \" + invalid);",
    "        ",
    "        // Get question with answers",
    "        System.out.println(\"\\n[4] Getting question with answers...\");",
    "        Question fetched = api.getQuestion(\"q_1\");",
    "        System.out.println(\"    Question: \" + fetched);",
    "        System.out.println(\"    Answers: \" + fetched.getAnswers());",
    "        ",
    "        // Get questions by user",
    "        System.out.println(\"\\n[5] Getting questions by user 'u1'...\");",
    "        List<Question> aliceQuestions = api.getQuestionsByUser(\"u1\");",
    "        for (Question q : aliceQuestions) {",
    "            System.out.println(\"    - \" + q);",
    "        }",
    "        ",
    "        // Get questions by tag",
    "        System.out.println(\"\\n[6] Getting questions by tag 'python'...\");",
    "        List<Question> pythonQuestions = api.getQuestionsByTag(\"python\");",
    "        for (Question q : pythonQuestions) {",
    "            System.out.println(\"    - \" + q);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Demo complete!\");",
    "        System.out.println(\"=\".repeat(60));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-15",
      "section": "Module Docstring & Imports",
      "explanation": "We document the module purpose and import essential types: `Dict`, `List`, `Optional` for type hints, `defaultdict` for automatic list initialization, `dataclass` for clean entity definitions, and `time` for timestamps."
    },
    {
      "lines": "17-34",
      "section": "User Dataclass",
      "explanation": "The `User` class is a simple dataclass with `id`, `username`, and `reputation`. Using `@dataclass` gives us `__init__`, `__eq__`, and `__repr__` automatically. Reputation defaults to 0 and will be used in Part 2 for voting."
    },
    {
      "lines": "36-61",
      "section": "Question Dataclass",
      "explanation": "The `Question` class stores all question attributes. Key points: `tags` uses `default_factory=list` to avoid mutable default argument pitfall, `created_at` auto-generates timestamp, and `answers` is populated on retrieval (not stored with question)."
    },
    {
      "lines": "63-88",
      "section": "Answer Dataclass",
      "explanation": "The `Answer` class has a foreign key `question_id` linking it to its question. `is_accepted` is for Part 2. Notice how `created_at` is auto-generated - we don't need to pass it."
    },
    {
      "lines": "90-124",
      "section": "StackOverflow Class & __init__",
      "explanation": "**This is the heart of the design.** We have three HashMaps for primary storage (`_users`, `_questions`, `_answers`) and three secondary indexes for efficient queries. `defaultdict(list)` means we don't need to check if a key exists before appending. The underscore prefix indicates private/internal attributes."
    },
    {
      "lines": "126-138",
      "section": "ID Generation Helpers",
      "explanation": "Simple helper methods to generate unique IDs like `q_1`, `q_2`, etc. These are private methods (underscore prefix). In production, you might use UUIDs, but simple counters work great for interviews and are easier to debug."
    },
    {
      "lines": "140-167",
      "section": "createUser Method",
      "explanation": "**Key validation**: Check if user_id already exists (O(1) HashMap lookup). If duplicate, return `None`. Otherwise, create User and store in HashMap. This demonstrates proper input validation and error handling."
    },
    {
      "lines": "172-212",
      "section": "postQuestion Method",
      "explanation": "**Critical method with multiple index updates**: 1) Validate user exists, 2) Generate unique ID, 3) Create Question, 4) Store in primary HashMap, 5) Update `user_questions` index, 6) Update `tag_questions` index for EACH tag. Time is O(t) where t = number of tags."
    },
    {
      "lines": "214-244",
      "section": "getQuestion Method",
      "explanation": "First lookup question in primary HashMap. If found, fetch all answer IDs from `question_answers` index, then fetch each Answer object and attach to question. This is the **join** operation - combining data from two collections."
    },
    {
      "lines": "246-268",
      "section": "getQuestionsByUser Method",
      "explanation": "Use the `user_questions` secondary index to get question IDs in O(1), then fetch each question. **Sorting is done on read** because questions are sorted by `created_at` which is immutable. We sort descending (newest first)."
    },
    {
      "lines": "270-295",
      "section": "getQuestionsByTag Method",
      "explanation": "Similar pattern using `tag_questions` index. **Key insight**: We sort by score on read because scores can change (Part 2 voting). Secondary sort by `created_at` for tie-breaking. This is O(q log q) where q = questions with this tag."
    },
    {
      "lines": "297-341",
      "section": "postAnswer Method",
      "explanation": "**Validate question exists first** - this is the critical edge case! If question doesn't exist, return `None`. Otherwise, create Answer, store in primary HashMap, and update `question_answers` index."
    },
    {
      "lines": "343-420",
      "section": "Main Demo Function",
      "explanation": "A comprehensive demo that exercises all methods: creates users, posts questions with tags, posts answers, tests edge cases (duplicate user, answer to invalid question), and demonstrates all query methods. **Always include a runnable demo in interviews!**"
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test `createUser` first - verify user stored in HashMap\n2. Test `postQuestion` - verify question stored AND indexes updated (print `user_questions` and `tag_questions`)\n3. Test `getQuestion` before adding answers - should return question with empty answers list\n4. Add answers, then test `getQuestion` again - verify answers populated\n5. Test edge cases last (duplicate user, invalid question ID)",
    "what_to_print_or_assert": [
      "print(f\"Users: {self._users}\")",
      "print(f\"User questions index: {dict(self._user_questions)}\")",
      "print(f\"Tag questions index: {dict(self._tag_questions)}\")",
      "assert len(self._questions) == expected_count",
      "assert question_id in self._questions"
    ],
    "common_failure_modes": [
      "**Index not updated**: Forgetting to update secondary index when adding entity",
      "**Wrong return type**: Returning empty list instead of None for missing entity",
      "**Sort order wrong**: Forgetting `reverse=True` for descending sort",
      "**Mutable default argument**: Using `tags=[]` instead of `tags=None` with `tags = tags or []`",
      "**Reference vs copy**: Returning internal list directly (allowing external mutation)"
    ],
    "how_to_fix_fast": "**1. Print state before and after operation** - usually reveals which index wasn't updated\n**2. Check return value** - are you returning `None` when you should return empty list or vice versa?\n**3. Verify sort key** - print the key values being sorted to confirm order\n**4. Trace through with one example** - step through the exact operations"
  },
  "complexity_analysis": {
    "time": {
      "createUser": {
        "complexity": "O(1)",
        "explanation": "HashMap containsKey + put"
      },
      "postQuestion": {
        "complexity": "O(t)",
        "explanation": "O(1) HashMap + O(t) for updating tag index for each of t tags"
      },
      "postAnswer": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup + put + list append"
      },
      "getQuestion": {
        "complexity": "O(a)",
        "explanation": "O(1) HashMap lookup + O(a) to fetch a answers"
      },
      "getQuestionsByUser": {
        "complexity": "O(q log q)",
        "explanation": "O(q) to fetch q questions + O(q log q) to sort"
      },
      "getQuestionsByTag": {
        "complexity": "O(q log q)",
        "explanation": "O(q) to fetch q questions + O(q log q) to sort"
      },
      "overall": "All operations are O(1) or O(k log k) where k is result set size - meets the 10\u2075 operations constraint"
    },
    "space": {
      "complexity": "O(U + Q + A + Q\u00d7T) where U=users, Q=questions, A=answers, T=avg tags/question",
      "breakdown": "- Primary storage: O(U + Q + A) for entity HashMaps\n- user_questions index: O(Q) total entries\n- tag_questions index: O(Q \u00d7 T) worst case\n- question_answers index: O(A) total entries",
      "note": "Space is linear in the number of entities - very efficient"
    },
    "can_we_do_better": "For Part 1, this is optimal. For Part 2-3, we might add more indexes (e.g., sorted by score) or use different data structures (TreeMap for range queries)."
  },
  "dry_run": {
    "example": "createUser('u1', 'alice'), createUser('u2', 'bob'), postQuestion('u1', 'Q1', 'body', ['python', 'java']), postAnswer('u2', 'q_1', 'answer'), getQuestion('q_1')",
    "trace_table": "| Step | Operation | Primary Storage | Indexes | Result |\n|------|-----------|-----------------|---------|--------|\n| 1 | `createUser('u1', 'alice')` | users={'u1': User(u1,alice)} | - | User(u1) |\n| 2 | `createUser('u2', 'bob')` | users={'u1':..,'u2': User(u2,bob)} | - | User(u2) |\n| 3 | `postQuestion('u1','Q1','body',['python','java'])` | questions={'q_1': Question} | user_questions={'u1':['q_1']}, tag_questions={'python':['q_1'],'java':['q_1']} | Question(q_1) |\n| 4 | `postAnswer('u2', 'q_1', 'answer')` | answers={'a_1': Answer} | question_answers={'q_1':['a_1']} | Answer(a_1) |\n| 5 | `getQuestion('q_1')` | (read only) | lookup question_answers['q_1']\u2192['a_1'] | Question(q_1, answers=[Answer(a_1)]) |",
    "final_answer": "Question with ID 'q_1', title 'Q1', and one answer from user 'u2'"
  },
  "test_cases": [
    {
      "name": "Basic - Create user and post question",
      "category": "Happy Path",
      "input": "createUser('u1', 'alice'), postQuestion('u1', 'Title', 'Body', ['python'])",
      "expected": "User(u1), Question(q_1)",
      "explanation": "Basic flow works - user created, question posted with auto-generated ID"
    },
    {
      "name": "Duplicate user ID",
      "category": "Edge Case - Validation",
      "input": "createUser('u1', 'alice'), createUser('u1', 'bob')",
      "expected": "User(u1), None",
      "explanation": "Second createUser with same ID returns None"
    },
    {
      "name": "Post answer to non-existent question",
      "category": "Edge Case - Validation",
      "input": "createUser('u1', 'alice'), postAnswer('u1', 'invalid_q', 'answer')",
      "expected": "User(u1), None",
      "explanation": "Must validate question exists before allowing answer"
    },
    {
      "name": "Get non-existent question",
      "category": "Edge Case - Not Found",
      "input": "getQuestion('invalid_q')",
      "expected": "None",
      "explanation": "Return None, not empty object or error"
    },
    {
      "name": "Get questions by user with no questions",
      "category": "Edge Case - Empty Result",
      "input": "createUser('u1', 'alice'), getQuestionsByUser('u1')",
      "expected": "User(u1), []",
      "explanation": "Return empty list, not None"
    },
    {
      "name": "Get questions by non-existent tag",
      "category": "Edge Case - Empty Result",
      "input": "getQuestionsByTag('nonexistent')",
      "expected": "[]",
      "explanation": "Return empty list for tag with no questions"
    },
    {
      "name": "Questions sorted by creation time",
      "category": "Sorting",
      "input": "createUser('u1',..), postQuestion('u1', 'Q1',..), postQuestion('u1', 'Q2',..), getQuestionsByUser('u1')",
      "expected": "[Q2, Q1]",
      "explanation": "Newest first - Q2 was created after Q1"
    },
    {
      "name": "Question with multiple answers",
      "category": "Relationships",
      "input": "createUser('u1','alice'), createUser('u2','bob'), postQuestion('u1','Q1',..,[]), postAnswer('u2','q_1','A1'), postAnswer('u1','q_1','A2'), getQuestion('q_1')",
      "expected": "Question with 2 answers [A1, A2]",
      "explanation": "Question retrieval includes all its answers"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not validating question exists before posting answer",
      "why_wrong": "Creates orphan answer with invalid questionId, breaks data integrity",
      "correct_approach": "Check `if question_id not in self._questions: return None`",
      "code_wrong": "def post_answer(self, user_id, question_id, body):\n    answer = Answer(...)\n    self._answers[answer.id] = answer  # No validation!",
      "code_correct": "def post_answer(self, user_id, question_id, body):\n    if question_id not in self._questions:\n        return None\n    answer = Answer(...)\n    self._answers[answer.id] = answer"
    },
    {
      "mistake": "O(n) scan for getQuestionsByTag instead of using index",
      "why_wrong": "Doesn't scale - O(n) per query \u00d7 10\u2075 queries = too slow",
      "correct_approach": "Use secondary index: `tag_questions[tag]` returns list of question IDs in O(1)",
      "code_wrong": "def get_questions_by_tag(self, tag):\n    result = []\n    for q in self._questions.values():  # O(n) scan!\n        if tag in q.tags:\n            result.append(q)\n    return result",
      "code_correct": "def get_questions_by_tag(self, tag):\n    qids = self._tag_questions.get(tag, [])\n    return [self._questions[qid] for qid in qids]  # O(k)"
    },
    {
      "mistake": "Forgetting to update index when posting question",
      "why_wrong": "getQuestionsByTag and getQuestionsByUser will return incomplete results",
      "correct_approach": "Update ALL relevant indexes in postQuestion",
      "code_wrong": "def post_question(...):\n    self._questions[q.id] = q\n    # Forgot to update indexes!",
      "code_correct": "def post_question(...):\n    self._questions[q.id] = q\n    self._user_questions[user_id].append(q.id)\n    for tag in tags:\n        self._tag_questions[tag].append(q.id)"
    },
    {
      "mistake": "Returning mutable internal list directly",
      "why_wrong": "External code could modify internal state",
      "correct_approach": "Return a copy or use `collections.unmodifiableList` (Java)",
      "code_wrong": "def get_questions_by_user(self, user_id):\n    return self._user_questions[user_id]  # Returns internal list!",
      "code_correct": "def get_questions_by_user(self, user_id):\n    qids = self._user_questions.get(user_id, [])\n    return [self._questions[qid] for qid in qids]  # Returns new list"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things and share my initial approach. This looks like a classic LLD problem focused on data modeling and efficient queries.",
    "clarifying_questions_to_ask": [
      "For createUser, should I throw an error for duplicate IDs or return null/existing user?",
      "Should postQuestion/postAnswer fail if the user doesn't exist?",
      "For getQuestion, should I include the full Answer objects or just answer IDs?",
      "What's the expected scale - how many operations should I optimize for?",
      "Do I need to handle concurrent access, or is single-threaded sufficient?",
      "For sorting by score when all scores are 0, should I use a secondary sort key?"
    ],
    "what_to_mention_proactively": [
      "I'll use HashMaps for O(1) entity lookup by ID",
      "I'll create secondary indexes for efficient filtered queries",
      "I'll validate inputs before creating entities",
      "Let me walk through my data model before coding"
    ],
    "communication_during_coding": [
      "I'm creating the data classes first - User, Question, Answer",
      "Now the main StackOverflow class with primary storage and indexes",
      "Notice I'm updating ALL relevant indexes when posting a question",
      "Here's the key validation - checking if question exists before allowing answer"
    ],
    "if_stuck": [
      "Let me think about what queries I need to support efficiently",
      "For getQuestionsByTag, I need to quickly find all questions with a tag - that suggests an index",
      "Let me draw out the data flow to visualize the relationships"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Explain approach + data model | 10-25min: Code core methods | 25-35min: Test + edge cases | 35-45min: Discuss Part 2"
  },
  "pattern_recognition": {
    "pattern_name": "HashMap + Secondary Indexes (Inverted Index Pattern)",
    "indicators": [
      "Multiple query patterns (by ID, by attribute, by relationship)",
      "O(1) or efficient lookup requirements",
      "Entity relationships (one-to-many)",
      "Need to filter/search by different criteria"
    ],
    "similar_problems": [
      "**Design Twitter** - Users, Tweets, Follows (similar indexes needed)",
      "**Design LRU Cache** - HashMap + Doubly Linked List",
      "**Design File System** - Hierarchical data with path lookups",
      "**LC 355 - Design Twitter** - Similar user/content model",
      "**LC 380 - Insert Delete GetRandom O(1)** - Multiple data structures for different operations"
    ],
    "template": "For each query type, ask: 'What index do I need to answer this in O(1) or O(k)?'\n1. Primary storage: HashMap by ID\n2. For each filter (by user, by tag, by date): Add secondary index\n3. For relationships: Add linking index (question_id \u2192 answer_ids)"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Voting System**: Add `upvote(user_id, entity_id, entity_type)` and `downvote()` methods. Track who voted (prevent double voting) with a `Set<(user_id, entity_id)>`. Update entity score. For reputation: +10 for question upvote, +15 for answer upvote, -2 for downvote received.",
    "part_3_hint": "**Search and Filtering**: Add full-text search. Create an inverted index: `word \u2192 [question_ids]`. For advanced filtering (by date range, score range), consider sorted data structures or compute on read.",
    "data_structure_evolution": "Part 1: HashMap + List indexes \u2192 Part 2: Add Set for vote tracking \u2192 Part 3: Add inverted index for text search, possibly TreeMap for range queries"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This looks like a low-level design question for a Q&A platform like Stack Overflow. Before I dive into coding, let me make sure I understand the requirements correctly and share my approach.",
    "after_clarification": "Great, so to summarize: I need to implement user management, question posting with tags, answer posting, and several query methods. The key constraints are O(1) or O(k log k) operations and up to 10\u2075 total operations. My approach will be to use HashMaps for primary storage and secondary indexes for efficient queries. Does that sound right?",
    "while_coding": [
      "I'll start with the data classes - User, Question, and Answer as simple dataclasses...",
      "Now the main StackOverflow class. Notice I have three primary HashMaps and three secondary indexes...",
      "For postQuestion, I need to update three things: the questions HashMap, the user_questions index, and the tag_questions index for each tag...",
      "Here's the critical validation for postAnswer - I check if the question exists before creating the answer..."
    ],
    "after_coding": "Let me trace through this with a quick example to verify it works. Create user, post question, post answer, then get the question back with its answers...",
    "when_stuck_verbatim": "Let me step back and think about this. The key question is: what data structure gives me the access pattern I need? For O(1) lookup by ID, that's a HashMap. For finding all questions by a user, I need an index mapping user_id to question_ids...",
    "after_mistake": "Actually, I see an issue here - I forgot to update the tag_questions index in postQuestion. Let me add that... For each tag, I need to append the question ID to the tag's list.",
    "before_moving_on": "This handles Part 1. All operations are O(1) or O(k log k). Space is O(n) for entities plus O(n \u00d7 t) for indexes. The design is extensible for Part 2 - we can add vote tracking without changing the core structure. Ready for the follow-up?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem Decomposition**: Can you break down 'Stack Overflow' into entities and operations?",
      "**Data Modeling**: Are your entities well-designed with appropriate relationships?",
      "**Efficiency Awareness**: Do you recognize the need for indexes without being told?",
      "**Code Quality**: Clean, readable, well-structured code",
      "**Edge Case Handling**: Do you validate inputs and handle errors gracefully?",
      "**Communication**: Can you explain your design decisions clearly?"
    ],
    "bonus_points": [
      "Drawing the data model before coding",
      "Explaining WHY you chose HashMap + indexes",
      "Mentioning the trade-off between write and read performance",
      "Proactively discussing tie-breaking in sorting",
      "Clean code with good method names on first pass",
      "Asking about thread-safety / concurrent access"
    ],
    "red_flags": [
      "Jumping into code without understanding the full problem",
      "O(n) scans for every query (no indexes)",
      "Not validating that question exists before posting answer",
      "Forgetting to update indexes when adding entities",
      "Hard-coding IDs instead of generating them",
      "Not considering duplicate user IDs"
    ],
    "what_differentiates_strong_candidates": "Strong candidates think like database designers - they immediately recognize that different query patterns need different indexes. They communicate the trade-offs (more indexes = faster reads, slower writes, more space). They write clean code with validation and handle edge cases naturally. They treat this as building a real system, not just passing test cases."
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions, identify key operations (CRUD + queries), confirm constraints",
    "by_10_min": "Explain data model (entities + relationships), identify need for indexes, get buy-in on approach",
    "by_20_min": "Core classes done, postQuestion and postAnswer implemented with index updates",
    "by_25_min": "Query methods implemented (getQuestion, getQuestionsByUser, getQuestionsByTag)",
    "by_30_min": "Edge cases handled, dry run complete, complexity discussed",
    "by_35_min": "Part 1 finished, ready for Part 2 (voting)",
    "warning_signs": "If still clarifying at 10min or still on first method at 20min, you're behind. Simplify and focus on core functionality."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see an issue - I forgot to update the X index. Let me fix that.' Add the missing code, briefly explain why it was needed, and move on. Interviewers expect bugs; they evaluate your debugging process.",
    "when_you_dont_know_syntax": "Say: 'I don't remember if it's getOrDefault or computeIfAbsent in Java, but conceptually I need to get the list or create empty one. Let me use the pattern that works.' Focus on logic, not syntax.",
    "when_approach_is_wrong": "Say: 'Actually, scanning all questions for each getQuestionsByTag won't meet the O(1) requirement. Let me add an index - a HashMap from tag to question IDs.' Pivot cleanly.",
    "when_completely_stuck": "Say: 'I'm stuck on how to efficiently support getQuestionsByTag. Could you give me a hint about what data structure might help?' Asking shows self-awareness.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on postQuestion and getQuestionsByTag - those are the most complex. I'll explain the pattern for the others.' Prioritize demonstrating the key insights."
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling and many companies allow AI tools. Use them wisely to augment, not replace, your thinking.",
    "what_to_do": [
      "Use AI for boilerplate (dataclass definitions, imports, docstrings)",
      "Use for syntax you forgot (`defaultdict` usage, `sorted` key functions)",
      "Let it autocomplete obvious code (getters, __repr__ methods)",
      "Generate test cases from your examples"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for solution",
      "Don't accept complex suggestions without understanding them",
      "Don't let AI choose your data structures - YOU decide, AI implements",
      "Don't skip explaining your approach because AI wrote it"
    ],
    "how_to_demonstrate_understanding": "If AI suggests using defaultdict, explain: 'I'm using defaultdict(list) so I don't need to check if a key exists before appending. It automatically creates an empty list for new keys.' Show you understand every line.",
    "expectation_adjustment": "With AI, interviewers expect you to complete MORE parts and with HIGHER quality. If you're slower with AI than you'd be without, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing an entity-relationship diagram before coding",
      "Immediately recognizing need for secondary indexes without being prompted",
      "Discussing the read vs write trade-off of indexing",
      "Clean, production-quality code with docstrings on first pass",
      "Proactively mentioning what you'd add for production (logging, thread-safety, metrics)",
      "Asking about tie-breaking behavior in sorting"
    ],
    "subtle_signals_of_experience": [
      "Using defensive copies for mutable inputs (tags = list(tags))",
      "Using underscore prefix for private attributes",
      "Separating ID generation into helper methods",
      "Including a runnable demo/main function",
      "Testing incrementally as you code"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Starting to code without explaining your approach",
      "Staying silent for more than 30 seconds",
      "Getting defensive when interviewer suggests an improvement",
      "Not asking any clarifying questions"
    ],
    "technical": [
      "O(n) scan for every query (no understanding of indexing)",
      "Not validating inputs (question exists? user exists?)",
      "Hardcoding IDs ('q1') instead of generating them",
      "Returning wrong types (None vs empty list)",
      "Not updating indexes when adding entities"
    ],
    "communication": [
      "Using jargon without explaining (\"I'll use an inverted index\" - explain what that means)",
      "Going too deep into irrelevant details (thread-safety before basic correctness)",
      "Not summarizing your approach before coding",
      "Not explaining WHY you chose certain data structures"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2705 All 6 required methods implemented",
      "\u2705 createUser handles duplicate IDs",
      "\u2705 postQuestion updates all indexes (user_questions, tag_questions)",
      "\u2705 postAnswer validates question exists",
      "\u2705 getQuestionsByUser sorted by created_at DESC",
      "\u2705 getQuestionsByTag sorted by score DESC",
      "\u2705 Traced through at least one example",
      "\u2705 Discussed time and space complexity",
      "\u2705 Mentioned key edge cases"
    ],
    "quick_code_review": [
      "No magic strings (IDs generated, not hardcoded)",
      "Consistent naming (snake_case for Python, camelCase for Java)",
      "Proper indentation",
      "No unused variables",
      "Input validation where required"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation**: Check string lengths, sanitize HTML in body",
      "**Logging**: Log all operations for debugging and audit",
      "**Thread-safety**: Use concurrent data structures or locks",
      "**Persistence**: Connect to a real database instead of in-memory",
      "**Rate limiting**: Prevent spam/abuse",
      "**Pagination**: Return paginated results for large query results",
      "**Soft deletes**: Mark as deleted instead of hard delete",
      "**Timestamps**: Use UTC, consider timezone handling"
    ],
    "why_not_in_interview": "Keep interview code focused on demonstrating the core design. Mention these verbally to show senior thinking, but implementing them all would take too long and distract from the main problem.",
    "how_to_mention": "Say: 'In production, I'd also add input validation, logging, and thread-safety. For this interview, I'll focus on the core logic and data structures, but happy to discuss any of those if you'd like.'"
  },
  "generated_at": "2026-01-18T18:52:58.360390",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}