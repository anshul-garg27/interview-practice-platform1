{
  "problem_title": "Stack Overflow API Design - Part 3: Search and Filtering",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 3 adds comprehensive search capabilities to the platform. While Parts 1-2 focused on CRUD operations and voting, Part 3 requires building an efficient search infrastructure with inverted indexes. The challenge shifts from simple data storage to building a mini search engine with text matching, tag filtering, and result ranking.",
    "new_requirements": [
      "Full-text search across question titles and bodies with case-insensitive, partial-word matching",
      "Tag-based filtering with both AND (intersection) and OR (union) logic",
      "Relevance scoring that ranks results by number of query word matches",
      "Top questions retrieval sorted by score",
      "Recent questions retrieval sorted by date",
      "Unanswered questions filtering"
    ],
    "new_constraints": [
      "Search must be case-insensitive ('Java' matches 'java')",
      "Partial word matching required ('java' matches 'JavaScript')",
      "Results must be sorted by relevance (match count)",
      "Tag matching uses lowercase normalization"
    ],
    "key_insight": "Pre-build an inverted index on question insertion to enable O(1) word lookups during search. Instead of scanning all questions for each search, maintain a mapping from words \u2192 question IDs. This transforms search from O(n \u00d7 m) to O(k \u00d7 avg_matches) where k is query word count."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Full-text search in titles and bodies",
        "how_met": "_word_index maps each word to question IDs; search checks all indexed words for partial matches",
        "gotchas": [
          "Must handle partial matching by checking if query word is substring of indexed word",
          "Title matches should potentially rank higher"
        ]
      },
      {
        "requirement": "Case-insensitive matching",
        "how_met": "_tokenize() lowercases all text before indexing and searching",
        "gotchas": [
          "Normalize both indexed content and search queries",
          "Don't forget to lowercase tags too"
        ]
      },
      {
        "requirement": "Tag filtering with AND/OR logic",
        "how_met": "_tag_index maps tags to question IDs; AND uses set intersection, OR uses set union",
        "gotchas": [
          "Empty intersection should return empty set, not crash",
          "Handle case where tag doesn't exist in index"
        ]
      },
      {
        "requirement": "Relevance-based sorting",
        "how_met": "_calculate_relevance() counts word matches; results sorted by relevance desc, then date desc",
        "gotchas": [
          "Must recalculate relevance for each candidate, not just use index",
          "Secondary sort by date for stability"
        ]
      },
      {
        "requirement": "Top/Recent/Unanswered queries",
        "how_met": "Simple list operations with appropriate sorting keys",
        "gotchas": [
          "Handle limit <= 0 edge case",
          "Sort must be stable for consistent results"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "searchQuestions",
        "target": "O(k \u00d7 m + r log r)",
        "achieved": "O(k \u00d7 w \u00d7 m + r log r)",
        "why": "k=query words, w=index words checked for partial match, m=avg matches per word, r=results. The extra w factor is due to partial matching requirement."
      },
      {
        "operation": "searchByTags",
        "target": "O(t \u00d7 q)",
        "achieved": "O(t \u00d7 q + r log r)",
        "why": "t=tags, q=avg questions per tag, r=results. Set operations are efficient."
      },
      {
        "operation": "getTopQuestions",
        "target": "O(n log n)",
        "achieved": "O(n log n)",
        "why": "Must sort all questions. Could be optimized with heap to O(n + k log n)."
      },
      {
        "operation": "getUnansweredQuestions",
        "target": "O(n log n)",
        "achieved": "O(n log n)",
        "why": "Filter then sort."
      }
    ],
    "non_goals": [
      "Real-time index updates (we rebuild on insert only)",
      "Fuzzy matching or typo tolerance",
      "TF-IDF or advanced relevance scoring",
      "Pagination (would add in production)",
      "Caching search results"
    ]
  },
  "assumptions": [
    "Questions are not edited after creation (no index update needed for edits)",
    "Partial matching means 'substring contains' not 'prefix match'",
    "Relevance = count of matching words, with title matches worth 2x",
    "Empty search returns empty list, not all questions",
    "Tags are single words without spaces"
  ],
  "tradeoffs": [
    {
      "decision": "Inverted index vs linear scan",
      "chosen": "Inverted index",
      "why": "Enables fast lookups even with large question counts; index built incrementally on insert",
      "alternative": "Linear scan through all questions",
      "when_to_switch": "Never for production; linear scan only acceptable for < 100 questions"
    },
    {
      "decision": "Full partial matching vs prefix-only",
      "chosen": "Full partial matching (substring contains)",
      "why": "Problem requirement states 'java matches JavaScript'",
      "alternative": "Prefix matching or exact word matching",
      "when_to_switch": "If partial matching causes too many false positives or performance issues"
    },
    {
      "decision": "Recalculate relevance vs store in index",
      "chosen": "Recalculate at query time",
      "why": "Relevance depends on specific query words which vary per search",
      "alternative": "Pre-computed relevance scores per word pair",
      "when_to_switch": "For very hot queries, could cache common searches"
    },
    {
      "decision": "Simple sort vs heap for top-k",
      "chosen": "Simple sort",
      "why": "Cleaner code; heap optimization matters only at scale",
      "alternative": "Use heapq.nlargest for top-k queries",
      "when_to_switch": "When n >> k and performance is measured bottleneck"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Public search method signatures",
      "Question/Answer/User data classes",
      "Voting and reputation system from Part 2"
    ],
    "what_to_change": [
      "Added _word_index and _tag_index data structures",
      "Added _index_question() helper called during post_question()",
      "Added _tokenize() and _calculate_relevance() helpers"
    ],
    "interfaces_and_boundaries": "Search functionality is encapsulated in dedicated methods. Index maintenance is isolated to _index_question(). This allows Part 4 to add features like question updates (would need _reindex_question) or advanced analytics without touching search logic.",
    "invariants": [
      "Every question ID in _word_index exists in _questions",
      "Every question ID in _tag_index exists in _questions",
      "Index is always synchronized with _questions (built on insert)"
    ]
  },
  "visual_explanation": {
    "before_after": "```\n=== BEFORE (Parts 1-2): No search capability ===\n\n_questions = {\n  'q_1': Question(title='Java Arrays', ...),\n  'q_2': Question(title='Python Lists', ...)\n}\n\nTo find 'java' \u2192 must scan ALL questions O(n)\n\n=== AFTER (Part 3): Inverted index ===\n\n_questions = {same}\n\n_word_index = {\n  'java':   {'q_1'},\n  'arrays': {'q_1'},\n  'python': {'q_2'},\n  'lists':  {'q_2'}\n}\n\n_tag_index = {\n  'java':   {'q_1'},\n  'python': {'q_2'}\n}\n\nTo find 'java' \u2192 direct lookup O(1) \u2192 {'q_1'}\n```",
    "algorithm_flow": "```\n        searchQuestions(\"java spring\")\n                   \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u25bc                     \u25bc\n   tokenize()            tokenize()\n   query_words =         \n   ['java', 'spring']    \n        \u2502\n        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  For each query_word:                 \u2502\n\u2502    For each word in _word_index:      \u2502\n\u2502      if query_word in word:           \u2502\n\u2502        candidates += index[word]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc  candidates = {'q_1', 'q_3'}\n        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  For each candidate question:         \u2502\n\u2502    relevance = count_matches()        \u2502\n\u2502    results.append((relevance, q))     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u25bc  results = [(4, q_1), (3, q_3)]\n        \u2502\n   sort by relevance DESC\n        \u2502\n        \u25bc\n   return [q_1, q_3]\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Linear Scan",
      "description": "For each search, iterate through all questions and check if any query word appears in title/body. Simple to implement but scales poorly.",
      "time_complexity": "O(n \u00d7 m \u00d7 k) where n=questions, m=avg text length, k=query words",
      "space_complexity": "O(1) additional space",
      "why_not_optimal": "With 1M questions and average 500 chars, searching would require scanning 500M characters per query. Completely impractical for production."
    },
    {
      "name": "Optimal Approach - Inverted Index",
      "description": "Build an inverted index mapping words to question IDs during insertion. Search becomes a lookup + set operations. Index built incrementally, one-time cost per question.",
      "time_complexity": "O(k \u00d7 w + r log r) for search where k=query words, w=partial match checks, r=results",
      "space_complexity": "O(n \u00d7 w) additional space for index where n=questions, w=avg words per question",
      "key_insight": "Trade space for time. By pre-computing word\u2192question mappings, we transform each search from scanning all content to direct lookups."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Optimal Solution: Inverted Index with Relevance Scoring\n\n### Core Idea\nBuild two indexes when questions are created:\n1. **Word Index**: Maps each word \u2192 set of question IDs containing that word\n2. **Tag Index**: Maps each tag \u2192 set of question IDs with that tag\n\n### Implementation Strategy\n\n**1. Tokenization**\n- Convert text to lowercase\n- Remove punctuation\n- Split on whitespace\n- Store unique words\n\n**2. Indexing (on insert)**\n```\npost_question() \u2192 _index_question():\n  - Tokenize title + body\n  - For each word: _word_index[word].add(question_id)\n  - For each tag: _tag_index[tag].add(question_id)\n```\n\n**3. Search Algorithm**\n```\nsearchQuestions(query):\n  1. Tokenize query into words\n  2. For each query word, find all index entries where query_word is SUBSTRING of indexed_word\n  3. Union all matching question IDs (candidates)\n  4. For each candidate, calculate relevance score\n  5. Sort by relevance DESC, date DESC\n  6. Return sorted questions\n```\n\n**4. Tag Search**\n```\nsearchByTags(tags, matchAll):\n  If matchAll=True:  result = intersection of all tag sets\n  If matchAll=False: result = union of all tag sets\n  Sort by score DESC\n```\n\n### Why This Works\n- **Inverted index** provides O(1) lookup per word\n- **Set operations** efficiently combine results (intersection/union)\n- **Incremental indexing** means no costly rebuilds\n- **Relevance scoring** ensures best matches appear first",
    "data_structures": [
      {
        "structure": "Dict[str, Set[str]] (_word_index)",
        "purpose": "Inverted index mapping lowercase words to question IDs for fast text search"
      },
      {
        "structure": "Dict[str, Set[str]] (_tag_index)",
        "purpose": "Tag index mapping lowercase tags to question IDs for tag filtering"
      },
      {
        "structure": "List[Tuple[int, datetime, Question]]",
        "purpose": "Temporary storage for sorting search results by (relevance, date)"
      }
    ],
    "algorithm_steps": [
      "Step 1: On question creation, tokenize title and body into words (lowercase, remove punctuation)",
      "Step 2: Add question ID to _word_index for each unique word",
      "Step 3: Add question ID to _tag_index for each tag",
      "Step 4: On search, tokenize query into words",
      "Step 5: For each query word, scan index keys for partial matches (substring check)",
      "Step 6: Collect all matching question IDs (union of all matches)",
      "Step 7: For each candidate question, calculate relevance (count of query words found)",
      "Step 8: Sort candidates by relevance descending, then by date descending",
      "Step 9: Return sorted list of questions"
    ]
  },
  "solution_python_lines": [
    "from typing import Dict, List, Optional, Set",
    "from dataclasses import dataclass, field",
    "from datetime import datetime",
    "from enum import Enum",
    "from collections import defaultdict",
    "import re",
    "",
    "",
    "class VoteType(Enum):",
    "    \"\"\"Vote type enumeration.\"\"\"",
    "    UPVOTE = 1",
    "    DOWNVOTE = -1",
    "",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"User entity.\"\"\"",
    "    id: str",
    "    username: str",
    "    reputation: int = 0",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Question entity with tags and metadata.\"\"\"",
    "    id: str",
    "    author_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    score: int = 0",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "    answer_ids: List[str] = field(default_factory=list)",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Answer entity.\"\"\"",
    "    id: str",
    "    question_id: str",
    "    author_id: str",
    "    body: str",
    "    score: int = 0",
    "    is_accepted: bool = False",
    "    created_at: datetime = field(default_factory=datetime.now)",
    "",
    "",
    "class StackOverflowAPI:",
    "    \"\"\"",
    "    Stack Overflow API with Search and Filtering (Part 3).",
    "    ",
    "    Features:",
    "    - User, Question, Answer CRUD (Part 1)",
    "    - Voting and Reputation (Part 2)",
    "    - Full-text search with inverted index (Part 3)",
    "    - Tag-based filtering with AND/OR logic (Part 3)",
    "    \"\"\"",
    "",
    "    # Reputation constants",
    "    UPVOTE_QUESTION_REP = 10",
    "    DOWNVOTE_QUESTION_REP = -2",
    "    UPVOTE_ANSWER_REP = 10",
    "    DOWNVOTE_ANSWER_REP = -2",
    "    ACCEPT_ANSWER_REP = 15",
    "",
    "    def __init__(self):",
    "        \"\"\"Initialize the StackOverflow API.\"\"\"",
    "        # Core data stores (Part 1)",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "",
    "        # Voting system (Part 2)",
    "        self._votes: Dict[tuple, VoteType] = {}",
    "",
    "        # ID counters",
    "        self._question_counter = 0",
    "        self._answer_counter = 0",
    "",
    "        # Search indexes (Part 3 - NEW)",
    "        self._word_index: Dict[str, Set[str]] = defaultdict(set)",
    "        self._tag_index: Dict[str, Set[str]] = defaultdict(set)",
    "",
    "    # ==========================================",
    "    # Part 1: User Management",
    "    # ==========================================",
    "",
    "    def create_user(self, user_id: str, username: str) -> Optional[User]:",
    "        \"\"\"Create a new user.\"\"\"",
    "        if user_id in self._users:",
    "            return None",
    "        user = User(id=user_id, username=username)",
    "        self._users[user_id] = user",
    "        return user",
    "",
    "    def get_user(self, user_id: str) -> Optional[User]:",
    "        \"\"\"Get user by ID.\"\"\"",
    "        return self._users.get(user_id)",
    "",
    "    # ==========================================",
    "    # Part 1: Question Management",
    "    # ==========================================",
    "",
    "    def post_question(self, user_id: str, title: str, body: str,",
    "                      tags: List[str]) -> Optional[Question]:",
    "        \"\"\"Post a new question and index it for search.\"\"\"",
    "        if user_id not in self._users:",
    "            return None",
    "",
    "        self._question_counter += 1",
    "        question_id = f\"q_{self._question_counter}\"",
    "",
    "        question = Question(",
    "            id=question_id,",
    "            author_id=user_id,",
    "            title=title,",
    "            body=body,",
    "            tags=tags",
    "        )",
    "        self._questions[question_id] = question",
    "",
    "        # Part 3: Index the question for search",
    "        self._index_question(question)",
    "",
    "        return question",
    "",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"Get question by ID.\"\"\"",
    "        return self._questions.get(question_id)",
    "",
    "    # ==========================================",
    "    # Part 1: Answer Management",
    "    # ==========================================",
    "",
    "    def post_answer(self, user_id: str, question_id: str,",
    "                    body: str) -> Optional[Answer]:",
    "        \"\"\"Post an answer to a question.\"\"\"",
    "        if user_id not in self._users:",
    "            return None",
    "        if question_id not in self._questions:",
    "            return None",
    "",
    "        self._answer_counter += 1",
    "        answer_id = f\"a_{self._answer_counter}\"",
    "",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            author_id=user_id,",
    "            body=body",
    "        )",
    "        self._answers[answer_id] = answer",
    "        self._questions[question_id].answer_ids.append(answer_id)",
    "",
    "        return answer",
    "",
    "    def get_answer(self, answer_id: str) -> Optional[Answer]:",
    "        \"\"\"Get answer by ID.\"\"\"",
    "        return self._answers.get(answer_id)",
    "",
    "    def get_answers_for_question(self, question_id: str) -> List[Answer]:",
    "        \"\"\"Get all answers for a question.\"\"\"",
    "        question = self._questions.get(question_id)",
    "        if not question:",
    "            return []",
    "        return [self._answers[aid] for aid in question.answer_ids",
    "                if aid in self._answers]",
    "",
    "    # ==========================================",
    "    # Part 2: Voting System",
    "    # ==========================================",
    "",
    "    def vote_question(self, user_id: str, question_id: str,",
    "                      is_upvote: bool) -> bool:",
    "        \"\"\"Vote on a question. Returns True if successful.\"\"\"",
    "        if user_id not in self._users:",
    "            return False",
    "        question = self._questions.get(question_id)",
    "        if not question:",
    "            return False",
    "        if question.author_id == user_id:",
    "            return False  # Can't vote on own content",
    "",
    "        vote_key = (user_id, question_id)",
    "        new_vote = VoteType.UPVOTE if is_upvote else VoteType.DOWNVOTE",
    "",
    "        # Handle vote changes",
    "        if vote_key in self._votes:",
    "            old_vote = self._votes[vote_key]",
    "            if old_vote == new_vote:",
    "                return True  # Same vote, no change",
    "            # Reverse old vote effects",
    "            question.score -= old_vote.value",
    "            old_rep = self.UPVOTE_QUESTION_REP if old_vote == VoteType.UPVOTE else self.DOWNVOTE_QUESTION_REP",
    "            self._update_reputation(question.author_id, -old_rep)",
    "",
    "        # Apply new vote",
    "        question.score += new_vote.value",
    "        rep_change = self.UPVOTE_QUESTION_REP if is_upvote else self.DOWNVOTE_QUESTION_REP",
    "        self._update_reputation(question.author_id, rep_change)",
    "        self._votes[vote_key] = new_vote",
    "",
    "        return True",
    "",
    "    def vote_answer(self, user_id: str, answer_id: str,",
    "                    is_upvote: bool) -> bool:",
    "        \"\"\"Vote on an answer. Returns True if successful.\"\"\"",
    "        if user_id not in self._users:",
    "            return False",
    "        answer = self._answers.get(answer_id)",
    "        if not answer:",
    "            return False",
    "        if answer.author_id == user_id:",
    "            return False",
    "",
    "        vote_key = (user_id, answer_id)",
    "        new_vote = VoteType.UPVOTE if is_upvote else VoteType.DOWNVOTE",
    "",
    "        if vote_key in self._votes:",
    "            old_vote = self._votes[vote_key]",
    "            if old_vote == new_vote:",
    "                return True",
    "            answer.score -= old_vote.value",
    "            old_rep = self.UPVOTE_ANSWER_REP if old_vote == VoteType.UPVOTE else self.DOWNVOTE_ANSWER_REP",
    "            self._update_reputation(answer.author_id, -old_rep)",
    "",
    "        answer.score += new_vote.value",
    "        rep_change = self.UPVOTE_ANSWER_REP if is_upvote else self.DOWNVOTE_ANSWER_REP",
    "        self._update_reputation(answer.author_id, rep_change)",
    "        self._votes[vote_key] = new_vote",
    "",
    "        return True",
    "",
    "    def accept_answer(self, user_id: str, answer_id: str) -> bool:",
    "        \"\"\"Accept an answer. Only question author can accept.\"\"\"",
    "        answer = self._answers.get(answer_id)",
    "        if not answer:",
    "            return False",
    "        question = self._questions.get(answer.question_id)",
    "        if not question:",
    "            return False",
    "        if question.author_id != user_id:",
    "            return False",
    "        if answer.is_accepted:",
    "            return True",
    "",
    "        # Unaccept any previously accepted answer",
    "        for aid in question.answer_ids:",
    "            a = self._answers.get(aid)",
    "            if a and a.is_accepted:",
    "                a.is_accepted = False",
    "                self._update_reputation(a.author_id, -self.ACCEPT_ANSWER_REP)",
    "",
    "        answer.is_accepted = True",
    "        self._update_reputation(answer.author_id, self.ACCEPT_ANSWER_REP)",
    "        return True",
    "",
    "    def get_user_reputation(self, user_id: str) -> int:",
    "        \"\"\"Get user's current reputation.\"\"\"",
    "        user = self._users.get(user_id)",
    "        return user.reputation if user else 0",
    "",
    "    def _update_reputation(self, user_id: str, delta: int) -> None:",
    "        \"\"\"Update user's reputation by delta.\"\"\"",
    "        if user_id in self._users:",
    "            self._users[user_id].reputation += delta",
    "",
    "    # ==========================================",
    "    # Part 3: Search and Filtering (NEW)",
    "    # ==========================================",
    "",
    "    def _tokenize(self, text: str) -> List[str]:",
    "        \"\"\"",
    "        Tokenize text into lowercase words.",
    "        Removes punctuation and splits on whitespace.",
    "        ",
    "        Args:",
    "            text: Input text to tokenize",
    "            ",
    "        Returns:",
    "            List of lowercase words",
    "        \"\"\"",
    "        # Remove non-alphanumeric (keep spaces), lowercase, split",
    "        text = re.sub(r'[^a-zA-Z0-9\\s]', ' ', text.lower())",
    "        return [word for word in text.split() if word]",
    "",
    "    def _index_question(self, question: Question) -> None:",
    "        \"\"\"",
    "        Index a question for search.",
    "        Adds to both word index and tag index.",
    "        ",
    "        Time Complexity: O(w) where w = words in title + body",
    "        \"\"\"",
    "        # Index title and body words",
    "        words = set(self._tokenize(question.title))",
    "        words.update(self._tokenize(question.body))",
    "",
    "        for word in words:",
    "            self._word_index[word].add(question.id)",
    "",
    "        # Index tags (normalized to lowercase)",
    "        for tag in question.tags:",
    "            self._tag_index[tag.lower()].add(question.id)",
    "",
    "    def _calculate_relevance(self, question: Question,",
    "                             query_words: List[str]) -> int:",
    "        \"\"\"",
    "        Calculate relevance score based on word matches.",
    "        Title matches count double.",
    "        ",
    "        Args:",
    "            question: Question to score",
    "            query_words: List of query words to match",
    "            ",
    "        Returns:",
    "            Relevance score (higher = more relevant)",
    "        \"\"\"",
    "        title_words = set(self._tokenize(question.title))",
    "        body_words = set(self._tokenize(question.body))",
    "        all_words = title_words | body_words",
    "",
    "        score = 0",
    "        for query_word in query_words:",
    "            # Check for partial matches (substring check)",
    "            for word in all_words:",
    "                if query_word in word:",
    "                    # Title matches are worth more",
    "                    if word in title_words:",
    "                        score += 2",
    "                    else:",
    "                        score += 1",
    "        return score",
    "",
    "    def search_questions(self, query: str) -> List[Question]:",
    "        \"\"\"",
    "        Search questions by text query.",
    "        ",
    "        Performs case-insensitive, partial-word matching.",
    "        Results sorted by relevance (match count) descending.",
    "        ",
    "        Args:",
    "            query: Space-separated search keywords",
    "            ",
    "        Returns:",
    "            Matching questions sorted by relevance",
    "            ",
    "        Time Complexity: O(k * w + r log r) where",
    "            k = number of query words",
    "            w = words in index (for partial matching)",
    "            r = number of matching results",
    "        \"\"\"",
    "        if not query or not query.strip():",
    "            return []",
    "",
    "        query_words = self._tokenize(query)",
    "        if not query_words:",
    "            return []",
    "",
    "        # Find all potentially matching question IDs",
    "        candidate_ids: Set[str] = set()",
    "",
    "        for query_word in query_words:",
    "            # Check for partial matches in index keys",
    "            for indexed_word, question_ids in self._word_index.items():",
    "                if query_word in indexed_word:",
    "                    candidate_ids.update(question_ids)",
    "",
    "        # Calculate relevance and filter",
    "        results = []",
    "        for qid in candidate_ids:",
    "            question = self._questions.get(qid)",
    "            if question:",
    "                relevance = self._calculate_relevance(question, query_words)",
    "                if relevance > 0:",
    "                    results.append((relevance, question.created_at, question))",
    "",
    "        # Sort by relevance (desc), then by date (desc)",
    "        results.sort(key=lambda x: (-x[0], -x[1].timestamp()))",
    "",
    "        return [r[2] for r in results]",
    "",
    "    def search_by_tags(self, tags: List[str], match_all: bool) -> List[Question]:",
    "        \"\"\"",
    "        Search questions by tags with AND/OR logic.",
    "        ",
    "        Args:",
    "            tags: List of tags to filter by",
    "            match_all: True = AND logic (all tags required),",
    "                       False = OR logic (any tag matches)",
    "            ",
    "        Returns:",
    "            Matching questions sorted by score descending",
    "            ",
    "        Time Complexity: O(t * q + r log r) where",
    "            t = number of tags",
    "            q = average questions per tag",
    "            r = number of results",
    "        \"\"\"",
    "        if not tags:",
    "            return []",
    "",
    "        # Normalize tags to lowercase",
    "        tags = [tag.lower() for tag in tags]",
    "",
    "        if match_all:",
    "            # AND logic: intersection of all tag sets",
    "            result_ids: Optional[Set[str]] = None",
    "            for tag in tags:",
    "                tag_questions = self._tag_index.get(tag, set())",
    "                if result_ids is None:",
    "                    result_ids = tag_questions.copy()",
    "                else:",
    "                    result_ids &= tag_questions",
    "            result_ids = result_ids or set()",
    "        else:",
    "            # OR logic: union of all tag sets",
    "            result_ids = set()",
    "            for tag in tags:",
    "                result_ids |= self._tag_index.get(tag, set())",
    "",
    "        # Get questions and sort by score",
    "        results = []",
    "        for qid in result_ids:",
    "            question = self._questions.get(qid)",
    "            if question:",
    "                results.append(question)",
    "",
    "        results.sort(key=lambda q: (-q.score, -q.created_at.timestamp()))",
    "        return results",
    "",
    "    def get_top_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"",
    "        Get top questions by score.",
    "        ",
    "        Args:",
    "            limit: Maximum number of questions to return",
    "            ",
    "        Returns:",
    "            Top questions sorted by score descending",
    "            ",
    "        Time Complexity: O(n log n) where n = total questions",
    "        \"\"\"",
    "        if limit <= 0:",
    "            return []",
    "",
    "        questions = list(self._questions.values())",
    "        questions.sort(key=lambda q: (-q.score, -q.created_at.timestamp()))",
    "        return questions[:limit]",
    "",
    "    def get_recent_questions(self, limit: int) -> List[Question]:",
    "        \"\"\"",
    "        Get most recent questions.",
    "        ",
    "        Args:",
    "            limit: Maximum number of questions to return",
    "            ",
    "        Returns:",
    "            Questions sorted by creation date (newest first)",
    "            ",
    "        Time Complexity: O(n log n) where n = total questions",
    "        \"\"\"",
    "        if limit <= 0:",
    "            return []",
    "",
    "        questions = list(self._questions.values())",
    "        questions.sort(key=lambda q: -q.created_at.timestamp())",
    "        return questions[:limit]",
    "",
    "    def get_unanswered_questions(self) -> List[Question]:",
    "        \"\"\"",
    "        Get questions with no answers.",
    "        ",
    "        Returns:",
    "            Unanswered questions sorted by date (newest first)",
    "            ",
    "        Time Complexity: O(n log n) where n = total questions",
    "        \"\"\"",
    "        unanswered = [q for q in self._questions.values()",
    "                      if not q.answer_ids]",
    "        unanswered.sort(key=lambda q: -q.created_at.timestamp())",
    "        return unanswered",
    "",
    "",
    "def main():",
    "    \"\"\"Demonstrate Part 3: Search and Filtering.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Stack Overflow API - Part 3: Search and Filtering Demo\")",
    "    print(\"=\" * 60)",
    "",
    "    api = StackOverflowAPI()",
    "",
    "    # Create users",
    "    print(\"\\n[Setup] Creating users...\")",
    "    api.create_user(\"u1\", \"alice\")",
    "    api.create_user(\"u2\", \"bob\")",
    "    api.create_user(\"u3\", \"charlie\")",
    "",
    "    # Post questions with various tags",
    "    print(\"[Setup] Posting questions...\")",
    "    q1 = api.post_question(\"u1\", \"Java Array Tutorial\",",
    "                           \"How to use arrays in Java programming\",",
    "                           [\"java\", \"arrays\", \"beginner\"])",
    "    q2 = api.post_question(\"u2\", \"Python List Comprehension\",",
    "                           \"Guide to Python list comprehension syntax\",",
    "                           [\"python\", \"lists\", \"beginner\"])",
    "    q3 = api.post_question(\"u3\", \"Java Spring Boot Guide\",",
    "                           \"Building REST APIs with Java Spring Boot\",",
    "                           [\"java\", \"spring\", \"backend\", \"rest\"])",
    "    q4 = api.post_question(\"u1\", \"JavaScript Async Await\",",
    "                           \"Understanding async/await in JavaScript\",",
    "                           [\"javascript\", \"async\", \"nodejs\"])",
    "    q5 = api.post_question(\"u2\", \"Python Django REST\",",
    "                           \"Creating REST APIs with Python Django\",",
    "                           [\"python\", \"django\", \"backend\", \"rest\"])",
    "",
    "    # Add votes to establish different scores",
    "    print(\"[Setup] Adding votes...\")",
    "    api.vote_question(\"u2\", q1.id, True)   # q1: score=1",
    "    api.vote_question(\"u3\", q1.id, True)   # q1: score=2",
    "    api.vote_question(\"u1\", q3.id, True)   # q3: score=1",
    "    api.vote_question(\"u2\", q3.id, True)   # q3: score=2",
    "    api.vote_question(\"u3\", q3.id, True)   # q3: score=3 (highest)",
    "    api.vote_question(\"u1\", q5.id, True)   # q5: score=1",
    "",
    "    # Add answers to some questions",
    "    print(\"[Setup] Adding answers...\")",
    "    api.post_answer(\"u2\", q1.id, \"Here's how arrays work...\")",
    "    api.post_answer(\"u3\", q3.id, \"Spring Boot is great for REST...\")",
    "",
    "    # ==========================================",
    "    # SEARCH TESTS",
    "    # ==========================================",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"SEARCH TESTS\")",
    "    print(\"=\" * 60)",
    "",
    "    print(\"\\n[Test 1] searchQuestions('java'):\")",
    "    results = api.search_questions(\"java\")",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title} (score: {q.score})\")",
    "",
    "    print(\"\\n[Test 2] searchQuestions('python'):\")",
    "    results = api.search_questions(\"python\")",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title}\")",
    "",
    "    print(\"\\n[Test 3] searchQuestions('rest') - partial match:\")",
    "    results = api.search_questions(\"rest\")",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title}\")",
    "",
    "    print(\"\\n[Test 4] searchByTags(['java', 'spring'], matchAll=True):\")",
    "    results = api.search_by_tags([\"java\", \"spring\"], True)",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title} (tags: {q.tags})\")",
    "",
    "    print(\"\\n[Test 5] searchByTags(['java', 'python'], matchAll=False):\")",
    "    results = api.search_by_tags([\"java\", \"python\"], False)",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title}\")",
    "",
    "    # ==========================================",
    "    # FILTERING TESTS",
    "    # ==========================================",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"FILTERING TESTS\")",
    "    print(\"=\" * 60)",
    "",
    "    print(\"\\n[Test 6] getTopQuestions(3):\")",
    "    results = api.get_top_questions(3)",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title} (score: {q.score})\")",
    "",
    "    print(\"\\n[Test 7] getRecentQuestions(3):\")",
    "    results = api.get_recent_questions(3)",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title}\")",
    "",
    "    print(\"\\n[Test 8] getUnansweredQuestions():\")",
    "    results = api.get_unanswered_questions()",
    "    for q in results:",
    "        print(f\"  - {q.id}: {q.title} (answers: {len(q.answer_ids)})\")",
    "",
    "    # ==========================================",
    "    # EDGE CASES",
    "    # ==========================================",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"EDGE CASE TESTS\")",
    "    print(\"=\" * 60)",
    "",
    "    print(\"\\n[Test 9] Empty query:\")",
    "    results = api.search_questions(\"\")",
    "    print(f\"  Results: {len(results)} (expected: 0)\")",
    "",
    "    print(\"\\n[Test 10] Non-matching query:\")",
    "    results = api.search_questions(\"xyz123nonexistent\")",
    "    print(f\"  Results: {len(results)} (expected: 0)\")",
    "",
    "    print(\"\\n[Test 11] Empty tag list:\")",
    "    results = api.search_by_tags([], True)",
    "    print(f\"  Results: {len(results)} (expected: 0)\")",
    "",
    "    print(\"\\n[Test 12] Non-existent tag:\")",
    "    results = api.search_by_tags([\"golang\"], False)",
    "    print(f\"  Results: {len(results)} (expected: 0)\")",
    "",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"All Part 3 tests completed!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.time.Instant;",
    "import java.util.regex.Pattern;",
    "import java.util.stream.Collectors;",
    "",
    "enum VoteType {",
    "    UPVOTE(1), DOWNVOTE(-1);",
    "    public final int value;",
    "    VoteType(int value) { this.value = value; }",
    "}",
    "",
    "class User {",
    "    String id;",
    "    String username;",
    "    int reputation;",
    "    Instant createdAt;",
    "",
    "    User(String id, String username) {",
    "        this.id = id;",
    "        this.username = username;",
    "        this.reputation = 0;",
    "        this.createdAt = Instant.now();",
    "    }",
    "}",
    "",
    "class Question {",
    "    String id;",
    "    String authorId;",
    "    String title;",
    "    String body;",
    "    List<String> tags;",
    "    int score;",
    "    Instant createdAt;",
    "    List<String> answerIds;",
    "",
    "    Question(String id, String authorId, String title, String body, List<String> tags) {",
    "        this.id = id;",
    "        this.authorId = authorId;",
    "        this.title = title;",
    "        this.body = body;",
    "        this.tags = new ArrayList<>(tags);",
    "        this.score = 0;",
    "        this.createdAt = Instant.now();",
    "        this.answerIds = new ArrayList<>();",
    "    }",
    "}",
    "",
    "class Answer {",
    "    String id;",
    "    String questionId;",
    "    String authorId;",
    "    String body;",
    "    int score;",
    "    boolean isAccepted;",
    "    Instant createdAt;",
    "",
    "    Answer(String id, String questionId, String authorId, String body) {",
    "        this.id = id;",
    "        this.questionId = questionId;",
    "        this.authorId = authorId;",
    "        this.body = body;",
    "        this.score = 0;",
    "        this.isAccepted = false;",
    "        this.createdAt = Instant.now();",
    "    }",
    "}",
    "",
    "public class StackOverflowAPI {",
    "    private static final int UPVOTE_REP = 10;",
    "    private static final int DOWNVOTE_REP = -2;",
    "    private static final int ACCEPT_REP = 15;",
    "",
    "    private Map<String, User> users = new HashMap<>();",
    "    private Map<String, Question> questions = new HashMap<>();",
    "    private Map<String, Answer> answers = new HashMap<>();",
    "    private Map<String, VoteType> votes = new HashMap<>();",
    "",
    "    private int questionCounter = 0;",
    "    private int answerCounter = 0;",
    "",
    "    // Part 3: Search indexes",
    "    private Map<String, Set<String>> wordIndex = new HashMap<>();",
    "    private Map<String, Set<String>> tagIndex = new HashMap<>();",
    "",
    "    private static final Pattern NON_ALPHANUM = Pattern.compile(\"[^a-zA-Z0-9\\\\s]\");",
    "",
    "    // ==========================================",
    "    // Part 1: User Management",
    "    // ==========================================",
    "",
    "    public User createUser(String userId, String username) {",
    "        if (users.containsKey(userId)) return null;",
    "        User user = new User(userId, username);",
    "        users.put(userId, user);",
    "        return user;",
    "    }",
    "",
    "    public User getUser(String userId) {",
    "        return users.get(userId);",
    "    }",
    "",
    "    // ==========================================",
    "    // Part 1: Question Management",
    "    // ==========================================",
    "",
    "    public Question postQuestion(String userId, String title, String body, List<String> tags) {",
    "        if (!users.containsKey(userId)) return null;",
    "",
    "        String questionId = \"q_\" + (++questionCounter);",
    "        Question question = new Question(questionId, userId, title, body, tags);",
    "        questions.put(questionId, question);",
    "",
    "        // Part 3: Index the question",
    "        indexQuestion(question);",
    "",
    "        return question;",
    "    }",
    "",
    "    public Question getQuestion(String questionId) {",
    "        return questions.get(questionId);",
    "    }",
    "",
    "    // ==========================================",
    "    // Part 1: Answer Management",
    "    // ==========================================",
    "",
    "    public Answer postAnswer(String userId, String questionId, String body) {",
    "        if (!users.containsKey(userId)) return null;",
    "        if (!questions.containsKey(questionId)) return null;",
    "",
    "        String answerId = \"a_\" + (++answerCounter);",
    "        Answer answer = new Answer(answerId, questionId, userId, body);",
    "        answers.put(answerId, answer);",
    "        questions.get(questionId).answerIds.add(answerId);",
    "",
    "        return answer;",
    "    }",
    "",
    "    public List<Answer> getAnswersForQuestion(String questionId) {",
    "        Question q = questions.get(questionId);",
    "        if (q == null) return Collections.emptyList();",
    "        return q.answerIds.stream()",
    "            .map(answers::get)",
    "            .filter(Objects::nonNull)",
    "            .collect(Collectors.toList());",
    "    }",
    "",
    "    // ==========================================",
    "    // Part 2: Voting System",
    "    // ==========================================",
    "",
    "    public boolean voteQuestion(String userId, String questionId, boolean isUpvote) {",
    "        if (!users.containsKey(userId)) return false;",
    "        Question q = questions.get(questionId);",
    "        if (q == null || q.authorId.equals(userId)) return false;",
    "",
    "        String voteKey = userId + \":\" + questionId;",
    "        VoteType newVote = isUpvote ? VoteType.UPVOTE : VoteType.DOWNVOTE;",
    "",
    "        if (votes.containsKey(voteKey)) {",
    "            VoteType oldVote = votes.get(voteKey);",
    "            if (oldVote == newVote) return true;",
    "            q.score -= oldVote.value;",
    "            int oldRep = oldVote == VoteType.UPVOTE ? UPVOTE_REP : DOWNVOTE_REP;",
    "            updateReputation(q.authorId, -oldRep);",
    "        }",
    "",
    "        q.score += newVote.value;",
    "        updateReputation(q.authorId, isUpvote ? UPVOTE_REP : DOWNVOTE_REP);",
    "        votes.put(voteKey, newVote);",
    "        return true;",
    "    }",
    "",
    "    public boolean voteAnswer(String userId, String answerId, boolean isUpvote) {",
    "        if (!users.containsKey(userId)) return false;",
    "        Answer a = answers.get(answerId);",
    "        if (a == null || a.authorId.equals(userId)) return false;",
    "",
    "        String voteKey = userId + \":\" + answerId;",
    "        VoteType newVote = isUpvote ? VoteType.UPVOTE : VoteType.DOWNVOTE;",
    "",
    "        if (votes.containsKey(voteKey)) {",
    "            VoteType oldVote = votes.get(voteKey);",
    "            if (oldVote == newVote) return true;",
    "            a.score -= oldVote.value;",
    "            int oldRep = oldVote == VoteType.UPVOTE ? UPVOTE_REP : DOWNVOTE_REP;",
    "            updateReputation(a.authorId, -oldRep);",
    "        }",
    "",
    "        a.score += newVote.value;",
    "        updateReputation(a.authorId, isUpvote ? UPVOTE_REP : DOWNVOTE_REP);",
    "        votes.put(voteKey, newVote);",
    "        return true;",
    "    }",
    "",
    "    private void updateReputation(String userId, int delta) {",
    "        User user = users.get(userId);",
    "        if (user != null) user.reputation += delta;",
    "    }",
    "",
    "    // ==========================================",
    "    // Part 3: Search and Filtering (NEW)",
    "    // ==========================================",
    "",
    "    private List<String> tokenize(String text) {",
    "        String cleaned = NON_ALPHANUM.matcher(text.toLowerCase()).replaceAll(\" \");",
    "        return Arrays.stream(cleaned.split(\"\\\\s+\"))",
    "            .filter(w -> !w.isEmpty())",
    "            .collect(Collectors.toList());",
    "    }",
    "",
    "    private void indexQuestion(Question question) {",
    "        Set<String> words = new HashSet<>(tokenize(question.title));",
    "        words.addAll(tokenize(question.body));",
    "",
    "        for (String word : words) {",
    "            wordIndex.computeIfAbsent(word, k -> new HashSet<>()).add(question.id);",
    "        }",
    "",
    "        for (String tag : question.tags) {",
    "            tagIndex.computeIfAbsent(tag.toLowerCase(), k -> new HashSet<>()).add(question.id);",
    "        }",
    "    }",
    "",
    "    private int calculateRelevance(Question question, List<String> queryWords) {",
    "        Set<String> titleWords = new HashSet<>(tokenize(question.title));",
    "        Set<String> bodyWords = new HashSet<>(tokenize(question.body));",
    "        Set<String> allWords = new HashSet<>(titleWords);",
    "        allWords.addAll(bodyWords);",
    "",
    "        int score = 0;",
    "        for (String queryWord : queryWords) {",
    "            for (String word : allWords) {",
    "                if (word.contains(queryWord)) {",
    "                    score += titleWords.contains(word) ? 2 : 1;",
    "                }",
    "            }",
    "        }",
    "        return score;",
    "    }",
    "",
    "    public List<Question> searchQuestions(String query) {",
    "        if (query == null || query.trim().isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "",
    "        List<String> queryWords = tokenize(query);",
    "        if (queryWords.isEmpty()) return Collections.emptyList();",
    "",
    "        Set<String> candidateIds = new HashSet<>();",
    "        for (String queryWord : queryWords) {",
    "            for (Map.Entry<String, Set<String>> entry : wordIndex.entrySet()) {",
    "                if (entry.getKey().contains(queryWord)) {",
    "                    candidateIds.addAll(entry.getValue());",
    "                }",
    "            }",
    "        }",
    "",
    "        List<Question> results = new ArrayList<>();",
    "        for (String qid : candidateIds) {",
    "            Question q = questions.get(qid);",
    "            if (q != null && calculateRelevance(q, queryWords) > 0) {",
    "                results.add(q);",
    "            }",
    "        }",
    "",
    "        results.sort((a, b) -> {",
    "            int relA = calculateRelevance(a, queryWords);",
    "            int relB = calculateRelevance(b, queryWords);",
    "            if (relA != relB) return relB - relA;",
    "            return b.createdAt.compareTo(a.createdAt);",
    "        });",
    "",
    "        return results;",
    "    }",
    "",
    "    public List<Question> searchByTags(List<String> tags, boolean matchAll) {",
    "        if (tags == null || tags.isEmpty()) return Collections.emptyList();",
    "",
    "        List<String> normalizedTags = tags.stream()",
    "            .map(String::toLowerCase)",
    "            .collect(Collectors.toList());",
    "",
    "        Set<String> resultIds;",
    "        if (matchAll) {",
    "            resultIds = null;",
    "            for (String tag : normalizedTags) {",
    "                Set<String> tagQuestions = tagIndex.getOrDefault(tag, Collections.emptySet());",
    "                if (resultIds == null) {",
    "                    resultIds = new HashSet<>(tagQuestions);",
    "                } else {",
    "                    resultIds.retainAll(tagQuestions);",
    "                }",
    "            }",
    "            if (resultIds == null) resultIds = Collections.emptySet();",
    "        } else {",
    "            resultIds = new HashSet<>();",
    "            for (String tag : normalizedTags) {",
    "                resultIds.addAll(tagIndex.getOrDefault(tag, Collections.emptySet()));",
    "            }",
    "        }",
    "",
    "        List<Question> results = resultIds.stream()",
    "            .map(questions::get)",
    "            .filter(Objects::nonNull)",
    "            .sorted((a, b) -> {",
    "                if (a.score != b.score) return b.score - a.score;",
    "                return b.createdAt.compareTo(a.createdAt);",
    "            })",
    "            .collect(Collectors.toList());",
    "",
    "        return results;",
    "    }",
    "",
    "    public List<Question> getTopQuestions(int limit) {",
    "        if (limit <= 0) return Collections.emptyList();",
    "",
    "        return questions.values().stream()",
    "            .sorted((a, b) -> {",
    "                if (a.score != b.score) return b.score - a.score;",
    "                return b.createdAt.compareTo(a.createdAt);",
    "            })",
    "            .limit(limit)",
    "            .collect(Collectors.toList());",
    "    }",
    "",
    "    public List<Question> getRecentQuestions(int limit) {",
    "        if (limit <= 0) return Collections.emptyList();",
    "",
    "        return questions.values().stream()",
    "            .sorted((a, b) -> b.createdAt.compareTo(a.createdAt))",
    "            .limit(limit)",
    "            .collect(Collectors.toList());",
    "    }",
    "",
    "    public List<Question> getUnansweredQuestions() {",
    "        return questions.values().stream()",
    "            .filter(q -> q.answerIds.isEmpty())",
    "            .sorted((a, b) -> b.createdAt.compareTo(a.createdAt))",
    "            .collect(Collectors.toList());",
    "    }",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Stack Overflow API - Part 3: Search and Filtering Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "",
    "        StackOverflowAPI api = new StackOverflowAPI();",
    "",
    "        // Setup",
    "        api.createUser(\"u1\", \"alice\");",
    "        api.createUser(\"u2\", \"bob\");",
    "",
    "        Question q1 = api.postQuestion(\"u1\", \"Java Help\",",
    "            \"Need help with Java arrays\", Arrays.asList(\"java\", \"arrays\"));",
    "        Question q2 = api.postQuestion(\"u2\", \"Python Help\",",
    "            \"Python list comprehension\", Arrays.asList(\"python\", \"lists\"));",
    "",
    "        api.voteQuestion(\"u2\", q1.id, true);",
    "",
    "        // Test search",
    "        System.out.println(\"\\nSearch 'java':\");",
    "        for (Question q : api.searchQuestions(\"java\")) {",
    "            System.out.println(\"  - \" + q.id + \": \" + q.title);",
    "        }",
    "",
    "        System.out.println(\"\\nTop questions:\");",
    "        for (Question q : api.getTopQuestions(2)) {",
    "            System.out.println(\"  - \" + q.id + \": \" + q.title + \" (score: \" + q.score + \")\");",
    "        }",
    "",
    "        System.out.println(\"\\nAll tests completed!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-6",
      "explanation": "Imports: typing for type hints, dataclasses for entities, datetime for timestamps, defaultdict for auto-initializing index maps, re for tokenization"
    },
    {
      "lines": "70-77",
      "explanation": "NEW: Initialize search indexes - _word_index maps words to question IDs, _tag_index maps tags to question IDs. Using defaultdict(set) for automatic set creation."
    },
    {
      "lines": "98-114",
      "explanation": "MODIFIED: post_question now calls _index_question() after creating the question to update search indexes."
    },
    {
      "lines": "217-228",
      "explanation": "NEW: _tokenize() converts text to lowercase, removes punctuation, splits into words. This normalizes text for consistent indexing and searching."
    },
    {
      "lines": "230-244",
      "explanation": "NEW: _index_question() adds question to both word and tag indexes. Extracts unique words from title+body, adds question ID to each word's set."
    },
    {
      "lines": "246-269",
      "explanation": "NEW: _calculate_relevance() counts how many query words match words in the question. Title matches get double weight (2 points vs 1 for body)."
    },
    {
      "lines": "271-308",
      "explanation": "NEW: searchQuestions() - The core search method. Tokenizes query, finds candidates via partial matching on index keys, calculates relevance, sorts results."
    },
    {
      "lines": "310-348",
      "explanation": "NEW: searchByTags() - Tag filtering with AND/OR logic. AND uses set intersection, OR uses set union. Results sorted by score."
    },
    {
      "lines": "350-378",
      "explanation": "NEW: getTopQuestions() and getRecentQuestions() - Simple sorting operations on all questions with limit parameter."
    },
    {
      "lines": "380-390",
      "explanation": "NEW: getUnansweredQuestions() - Filters questions where answer_ids list is empty, sorted by date."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "searchQuestions": {
          "complexity": "O(k \u00d7 W + r log r)",
          "explanation": "k=query words, W=total words in index (for partial matching), r=results. Partial matching requires checking all index keys."
        },
        "searchByTags": {
          "complexity": "O(t \u00d7 q + r log r)",
          "explanation": "t=tags, q=avg questions per tag, r=results. Set operations are efficient."
        },
        "getTopQuestions": {
          "complexity": "O(n log n)",
          "explanation": "Sort all n questions. Could optimize to O(n + k log n) with heap."
        },
        "getRecentQuestions": {
          "complexity": "O(n log n)",
          "explanation": "Sort all n questions by date."
        },
        "getUnansweredQuestions": {
          "complexity": "O(n log n)",
          "explanation": "Filter then sort."
        },
        "_index_question": {
          "complexity": "O(w)",
          "explanation": "w=words in title+body. Called once per question on insert."
        }
      },
      "overall_change": "Part 2 operations unchanged. Search adds index maintenance on insert (O(w) per question) but enables fast search. Trade insertion time for query time."
    },
    "space": {
      "additional_space": "O(Q \u00d7 W) where Q=questions, W=avg words per question",
      "explanation": "Word index stores mapping from each unique word to set of question IDs. Tag index is smaller (few tags per question). In practice, index size grows linearly with content."
    }
  },
  "dry_run": {
    "example_input": "searchQuestions('java') after posting Q1='Java Arrays' (body='How to use arrays in Java') and Q2='Python Lists'",
    "steps": [
      {
        "step": 1,
        "action": "Tokenize query",
        "state": "query_words = ['java']",
        "explanation": "Lowercase and split the query"
      },
      {
        "step": 2,
        "action": "Find candidates via partial match",
        "state": "Checking index keys: 'java', 'arrays', 'how', 'to', 'use', 'in', 'python', 'lists', 'list', 'comprehension'",
        "explanation": "For each index key, check if 'java' is substring"
      },
      {
        "step": 3,
        "action": "Collect matches",
        "state": "'java' contains 'java' \u2192 candidate_ids = {'q_1'}",
        "explanation": "Index['java'] = {'q_1'}"
      },
      {
        "step": 4,
        "action": "Calculate relevance for q_1",
        "state": "title_words={'java','arrays'}, body_words={'how','to','use','arrays','in','java'}",
        "explanation": "Tokenize q_1's content"
      },
      {
        "step": 5,
        "action": "Count matches",
        "state": "'java' in 'java' (title) \u2192 +2, 'java' in 'java' (body) \u2192 +1 = total 3",
        "explanation": "Title match counts 2, body match counts 1"
      },
      {
        "step": 6,
        "action": "Sort results",
        "state": "results = [(3, q_1)]",
        "explanation": "Single result, no sorting needed"
      },
      {
        "step": 7,
        "action": "Return",
        "state": "[Question(id='q_1', title='Java Arrays')]",
        "explanation": "Extract questions from sorted tuples"
      }
    ],
    "final_output": "[Question(id='q_1', title='Java Arrays')]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Search for a word that appears in exactly one question - should return that question",
      "searchByTags with single tag should return all questions with that tag"
    ],
    "likely_bugs": [
      "Forgetting to lowercase in tokenize() - causes case sensitivity",
      "Using word equality instead of substring check for partial matching",
      "Not calling _index_question() in post_question()",
      "Using AND logic when OR was requested (or vice versa)",
      "Forgetting secondary sort key causing unstable results"
    ],
    "recommended_logs_or_asserts": [
      "assert len(self._word_index) > 0 after indexing",
      "Log: print(f'Indexed question {q.id} with words: {words}')",
      "Log: print(f'Search found {len(candidate_ids)} candidates')"
    ],
    "how_to_localize": "1. Print query_words after tokenization. 2. Print candidate_ids after index lookup. 3. Print relevance scores before sorting. 4. Check index contents directly."
  },
  "edge_cases": [
    {
      "case": "Empty query string",
      "handling": "Return empty list immediately",
      "gotcha": "Don't forget to check both empty string and whitespace-only"
    },
    {
      "case": "Query with no matches",
      "handling": "candidate_ids stays empty, return empty list",
      "gotcha": "Partial matching still might find nothing"
    },
    {
      "case": "Empty tag list",
      "handling": "Return empty list",
      "gotcha": "AND with empty list should be empty, not all questions"
    },
    {
      "case": "Non-existent tag",
      "handling": "tagIndex.get() returns empty set, result is empty",
      "gotcha": "AND with one non-existent tag returns empty (intersection with empty set)"
    },
    {
      "case": "limit <= 0",
      "handling": "Return empty list",
      "gotcha": "Python slicing handles negative, but explicit check is clearer"
    },
    {
      "case": "Special characters in query",
      "handling": "Removed by regex in tokenize()",
      "gotcha": "Ensure regex doesn't remove valid word characters"
    }
  ],
  "test_cases": [
    {
      "name": "Basic text search",
      "input": "searchQuestions('java') with Q1='Java Help' body='Help with Java'",
      "expected": "[Q1]",
      "explanation": "'java' matches in title and body"
    },
    {
      "name": "Partial word match",
      "input": "searchQuestions('java') with Q1='JavaScript Tutorial'",
      "expected": "[Q1]",
      "explanation": "'java' is substring of 'javascript'"
    },
    {
      "name": "Tag AND logic",
      "input": "searchByTags(['java','spring'], true) with Q1 tags=['java','spring'], Q2 tags=['java','hibernate']",
      "expected": "[Q1]",
      "explanation": "Only Q1 has both tags"
    },
    {
      "name": "Tag OR logic",
      "input": "searchByTags(['java','python'], false) with Q1 tags=['java'], Q2 tags=['python']",
      "expected": "[Q1, Q2] (sorted by score)",
      "explanation": "Both match at least one tag"
    },
    {
      "name": "Unanswered filter",
      "input": "getUnansweredQuestions() with Q1 (2 answers), Q2 (0 answers)",
      "expected": "[Q2]",
      "explanation": "Only Q2 has no answers"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Case-sensitive search",
      "why_wrong": "User might search 'Java' but question has 'java'",
      "correct_approach": "Lowercase both indexed words and query words",
      "code_example_wrong": "if query_word == indexed_word:",
      "code_example_correct": "if query_word.lower() in indexed_word.lower():"
    },
    {
      "mistake": "Exact word match instead of partial",
      "why_wrong": "Problem requires 'java' to match 'JavaScript'",
      "correct_approach": "Use substring check (in operator)",
      "code_example_wrong": "if query_word in self._word_index:",
      "code_example_correct": "for indexed_word in self._word_index.keys():\\n    if query_word in indexed_word:"
    },
    {
      "mistake": "Not indexing on insert",
      "why_wrong": "Questions won't appear in search results",
      "correct_approach": "Call _index_question() at end of post_question()",
      "code_example_wrong": "# post_question returns without indexing",
      "code_example_correct": "self._index_question(question)\\nreturn question"
    },
    {
      "mistake": "Wrong set operation for tag matching",
      "why_wrong": "AND requires intersection, OR requires union",
      "correct_approach": "matchAll=True uses &=, matchAll=False uses |=",
      "code_example_wrong": "result_ids |= tag_questions  # for AND",
      "code_example_correct": "result_ids &= tag_questions  # for AND"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying this as an inverted index problem. Explain that you'll trade space for query speed by pre-computing word\u2192question mappings. Walk through the index structure before coding.",
    "what_to_mention": [
      "This is the same technique search engines use (inverted index)",
      "Index built incrementally on insert, not rebuilt for each search",
      "Partial matching adds complexity but is required by spec",
      "Relevance scoring is simple (match count) but could be extended to TF-IDF"
    ],
    "time_allocation": "2 min: understand requirements and identify inverted index pattern. 3 min: explain approach and data structures. 10 min: implement search methods. 3 min: test and handle edge cases.",
    "if_stuck": [
      "Think: How does Google search so fast? (Inverted index)",
      "Think: What's the opposite of question\u2192words? (words\u2192questions)",
      "For partial matching: iterate index keys, check if query word is substring"
    ]
  },
  "connection_to_next_part": "Part 4 might add: real-time notifications (Observer pattern), question editing (index update), advanced relevance (TF-IDF), or pagination. The current structure isolates search logic, making these extensions straightforward.",
  "communication_script": {
    "transition_from_previous": "Great, Part 2's voting system is working. For Part 3, I need to add search functionality. The key insight is to build an inverted index - mapping words to question IDs - so searches are fast lookups rather than full scans.",
    "explaining_changes": "I'll add two new data structures: _word_index and _tag_index. Both are Dict[str, Set[str]]. When a question is posted, I'll tokenize its content and add it to these indexes. Searches then become set operations on the index.",
    "while_extending_code": [
      "Adding _word_index and _tag_index to __init__...",
      "Creating _tokenize helper for consistent text processing...",
      "Adding _index_question to be called during post_question...",
      "Implementing searchQuestions with partial matching..."
    ],
    "after_completing": "Search is now implemented with O(k\u00d7W) time for queries where k is query words and W is index size. The inverted index uses O(Q\u00d7W) additional space. Ready for Part 4?"
  },
  "time_milestones": {
    "time_budget": "15-20 minutes for this part",
    "by_2_min": "Identify inverted index pattern, understand partial matching requirement",
    "by_5_min": "Explain index structure, start adding data structures",
    "by_10_min": "Core search methods implemented",
    "by_15_min": "All methods done, testing edge cases",
    "warning_signs": "If still designing at 7 min, simplify - implement exact match first, add partial matching after"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 voting affects search (e.g., score sorting), verify votes are updating scores correctly before debugging search",
    "if_new_requirement_unclear": "Ask: 'For partial matching, should \"java\" match \"JavaScript\" anywhere in the word, or only as a prefix?'",
    "if_running_behind": "Implement exact-match search first (simpler), mention partial matching as enhancement. Focus on searchQuestions, skip getTopQuestions if needed."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing inverted index as the solution",
      "Discussing how this scales (index sharding for distributed systems)",
      "Mentioning TF-IDF for better relevance scoring",
      "Noting that partial matching hurts performance and suggesting prefix trees (tries) as optimization",
      "Discussing how to handle index updates for question edits"
    ]
  },
  "pattern_recognition": {
    "pattern": "Inverted Index / Search Index Pattern",
    "indicators": [
      "Text search across many documents",
      "Need to find documents containing specific words",
      "Requirement for fast query response",
      "Partial or fuzzy matching needed"
    ],
    "similar_problems": [
      "LC 642 - Design Search Autocomplete System",
      "LC 588 - Design In-Memory File System",
      "Design Twitter search",
      "Document search engines"
    ],
    "template": "1. Tokenize content on insert\\n2. Add to inverted index: word \u2192 Set[docId]\\n3. On query: tokenize query, lookup each word, combine results\\n4. Score and sort results"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'search questions by text', I immediately think inverted index",
      "why": "Linear scan is O(n\u00d7m) for each query, unacceptable at scale. Inverted index is the standard solution."
    },
    {
      "step": 2,
      "thought": "Partial matching complicates things - can't do O(1) lookup",
      "why": "'java' matching 'javascript' requires checking if query word is SUBSTRING of index keys"
    },
    {
      "step": 3,
      "thought": "Tag filtering is set operations",
      "why": "AND = intersection, OR = union. Very efficient with HashSets."
    },
    {
      "step": 4,
      "thought": "Relevance needs to be calculated at query time",
      "why": "Relevance depends on specific query words, can't pre-compute for all possible queries"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize inverted index is the right pattern?",
      "Can you extend existing code without breaking Part 1-2?",
      "Do you understand set operations for AND/OR logic?",
      "Can you handle the partial matching requirement correctly?"
    ],
    "bonus_points": [
      "Discussing index updates for question edits",
      "Mentioning TF-IDF or BM25 for production relevance",
      "Noting the space-time tradeoff explicitly",
      "Discussing how to scale (sharding by word prefix)"
    ],
    "red_flags": [
      "Implementing linear scan through all questions",
      "Not understanding why inverted index is needed",
      "Confusing AND/OR logic for tag filtering",
      "Breaking the voting system while adding search"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate the tokenize regex pattern",
      "Let AI help with Python sorting key syntax",
      "Use AI for set operation methods if unsure"
    ],
    "what_not_to_do": [
      "Don't let AI decide on linear scan vs inverted index",
      "Verify the partial matching logic is correct",
      "Ensure index is updated on insert, not rebuilt on search"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping to code without explaining inverted index concept",
      "Not asking about edge cases (empty query, no matches)"
    ],
    "technical": [
      "Using linear scan instead of inverted index",
      "Forgetting to index questions on insert",
      "Case-sensitive matching",
      "Wrong set operation for AND vs OR"
    ],
    "communication": [
      "Not explaining WHY inverted index is needed",
      "Not mentioning complexity improvement over naive approach"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "searchQuestions returns results sorted by relevance",
      "searchByTags handles both AND and OR correctly",
      "Case-insensitive matching works",
      "Partial word matching works ('java' finds 'javascript')",
      "Empty queries return empty lists",
      "Index is built during post_question"
    ],
    "quick_code_review": [
      "All new methods have docstrings",
      "Type hints on new methods",
      "_tokenize normalizes to lowercase",
      "_index_question called in post_question"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Index updates for question edits/deletes",
      "Pagination for search results",
      "Search result caching for common queries",
      "Stop word filtering (remove 'the', 'a', etc.)",
      "Stemming (searching 'running' finds 'run')",
      "Logging and metrics for search latency"
    ],
    "why_not_in_interview": "Focus on core algorithm; these are implementation details that don't change the fundamental approach",
    "how_to_mention": "Say: 'In production, I'd add pagination, caching for hot queries, and possibly stemming for better recall. The inverted index structure would remain the same.'"
  },
  "generated_at": "2026-01-18T18:53:38.044633",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}