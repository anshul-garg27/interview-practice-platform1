{
  "problem_title": "Song Play Analytics System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "## Initial Assessment\n\nThis is a **classic OOP Design problem** that tests:\n\n1. **Data Structure Selection** - Choosing the right structures for efficient lookups and deduplication\n2. **State Management** - Maintaining consistent state across multiple operations\n3. **Custom Sorting** - Implementing multi-level comparators\n4. **Clean API Design** - Creating intuitive, well-encapsulated interfaces\n\nThe problem is straightforward but has subtle requirements that trip up candidates who rush.",
    "pattern_recognition": "## Patterns Identified\n\n| Pattern | Why It Applies |\n|---------|----------------|\n| **HashMap for O(1) Lookup** | Need fast song retrieval by ID |\n| **Set for Deduplication** | Track unique listeners per song |\n| **OOP Encapsulation** | Song as a first-class entity |\n| **Custom Comparator** | Multi-level sort (count desc, name asc) |\n| **Auto-increment ID** | Sequential ID generation pattern |",
    "key_constraints": [
      "**IDs start from 1, not 0** - Easy to miss, causes off-by-one errors",
      "**Unique listeners only** - Same user playing same song multiple times doesn't increase count",
      "**Tie-breaking: name ascending** - When counts equal, sort alphabetically A\u2192Z",
      "**Songs with 0 listeners included** - Don't filter out unplayed songs",
      "**Error handling for invalid song IDs** - Must print specific error message format"
    ],
    "clarifying_questions": [
      "**Can the same song name be added multiple times?** \u2192 Yes, each gets a unique ID (revealed in requirements)",
      "**Are song names case-sensitive for sorting?** \u2192 Standard lexicographic (case-sensitive) assumed",
      "**What happens if play_song is called before any songs exist?** \u2192 Error message format specified",
      "**Should we handle concurrent access?** \u2192 Not required for interview scope",
      "**Is there a limit on song name characters?** \u2192 1-100 chars per constraints",
      "**Do we need to support song removal?** \u2192 Not in Part 1 requirements",
      "**What precision for listener counts?** \u2192 Integer counts, no decimals"
    ],
    "edge_cases_to_consider": [
      "**Empty analytics** - `print_analytics()` called with no songs added",
      "**Song with no plays** - Added but never played (0 unique listeners)",
      "**Same user, same song, multiple times** - Count should stay at 1",
      "**All songs tied at 0** - Should sort purely alphabetically",
      "**Very long song names** - Up to 100 characters",
      "**Large user IDs** - Up to 10^6 per constraints",
      "**Invalid song ID = 0** - Since IDs start at 1"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Auto-incrementing IDs starting from 1",
        "how_met": "Instance variable `next_id` initialized to 1, incremented after each `add_song`",
        "gotchas": [
          "Don't start from 0",
          "Don't reuse IDs even if songs could be deleted (future-proofing)"
        ]
      },
      {
        "requirement": "Track unique listeners per song",
        "how_met": "Each Song object contains a Set<Integer> for user IDs",
        "gotchas": [
          "Using List instead of Set would allow duplicates",
          "Using counter instead of Set loses ability to query which users"
        ]
      },
      {
        "requirement": "Error handling for invalid song_id",
        "how_met": "Check if song_id exists in HashMap before processing, print exact error format",
        "gotchas": [
          "Wrong error message format",
          "Forgetting to return early after error"
        ]
      },
      {
        "requirement": "Sort by unique listeners DESC, then name ASC",
        "how_met": "Custom comparator with two-level comparison",
        "gotchas": [
          "Sorting count ascending instead of descending",
          "Forgetting secondary sort criterion"
        ]
      },
      {
        "requirement": "Include songs with 0 listeners",
        "how_met": "Analytics iterates over ALL songs in HashMap, not just those with plays",
        "gotchas": [
          "Filtering out songs where listeners.size() == 0"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "add_song",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap put operation"
      },
      {
        "operation": "play_song",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup + Set add"
      },
      {
        "operation": "print_analytics",
        "target": "O(n log n)",
        "achieved": "O(n log n)",
        "why": "Sorting n songs"
      }
    ],
    "non_goals": [
      "Removing songs (not in requirements)",
      "Getting play count by specific user",
      "Time-based analytics (that's Parts 2 & 3)",
      "Thread safety (interview scope)",
      "Persistent storage"
    ]
  },
  "assumptions": [
    "Song names can have spaces and special characters",
    "User IDs are always positive integers",
    "System is single-threaded (no concurrent access)",
    "Output goes to stdout (print statements)",
    "Lexicographic sorting is case-sensitive (standard string comparison)"
  ],
  "tradeoffs": [
    {
      "decision": "Store listeners as Set vs. just count",
      "chosen": "Set<Integer>",
      "why": "Enables deduplication automatically; allows future queries like 'which users played song X'",
      "alternative": "Just store count + separate seen-tracking",
      "when_to_switch": "Never for this problem; Set is strictly better"
    },
    {
      "decision": "Song as separate class vs. inline data structure",
      "chosen": "Separate Song class",
      "why": "Better encapsulation, cleaner code, easier to extend for follow-ups",
      "alternative": "Map<Integer, Tuple<String, Set<Integer>>>",
      "when_to_switch": "Only in very constrained environments or prototyping"
    },
    {
      "decision": "HashMap for song storage vs. ArrayList",
      "chosen": "HashMap<Integer, Song>",
      "why": "O(1) lookup by ID; ArrayList would need linear search or waste space",
      "alternative": "ArrayList with index = id - 1",
      "when_to_switch": "If IDs were always dense and sequential (but HashMap is more flexible)"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Encapsulate Song state** - All song-related data in Song class",
      "**Single Responsibility** - SongAnalytics manages collection; Song manages its own data",
      "**Keep public API minimal** - Only expose required methods",
      "**Prefer composition** - SongAnalytics HAS-A collection of Songs"
    ],
    "why_this_design_scales": "The Song class can be extended with additional fields (timestamps, play events) for Parts 2 & 3 without changing the SongAnalytics API. The HashMap allows O(1) access which remains efficient as data grows.",
    "expected_followup_hooks": [
      "**Song class** - Will likely add List<PlayEvent> for tracking individual plays",
      "**play_song method** - Will return something or store timestamp",
      "**print_analytics** - May filter by time window",
      "**HashMap structure** - Stable; won't need to change"
    ],
    "invariants": [
      "Song ID is immutable once assigned",
      "next_id is always > max existing ID",
      "listeners.size() always equals unique listener count",
      "All songs in HashMap were added via add_song"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SONG ANALYTICS SYSTEM                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502\n\u2502  \u2502    add_song()    \u2502    \u2502   play_song()    \u2502                   \u2502\n\u2502  \u2502  \"Bohemian...\"   \u2502    \u2502   (id=1, user=5) \u2502                   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                   \u2502\n\u2502           \u2502                       \u2502                              \u2502\n\u2502           \u25bc                       \u25bc                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                     SONGS HASHMAP                           \u2502 \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502 \u2502\n\u2502  \u2502  \u2502 ID  \u2502                    Song Object                  \u2502  \u2502 \u2502\n\u2502  \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502 \u2502\n\u2502  \u2502  \u2502  1  \u2502 name=\"Bohemian Rhapsody\", listeners={5, 12, 8} \u2502  \u2502 \u2502\n\u2502  \u2502  \u2502  2  \u2502 name=\"Hotel California\", listeners={5}         \u2502  \u2502 \u2502\n\u2502  \u2502  \u2502  3  \u2502 name=\"Stairway to Heaven\", listeners={}        \u2502  \u2502 \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                  \u2502\n\u2502           \u2502 print_analytics()                                   \u2502\n\u2502           \u25bc                                                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  Output (sorted by listeners DESC, name ASC):               \u2502 \u2502\n\u2502  \u2502  \u2022 Bohemian Rhapsody (3 unique listeners)                   \u2502 \u2502\n\u2502  \u2502  \u2022 Hotel California (1 unique listeners)                    \u2502 \u2502\n\u2502  \u2502  \u2022 Stairway to Heaven (0 unique listeners)                  \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              DATA STRUCTURE STATE EVOLUTION                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                \u2502\n\u2502  Initial State:                                                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 next_id = 1                                              \u2502  \u2502\n\u2502  \u2502 songs = {}  (empty HashMap)                              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                \u2502\n\u2502  After add_song(\"Song A\"):                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 next_id = 2                                              \u2502  \u2502\n\u2502  \u2502 songs = {1: Song(\"Song A\", listeners={})}                \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                \u2502\n\u2502  After play_song(1, 42):                                       \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 next_id = 2                                              \u2502  \u2502\n\u2502  \u2502 songs = {1: Song(\"Song A\", listeners={42})}              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                \u2502\n\u2502  After play_song(1, 42) again:                                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 next_id = 2                                              \u2502  \u2502\n\u2502  \u2502 songs = {1: Song(\"Song A\", listeners={42})}  \u2190 NO CHANGE\u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "add_song(name) - Create new song with auto-assigned ID",
        "visualization": "```\nnext_id = 1\n\u2502\n\u25bc\nCreate Song(name=\"Song A\")\n\u2502\n\u25bc\nsongs[1] = Song(\"Song A\", {})\n\u2502\n\u25bc\nnext_id = 2  (increment)\n\u2502\n\u25bc\nReturn 1\n```",
        "key_point": "ID is assigned BEFORE incrementing next_id"
      },
      {
        "step": 2,
        "description": "play_song(song_id, user_id) - Add user to song's listener set",
        "visualization": "```\nplay_song(1, 42)\n\u2502\n\u25bc\nCheck: Is 1 in songs? \u2500\u2500Yes\u2500\u2500\u25b6 songs[1].listeners.add(42)\n\u2502                              \u2502\n\u2502                              \u25bc\n\u2502                        {42} (Set handles duplicates)\n\u2502\n\u2514\u2500\u2500\u2500No\u2500\u2500\u2500\u25b6 Print \"Error: Song ID 1 does not exist.\"\n```",
        "key_point": "Set.add() is idempotent - adding same user twice has no effect"
      },
      {
        "step": 3,
        "description": "print_analytics() - Sort and display all songs",
        "visualization": "```\nCollect all songs from HashMap\n\u2502\n\u25bc\nSort with comparator:\n  1st: listener_count DESC (3 > 2 > 1 > 0)\n  2nd: name ASC (\"Apple\" < \"Zebra\")\n\u2502\n\u25bc\nFor each song in sorted order:\n  print(\"{name} ({count} unique listeners)\")\n```",
        "key_point": "Two-level sort with OPPOSITE directions (desc then asc)"
      }
    ],
    "dry_run_table": "| Step | Operation | songs HashMap | next_id | Output |\n|------|-----------|---------------|---------|--------|\n| 1 | `SongAnalytics()` | `{}` | 1 | - |\n| 2 | `add_song(\"Song A\")` | `{1: {name:\"Song A\", listeners:{}}}` | 2 | Returns `1` |\n| 3 | `add_song(\"Song B\")` | `{1: {..}, 2: {name:\"Song B\", listeners:{}}}` | 3 | Returns `2` |\n| 4 | `play_song(1, 10)` | `{1: {.., listeners:{10}}, 2: {..}}` | 3 | - |\n| 5 | `play_song(1, 20)` | `{1: {.., listeners:{10,20}}, 2: {..}}` | 3 | - |\n| 6 | `play_song(1, 10)` | `{1: {.., listeners:{10,20}}}` \u2190 **NO CHANGE** | 3 | - |\n| 7 | `play_song(2, 10)` | `{1: {.., listeners:{10,20}}, 2: {.., listeners:{10}}}` | 3 | - |\n| 8 | `play_song(99, 10)` | (unchanged) | 3 | `Error: Song ID 99 does not exist.` |\n| 9 | `print_analytics()` | (unchanged) | 3 | `Song A (2 unique listeners)`<br>`Song B (1 unique listeners)` |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'unique listeners'**, I immediately think **Set** - it handles deduplication automatically with O(1) add/contains",
      "**When I see 'auto-incrementing ID'**, I think of a simple counter variable starting at 1, incremented after each assignment",
      "**When I see 'lookup by ID'**, I think **HashMap<Integer, Song>** for O(1) retrieval",
      "**When I see 'sorted output with tie-breaking'**, I think custom **Comparator** with two-level comparison",
      "**The key insight**: Encapsulate song data in a Song class - this makes the code cleaner and more extensible for follow-ups",
      "**I should use OOP design** because the problem explicitly asks for a class-based system and this is tagged as LLD/OOP"
    ],
    "key_insight": "## The Core Insight\n\nThe **popularity score = unique listeners** is the key metric. Using a **Set** per song gives us:\n\n1. **Automatic deduplication** - Set.add() is idempotent\n2. **O(1) count query** - Set.size() is O(1)\n3. **Future flexibility** - Can query which users played a song\n\nThis is much cleaner than manually checking \"has this user played this song before?\"",
    "why_this_works": "The solution works because:\n\n1. **HashMap** provides O(1) song lookup by ID\n2. **Set** provides O(1) user tracking with automatic deduplication\n3. **Sorting** is O(n log n) which is optimal for comparison-based sorting\n4. **Encapsulation** keeps Song-related logic contained, making the code readable and maintainable"
  },
  "approaches": [
    {
      "name": "Brute Force / Naive Approach",
      "description": "Store play events as a list of (song_id, user_id) tuples. When printing analytics, iterate through all events to count unique users per song.",
      "pseudocode": "play_song(song_id, user_id):\n  events.append((song_id, user_id))\n\nprint_analytics():\n  for each song:\n    unique_users = set()\n    for each event:\n      if event.song_id == song.id:\n        unique_users.add(event.user_id)\n    print(song.name, len(unique_users))",
      "time_complexity": "O(E) per play, O(S * E) for print_analytics where E=events, S=songs",
      "space_complexity": "O(E) for storing all events",
      "pros": [
        "Simple to implement",
        "Preserves full event history"
      ],
      "cons": [
        "Slow print_analytics",
        "Wasteful - stores duplicate events"
      ],
      "when_to_use": "Never for this problem - doesn't meet efficiency expectations"
    },
    {
      "name": "Optimal: Set-Based Unique Tracking",
      "description": "Each Song maintains a Set<Integer> of user IDs. Adding a user to the set is idempotent - duplicates are automatically ignored. Print analytics sorts all songs by set size.",
      "pseudocode": "class Song:\n  name: string\n  listeners: Set<int>\n\nplay_song(song_id, user_id):\n  songs[song_id].listeners.add(user_id)  # Set handles dedup\n\nprint_analytics():\n  sorted_songs = sort(songs.values(), \n    key=lambda s: (-s.listeners.size(), s.name))\n  for song in sorted_songs:\n    print(f\"{song.name} ({len(song.listeners)} unique listeners)\")",
      "time_complexity": "O(1) for add_song and play_song, O(n log n) for print_analytics",
      "space_complexity": "O(S + U) where S=songs, U=total unique (song, user) pairs",
      "pros": [
        "Optimal time complexity",
        "Clean separation of concerns",
        "Extensible for follow-ups"
      ],
      "cons": [
        "Slightly more code than brute force"
      ],
      "key_insight": "Set.add() is idempotent - adding the same element twice has no effect, giving us automatic deduplication"
    }
  ],
  "optimal_solution": {
    "name": "OOP Design with Set-Based Unique Listener Tracking",
    "explanation_md": "## Approach\n\nWe design two classes:\n\n### 1. Song Class\nEncapsulates all song-related data:\n- `name`: The song's display name\n- `listeners`: A `Set<Integer>` of user IDs who played this song\n\n### 2. SongAnalytics Class\nManages the song collection:\n- `songs`: `HashMap<Integer, Song>` for O(1) lookup\n- `next_id`: Counter for auto-incrementing IDs (starts at 1)\n\n### Why This Works\n\n1. **Set for Listeners**: Adding the same user multiple times to a Set is a no-op, giving us automatic deduplication\n\n2. **HashMap for Songs**: O(1) lookup when playing a song by ID\n\n3. **Custom Sorting**: Python's `sorted()` with a tuple key `(-count, name)` gives us descending count + ascending name\n\n### Complexity\n- `add_song`: O(1)\n- `play_song`: O(1) average (HashSet add)\n- `print_analytics`: O(n log n) for sorting n songs",
    "data_structures": [
      {
        "structure": "HashMap<Integer, Song>",
        "purpose": "O(1) song lookup by ID"
      },
      {
        "structure": "Set<Integer> per Song",
        "purpose": "Track unique listeners with automatic deduplication"
      },
      {
        "structure": "int next_id",
        "purpose": "Generate sequential IDs starting from 1"
      }
    ],
    "algorithm_steps": [
      "1. **add_song(name)**: Create Song object, store in HashMap with current next_id, increment next_id, return assigned ID",
      "2. **play_song(song_id, user_id)**: Validate song_id exists in HashMap; if yes, add user_id to song's listener Set; if no, print error",
      "3. **print_analytics()**: Collect all Song objects, sort by (-listener_count, name), print each in format"
    ],
    "why_set": "A Set provides:\n- O(1) average add/contains\n- Automatic deduplication (same user added twice is no-op)\n- O(1) size() for listener count"
  },
  "solution_python_lines": [
    "\"\"\"",
    "Song Play Analytics System",
    "",
    "A music streaming analytics system that tracks songs and their unique listeners.",
    "Provides sorted analytics based on popularity (unique listener count).",
    "",
    "Author: Interview Preparation Guide",
    "Complexity: O(1) for add/play, O(n log n) for analytics",
    "\"\"\"",
    "",
    "from typing import Dict, Set, List",
    "",
    "",
    "class Song:",
    "    \"\"\"",
    "    Represents a song with its name and unique listeners.",
    "    ",
    "    Attributes:",
    "        name: The display name of the song",
    "        listeners: Set of user IDs who have played this song",
    "    ",
    "    Example:",
    "        >>> song = Song(\"Bohemian Rhapsody\")",
    "        >>> song.add_listener(42)",
    "        >>> song.add_listener(42)  # Duplicate - no effect",
    "        >>> song.get_listener_count()",
    "        1",
    "    \"\"\"",
    "    ",
    "    def __init__(self, name: str) -> None:",
    "        \"\"\"Initialize a song with the given name and empty listener set.\"\"\"",
    "        self.name: str = name",
    "        self.listeners: Set[int] = set()",
    "    ",
    "    def add_listener(self, user_id: int) -> None:",
    "        \"\"\"",
    "        Add a user to this song's listener set.",
    "        ",
    "        If the user already exists in the set, this is a no-op.",
    "        This provides automatic deduplication.",
    "        ",
    "        Args:",
    "            user_id: The ID of the user playing this song",
    "        \"\"\"",
    "        self.listeners.add(user_id)",
    "    ",
    "    def get_listener_count(self) -> int:",
    "        \"\"\"Return the number of unique listeners for this song.\"\"\"",
    "        return len(self.listeners)",
    "    ",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the name of this song.\"\"\"",
    "        return self.name",
    "    ",
    "    def __repr__(self) -> str:",
    "        \"\"\"String representation for debugging.\"\"\"",
    "        return f\"Song(name='{self.name}', listeners={self.listeners})\"",
    "",
    "",
    "class SongAnalytics:",
    "    \"\"\"",
    "    Analytics system for tracking song plays and unique listeners.",
    "    ",
    "    This system allows adding songs with auto-incrementing IDs,",
    "    recording play events while tracking unique listeners only,",
    "    and generating sorted analytics reports.",
    "    ",
    "    Example:",
    "        >>> analytics = SongAnalytics()",
    "        >>> analytics.add_song(\"Song A\")",
    "        1",
    "        >>> analytics.play_song(1, 42)",
    "        >>> analytics.print_analytics()",
    "        Song A (1 unique listeners)",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"",
    "        Initialize the analytics system.",
    "        ",
    "        Creates an empty song collection and sets the next ID to 1.",
    "        \"\"\"",
    "        self._songs: Dict[int, Song] = {}",
    "        self._next_id: int = 1  # IDs start from 1, not 0!",
    "    ",
    "    def add_song(self, name: str) -> int:",
    "        \"\"\"",
    "        Add a new song to the system.",
    "        ",
    "        Args:",
    "            name: The name of the song to add",
    "        ",
    "        Returns:",
    "            The auto-assigned unique ID for the song (starting from 1)",
    "        ",
    "        Note:",
    "            Same song name can be added multiple times - each gets a unique ID.",
    "        \"\"\"",
    "        song_id = self._next_id",
    "        self._songs[song_id] = Song(name)",
    "        self._next_id += 1",
    "        return song_id",
    "    ",
    "    def play_song(self, song_id: int, user_id: int) -> None:",
    "        \"\"\"",
    "        Record a play event for the given song by the given user.",
    "        ",
    "        Args:",
    "            song_id: The ID of the song being played",
    "            user_id: The ID of the user playing the song",
    "        ",
    "        Note:",
    "            - If song_id does not exist, prints an error message",
    "            - Each user is counted only once per song, even with multiple plays",
    "        \"\"\"",
    "        if song_id not in self._songs:",
    "            print(f\"Error: Song ID {song_id} does not exist.\")",
    "            return",
    "        ",
    "        self._songs[song_id].add_listener(user_id)",
    "    ",
    "    def print_analytics(self) -> None:",
    "        \"\"\"",
    "        Print all songs sorted by unique listener count.",
    "        ",
    "        Sorting rules:",
    "            1. Primary: Unique listeners (DESCENDING - highest first)",
    "            2. Secondary: Song name (ASCENDING - alphabetical)",
    "        ",
    "        Format: \"<song_name> (<count> unique listeners)\"",
    "        ",
    "        Note:",
    "            Songs with 0 listeners are included in the output.",
    "        \"\"\"",
    "        # Get all songs and sort them",
    "        sorted_songs: List[Song] = sorted(",
    "            self._songs.values(),",
    "            key=lambda song: (-song.get_listener_count(), song.get_name())",
    "        )",
    "        ",
    "        # Print each song in the required format",
    "        for song in sorted_songs:",
    "            count = song.get_listener_count()",
    "            print(f\"{song.get_name()} ({count} unique listeners)\")",
    "",
    "",
    "def run_example_1() -> None:",
    "    \"\"\"Run Example 1: Basic Operations.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 1: Basic Operations\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    ",
    "    # Add songs",
    "    id1 = analytics.add_song(\"Song A\")",
    "    print(f\"Added 'Song A' with ID: {id1}\")",
    "    ",
    "    id2 = analytics.add_song(\"Song B\")",
    "    print(f\"Added 'Song B' with ID: {id2}\")",
    "    ",
    "    id3 = analytics.add_song(\"Song C\")",
    "    print(f\"Added 'Song C' with ID: {id3}\")",
    "    ",
    "    # Play songs",
    "    print(\"\\nPlaying songs...\")",
    "    analytics.play_song(1, 1)  # User 1 plays Song A",
    "    analytics.play_song(1, 2)  # User 2 plays Song A",
    "    analytics.play_song(2, 1)  # User 1 plays Song B",
    "    analytics.play_song(3, 3)  # User 3 plays Song C",
    "    analytics.play_song(3, 3)  # User 3 plays Song C again (no change)",
    "    ",
    "    print(\"\\nAnalytics Report:\")",
    "    analytics.print_analytics()",
    "    print()",
    "",
    "",
    "def run_example_2() -> None:",
    "    \"\"\"Run Example 2: Tie-Breaking by Name.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 2: Tie-Breaking by Name\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    ",
    "    analytics.add_song(\"Zebra\")",
    "    analytics.add_song(\"Apple\")",
    "    analytics.add_song(\"Mango\")",
    "    ",
    "    analytics.play_song(1, 100)  # Zebra: 1 listener",
    "    analytics.play_song(2, 200)  # Apple: 1 listener",
    "    analytics.play_song(3, 300)  # Mango: 1 listener",
    "    ",
    "    print(\"All songs have 1 listener - sorted alphabetically:\")",
    "    analytics.print_analytics()",
    "    print()",
    "",
    "",
    "def run_example_3() -> None:",
    "    \"\"\"Run Example 3: Invalid Song ID Error.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 3: Invalid Song ID Error\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    analytics.add_song(\"Hello\")",
    "    ",
    "    print(\"Playing valid song ID 1:\")",
    "    analytics.play_song(1, 5)",
    "    print(\"Success!\")",
    "    ",
    "    print(\"\\nPlaying invalid song ID 999:\")",
    "    analytics.play_song(999, 5)",
    "    print()",
    "",
    "",
    "def run_example_4() -> None:",
    "    \"\"\"Run Example 4: Songs with Zero Listeners.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Example 4: Songs with Zero Listeners\")",
    "    print(\"=\" * 60)",
    "    ",
    "    analytics = SongAnalytics()",
    "    analytics.add_song(\"Popular\")",
    "    analytics.add_song(\"Unpopular\")",
    "    ",
    "    analytics.play_song(1, 1)  # Only Popular gets played",
    "    ",
    "    print(\"Analytics (including songs with 0 listeners):\")",
    "    analytics.print_analytics()",
    "    print()",
    "",
    "",
    "def run_edge_cases() -> None:",
    "    \"\"\"Run additional edge case tests.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Edge Cases\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # Edge case: Same user plays same song multiple times",
    "    print(\"\\nTest: Same user plays same song multiple times\")",
    "    analytics = SongAnalytics()",
    "    analytics.add_song(\"Test Song\")",
    "    for _ in range(5):",
    "        analytics.play_song(1, 42)  # User 42 plays 5 times",
    "    print(\"User 42 played 'Test Song' 5 times:\")",
    "    analytics.print_analytics()",
    "    print(\"(Count should still be 1)\")",
    "    ",
    "    # Edge case: Many unique users",
    "    print(\"\\nTest: Many unique users for one song\")",
    "    analytics2 = SongAnalytics()",
    "    analytics2.add_song(\"Viral Hit\")",
    "    for user_id in range(1, 11):",
    "        analytics2.play_song(1, user_id)",
    "    analytics2.print_analytics()",
    "    print()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    print()",
    "    print(\"#\" * 60)",
    "    print(\"#  SONG PLAY ANALYTICS SYSTEM - DEMO\")",
    "    print(\"#\" * 60)",
    "    print()",
    "    ",
    "    run_example_1()",
    "    run_example_2()",
    "    run_example_3()",
    "    run_example_4()",
    "    run_edge_cases()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"All demos completed successfully!\")",
    "    print(\"=\" * 60)"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "",
    "/**",
    " * Represents a song with its name and unique listeners.",
    " * ",
    " * This class encapsulates all song-related data and provides",
    " * methods for tracking unique listeners.",
    " */",
    "class Song {",
    "    private final String name;",
    "    private final Set<Integer> listeners;",
    "    ",
    "    /**",
    "     * Creates a new Song with the given name.",
    "     * ",
    "     * @param name The display name of the song",
    "     */",
    "    public Song(String name) {",
    "        this.name = name;",
    "        this.listeners = new HashSet<>();",
    "    }",
    "    ",
    "    /**",
    "     * Adds a user to this song's listener set.",
    "     * If the user already exists, this is a no-op (Set behavior).",
    "     * ",
    "     * @param userId The ID of the user playing this song",
    "     */",
    "    public void addListener(int userId) {",
    "        listeners.add(userId);",
    "    }",
    "    ",
    "    /**",
    "     * Returns the number of unique listeners for this song.",
    "     * ",
    "     * @return The count of unique listeners",
    "     */",
    "    public int getListenerCount() {",
    "        return listeners.size();",
    "    }",
    "    ",
    "    /**",
    "     * Returns the name of this song.",
    "     * ",
    "     * @return The song name",
    "     */",
    "    public String getName() {",
    "        return name;",
    "    }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return \"Song{name='\" + name + \"', listeners=\" + listeners + \"}\";",
    "    }",
    "}",
    "",
    "/**",
    " * Analytics system for tracking song plays and unique listeners.",
    " * ",
    " * This system allows adding songs with auto-incrementing IDs,",
    " * recording play events while tracking unique listeners only,",
    " * and generating sorted analytics reports.",
    " * ",
    " * Example usage:",
    " * <pre>",
    " * SongAnalytics analytics = new SongAnalytics();",
    " * int id = analytics.addSong(\"Song A\");  // Returns 1",
    " * analytics.playSong(1, 42);",
    " * analytics.printAnalytics();  // Prints: Song A (1 unique listeners)",
    " * </pre>",
    " */",
    "public class SongAnalytics {",
    "    private final Map<Integer, Song> songs;",
    "    private int nextId;",
    "    ",
    "    /**",
    "     * Initializes the analytics system with an empty song collection.",
    "     * IDs start from 1, not 0.",
    "     */",
    "    public SongAnalytics() {",
    "        this.songs = new HashMap<>();",
    "        this.nextId = 1;  // IDs start from 1!",
    "    }",
    "    ",
    "    /**",
    "     * Adds a new song to the system.",
    "     * ",
    "     * @param name The name of the song to add",
    "     * @return The auto-assigned unique ID for the song (starting from 1)",
    "     */",
    "    public int addSong(String name) {",
    "        int songId = nextId;",
    "        songs.put(songId, new Song(name));",
    "        nextId++;",
    "        return songId;",
    "    }",
    "    ",
    "    /**",
    "     * Records a play event for the given song by the given user.",
    "     * ",
    "     * @param songId The ID of the song being played",
    "     * @param userId The ID of the user playing the song",
    "     */",
    "    public void playSong(int songId, int userId) {",
    "        if (!songs.containsKey(songId)) {",
    "            System.out.println(\"Error: Song ID \" + songId + \" does not exist.\");",
    "            return;",
    "        }",
    "        ",
    "        songs.get(songId).addListener(userId);",
    "    }",
    "    ",
    "    /**",
    "     * Prints all songs sorted by unique listener count.",
    "     * ",
    "     * Sorting rules:",
    "     * 1. Primary: Unique listeners (DESCENDING - highest first)",
    "     * 2. Secondary: Song name (ASCENDING - alphabetical)",
    "     */",
    "    public void printAnalytics() {",
    "        // Collect all songs",
    "        List<Song> sortedSongs = new ArrayList<>(songs.values());",
    "        ",
    "        // Sort with custom comparator",
    "        sortedSongs.sort((s1, s2) -> {",
    "            // Primary: listener count descending",
    "            int countCompare = Integer.compare(s2.getListenerCount(), s1.getListenerCount());",
    "            if (countCompare != 0) {",
    "                return countCompare;",
    "            }",
    "            // Secondary: name ascending",
    "            return s1.getName().compareTo(s2.getName());",
    "        });",
    "        ",
    "        // Print each song",
    "        for (Song song : sortedSongs) {",
    "            System.out.println(song.getName() + \" (\" + song.getListenerCount() + \" unique listeners)\");",
    "        }",
    "    }",
    "    ",
    "    // ==================== DEMO MAIN METHOD ====================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println();",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"  SONG PLAY ANALYTICS SYSTEM - JAVA DEMO\");",
    "        System.out.println(\"============================================================\");",
    "        System.out.println();",
    "        ",
    "        // Example 1: Basic Operations",
    "        System.out.println(\"--- Example 1: Basic Operations ---\");",
    "        SongAnalytics analytics = new SongAnalytics();",
    "        ",
    "        int id1 = analytics.addSong(\"Song A\");",
    "        System.out.println(\"Added 'Song A' with ID: \" + id1);",
    "        ",
    "        int id2 = analytics.addSong(\"Song B\");",
    "        System.out.println(\"Added 'Song B' with ID: \" + id2);",
    "        ",
    "        int id3 = analytics.addSong(\"Song C\");",
    "        System.out.println(\"Added 'Song C' with ID: \" + id3);",
    "        ",
    "        analytics.playSong(1, 1);  // User 1 plays Song A",
    "        analytics.playSong(1, 2);  // User 2 plays Song A",
    "        analytics.playSong(2, 1);  // User 1 plays Song B",
    "        analytics.playSong(3, 3);  // User 3 plays Song C",
    "        analytics.playSong(3, 3);  // User 3 plays Song C again (no change)",
    "        ",
    "        System.out.println(\"\\nAnalytics Report:\");",
    "        analytics.printAnalytics();",
    "        System.out.println();",
    "        ",
    "        // Example 2: Tie-Breaking",
    "        System.out.println(\"--- Example 2: Tie-Breaking by Name ---\");",
    "        SongAnalytics analytics2 = new SongAnalytics();",
    "        analytics2.addSong(\"Zebra\");",
    "        analytics2.addSong(\"Apple\");",
    "        analytics2.addSong(\"Mango\");",
    "        ",
    "        analytics2.playSong(1, 100);",
    "        analytics2.playSong(2, 200);",
    "        analytics2.playSong(3, 300);",
    "        ",
    "        System.out.println(\"All songs have 1 listener - sorted alphabetically:\");",
    "        analytics2.printAnalytics();",
    "        System.out.println();",
    "        ",
    "        // Example 3: Error Handling",
    "        System.out.println(\"--- Example 3: Error Handling ---\");",
    "        SongAnalytics analytics3 = new SongAnalytics();",
    "        analytics3.addSong(\"Hello\");",
    "        analytics3.playSong(999, 5);  // Invalid ID",
    "        System.out.println();",
    "        ",
    "        // Example 4: Zero Listeners",
    "        System.out.println(\"--- Example 4: Zero Listeners ---\");",
    "        SongAnalytics analytics4 = new SongAnalytics();",
    "        analytics4.addSong(\"Popular\");",
    "        analytics4.addSong(\"Unpopular\");",
    "        analytics4.playSong(1, 1);",
    "        analytics4.printAnalytics();",
    "        System.out.println();",
    "        ",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"  All demos completed successfully!\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-11",
      "section": "Module Docstring & Imports",
      "explanation": "We document the purpose and import `Dict`, `Set`, `List` from typing for type hints. Clean imports signal professional code quality."
    },
    {
      "lines": "14-52",
      "section": "Song Class",
      "explanation": "The Song class encapsulates:\n- `name`: The song's display name\n- `listeners`: A Set for automatic deduplication\n\nThe `add_listener` method uses Set's natural behavior - adding a duplicate is a no-op. This is the **key insight** that makes unique tracking trivial."
    },
    {
      "lines": "55-77",
      "section": "SongAnalytics.__init__",
      "explanation": "Initialize with:\n- `_songs`: Empty HashMap for O(1) song lookup\n- `_next_id = 1`: Critical! IDs start from 1, not 0\n\nUsing underscore prefix (`_songs`) signals these are internal implementation details."
    },
    {
      "lines": "79-95",
      "section": "add_song Method",
      "explanation": "The sequence is important:\n1. Capture current `next_id` as `song_id`\n2. Create Song and store in HashMap\n3. Increment `next_id`\n4. Return the captured `song_id`\n\nThis ensures the ID returned matches what was stored."
    },
    {
      "lines": "97-116",
      "section": "play_song Method",
      "explanation": "**Error handling first**: Check if song_id exists before processing. The exact error message format is specified in requirements - match it exactly.\n\nIf valid, delegate to `song.add_listener()` - let the Song class handle its own state."
    },
    {
      "lines": "118-140",
      "section": "print_analytics Method",
      "explanation": "The sorting key `(-count, name)` is the clever bit:\n- Negative count gives **descending** order (3 > 2 > 1)\n- Positive name gives **ascending** order ('A' < 'B' < 'C')\n\nPython's tuple comparison handles tie-breaking automatically."
    },
    {
      "lines": "142-end",
      "section": "Demo Main Block",
      "explanation": "A comprehensive test suite demonstrating all examples from the problem. This shows the interviewer you test your code and understand all requirements."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. After implementing `add_song`: Print `self._songs` and `self._next_id` to verify IDs increment correctly\n2. After implementing `play_song`: Print the song's listener set to verify users are added\n3. After implementing `print_analytics`: Test with known examples, verify sort order",
    "what_to_print_or_assert": [
      "assert analytics.add_song('A') == 1, 'First ID should be 1'",
      "assert analytics.add_song('B') == 2, 'Second ID should be 2'",
      "print(f'Songs map: {analytics._songs}')",
      "print(f'Listeners for song 1: {analytics._songs[1].listeners}')"
    ],
    "common_failure_modes": [
      "**Off-by-one**: Starting ID from 0 instead of 1",
      "**Wrong sort order**: Sorting count ascending instead of descending",
      "**Missing error check**: Not validating song_id before processing",
      "**Using list instead of set**: Allows duplicate listeners",
      "**Wrong error format**: Mismatching the exact error message string"
    ],
    "how_to_fix_fast": "1. **Read the error message carefully** - often reveals exact issue\n2. **Add print statements** at each step to trace data flow\n3. **Test minimal case** - one song, one user, one play\n4. **Compare with examples** - expected vs actual output"
  },
  "complexity_analysis": {
    "time": {
      "add_song": {
        "complexity": "O(1)",
        "explanation": "HashMap put + integer increment"
      },
      "play_song": {
        "complexity": "O(1) average",
        "explanation": "HashMap get O(1) + HashSet add O(1) average"
      },
      "print_analytics": {
        "complexity": "O(n log n)",
        "explanation": "Sorting n songs dominates; printing is O(n)"
      },
      "overall": "add_song: O(1), play_song: O(1), print_analytics: O(n log n)"
    },
    "space": {
      "complexity": "O(S + P) where S = songs, P = unique (song, user) pairs",
      "breakdown": "- HashMap for songs: O(S)\n- Each song's listener Set: O(users per song)\n- Total across all songs: O(P) where P = sum of all unique plays\n- next_id counter: O(1)",
      "note": "In worst case, all users play all songs: O(S * U) where U = unique users"
    },
    "can_we_do_better": "For the given requirements, this is optimal:\n- O(1) for add/play is best possible\n- O(n log n) for sorting is optimal for comparison-based sort\n- We could use O(n) counting sort if listener counts were bounded, but it's unnecessary"
  },
  "dry_run": {
    "example": "add_song(\"Song A\"), add_song(\"Song B\"), play_song(1, 10), play_song(1, 20), play_song(1, 10), play_song(2, 10), print_analytics()",
    "trace_table": "| Step | Operation | songs HashMap | next_id | Output |\n|------|-----------|---------------|---------|--------|\n| 1 | `SongAnalytics()` | `{}` | `1` | - |\n| 2 | `add_song(\"Song A\")` | `{1: Song(\"Song A\", {})}` | `2` | Returns `1` |\n| 3 | `add_song(\"Song B\")` | `{1: Song(\"Song A\", {}), 2: Song(\"Song B\", {})}` | `3` | Returns `2` |\n| 4 | `play_song(1, 10)` | `{1: Song(\"Song A\", {10}), 2: Song(\"Song B\", {})}` | `3` | - |\n| 5 | `play_song(1, 20)` | `{1: Song(\"Song A\", {10, 20}), 2: Song(\"Song B\", {})}` | `3` | - |\n| 6 | `play_song(1, 10)` | `{1: Song(\"Song A\", {10, 20})}` \u2190 **NO CHANGE** (duplicate) | `3` | - |\n| 7 | `play_song(2, 10)` | `{1: Song(\"Song A\", {10, 20}), 2: Song(\"Song B\", {10})}` | `3` | - |\n| 8 | `print_analytics()` | (unchanged) | `3` | `Song A (2 unique listeners)`<br>`Song B (1 unique listeners)` |",
    "final_answer": "Song A (2 unique listeners)\\nSong B (1 unique listeners)"
  },
  "test_cases": [
    {
      "name": "Basic - Single song, single user",
      "category": "Happy Path",
      "input": "add_song(\"Hello\"), play_song(1, 42), print_analytics()",
      "expected": "Hello (1 unique listeners)",
      "explanation": "Most basic case: one song, one play, one user"
    },
    {
      "name": "Same user plays same song multiple times",
      "category": "Deduplication",
      "input": "add_song(\"Test\"), play_song(1, 5) x4, print_analytics()",
      "expected": "Test (1 unique listeners)",
      "explanation": "User 5 plays 4 times but count stays at 1 - Set deduplication"
    },
    {
      "name": "Tie-breaking by name",
      "category": "Sorting",
      "input": "add_song(\"Zebra\"), add_song(\"Apple\"), add_song(\"Mango\"), play each once with different users",
      "expected": "Apple (1 unique listeners)\\nMango (1 unique listeners)\\nZebra (1 unique listeners)",
      "explanation": "All tied at 1 listener, sorted alphabetically A < M < Z"
    },
    {
      "name": "Invalid song ID",
      "category": "Error Handling",
      "input": "add_song(\"X\"), play_song(999, 1)",
      "expected": "Error: Song ID 999 does not exist.",
      "explanation": "Must print exact error message format"
    },
    {
      "name": "Song with zero listeners",
      "category": "Edge Case",
      "input": "add_song(\"Popular\"), add_song(\"Unpopular\"), play_song(1, 1), print_analytics()",
      "expected": "Popular (1 unique listeners)\\nUnpopular (0 unique listeners)",
      "explanation": "Unpopular has 0 listeners but still appears in output"
    },
    {
      "name": "Many users, one song",
      "category": "Scale",
      "input": "add_song(\"Viral\"), 10 different users play it",
      "expected": "Viral (10 unique listeners)",
      "explanation": "10 unique users should show count of 10"
    },
    {
      "name": "Complex sorting scenario",
      "category": "Integration",
      "input": "Songs: Alpha, Beta, Gamma with 2, 3, 2 listeners respectively",
      "expected": "Beta (3 unique listeners)\\nAlpha (2 unique listeners)\\nGamma (2 unique listeners)",
      "explanation": "Beta first (highest count), then Alpha before Gamma (alphabetical tie-break)"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Starting ID from 0 instead of 1",
      "why_wrong": "Requirements explicitly state IDs start from 1",
      "correct_approach": "Initialize next_id = 1",
      "code_wrong": "self._next_id = 0  # WRONG",
      "code_correct": "self._next_id = 1  # Correct - IDs start from 1"
    },
    {
      "mistake": "Using List instead of Set for listeners",
      "why_wrong": "Lists allow duplicates; same user would be counted multiple times",
      "correct_approach": "Use Set for automatic deduplication",
      "code_wrong": "self.listeners = []  # Allows duplicates!",
      "code_correct": "self.listeners = set()  # Automatic deduplication"
    },
    {
      "mistake": "Sorting listener count in ascending order",
      "why_wrong": "Requirements say 'descending order' - highest count first",
      "correct_approach": "Negate the count in sort key OR use reverse=True with care",
      "code_wrong": "sorted(songs, key=lambda s: (s.get_listener_count(), s.name))",
      "code_correct": "sorted(songs, key=lambda s: (-s.get_listener_count(), s.name))"
    },
    {
      "mistake": "Forgetting to handle invalid song ID",
      "why_wrong": "Will throw KeyError/NullPointerException",
      "correct_approach": "Check if song_id exists before processing",
      "code_wrong": "self._songs[song_id].add_listener(user_id)  # Crashes if invalid",
      "code_correct": "if song_id not in self._songs:\\n    print(f\"Error: Song ID {song_id} does not exist.\")\\n    return"
    },
    {
      "mistake": "Filtering out songs with 0 listeners",
      "why_wrong": "Requirements state songs with 0 listeners should be included",
      "correct_approach": "Include all songs from the HashMap",
      "code_wrong": "songs = [s for s in self._songs.values() if s.get_listener_count() > 0]",
      "code_correct": "songs = list(self._songs.values())  # Include ALL songs"
    },
    {
      "mistake": "Wrong error message format",
      "why_wrong": "Tests may check exact string match",
      "correct_approach": "Copy the exact format from requirements",
      "code_wrong": "print(f\"Song {song_id} not found\")",
      "code_correct": "print(f\"Error: Song ID {song_id} does not exist.\")"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for the problem. This looks like an OOP design problem for a music analytics system. Before I start coding, let me make sure I understand the requirements correctly...",
    "clarifying_questions_to_ask": [
      "Do IDs start from 0 or 1? (Answer: 1)",
      "If the same song name is added twice, do they get different IDs? (Answer: Yes)",
      "For the sort, is it case-sensitive comparison? (Likely: Yes, standard lexicographic)",
      "Should songs with 0 listeners appear in analytics? (Answer: Yes)",
      "What's the exact error message format for invalid song ID? (Copy from requirements)"
    ],
    "what_to_mention_proactively": [
      "I'll use a **Set** for listeners to get automatic deduplication",
      "I'll use a **HashMap** for O(1) song lookup by ID",
      "I'll create a **Song class** for clean encapsulation",
      "For sorting, I'll use a tuple key `(-count, name)` for descending count and ascending name"
    ],
    "communication_during_coding": [
      "I'm starting with the Song class since it's the simpler building block",
      "Using a Set here so that adding the same user twice is a no-op",
      "Note that I'm starting next_id at 1, not 0, per the requirements",
      "The negative sign here makes the sort descending for count"
    ],
    "if_stuck": [
      "Let me step back and think about what data structure I need for unique tracking",
      "The key insight is that Set.add() is idempotent - adding the same element twice has no effect",
      "Let me trace through an example to verify my sort order is correct"
    ],
    "time_management": "0-5min: Clarify requirements | 5-10min: Explain approach, draw data structure | 10-25min: Code Song class, then SongAnalytics | 25-35min: Test with examples, handle edge cases | 35-45min: Discuss complexity, prepare for follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Set-based Unique Tracking + Custom Multi-level Sort",
    "indicators": [
      "\"Unique\" or \"distinct\" count required",
      "Same entity can appear multiple times but should count once",
      "Multi-level sorting with different directions",
      "OOP design with encapsulated entities"
    ],
    "similar_problems": [
      "LC 347 - Top K Frequent Elements: Frequency counting + sorting",
      "LC 692 - Top K Frequent Words: Multi-level sort (freq desc, word asc)",
      "LC 355 - Design Twitter: OOP design with collections",
      "LC 1165 - Single-Row Keyboard: Mapping with HashMap"
    ],
    "template": "1. Create entity class with Set for unique tracking\n2. Create manager class with HashMap for O(1) lookup\n3. For sorting: use tuple key with signs to control direction\n4. Handle error cases before processing"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 adds **recent plays with duplicates** - you'll need to track individual play events with timestamps. Consider adding a `List<PlayEvent>` to the Song class where each PlayEvent has timestamp and user_id. The unique listener tracking stays the same.",
    "part_3_hint": "Part 3 asks for **recent unique plays** - you'll need to query listeners within a time window. Consider using a TreeMap/SortedDict keyed by timestamp for efficient range queries. The key challenge is deduplicating within the time window.",
    "data_structure_evolution": "```\nPart 1: Song { name, Set<userId> }\n         \u2193\nPart 2: Song { name, Set<userId>, List<PlayEvent> }\n         \u2193\nPart 3: Song { name, TreeMap<timestamp, userId> }\n```"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. It looks like I'm building a music analytics system that tracks unique listeners per song. Before I code, I'd like to clarify a few things and then share my approach.",
    "after_clarification": "Great, so to summarize: I need to track songs with auto-incrementing IDs starting from 1, count unique listeners per song (not total plays), and print sorted analytics with descending listener count and ascending name for ties. My approach will be to use a Song class with a Set for listeners, and a SongAnalytics class with a HashMap for O(1) lookups. Does that sound right?",
    "while_coding": [
      "I'm creating the Song class first since it's the simpler building block...",
      "Using a Set here for listeners - this gives me automatic deduplication...",
      "Note I'm initializing next_id to 1, not 0, since IDs start from 1...",
      "For the sort key, I'm using negative count for descending order..."
    ],
    "after_coding": "Let me trace through Example 1 to verify this works correctly...",
    "when_stuck_verbatim": "I'm thinking about the sort order... Let me trace through an example with tied counts to make sure I have the comparison right.",
    "after_mistake": "Oh, I see the issue - I was sorting count ascending instead of descending. Let me fix that by negating the count in the sort key.",
    "before_moving_on": "This handles Part 1. The time complexity is O(1) for add_song and play_song, O(n log n) for print_analytics due to sorting. Space is O(S + P) where S is songs and P is total unique play pairs. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem decomposition** - Can you break this into logical components (Song class, Analytics class)?",
      "**Data structure selection** - Do you recognize Set for deduplication, HashMap for lookup?",
      "**Attention to detail** - Do you catch the ID starts from 1, exact error format?",
      "**Code quality** - Clean naming, proper encapsulation, type hints?",
      "**Testing instinct** - Do you trace through examples after coding?"
    ],
    "bonus_points": [
      "Mentioning Set for deduplication immediately",
      "Drawing a quick data structure diagram before coding",
      "Catching the 'ID starts from 1' detail unprompted",
      "Explaining the sort key trick (`-count, name`) clearly",
      "Testing with the 'same user plays same song multiple times' case"
    ],
    "red_flags": [
      "Jumping to code without understanding requirements",
      "Using List instead of Set for listeners",
      "Not handling the invalid song ID error",
      "Getting the sort order wrong (ascending instead of descending)",
      "Ignoring songs with 0 listeners in output"
    ],
    "what_differentiates_strong_candidates": "Strong candidates:\n1. Ask clarifying questions that reveal edge cases\n2. Explain their approach before coding\n3. Recognize the Set pattern for uniqueness immediately\n4. Handle error cases naturally, not as an afterthought\n5. Test their code with examples after writing\n6. Discuss complexity confidently"
  },
  "time_milestones": {
    "by_5_min": "Understand problem, ask clarifying questions about IDs (start from 1?), sort order, error handling",
    "by_10_min": "Explain approach: Song class with Set, SongAnalytics with HashMap, tuple sort key for multi-level sorting",
    "by_15_min": "Song class implemented with add_listener, get_listener_count, get_name methods",
    "by_25_min": "SongAnalytics class implemented with all four methods, basic testing started",
    "by_30_min": "Edge cases handled (invalid ID, zero listeners, duplicate plays), dry run complete",
    "by_35_min": "Part 1 complete, complexity discussed, ready for Part 2",
    "warning_signs": "If still clarifying at 10 min or Song class not done by 15 min, speed up. Simplify if needed."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see the issue - I was sorting ascending instead of descending. Let me fix that.' Quickly fix it, explain briefly, and move on. Interviewers expect small bugs; they evaluate your debugging ability.",
    "when_you_dont_know_syntax": "Say: 'I don't remember if it's `compareTo` or `compare` in Java, but conceptually I need to compare these two strings lexicographically.' The interviewer may help, or you can write pseudocode.",
    "when_approach_is_wrong": "Say: 'Actually, I realize using a List won't give me unique counts. Let me switch to a Set which handles deduplication automatically.' Pivot cleanly and explain why.",
    "when_completely_stuck": "Say: 'I'm stuck on how to sort with different directions. Could you confirm that I need descending for count and ascending for name?' Asking focused questions shows self-awareness.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me focus on getting the core functionality working and explain what I'd add for edge cases.' Prioritize working code over perfect code."
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them wisely - they can help with boilerplate and syntax, but YOU must drive the solution approach.",
    "what_to_do": [
      "Use AI for generating class structure and imports",
      "Use for suggesting method signatures",
      "Use for syntax you've forgotten (e.g., Python sort key syntax)",
      "Let it autocomplete obvious code like getters/setters"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for solution",
      "Don't accept suggestions without understanding them",
      "Don't let AI decide your data structures - YOU decide, AI assists",
      "Don't blindly accept sort order - verify it matches requirements"
    ],
    "how_to_demonstrate_understanding": "If AI suggests code, explain WHY it works. Say: 'The AI suggested using a Set here, and that's correct because Set.add() is idempotent - adding the same user twice has no effect.'",
    "expectation_adjustment": "Using AI means you should complete MORE parts faster. If you're slower with AI than without, don't use it for this problem."
  },
  "signal_points": {
    "wow_factors": [
      "Immediately recognizing Set for unique tracking",
      "Drawing a quick data structure diagram unprompted",
      "Catching 'ID starts from 1' without being told",
      "Explaining the `-count` trick for descending sort elegantly",
      "Testing with the 'same user multiple plays' edge case first"
    ],
    "subtle_signals_of_experience": [
      "Using underscore prefix for internal attributes (`_songs`, `_next_id`)",
      "Writing docstrings with examples",
      "Considering thread safety (mentioning it even if not implementing)",
      "Asking about edge cases before coding",
      "Writing testable code with dependency injection potential"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Staying silent for more than 30 seconds without explaining your thinking",
      "Getting defensive when interviewer points out an issue",
      "Not asking any clarifying questions",
      "Rushing to code without understanding requirements"
    ],
    "technical": [
      "Using List instead of Set for unique tracking",
      "Starting ID from 0 instead of 1",
      "Wrong sort direction",
      "Not handling error cases",
      "Forgetting to include 0-listener songs"
    ],
    "communication": [
      "Using jargon without explaining (e.g., 'I'll use a hash map' without saying why)",
      "Going too deep into implementation details before explaining the approach",
      "Not summarizing your approach before coding",
      "Not testing after coding"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2713 IDs start from 1 (not 0)",
      "\u2713 Using Set for unique listeners (not List)",
      "\u2713 Sort: listener count DESCENDING, name ASCENDING",
      "\u2713 Error message format matches exactly",
      "\u2713 Songs with 0 listeners included in output",
      "\u2713 Traced through at least one example",
      "\u2713 Discussed time and space complexity"
    ],
    "quick_code_review": [
      "No hardcoded values (IDs, test data in production code)",
      "Consistent naming (snake_case for Python, camelCase for Java)",
      "Proper indentation (4 spaces in Python)",
      "Error handling before processing",
      "Type hints on all methods"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "Input validation (name length, non-empty strings)",
      "Logging for debugging and monitoring",
      "Thread-safety if concurrent access is possible",
      "Configuration for output format",
      "Database persistence instead of in-memory storage",
      "Rate limiting for play_song to prevent abuse"
    ],
    "why_not_in_interview": "Keep interview code focused on the core problem. Over-engineering shows poor prioritization under time constraints.",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging, and consider thread-safety. For this interview, I'll focus on the core logic.'"
  },
  "generated_at": "2026-01-18T18:50:59.179462",
  "_meta": {
    "problem_id": "song_play_analytics",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}