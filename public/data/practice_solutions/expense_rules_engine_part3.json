{
  "problem_title": "Corporate Expense Rules Engine - Part 3: Rule Creation API",
  "part_number": 3,
  "builds_on": "Part 2",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "Part 2 had hardcoded rules. Part 3 introduces dynamic rule creation at runtime via JSON configuration. We need to build a Factory + Registry pattern for creating rule instances from config, and a Composite pattern for combining rules with AND/OR logic.",
    "new_requirements": [
      "Create rules dynamically from JSON configuration",
      "Support Rule Registry for type lookup by name",
      "Implement Rule Factory for instantiation",
      "Support Composite rules with AND/OR operators",
      "Validate rule configurations",
      "Allow recursive composition of rules"
    ],
    "new_constraints": [
      "Rules must be creatable without modifying core factory code",
      "Composite rules can contain other composite rules (recursive)",
      "Config validation must fail fast with clear error messages",
      "Registry must support runtime registration of new rule types"
    ],
    "key_insight": "The Factory Pattern decouples rule creation from rule usage, while the Registry Pattern allows new rule types to be added without modifying the factory. The Composite Pattern treats individual rules and rule groups uniformly, enabling powerful rule combinations."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Dynamic rule creation from JSON",
        "how_met": "RuleFactory.create_rule() parses config and instantiates appropriate rule class",
        "gotchas": [
          "Forgetting to handle nested CompositeRules recursively"
        ]
      },
      {
        "requirement": "Rule type registry",
        "how_met": "RuleRegistry maps string type names to rule classes",
        "gotchas": [
          "Not handling unknown type gracefully"
        ]
      },
      {
        "requirement": "AND/OR composition",
        "how_met": "CompositeRule evaluates children and combines results based on operator",
        "gotchas": [
          "Getting AND/OR semantics backwards"
        ]
      },
      {
        "requirement": "Config validation",
        "how_met": "Validators check required fields and types before instantiation",
        "gotchas": [
          "Missing validation for nested rules"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "registry.lookup",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap lookup"
      },
      {
        "operation": "factory.create_rule",
        "target": "O(r) for composite with r rules",
        "achieved": "O(r)",
        "why": "Linear in number of child rules"
      },
      {
        "operation": "CompositeRule.evaluate",
        "target": "O(r) for r child rules",
        "achieved": "O(r)",
        "why": "Must evaluate each child"
      }
    ],
    "non_goals": [
      "Rule persistence to database",
      "Rule versioning",
      "Rule priority/ordering conflicts"
    ]
  },
  "assumptions": [
    "Rule type names are case-sensitive strings matching class names",
    "All rules support creation from a config dictionary via from_config() class method",
    "CompositeRule AND means 'all must pass' (any violation = composite violation)",
    "CompositeRule OR means 'at least one must pass' (all violated = composite violation)",
    "Invalid configs should raise ValueError with descriptive message"
  ],
  "tradeoffs": [
    {
      "decision": "Singleton vs Instance Registry",
      "chosen": "Instance with default singleton",
      "why": "Allows testing with isolated registries while providing convenient global access",
      "alternative": "Pure singleton",
      "when_to_switch": "If testing isolation is not a concern"
    },
    {
      "decision": "Class-based vs Callable registration",
      "chosen": "Class with from_config method",
      "why": "Type safety and consistency in how rules are created",
      "alternative": "Register factory functions",
      "when_to_switch": "If rules need complex initialization logic"
    },
    {
      "decision": "Eager vs Lazy validation",
      "chosen": "Eager validation on creation",
      "why": "Fail fast, clear error messages at configuration time",
      "alternative": "Lazy validation on first use",
      "when_to_switch": "If rule creation needs to be very fast"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Rule interface (evaluate method)",
      "RuleFactory.create_rule signature",
      "RuleRegistry.register/lookup signatures"
    ],
    "what_to_change": [
      "Adding new rule types only requires registry.register()",
      "New operators can be added to CompositeRule"
    ],
    "interfaces_and_boundaries": "Each rule type owns its own from_config() validation. The factory only orchestrates, not validates rule-specific config.",
    "invariants": [
      "Registry never contains None values",
      "All registered classes implement Rule interface",
      "CompositeRule children are always valid Rule instances"
    ]
  },
  "visual_explanation": {
    "before_after": "BEFORE (Part 2):                    AFTER (Part 3):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502  Hardcoded Rules \u2502              \u2502     JSON Config                 \u2502\\n\u2502  ban_rule = ...  \u2502              \u2502     {\\\"type\\\": \\\"BanRule\\\", ...}   \u2502\\n\u2502  limit_rule = ...\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2502\\n         \u2502                                       \u25bc\\n         \u2502                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n         \u25bc                          \u2502     RuleFactory        \u2502\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\\n\u2502   RulesEngine    \u2502                \u2502  \u2502 RuleRegistry   \u2502    \u2502\\n\u2502   .add_rule()    \u2502                \u2502  \u2502 \\\"BanRule\\\" \u2192 cls\u2502    \u2502\\n\u2502   .evaluate()    \u2502                \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n                                                   \u2502\\n                                                   \u25bc\\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n                                    \u2502  Rule Instance         \u2502\\n                                    \u2502  (BanRule, Composite)  \u2502\\n                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518",
    "algorithm_flow": "COMPOSITE RULE EVALUATION:\\n\\nAND Operator (All must pass):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502  CompositeRule(AND)                         \u2502\\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\\n\u2502  \u2502 Rule A   \u2502 \u2502 Rule B   \u2502 \u2502 Rule C   \u2502    \u2502\\n\u2502  \u2502 PASS \u2713   \u2502 \u2502 FAIL \u2717   \u2502 \u2502 PASS \u2713   \u2502    \u2502\\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\\n\u2502       \u2502            \u2502            \u2502           \u2502\\n\u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502            any(violated)?                   \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502                   YES                       \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502            COMPOSITE: FAIL \u2717                \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\nOR Operator (At least one must pass):\\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n\u2502  CompositeRule(OR)                          \u2502\\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\\n\u2502  \u2502 Rule A   \u2502 \u2502 Rule B   \u2502 \u2502 Rule C   \u2502    \u2502\\n\u2502  \u2502 FAIL \u2717   \u2502 \u2502 FAIL \u2717   \u2502 \u2502 PASS \u2713   \u2502    \u2502\\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\\n\u2502       \u2502            \u2502            \u2502           \u2502\\n\u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502            all(violated)?                   \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502                   NO                        \u2502\\n\u2502                    \u2502                        \u2502\\n\u2502            COMPOSITE: PASS \u2713                \u2502\\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518"
  },
  "approaches": [
    {
      "name": "Naive Extension - Giant Switch Statement",
      "description": "Add a big if/elif chain in a create_rule function checking type strings and manually constructing each rule type",
      "time_complexity": "O(n) where n is number of rule types for type lookup",
      "space_complexity": "O(1)",
      "why_not_optimal": "Violates Open/Closed Principle - must modify factory code for every new rule type. Not extensible at runtime. Becomes unwieldy with many rule types."
    },
    {
      "name": "Optimal Approach - Factory + Registry + Composite",
      "description": "Use Registry pattern for O(1) type lookup, Factory pattern for encapsulated creation, and Composite pattern for AND/OR combinations. Rules self-register and self-validate.",
      "time_complexity": "O(1) lookup, O(r) for composite creation with r rules",
      "space_complexity": "O(t) for t registered types",
      "key_insight": "Decouple 'what rules exist' (Registry) from 'how to create them' (Factory) from 'how to combine them' (Composite). Each rule class owns its own config validation via from_config()."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Solution Architecture\\n\\n### Pattern Combination\\n\\nWe combine **three classic design patterns**:\\n\\n1. **Registry Pattern**: A HashMap that maps type names (strings) to rule classes. This allows O(1) lookup and runtime registration of new rule types without modifying existing code.\\n\\n2. **Factory Pattern**: A single `create_rule()` method that:\\n   - Looks up the rule class from the registry\\n   - Calls the class's `from_config()` method with the config dict\\n   - Handles CompositeRule specially for recursive creation\\n\\n3. **Composite Pattern**: `CompositeRule` contains a list of child rules and an operator. It implements the same `evaluate()` interface as leaf rules, allowing uniform treatment.\\n\\n### AND/OR Semantics\\n\\n**AND**: All rules must pass (not be violated). If **any** child is violated, the composite is violated.\\n- Use case: Multiple limits that all apply\\n\\n**OR**: At least one rule must pass. Only if **all** children are violated is the composite violated.\\n- Use case: Alternative approval paths\\n\\n### Key Design Decisions\\n\\n1. **Self-describing rules**: Each rule class has a `from_config()` classmethod that knows how to parse its own config and validate it.\\n\\n2. **Recursive composition**: CompositeRule can contain other CompositeRules, enabling complex logic like `(A AND B) OR (C AND D)`.\\n\\n3. **Fail-fast validation**: Config errors raise immediately with descriptive messages, not at evaluation time.",
    "data_structures": [
      {
        "structure": "HashMap (dict)",
        "purpose": "RuleRegistry stores type_name \u2192 rule_class mapping for O(1) lookup"
      },
      {
        "structure": "List of Rules",
        "purpose": "CompositeRule stores child rules for AND/OR evaluation"
      },
      {
        "structure": "Enum/String",
        "purpose": "Operator type (AND/OR) for composite behavior"
      }
    ],
    "algorithm_steps": [
      "Step 1: RuleRegistry.register() stores rule class by type name in HashMap",
      "Step 2: RuleFactory.create_rule() extracts 'type' from config",
      "Step 3: Factory looks up rule class in registry (O(1))",
      "Step 4: If CompositeRule, recursively create child rules",
      "Step 5: Call rule_class.from_config() with config dict",
      "Step 6: from_config() validates required fields and creates instance",
      "Step 7: CompositeRule.evaluate() evaluates all children",
      "Step 8: Combine results: AND = any(violated), OR = all(violated)"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Corporate Expense Rules Engine - Part 3: Rule Creation API",
    "",
    "Implements Factory + Registry + Composite patterns for dynamic rule creation.",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from decimal import Decimal",
    "from enum import Enum",
    "from typing import Dict, List, Any, Optional, Type, Set",
    "",
    "",
    "# ============================================================================",
    "# CORE DATA STRUCTURES (from Parts 1 & 2)",
    "# ============================================================================",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Represents a corporate expense transaction.\"\"\"",
    "    expense_id: str",
    "    trip_id: Optional[str]",
    "    amount_usd: Decimal",
    "    expense_type: str",
    "    vendor_type: str",
    "    vendor_name: str",
    "    ",
    "    @classmethod",
    "    def from_dict(cls, data: Dict[str, Any]) -> 'Expense':",
    "        return cls(",
    "            expense_id=data['expense_id'],",
    "            trip_id=data.get('trip_id'),",
    "            amount_usd=Decimal(str(data['amount_usd'])),",
    "            expense_type=data['expense_type'],",
    "            vendor_type=data['vendor_type'],",
    "            vendor_name=data['vendor_name']",
    "        )",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"Details of a rule violation.\"\"\"",
    "    rule_name: str",
    "    expense_id: str",
    "    message: str",
    "    details: Dict[str, Any] = field(default_factory=dict)",
    "",
    "",
    "@dataclass",
    "class RuleResult:",
    "    \"\"\"Result of evaluating a rule against an expense.\"\"\"",
    "    violated: bool",
    "    violations: List[Violation] = field(default_factory=list)",
    "    ",
    "    @staticmethod",
    "    def passed() -> 'RuleResult':",
    "        return RuleResult(violated=False)",
    "    ",
    "    @staticmethod",
    "    def failed(violations: List[Violation]) -> 'RuleResult':",
    "        return RuleResult(violated=True, violations=violations)",
    "",
    "",
    "@dataclass",
    "class EvaluationContext:",
    "    \"\"\"Context for rule evaluation, including trip aggregations.\"\"\"",
    "    trip_totals: Dict[str, Decimal] = field(default_factory=dict)",
    "    ",
    "    def add_expense_to_trip(self, trip_id: str, amount: Decimal) -> Decimal:",
    "        if trip_id not in self.trip_totals:",
    "            self.trip_totals[trip_id] = Decimal('0')",
    "        self.trip_totals[trip_id] += amount",
    "        return self.trip_totals[trip_id]",
    "",
    "",
    "# ============================================================================",
    "# RULE INTERFACE",
    "# ============================================================================",
    "",
    "class Rule(ABC):",
    "    \"\"\"Abstract base class for all expense rules.\"\"\"",
    "    ",
    "    @property",
    "    @abstractmethod",
    "    def name(self) -> str:",
    "        \"\"\"Human-readable rule name.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        \"\"\"Evaluate the rule against an expense.\"\"\"",
    "        pass",
    "    ",
    "    @classmethod",
    "    @abstractmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'Rule':",
    "        \"\"\"Create a rule instance from configuration dictionary.\"\"\"",
    "        pass",
    "",
    "",
    "# ============================================================================",
    "# CONCRETE RULE IMPLEMENTATIONS",
    "# ============================================================================",
    "",
    "class BanRule(Rule):",
    "    \"\"\"Bans expenses matching a specific field value.\"\"\"",
    "    ",
    "    def __init__(self, field_name: str, banned_value: str):",
    "        self._field_name = field_name",
    "        self._banned_value = banned_value",
    "        self._name = f\"Ban({field_name}={banned_value})\"",
    "    ",
    "    @property",
    "    def name(self) -> str:",
    "        return self._name",
    "    ",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        actual_value = getattr(expense, self._field_name, None)",
    "        ",
    "        if actual_value == self._banned_value:",
    "            violation = Violation(",
    "                rule_name=self.name,",
    "                expense_id=expense.expense_id,",
    "                message=f\"Expense {self._field_name} '{self._banned_value}' is banned\",",
    "                details={'field': self._field_name, 'value': self._banned_value}",
    "            )",
    "            return RuleResult.failed([violation])",
    "        ",
    "        return RuleResult.passed()",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'BanRule':",
    "        if 'field' not in config:",
    "            raise ValueError(\"BanRule config requires 'field'\")",
    "        if 'value' not in config:",
    "            raise ValueError(\"BanRule config requires 'value'\")",
    "        return cls(field_name=config['field'], banned_value=config['value'])",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"Enforces a maximum amount per expense.\"\"\"",
    "    ",
    "    def __init__(self, max_amount: Decimal):",
    "        self._max_amount = max_amount",
    "        self._name = f\"MaxAmount(${max_amount})\"",
    "    ",
    "    @property",
    "    def name(self) -> str:",
    "        return self._name",
    "    ",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        if expense.amount_usd > self._max_amount:",
    "            violation = Violation(",
    "                rule_name=self.name,",
    "                expense_id=expense.expense_id,",
    "                message=f\"Amount ${expense.amount_usd} exceeds maximum ${self._max_amount}\",",
    "                details={'amount': str(expense.amount_usd), 'max': str(self._max_amount)}",
    "            )",
    "            return RuleResult.failed([violation])",
    "        return RuleResult.passed()",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'MaxAmountRule':",
    "        if 'max_amount' not in config:",
    "            raise ValueError(\"MaxAmountRule config requires 'max_amount'\")",
    "        return cls(max_amount=Decimal(str(config['max_amount'])))",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"Limits expense amount for a specific vendor type.\"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: Decimal):",
    "        self._vendor_type = vendor_type",
    "        self._max_amount = max_amount",
    "        self._name = f\"VendorLimit({vendor_type}, ${max_amount})\"",
    "    ",
    "    @property",
    "    def name(self) -> str:",
    "        return self._name",
    "    ",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        if expense.vendor_type != self._vendor_type:",
    "            return RuleResult.passed()",
    "        ",
    "        if expense.amount_usd > self._max_amount:",
    "            violation = Violation(",
    "                rule_name=self.name,",
    "                expense_id=expense.expense_id,",
    "                message=f\"{self._vendor_type} expense ${expense.amount_usd} exceeds limit ${self._max_amount}\",",
    "                details={'vendor_type': self._vendor_type, 'amount': str(expense.amount_usd)}",
    "            )",
    "            return RuleResult.failed([violation])",
    "        return RuleResult.passed()",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'VendorTypeLimitRule':",
    "        if 'vendor_type' not in config:",
    "            raise ValueError(\"VendorTypeLimitRule requires 'vendor_type'\")",
    "        if 'max_amount' not in config:",
    "            raise ValueError(\"VendorTypeLimitRule requires 'max_amount'\")",
    "        return cls(",
    "            vendor_type=config['vendor_type'],",
    "            max_amount=Decimal(str(config['max_amount']))",
    "        )",
    "",
    "",
    "class TripTotalRule(Rule):",
    "    \"\"\"Enforces maximum total spending per trip (aggregation rule from Part 2).\"\"\"",
    "    ",
    "    def __init__(self, max_total: Decimal):",
    "        self._max_total = max_total",
    "        self._name = f\"TripTotal(${max_total})\"",
    "    ",
    "    @property",
    "    def name(self) -> str:",
    "        return self._name",
    "    ",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        if not expense.trip_id or context is None:",
    "            return RuleResult.passed()",
    "        ",
    "        trip_total = context.add_expense_to_trip(expense.trip_id, expense.amount_usd)",
    "        ",
    "        if trip_total > self._max_total:",
    "            violation = Violation(",
    "                rule_name=self.name,",
    "                expense_id=expense.expense_id,",
    "                message=f\"Trip {expense.trip_id} total ${trip_total} exceeds limit ${self._max_total}\",",
    "                details={'trip_id': expense.trip_id, 'trip_total': str(trip_total)}",
    "            )",
    "            return RuleResult.failed([violation])",
    "        return RuleResult.passed()",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any]) -> 'TripTotalRule':",
    "        if 'max_total' not in config:",
    "            raise ValueError(\"TripTotalRule requires 'max_total'\")",
    "        return cls(max_total=Decimal(str(config['max_total'])))",
    "",
    "",
    "# ============================================================================",
    "# COMPOSITE RULE (Part 3 - AND/OR combinations)",
    "# ============================================================================",
    "",
    "class CompositeOperator(Enum):",
    "    \"\"\"Operators for combining rules.\"\"\"",
    "    AND = \"AND\"  # All must pass (any violation = composite violation)",
    "    OR = \"OR\"    # At least one must pass (all violated = composite violation)",
    "",
    "",
    "class CompositeRule(Rule):",
    "    \"\"\"",
    "    Combines multiple rules with AND/OR logic.",
    "    ",
    "    AND: All rules must pass. Violated if ANY child is violated.",
    "    OR:  At least one must pass. Violated only if ALL children are violated.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, operator: CompositeOperator, rules: List[Rule]):",
    "        if not rules:",
    "            raise ValueError(\"CompositeRule requires at least one child rule\")",
    "        self._operator = operator",
    "        self._rules = rules",
    "        rule_names = ', '.join(r.name for r in rules[:3])",
    "        suffix = '...' if len(rules) > 3 else ''",
    "        self._name = f\"Composite({operator.value}: {rule_names}{suffix})\"",
    "    ",
    "    @property",
    "    def name(self) -> str:",
    "        return self._name",
    "    ",
    "    @property",
    "    def operator(self) -> CompositeOperator:",
    "        return self._operator",
    "    ",
    "    @property",
    "    def rules(self) -> List[Rule]:",
    "        return self._rules.copy()",
    "    ",
    "    def evaluate(self, expense: Expense, context: Optional[EvaluationContext] = None) -> RuleResult:",
    "        \"\"\"",
    "        Evaluate all child rules and combine results.",
    "        ",
    "        AND: Violated if ANY child is violated (all must pass)",
    "        OR:  Violated only if ALL children are violated (at least one must pass)",
    "        \"\"\"",
    "        results = [rule.evaluate(expense, context) for rule in self._rules]",
    "        ",
    "        if self._operator == CompositeOperator.AND:",
    "            # All must pass - violated if ANY is violated",
    "            all_violations = []",
    "            for result in results:",
    "                if result.violated:",
    "                    all_violations.extend(result.violations)",
    "            ",
    "            if all_violations:",
    "                return RuleResult.failed(all_violations)",
    "            return RuleResult.passed()",
    "        ",
    "        else:  # OR",
    "            # At least one must pass - violated only if ALL are violated",
    "            if all(result.violated for result in results):",
    "                all_violations = []",
    "                for result in results:",
    "                    all_violations.extend(result.violations)",
    "                return RuleResult.failed(all_violations)",
    "            return RuleResult.passed()",
    "    ",
    "    @classmethod",
    "    def from_config(cls, config: Dict[str, Any], factory: 'RuleFactory' = None) -> 'CompositeRule':",
    "        \"\"\"",
    "        Create CompositeRule from config.",
    "        Requires factory parameter for recursive rule creation.",
    "        \"\"\"",
    "        if 'operator' not in config:",
    "            raise ValueError(\"CompositeRule requires 'operator'\")",
    "        if 'rules' not in config:",
    "            raise ValueError(\"CompositeRule requires 'rules'\")",
    "        ",
    "        operator = CompositeOperator(config['operator'].upper())",
    "        ",
    "        if factory is None:",
    "            raise ValueError(\"CompositeRule.from_config requires factory for child rules\")",
    "        ",
    "        child_rules = [factory.create_rule(rule_config) for rule_config in config['rules']]",
    "        return cls(operator=operator, rules=child_rules)",
    "",
    "",
    "# ============================================================================",
    "# RULE REGISTRY (Part 3)",
    "# ============================================================================",
    "",
    "class RuleRegistry:",
    "    \"\"\"",
    "    Registry mapping rule type names to rule classes.",
    "    ",
    "    Supports runtime registration of new rule types without",
    "    modifying factory code (Open/Closed Principle).",
    "    \"\"\"",
    "    ",
    "    _default_instance: Optional['RuleRegistry'] = None",
    "    ",
    "    def __init__(self):",
    "        self._registry: Dict[str, Type[Rule]] = {}",
    "    ",
    "    @classmethod",
    "    def get_default(cls) -> 'RuleRegistry':",
    "        \"\"\"Get the default singleton registry.\"\"\"",
    "        if cls._default_instance is None:",
    "            cls._default_instance = cls()",
    "            cls._default_instance._register_built_in_rules()",
    "        return cls._default_instance",
    "    ",
    "    @classmethod",
    "    def reset_default(cls) -> None:",
    "        \"\"\"Reset the default registry (useful for testing).\"\"\"",
    "        cls._default_instance = None",
    "    ",
    "    def _register_built_in_rules(self) -> None:",
    "        \"\"\"Register all built-in rule types.\"\"\"",
    "        self.register(\"BanRule\", BanRule)",
    "        self.register(\"MaxAmountRule\", MaxAmountRule)",
    "        self.register(\"VendorTypeLimitRule\", VendorTypeLimitRule)",
    "        self.register(\"TripTotalRule\", TripTotalRule)",
    "        self.register(\"CompositeRule\", CompositeRule)",
    "    ",
    "    def register(self, type_name: str, rule_class: Type[Rule]) -> None:",
    "        \"\"\"",
    "        Register a rule class with a type name.",
    "        ",
    "        Args:",
    "            type_name: String identifier used in JSON config",
    "            rule_class: Class that implements Rule interface",
    "            ",
    "        Raises:",
    "            ValueError: If rule_class doesn't have from_config method",
    "        \"\"\"",
    "        if not hasattr(rule_class, 'from_config'):",
    "            raise ValueError(f\"{rule_class.__name__} must implement from_config()\")",
    "        self._registry[type_name] = rule_class",
    "    ",
    "    def lookup(self, type_name: str) -> Type[Rule]:",
    "        \"\"\"",
    "        Look up a rule class by type name.",
    "        ",
    "        Args:",
    "            type_name: String identifier from JSON config",
    "            ",
    "        Returns:",
    "            Rule class for the given type name",
    "            ",
    "        Raises:",
    "            ValueError: If type_name is not registered",
    "        \"\"\"",
    "        if type_name not in self._registry:",
    "            available = list(self._registry.keys())",
    "            raise ValueError(f\"Unknown rule type '{type_name}'. Available: {available}\")",
    "        return self._registry[type_name]",
    "    ",
    "    def get_registered_types(self) -> Set[str]:",
    "        \"\"\"Return all registered type names.\"\"\"",
    "        return set(self._registry.keys())",
    "",
    "",
    "# ============================================================================",
    "# RULE FACTORY (Part 3)",
    "# ============================================================================",
    "",
    "class RuleFactory:",
    "    \"\"\"",
    "    Factory for creating Rule instances from JSON/dict configuration.",
    "    ",
    "    Uses the Registry pattern to look up rule classes by type name,",
    "    then delegates to each class's from_config() method.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, registry: Optional[RuleRegistry] = None):",
    "        \"\"\"",
    "        Initialize factory with a registry.",
    "        ",
    "        Args:",
    "            registry: RuleRegistry to use. Defaults to the global default.",
    "        \"\"\"",
    "        self._registry = registry or RuleRegistry.get_default()",
    "    ",
    "    def create_rule(self, config: Dict[str, Any]) -> Rule:",
    "        \"\"\"",
    "        Create a Rule instance from configuration.",
    "        ",
    "        Args:",
    "            config: Dictionary with 'type' and rule-specific 'config' keys",
    "                   Example: {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}}",
    "        ",
    "        Returns:",
    "            Configured Rule instance",
    "            ",
    "        Raises:",
    "            ValueError: If config is invalid or type is unknown",
    "        \"\"\"",
    "        if 'type' not in config:",
    "            raise ValueError(\"Rule config must have 'type' field\")",
    "        ",
    "        type_name = config['type']",
    "        rule_class = self._registry.lookup(type_name)",
    "        rule_config = config.get('config', {})",
    "        ",
    "        # Special handling for CompositeRule (needs factory for recursion)",
    "        if type_name == 'CompositeRule':",
    "            # CompositeRule config is at top level, not nested",
    "            composite_config = {",
    "                'operator': config.get('operator', 'AND'),",
    "                'rules': config.get('rules', [])",
    "            }",
    "            return CompositeRule.from_config(composite_config, factory=self)",
    "        ",
    "        return rule_class.from_config(rule_config)",
    "    ",
    "    def create_rules(self, configs: List[Dict[str, Any]]) -> List[Rule]:",
    "        \"\"\"Create multiple rules from a list of configs.\"\"\"",
    "        return [self.create_rule(config) for config in configs]",
    "",
    "",
    "# ============================================================================",
    "# RULES ENGINE (Extended from Parts 1 & 2)",
    "# ============================================================================",
    "",
    "class RulesEngine:",
    "    \"\"\"",
    "    Engine for evaluating expenses against a set of rules.",
    "    Now supports dynamic rule creation via RuleFactory.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, factory: Optional[RuleFactory] = None):",
    "        self._rules: List[Rule] = []",
    "        self._factory = factory or RuleFactory()",
    "    ",
    "    def add_rule(self, rule: Rule) -> None:",
    "        \"\"\"Add a pre-built rule to the engine.\"\"\"",
    "        self._rules.append(rule)",
    "    ",
    "    def add_rule_from_config(self, config: Dict[str, Any]) -> Rule:",
    "        \"\"\"Create a rule from config and add it to the engine.\"\"\"",
    "        rule = self._factory.create_rule(config)",
    "        self._rules.append(rule)",
    "        return rule",
    "    ",
    "    def clear_rules(self) -> None:",
    "        \"\"\"Remove all rules.\"\"\"",
    "        self._rules.clear()",
    "    ",
    "    def evaluate(self, expenses: List[Expense]) -> Dict[str, List[Violation]]:",
    "        \"\"\"",
    "        Evaluate all expenses against all rules.",
    "        ",
    "        Returns:",
    "            Dict mapping expense_id to list of violations",
    "        \"\"\"",
    "        context = EvaluationContext()",
    "        violations_by_expense: Dict[str, List[Violation]] = {}",
    "        ",
    "        for expense in expenses:",
    "            expense_violations = []",
    "            ",
    "            for rule in self._rules:",
    "                result = rule.evaluate(expense, context)",
    "                if result.violated:",
    "                    expense_violations.extend(result.violations)",
    "            ",
    "            if expense_violations:",
    "                violations_by_expense[expense.expense_id] = expense_violations",
    "        ",
    "        return violations_by_expense",
    "",
    "",
    "# ============================================================================",
    "# API HANDLER (Simulated REST API)",
    "# ============================================================================",
    "",
    "class RulesAPIHandler:",
    "    \"\"\"",
    "    Handles API requests for rule creation and management.",
    "    Simulates REST API endpoints.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, engine: RulesEngine):",
    "        self._engine = engine",
    "    ",
    "    def post_rule(self, request_body: Dict[str, Any]) -> Dict[str, Any]:",
    "        \"\"\"",
    "        POST /api/rules - Create a new rule",
    "        ",
    "        Args:",
    "            request_body: JSON body of the request",
    "            ",
    "        Returns:",
    "            Response dict with rule_name and status",
    "        \"\"\"",
    "        try:",
    "            rule = self._engine.add_rule_from_config(request_body)",
    "            return {",
    "                'status': 'created',",
    "                'rule_name': rule.name,",
    "                'message': f'Rule {rule.name} created successfully'",
    "            }",
    "        except ValueError as e:",
    "            return {",
    "                'status': 'error',",
    "                'message': str(e)",
    "            }",
    "    ",
    "    def post_evaluate(self, expenses_data: List[Dict[str, Any]]) -> Dict[str, Any]:",
    "        \"\"\"",
    "        POST /api/evaluate - Evaluate expenses against all rules",
    "        \"\"\"",
    "        expenses = [Expense.from_dict(e) for e in expenses_data]",
    "        violations = self._engine.evaluate(expenses)",
    "        ",
    "        return {",
    "            'status': 'success',",
    "            'total_expenses': len(expenses),",
    "            'violations_count': sum(len(v) for v in violations.values()),",
    "            'violations': {",
    "                exp_id: [{'rule': v.rule_name, 'message': v.message} for v in viols]",
    "                for exp_id, viols in violations.items()",
    "            }",
    "        }",
    "",
    "",
    "# ============================================================================",
    "# DEMO AND TESTING",
    "# ============================================================================",
    "",
    "def demo_part3():",
    "    \"\"\"Comprehensive demo of Part 3: Rule Creation API.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"PART 3 DEMO: Dynamic Rule Creation API\")",
    "    print(\"=\" * 70)",
    "    ",
    "    # Reset registry for clean state",
    "    RuleRegistry.reset_default()",
    "    ",
    "    # Create engine and API handler",
    "    engine = RulesEngine()",
    "    api = RulesAPIHandler(engine)",
    "    ",
    "    # Demo 1: Create a simple BanRule via API",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 1: Create BanRule via API\")",
    "    print(\"-\" * 50)",
    "    ",
    "    ban_config = {",
    "        'type': 'BanRule',",
    "        'config': {",
    "            'field': 'expense_type',",
    "            'value': 'gambling'",
    "        }",
    "    }",
    "    print(f\"Request: POST /api/rules\")",
    "    print(f\"Body: {ban_config}\")",
    "    response = api.post_rule(ban_config)",
    "    print(f\"Response: {response}\")",
    "    ",
    "    # Demo 2: Create VendorTypeLimitRule",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 2: Create VendorTypeLimitRule\")",
    "    print(\"-\" * 50)",
    "    ",
    "    limit_config = {",
    "        'type': 'VendorTypeLimitRule',",
    "        'config': {",
    "            'vendor_type': 'restaurant',",
    "            'max_amount': 50",
    "        }",
    "    }",
    "    print(f\"Request body: {limit_config}\")",
    "    response = api.post_rule(limit_config)",
    "    print(f\"Response: {response}\")",
    "    ",
    "    # Demo 3: Create CompositeRule with AND",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 3: CompositeRule with AND (all must pass)\")",
    "    print(\"-\" * 50)",
    "    ",
    "    composite_and_config = {",
    "        'type': 'CompositeRule',",
    "        'operator': 'AND',",
    "        'rules': [",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 100}},",
    "            {'type': 'BanRule', 'config': {'field': 'vendor_type', 'value': 'casino'}}",
    "        ]",
    "    }",
    "    print(f\"Request body: {composite_and_config}\")",
    "    response = api.post_rule(composite_and_config)",
    "    print(f\"Response: {response}\")",
    "    ",
    "    # Demo 4: Create CompositeRule with OR",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 4: CompositeRule with OR (at least one must pass)\")",
    "    print(\"-\" * 50)",
    "    ",
    "    # Example: Expense passes if amount < $20 OR expense_type is 'travel'",
    "    # This creates a rule where small amounts OR travel expenses are OK",
    "    composite_or_config = {",
    "        'type': 'CompositeRule',",
    "        'operator': 'OR',",
    "        'rules': [",
    "            # Rule 1: Violated if amount > 500",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 500}},",
    "            # Rule 2: Violated if not a restaurant",
    "            {'type': 'BanRule', 'config': {'field': 'vendor_type', 'value': 'other'}}",
    "        ]",
    "    }",
    "    print(f\"Request body: {composite_or_config}\")",
    "    response = api.post_rule(composite_or_config)",
    "    print(f\"Response: {response}\")",
    "    ",
    "    # Demo 5: Test with expenses",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 5: Evaluate Expenses\")",
    "    print(\"-\" * 50)",
    "    ",
    "    expenses = [",
    "        {",
    "            'expense_id': 'E001',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '25.00',",
    "            'expense_type': 'meals',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Good Eats'",
    "        },",
    "        {",
    "            'expense_id': 'E002',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '75.00',",
    "            'expense_type': 'meals',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Fancy Place'",
    "        },",
    "        {",
    "            'expense_id': 'E003',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '150.00',",
    "            'expense_type': 'gambling',",
    "            'vendor_type': 'casino',",
    "            'vendor_name': 'Lucky Casino'",
    "        },",
    "    ]",
    "    ",
    "    print(\"Expenses to evaluate:\")",
    "    for exp in expenses:",
    "        print(f\"  {exp['expense_id']}: ${exp['amount_usd']} at {exp['vendor_name']} ({exp['expense_type']})\")",
    "    ",
    "    print(\"\\nEvaluating...\")",
    "    result = api.post_evaluate(expenses)",
    "    ",
    "    print(f\"\\nResults:\")",
    "    print(f\"  Total expenses: {result['total_expenses']}\")",
    "    print(f\"  Total violations: {result['violations_count']}\")",
    "    print(f\"\\nViolations by expense:\")",
    "    for exp_id, viols in result['violations'].items():",
    "        print(f\"  {exp_id}:\")",
    "        for v in viols:",
    "            print(f\"    - [{v['rule']}] {v['message']}\")",
    "    ",
    "    # Demo 6: Nested Composite Rules",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 6: Nested Composite Rules\")",
    "    print(\"-\" * 50)",
    "    ",
    "    engine.clear_rules()",
    "    ",
    "    # Complex rule: (BanGambling AND MaxAmount$200) OR TripTotal$1000",
    "    nested_config = {",
    "        'type': 'CompositeRule',",
    "        'operator': 'OR',",
    "        'rules': [",
    "            {",
    "                'type': 'CompositeRule',",
    "                'operator': 'AND',",
    "                'rules': [",
    "                    {'type': 'BanRule', 'config': {'field': 'expense_type', 'value': 'gambling'}},",
    "                    {'type': 'MaxAmountRule', 'config': {'max_amount': 200}}",
    "                ]",
    "            },",
    "            {'type': 'TripTotalRule', 'config': {'max_total': 1000}}",
    "        ]",
    "    }",
    "    print(f\"Nested config: Complex (A AND B) OR C structure\")",
    "    response = api.post_rule(nested_config)",
    "    print(f\"Response: {response}\")",
    "    ",
    "    # Demo 7: Error Handling",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"Demo 7: Error Handling\")",
    "    print(\"-\" * 50)",
    "    ",
    "    invalid_configs = [",
    "        {'type': 'UnknownRule', 'config': {}},",
    "        {'type': 'BanRule', 'config': {}},  # Missing required fields",
    "        {'config': {'field': 'test'}},  # Missing type",
    "    ]",
    "    ",
    "    for config in invalid_configs:",
    "        response = api.post_rule(config)",
    "        print(f\"Config: {config}\")",
    "        print(f\"Response: {response}\")",
    "        print()",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"PART 3 DEMO COMPLETE\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "def run_tests():",
    "    \"\"\"Run unit tests for Part 3 functionality.\"\"\"",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"RUNNING UNIT TESTS\")",
    "    print(\"=\" * 70)",
    "    ",
    "    RuleRegistry.reset_default()",
    "    ",
    "    # Test 1: Registry registration and lookup",
    "    print(\"\\nTest 1: Registry operations\")",
    "    registry = RuleRegistry()",
    "    registry.register(\"TestRule\", BanRule)",
    "    assert registry.lookup(\"TestRule\") == BanRule",
    "    print(\"  \u2713 Registration and lookup work\")",
    "    ",
    "    try:",
    "        registry.lookup(\"NonExistent\")",
    "        assert False, \"Should have raised ValueError\"",
    "    except ValueError as e:",
    "        print(f\"  \u2713 Unknown type raises error: {e}\")",
    "    ",
    "    # Test 2: Factory creates correct rule types",
    "    print(\"\\nTest 2: Factory creates correct types\")",
    "    factory = RuleFactory()",
    "    ",
    "    ban = factory.create_rule({'type': 'BanRule', 'config': {'field': 'x', 'value': 'y'}})",
    "    assert isinstance(ban, BanRule)",
    "    print(\"  \u2713 BanRule created\")",
    "    ",
    "    limit = factory.create_rule({'type': 'MaxAmountRule', 'config': {'max_amount': 100}})",
    "    assert isinstance(limit, MaxAmountRule)",
    "    print(\"  \u2713 MaxAmountRule created\")",
    "    ",
    "    # Test 3: CompositeRule AND logic",
    "    print(\"\\nTest 3: CompositeRule AND logic\")",
    "    composite = factory.create_rule({",
    "        'type': 'CompositeRule',",
    "        'operator': 'AND',",
    "        'rules': [",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 50}},",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 100}}",
    "        ]",
    "    })",
    "    ",
    "    expense_ok = Expense('E1', None, Decimal('40'), 'meals', 'restaurant', 'Test')",
    "    expense_mid = Expense('E2', None, Decimal('75'), 'meals', 'restaurant', 'Test')",
    "    expense_high = Expense('E3', None, Decimal('150'), 'meals', 'restaurant', 'Test')",
    "    ",
    "    result = composite.evaluate(expense_ok)",
    "    assert not result.violated, \"$40 should pass both limits\"",
    "    print(\"  \u2713 $40 passes AND(50, 100)\")",
    "    ",
    "    result = composite.evaluate(expense_mid)",
    "    assert result.violated, \"$75 should fail the 50 limit\"",
    "    print(\"  \u2713 $75 fails AND(50, 100) due to first limit\")",
    "    ",
    "    result = composite.evaluate(expense_high)",
    "    assert result.violated, \"$150 should fail both limits\"",
    "    assert len(result.violations) == 2, \"Should have 2 violations\"",
    "    print(\"  \u2713 $150 fails AND(50, 100) with 2 violations\")",
    "    ",
    "    # Test 4: CompositeRule OR logic",
    "    print(\"\\nTest 4: CompositeRule OR logic\")",
    "    composite_or = factory.create_rule({",
    "        'type': 'CompositeRule',",
    "        'operator': 'OR',",
    "        'rules': [",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 50}},",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 100}}",
    "        ]",
    "    })",
    "    ",
    "    result = composite_or.evaluate(expense_ok)",
    "    assert not result.violated, \"$40 passes both, so OR passes\"",
    "    print(\"  \u2713 $40 passes OR(50, 100)\")",
    "    ",
    "    result = composite_or.evaluate(expense_mid)",
    "    assert not result.violated, \"$75 passes second limit, so OR passes\"",
    "    print(\"  \u2713 $75 passes OR(50, 100) because second passes\")",
    "    ",
    "    result = composite_or.evaluate(expense_high)",
    "    assert result.violated, \"$150 fails both, so OR fails\"",
    "    print(\"  \u2713 $150 fails OR(50, 100) because both fail\")",
    "    ",
    "    # Test 5: Nested composites",
    "    print(\"\\nTest 5: Nested composite rules\")",
    "    nested = factory.create_rule({",
    "        'type': 'CompositeRule',",
    "        'operator': 'AND',",
    "        'rules': [",
    "            {",
    "                'type': 'CompositeRule',",
    "                'operator': 'OR',",
    "                'rules': [",
    "                    {'type': 'MaxAmountRule', 'config': {'max_amount': 30}},",
    "                    {'type': 'MaxAmountRule', 'config': {'max_amount': 60}}",
    "                ]",
    "            },",
    "            {'type': 'MaxAmountRule', 'config': {'max_amount': 100}}",
    "        ]",
    "    })",
    "    ",
    "    assert not nested.evaluate(expense_ok).violated, \"$40 passes nested\"",
    "    print(\"  \u2713 Nested composite works correctly\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"ALL TESTS PASSED \u2713\")",
    "    print(\"=\" * 70)",
    "",
    "",
    "if __name__ == '__main__':",
    "    run_tests()",
    "    demo_part3()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.function.Function;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Corporate Expense Rules Engine - Part 3: Rule Creation API",
    " * Implements Factory + Registry + Composite patterns for dynamic rule creation.",
    " */",
    "public class ExpenseRulesEnginePart3 {",
    "",
    "    // ========================================================================",
    "    // CORE DATA STRUCTURES",
    "    // ========================================================================",
    "",
    "    public static class Expense {",
    "        public final String expenseId;",
    "        public final String tripId;",
    "        public final BigDecimal amountUsd;",
    "        public final String expenseType;",
    "        public final String vendorType;",
    "        public final String vendorName;",
    "",
    "        public Expense(String expenseId, String tripId, BigDecimal amountUsd,",
    "                      String expenseType, String vendorType, String vendorName) {",
    "            this.expenseId = expenseId;",
    "            this.tripId = tripId;",
    "            this.amountUsd = amountUsd;",
    "            this.expenseType = expenseType;",
    "            this.vendorType = vendorType;",
    "            this.vendorName = vendorName;",
    "        }",
    "",
    "        public String getField(String fieldName) {",
    "            switch (fieldName) {",
    "                case \"expense_type\": return expenseType;",
    "                case \"vendor_type\": return vendorType;",
    "                case \"vendor_name\": return vendorName;",
    "                default: return null;",
    "            }",
    "        }",
    "    }",
    "",
    "    public static class Violation {",
    "        public final String ruleName;",
    "        public final String expenseId;",
    "        public final String message;",
    "        public final Map<String, String> details;",
    "",
    "        public Violation(String ruleName, String expenseId, String message, Map<String, String> details) {",
    "            this.ruleName = ruleName;",
    "            this.expenseId = expenseId;",
    "            this.message = message;",
    "            this.details = details != null ? details : new HashMap<>();",
    "        }",
    "    }",
    "",
    "    public static class RuleResult {",
    "        public final boolean violated;",
    "        public final List<Violation> violations;",
    "",
    "        private RuleResult(boolean violated, List<Violation> violations) {",
    "            this.violated = violated;",
    "            this.violations = violations;",
    "        }",
    "",
    "        public static RuleResult passed() {",
    "            return new RuleResult(false, Collections.emptyList());",
    "        }",
    "",
    "        public static RuleResult failed(List<Violation> violations) {",
    "            return new RuleResult(true, violations);",
    "        }",
    "",
    "        public static RuleResult failed(Violation violation) {",
    "            return new RuleResult(true, Collections.singletonList(violation));",
    "        }",
    "    }",
    "",
    "    public static class EvaluationContext {",
    "        private final Map<String, BigDecimal> tripTotals = new HashMap<>();",
    "",
    "        public BigDecimal addExpenseToTrip(String tripId, BigDecimal amount) {",
    "            tripTotals.merge(tripId, amount, BigDecimal::add);",
    "            return tripTotals.get(tripId);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // RULE INTERFACE AND FACTORY INTERFACE",
    "    // ========================================================================",
    "",
    "    public interface Rule {",
    "        String getName();",
    "        RuleResult evaluate(Expense expense, EvaluationContext context);",
    "    }",
    "",
    "    public interface RuleCreator {",
    "        Rule create(Map<String, Object> config, RuleFactory factory);",
    "    }",
    "",
    "    // ========================================================================",
    "    // CONCRETE RULES",
    "    // ========================================================================",
    "",
    "    public static class BanRule implements Rule {",
    "        private final String fieldName;",
    "        private final String bannedValue;",
    "        private final String name;",
    "",
    "        public BanRule(String fieldName, String bannedValue) {",
    "            this.fieldName = fieldName;",
    "            this.bannedValue = bannedValue;",
    "            this.name = String.format(\"Ban(%s=%s)\", fieldName, bannedValue);",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return name; }",
    "",
    "        @Override",
    "        public RuleResult evaluate(Expense expense, EvaluationContext context) {",
    "            String actualValue = expense.getField(fieldName);",
    "            if (bannedValue.equals(actualValue)) {",
    "                Violation v = new Violation(name, expense.expenseId,",
    "                    String.format(\"Expense %s '%s' is banned\", fieldName, bannedValue), null);",
    "                return RuleResult.failed(v);",
    "            }",
    "            return RuleResult.passed();",
    "        }",
    "",
    "        public static RuleCreator creator() {",
    "            return (config, factory) -> {",
    "                String field = (String) config.get(\"field\");",
    "                String value = (String) config.get(\"value\");",
    "                if (field == null || value == null) {",
    "                    throw new IllegalArgumentException(\"BanRule requires 'field' and 'value'\");",
    "                }",
    "                return new BanRule(field, value);",
    "            };",
    "        }",
    "    }",
    "",
    "    public static class MaxAmountRule implements Rule {",
    "        private final BigDecimal maxAmount;",
    "        private final String name;",
    "",
    "        public MaxAmountRule(BigDecimal maxAmount) {",
    "            this.maxAmount = maxAmount;",
    "            this.name = String.format(\"MaxAmount($%s)\", maxAmount);",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return name; }",
    "",
    "        @Override",
    "        public RuleResult evaluate(Expense expense, EvaluationContext context) {",
    "            if (expense.amountUsd.compareTo(maxAmount) > 0) {",
    "                Violation v = new Violation(name, expense.expenseId,",
    "                    String.format(\"Amount $%s exceeds maximum $%s\", expense.amountUsd, maxAmount), null);",
    "                return RuleResult.failed(v);",
    "            }",
    "            return RuleResult.passed();",
    "        }",
    "",
    "        public static RuleCreator creator() {",
    "            return (config, factory) -> {",
    "                Object max = config.get(\"max_amount\");",
    "                if (max == null) {",
    "                    throw new IllegalArgumentException(\"MaxAmountRule requires 'max_amount'\");",
    "                }",
    "                return new MaxAmountRule(new BigDecimal(max.toString()));",
    "            };",
    "        }",
    "    }",
    "",
    "    public static class VendorTypeLimitRule implements Rule {",
    "        private final String vendorType;",
    "        private final BigDecimal maxAmount;",
    "        private final String name;",
    "",
    "        public VendorTypeLimitRule(String vendorType, BigDecimal maxAmount) {",
    "            this.vendorType = vendorType;",
    "            this.maxAmount = maxAmount;",
    "            this.name = String.format(\"VendorLimit(%s, $%s)\", vendorType, maxAmount);",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return name; }",
    "",
    "        @Override",
    "        public RuleResult evaluate(Expense expense, EvaluationContext context) {",
    "            if (!vendorType.equals(expense.vendorType)) {",
    "                return RuleResult.passed();",
    "            }",
    "            if (expense.amountUsd.compareTo(maxAmount) > 0) {",
    "                Violation v = new Violation(name, expense.expenseId,",
    "                    String.format(\"%s expense $%s exceeds limit $%s\", vendorType, expense.amountUsd, maxAmount), null);",
    "                return RuleResult.failed(v);",
    "            }",
    "            return RuleResult.passed();",
    "        }",
    "",
    "        public static RuleCreator creator() {",
    "            return (config, factory) -> {",
    "                String vt = (String) config.get(\"vendor_type\");",
    "                Object max = config.get(\"max_amount\");",
    "                if (vt == null || max == null) {",
    "                    throw new IllegalArgumentException(\"VendorTypeLimitRule requires 'vendor_type' and 'max_amount'\");",
    "                }",
    "                return new VendorTypeLimitRule(vt, new BigDecimal(max.toString()));",
    "            };",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // COMPOSITE RULE (Part 3)",
    "    // ========================================================================",
    "",
    "    public enum CompositeOperator { AND, OR }",
    "",
    "    public static class CompositeRule implements Rule {",
    "        private final CompositeOperator operator;",
    "        private final List<Rule> rules;",
    "        private final String name;",
    "",
    "        public CompositeRule(CompositeOperator operator, List<Rule> rules) {",
    "            if (rules == null || rules.isEmpty()) {",
    "                throw new IllegalArgumentException(\"CompositeRule requires at least one rule\");",
    "            }",
    "            this.operator = operator;",
    "            this.rules = new ArrayList<>(rules);",
    "            String ruleNames = rules.stream().limit(3).map(Rule::getName)",
    "                .collect(Collectors.joining(\", \"));",
    "            String suffix = rules.size() > 3 ? \"...\" : \"\";",
    "            this.name = String.format(\"Composite(%s: %s%s)\", operator, ruleNames, suffix);",
    "        }",
    "",
    "        @Override",
    "        public String getName() { return name; }",
    "",
    "        @Override",
    "        public RuleResult evaluate(Expense expense, EvaluationContext context) {",
    "            List<RuleResult> results = rules.stream()",
    "                .map(r -> r.evaluate(expense, context))",
    "                .collect(Collectors.toList());",
    "",
    "            if (operator == CompositeOperator.AND) {",
    "                // All must pass - violated if ANY is violated",
    "                List<Violation> allViolations = results.stream()",
    "                    .filter(r -> r.violated)",
    "                    .flatMap(r -> r.violations.stream())",
    "                    .collect(Collectors.toList());",
    "                return allViolations.isEmpty() ? RuleResult.passed() : RuleResult.failed(allViolations);",
    "            } else {",
    "                // OR: At least one must pass",
    "                boolean anyPassed = results.stream().anyMatch(r -> !r.violated);",
    "                if (anyPassed) {",
    "                    return RuleResult.passed();",
    "                }",
    "                List<Violation> allViolations = results.stream()",
    "                    .flatMap(r -> r.violations.stream())",
    "                    .collect(Collectors.toList());",
    "                return RuleResult.failed(allViolations);",
    "            }",
    "        }",
    "",
    "        @SuppressWarnings(\"unchecked\")",
    "        public static RuleCreator creator() {",
    "            return (config, factory) -> {",
    "                String op = (String) config.get(\"operator\");",
    "                List<Map<String, Object>> ruleConfigs = (List<Map<String, Object>>) config.get(\"rules\");",
    "                if (op == null || ruleConfigs == null) {",
    "                    throw new IllegalArgumentException(\"CompositeRule requires 'operator' and 'rules'\");",
    "                }",
    "                CompositeOperator operator = CompositeOperator.valueOf(op.toUpperCase());",
    "                List<Rule> childRules = ruleConfigs.stream()",
    "                    .map(factory::createRule)",
    "                    .collect(Collectors.toList());",
    "                return new CompositeRule(operator, childRules);",
    "            };",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // RULE REGISTRY (Part 3)",
    "    // ========================================================================",
    "",
    "    public static class RuleRegistry {",
    "        private static RuleRegistry defaultInstance;",
    "        private final Map<String, RuleCreator> registry = new HashMap<>();",
    "",
    "        public static synchronized RuleRegistry getDefault() {",
    "            if (defaultInstance == null) {",
    "                defaultInstance = new RuleRegistry();",
    "                defaultInstance.registerBuiltInRules();",
    "            }",
    "            return defaultInstance;",
    "        }",
    "",
    "        public static synchronized void resetDefault() {",
    "            defaultInstance = null;",
    "        }",
    "",
    "        private void registerBuiltInRules() {",
    "            register(\"BanRule\", BanRule.creator());",
    "            register(\"MaxAmountRule\", MaxAmountRule.creator());",
    "            register(\"VendorTypeLimitRule\", VendorTypeLimitRule.creator());",
    "            register(\"CompositeRule\", CompositeRule.creator());",
    "        }",
    "",
    "        public void register(String typeName, RuleCreator creator) {",
    "            registry.put(typeName, creator);",
    "        }",
    "",
    "        public RuleCreator lookup(String typeName) {",
    "            RuleCreator creator = registry.get(typeName);",
    "            if (creator == null) {",
    "                throw new IllegalArgumentException(",
    "                    String.format(\"Unknown rule type '%s'. Available: %s\", typeName, registry.keySet()));",
    "            }",
    "            return creator;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // RULE FACTORY (Part 3)",
    "    // ========================================================================",
    "",
    "    public static class RuleFactory {",
    "        private final RuleRegistry registry;",
    "",
    "        public RuleFactory() {",
    "            this(RuleRegistry.getDefault());",
    "        }",
    "",
    "        public RuleFactory(RuleRegistry registry) {",
    "            this.registry = registry;",
    "        }",
    "",
    "        @SuppressWarnings(\"unchecked\")",
    "        public Rule createRule(Map<String, Object> config) {",
    "            String typeName = (String) config.get(\"type\");",
    "            if (typeName == null) {",
    "                throw new IllegalArgumentException(\"Rule config must have 'type' field\");",
    "            }",
    "",
    "            RuleCreator creator = registry.lookup(typeName);",
    "            Map<String, Object> ruleConfig;",
    "",
    "            if (\"CompositeRule\".equals(typeName)) {",
    "                ruleConfig = config;",
    "            } else {",
    "                ruleConfig = (Map<String, Object>) config.getOrDefault(\"config\", new HashMap<>());",
    "            }",
    "",
    "            return creator.create(ruleConfig, this);",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // RULES ENGINE",
    "    // ========================================================================",
    "",
    "    public static class RulesEngine {",
    "        private final List<Rule> rules = new ArrayList<>();",
    "        private final RuleFactory factory;",
    "",
    "        public RulesEngine() {",
    "            this(new RuleFactory());",
    "        }",
    "",
    "        public RulesEngine(RuleFactory factory) {",
    "            this.factory = factory;",
    "        }",
    "",
    "        public void addRule(Rule rule) {",
    "            rules.add(rule);",
    "        }",
    "",
    "        public Rule addRuleFromConfig(Map<String, Object> config) {",
    "            Rule rule = factory.createRule(config);",
    "            rules.add(rule);",
    "            return rule;",
    "        }",
    "",
    "        public Map<String, List<Violation>> evaluate(List<Expense> expenses) {",
    "            EvaluationContext context = new EvaluationContext();",
    "            Map<String, List<Violation>> violations = new HashMap<>();",
    "",
    "            for (Expense expense : expenses) {",
    "                List<Violation> expenseViolations = new ArrayList<>();",
    "                for (Rule rule : rules) {",
    "                    RuleResult result = rule.evaluate(expense, context);",
    "                    if (result.violated) {",
    "                        expenseViolations.addAll(result.violations);",
    "                    }",
    "                }",
    "                if (!expenseViolations.isEmpty()) {",
    "                    violations.put(expense.expenseId, expenseViolations);",
    "                }",
    "            }",
    "            return violations;",
    "        }",
    "    }",
    "",
    "    // ========================================================================",
    "    // DEMO",
    "    // ========================================================================",
    "",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"Part 3: Rule Creation API Demo\");",
    "        System.out.println(\"=\" .repeat(60));",
    "",
    "        RuleRegistry.resetDefault();",
    "        RulesEngine engine = new RulesEngine();",
    "",
    "        // Create rules via config",
    "        Map<String, Object> banConfig = new HashMap<>();",
    "        banConfig.put(\"type\", \"BanRule\");",
    "        banConfig.put(\"config\", Map.of(\"field\", \"expense_type\", \"value\", \"gambling\"));",
    "        Rule banRule = engine.addRuleFromConfig(banConfig);",
    "        System.out.println(\"Created: \" + banRule.getName());",
    "",
    "        // Create composite rule",
    "        Map<String, Object> compositeConfig = new HashMap<>();",
    "        compositeConfig.put(\"type\", \"CompositeRule\");",
    "        compositeConfig.put(\"operator\", \"AND\");",
    "        compositeConfig.put(\"rules\", List.of(",
    "            Map.of(\"type\", \"MaxAmountRule\", \"config\", Map.of(\"max_amount\", 100)),",
    "            Map.of(\"type\", \"VendorTypeLimitRule\", \"config\", Map.of(\"vendor_type\", \"restaurant\", \"max_amount\", 50))",
    "        ));",
    "        Rule compositeRule = engine.addRuleFromConfig(compositeConfig);",
    "        System.out.println(\"Created: \" + compositeRule.getName());",
    "",
    "        // Test expenses",
    "        List<Expense> expenses = List.of(",
    "            new Expense(\"E001\", \"T001\", new BigDecimal(\"25.00\"), \"meals\", \"restaurant\", \"Good Eats\"),",
    "            new Expense(\"E002\", \"T001\", new BigDecimal(\"75.00\"), \"meals\", \"restaurant\", \"Fancy Place\"),",
    "            new Expense(\"E003\", \"T001\", new BigDecimal(\"100.00\"), \"gambling\", \"casino\", \"Lucky Casino\")",
    "        );",
    "",
    "        System.out.println(\"\\nEvaluating expenses...\");",
    "        Map<String, List<Violation>> violations = engine.evaluate(expenses);",
    "",
    "        violations.forEach((expId, viols) -> {",
    "            System.out.println(expId + \":\");",
    "            viols.forEach(v -> System.out.println(\"  - \" + v.message));",
    "        });",
    "",
    "        System.out.println(\"\\nDemo complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-30",
      "explanation": "Core data structures (Expense, Violation, RuleResult) from Parts 1 & 2"
    },
    {
      "lines": "65-85",
      "explanation": "Rule abstract base class with from_config classmethod requirement"
    },
    {
      "lines": "90-130",
      "explanation": "BanRule implementation with field-based matching and from_config factory method"
    },
    {
      "lines": "195-265",
      "explanation": "CompositeRule with AND/OR operators - the key Part 3 addition"
    },
    {
      "lines": "270-320",
      "explanation": "RuleRegistry with HashMap for O(1) type lookup and built-in registration"
    },
    {
      "lines": "325-380",
      "explanation": "RuleFactory that uses registry for creation, with special CompositeRule handling"
    },
    {
      "lines": "385-430",
      "explanation": "RulesEngine extended with add_rule_from_config method"
    },
    {
      "lines": "435-480",
      "explanation": "RulesAPIHandler simulating REST API endpoints"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "RuleRegistry.register": {
          "complexity": "O(1)",
          "explanation": "HashMap insertion"
        },
        "RuleRegistry.lookup": {
          "complexity": "O(1)",
          "explanation": "HashMap lookup"
        },
        "RuleFactory.create_rule": {
          "complexity": "O(r) for composite with r rules",
          "explanation": "Must recursively create each child rule"
        },
        "CompositeRule.evaluate": {
          "complexity": "O(r \u00d7 c) where r is rules and c is per-rule cost",
          "explanation": "Evaluates each child rule"
        }
      },
      "overall_change": "Rule creation is O(1) for simple rules, O(r) for composites. Evaluation complexity unchanged per rule."
    },
    "space": {
      "additional_space": "O(t) for t registered types in registry",
      "explanation": "Registry stores one entry per rule type. Composite rules store list of children."
    }
  },
  "dry_run": {
    "example_input": "Create CompositeRule(AND, [MaxAmount($50), BanRule(vendor_type=casino)]) then evaluate $60 restaurant expense",
    "steps": [
      {
        "step": 1,
        "action": "Factory receives config with type='CompositeRule'",
        "state": "config parsed",
        "explanation": "Factory extracts type name"
      },
      {
        "step": 2,
        "action": "Factory looks up 'CompositeRule' in registry",
        "state": "CompositeRule class found",
        "explanation": "O(1) HashMap lookup"
      },
      {
        "step": 3,
        "action": "Factory recursively creates MaxAmountRule($50)",
        "state": "first child created",
        "explanation": "Nested create_rule call"
      },
      {
        "step": 4,
        "action": "Factory recursively creates BanRule(vendor_type=casino)",
        "state": "second child created",
        "explanation": "Another nested call"
      },
      {
        "step": 5,
        "action": "CompositeRule constructed with AND operator and 2 children",
        "state": "composite ready",
        "explanation": "All children in list"
      },
      {
        "step": 6,
        "action": "Evaluate $60 restaurant expense against composite",
        "state": "evaluating",
        "explanation": "AND evaluation starts"
      },
      {
        "step": 7,
        "action": "MaxAmountRule($50) evaluates $60",
        "state": "violated=True",
        "explanation": "60 > 50"
      },
      {
        "step": 8,
        "action": "BanRule(vendor_type=casino) evaluates restaurant",
        "state": "violated=False",
        "explanation": "restaurant != casino"
      },
      {
        "step": 9,
        "action": "AND logic: any(violated)? Yes",
        "state": "composite violated",
        "explanation": "First rule was violated"
      }
    ],
    "final_output": "RuleResult(violated=True, violations=[MaxAmount violation for $60])"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Create simple BanRule, verify it bans correctly",
      "Create AND composite, verify 'any violation = fail'"
    ],
    "likely_bugs": [
      "CompositeRule.from_config not receiving factory for recursion",
      "Wrong AND/OR semantics",
      "Not handling nested config structure"
    ],
    "recommended_logs_or_asserts": [
      "assert rule_class is not None after lookup",
      "log each child rule created in composite",
      "assert len(children) > 0 for composite"
    ],
    "how_to_localize": "1. Verify registry has rule type. 2. Print config at each factory call. 3. Trace composite child creation. 4. Check evaluation results per child."
  },
  "edge_cases": [
    {
      "case": "Unknown rule type",
      "handling": "Registry raises ValueError with available types listed",
      "gotcha": "Don't return None, raise descriptive error"
    },
    {
      "case": "Empty CompositeRule",
      "handling": "Constructor raises ValueError",
      "gotcha": "Must have at least one child rule"
    },
    {
      "case": "Deeply nested composites",
      "handling": "Recursive factory calls handle any depth",
      "gotcha": "Watch for stack overflow on pathological inputs"
    },
    {
      "case": "Missing config fields",
      "handling": "Each rule's from_config validates and raises ValueError",
      "gotcha": "Fail fast with specific message"
    },
    {
      "case": "Invalid operator string",
      "handling": "CompositeOperator.valueOf raises error",
      "gotcha": "Normalize to uppercase before parsing"
    }
  ],
  "test_cases": [
    {
      "name": "Create BanRule from config",
      "input": "{'type': 'BanRule', 'config': {'field': 'vendor_type', 'value': 'casino'}}",
      "expected": "BanRule instance that bans casino vendor_type",
      "explanation": "Factory looks up BanRule, calls from_config with nested config"
    },
    {
      "name": "AND composite with one violation",
      "input": "CompositeRule(AND, [MaxAmount($50), MaxAmount($100)]) with $75 expense",
      "expected": "Violated (first rule fails)",
      "explanation": "AND requires all to pass; first rule violated means composite violated"
    },
    {
      "name": "OR composite with one pass",
      "input": "CompositeRule(OR, [MaxAmount($50), MaxAmount($100)]) with $75 expense",
      "expected": "Not violated (second rule passes)",
      "explanation": "OR requires at least one to pass; second rule passes so composite passes"
    },
    {
      "name": "Nested composite",
      "input": "(A AND B) OR C where A fails, B fails, C passes",
      "expected": "Not violated",
      "explanation": "Inner AND is violated, but outer OR passes because C passes"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Hardcoding rule types in switch statement",
      "why_wrong": "Violates Open/Closed Principle; must modify factory for each new type",
      "correct_approach": "Use registry pattern for O(1) lookup and runtime extensibility",
      "code_example_wrong": "if type == 'BanRule': return BanRule(...) elif type == 'MaxRule': ...",
      "code_example_correct": "rule_class = self.registry.lookup(type_name); return rule_class.from_config(config)"
    },
    {
      "mistake": "Confusing AND/OR semantics for rule composition",
      "why_wrong": "AND should mean 'all must pass' (any violation fails), OR means 'at least one passes'",
      "correct_approach": "AND: violated = any(child.violated), OR: violated = all(child.violated)",
      "code_example_wrong": "# AND: violated = all(child.violated) -- WRONG!",
      "code_example_correct": "# AND: violated = any(child.violated) -- Correct"
    },
    {
      "mistake": "Not passing factory to CompositeRule.from_config",
      "why_wrong": "CompositeRule needs factory to recursively create child rules",
      "correct_approach": "Pass factory reference to enable recursive creation",
      "code_example_wrong": "return CompositeRule.from_config(config)  # Can't create children!",
      "code_example_correct": "return CompositeRule.from_config(config, factory=self)"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by identifying the three patterns (Factory, Registry, Composite) and their purposes. Sketch the class diagram before coding. Emphasize extensibility.",
    "what_to_mention": [
      "Open/Closed Principle - new rules without modifying factory",
      "Composite pattern - uniform treatment of leaves and branches",
      "Fail-fast validation at creation time"
    ],
    "time_allocation": "3 min: understand and discuss patterns. 7 min: implement core classes. 5 min: test and handle edge cases.",
    "if_stuck": [
      "Start with just Registry and Factory, add Composite after",
      "Use simple dict for registry, not fancy generics",
      "Hardcode AND first, add OR after"
    ]
  },
  "connection_to_next_part": "Part 4 might add: Rule versioning/history, Priority/conflict resolution between rules, Async rule evaluation, Rule persistence to database, A/B testing of rule sets.",
  "communication_script": {
    "transition_from_previous": "Part 2 had hardcoded rules. For Part 3, I need to make rules configurable at runtime. I'll use three classic patterns: Registry for type lookup, Factory for creation, and Composite for AND/OR combinations.",
    "explaining_changes": "The key insight is decoupling. The Registry decouples 'what types exist' from the factory. Each rule class owns its own config validation via from_config(). The Factory orchestrates but doesn't know rule details.",
    "while_extending_code": [
      "Adding RuleRegistry for O(1) type lookup...",
      "Each rule gets a from_config classmethod for self-describing creation...",
      "CompositeRule is special - it needs the factory reference for recursive child creation..."
    ],
    "after_completing": "Now we can create any registered rule from JSON config. Registry lookup is O(1), composite creation is O(r) for r child rules. The system is extensible - new rule types just register themselves."
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this part",
    "by_2_min": "Identify the three patterns, understand AND/OR semantics",
    "by_5_min": "Have Registry and basic Factory structure, starting on CompositeRule",
    "by_10_min": "Core implementation done, testing basic cases",
    "warning_signs": "If still deciding on patterns at 5 min, simplify. Start with just BanRule working, add others incrementally."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 2 evaluate() has bugs, fix them first. The factory/registry are independent, but composite evaluation uses the same logic.",
    "if_new_requirement_unclear": "Ask: 'For CompositeRule AND, does any violation fail the composite, or must all fail?' Clarify semantics early.",
    "if_running_behind": "Skip TripTotalRule from_config, focus on BanRule and CompositeRule. Mention you'd add others similarly."
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Correctly identifying Factory + Registry + Composite pattern combination",
      "Explaining why from_config is on the rule class (self-describing rules)",
      "Handling the recursive CompositeRule creation cleanly",
      "Discussing production concerns: validation, error messages, logging"
    ]
  },
  "pattern_recognition": {
    "pattern": "Factory + Registry + Composite",
    "indicators": [
      "Create objects from config/JSON",
      "Lookup type by string name",
      "Combine items with AND/OR logic"
    ],
    "similar_problems": [
      "Expression parser/evaluator",
      "Plugin systems",
      "UI component factories",
      "Query builders"
    ],
    "template": "Registry: dict[str, Type]; Factory: lookup_and_create(); Composite: list of children + operator"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'create from JSON config', I think Factory Pattern",
      "why": "Factory encapsulates object creation logic"
    },
    {
      "step": 2,
      "thought": "When I see 'type name in config', I think Registry Pattern",
      "why": "Registry maps strings to classes for O(1) lookup"
    },
    {
      "step": 3,
      "thought": "When I see 'AND/OR combinations', I think Composite Pattern",
      "why": "Composite treats single items and groups uniformly"
    },
    {
      "step": 4,
      "thought": "Key constraint is extensibility without code changes",
      "why": "This drives the registry approach over switch statements"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Do you recognize classic OOP patterns?",
      "Can you compose patterns effectively?",
      "Do you handle recursion (nested composites) cleanly?",
      "Is your code extensible?"
    ],
    "bonus_points": [
      "Mentioning Open/Closed Principle",
      "Discussing factory method vs abstract factory",
      "Handling validation errors gracefully",
      "Considering thread safety for registry"
    ],
    "red_flags": [
      "Giant switch statement for types",
      "Not understanding AND/OR semantics",
      "Missing recursive case for nested composites",
      "No validation of config"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Let AI generate boilerplate for data classes",
      "Use AI for typing hints on factory methods"
    ],
    "what_not_to_do": [
      "Don't accept AI's first attempt at AND/OR logic without verifying",
      "Understand the pattern architecture yourself"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Jumping into code without discussing patterns",
      "Not asking about AND/OR semantics"
    ],
    "technical": [
      "Putting all creation logic in one giant function",
      "Forgetting to handle recursive composites",
      "Not validating config"
    ],
    "communication": [
      "Not explaining why three patterns together",
      "Not mentioning extensibility benefits"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Can I create any registered rule type from config?",
      "Does CompositeRule handle nested composites?",
      "Are AND/OR semantics correct?",
      "Do I validate configs and give good error messages?"
    ],
    "quick_code_review": [
      "Registry lookup is O(1)",
      "Factory doesn't have type-specific switch statements",
      "CompositeRule receives factory for recursion",
      "from_config validates required fields"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Thread-safe registry for concurrent rule creation",
      "Rule serialization back to JSON",
      "Metrics on rule creation and evaluation",
      "Audit logging for who created which rules"
    ],
    "why_not_in_interview": "Focus on core patterns; these are implementation details",
    "how_to_mention": "Say: 'In production, I'd add thread-safety to the registry singleton and audit logging for compliance.'"
  },
  "generated_at": "2026-01-18T18:40:31.248540",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 3,
    "model": "claude-opus-4-5-20251101"
  }
}