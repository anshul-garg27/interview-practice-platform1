{
  "problem_title": "Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
  "part_number": 2,
  "builds_on": "Part 1",
  "difficulty": "medium",
  "problem_understanding": {
    "what_changes": "Part 1 evaluated rules on individual expenses independently. Part 2 introduces **aggregation rules** that need to see ALL expenses for a trip before making a decision. This requires grouping expenses by trip_id and computing aggregate metrics (sums) across multiple expenses.",
    "new_requirements": [
      "TripTotalLimitRule: Sum all expenses per trip and check against a maximum limit",
      "ExpenseTypeAggregationRule: Sum expenses of a specific type per trip and check against a limit",
      "Return contributing expense IDs for transparency in violations",
      "Support mixed evaluation of individual and aggregation rules"
    ],
    "new_constraints": [
      "Aggregation rules cannot evaluate one expense at a time - they need full trip context",
      "Must efficiently group expenses by trip_id before evaluation",
      "Violation output format changes - includes trip_id and contributing_expenses instead of single expense_id"
    ],
    "key_insight": "**Pre-process expenses into a HashMap grouped by trip_id in O(n), then evaluate aggregation rules against each trip's expense list.** This transforms a potentially O(n\u00b2) problem (checking every expense against every other expense in same trip) into O(n + t*r) where t=trips, r=rules."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "TripTotalLimitRule - sum all expenses per trip",
        "how_met": "TripTotalLimitRule.evaluate() sums all expense amounts and compares to max_trip_total",
        "gotchas": [
          "Remember to include ALL expenses, not filter by type",
          "Use Decimal for precise money arithmetic"
        ]
      },
      {
        "requirement": "ExpenseTypeAggregationRule - sum by expense type per trip",
        "how_met": "ExpenseTypeAggregationRule.evaluate() filters expenses by type, then sums matching amounts",
        "gotchas": [
          "Return None if no expenses match the type",
          "Only include matching expenses in contributing_expenses"
        ]
      },
      {
        "requirement": "Return contributing expense IDs",
        "how_met": "AggregationViolation dataclass includes contributing_expenses list with all relevant expense_ids",
        "gotchas": [
          "For TripTotalLimit, ALL trip expenses contribute; for ExpenseType, only matching type contributes"
        ]
      },
      {
        "requirement": "Efficient trip grouping",
        "how_met": "_group_expenses_by_trip() uses defaultdict(list) for O(n) grouping",
        "gotchas": [
          "Don't recreate grouping for each rule - do it once and reuse"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "groupByTrip",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Single pass through expenses using HashMap"
      },
      {
        "operation": "evaluateAggregationRules",
        "target": "O(n + t*r)",
        "achieved": "O(n + t*r)",
        "why": "O(n) for grouping + O(t*r) for evaluating r rules against t trips"
      }
    ],
    "non_goals": [
      "Real-time streaming evaluation (we process batches)",
      "Partial trip tracking (we see all expenses at once)",
      "Rule priority or conflict resolution between aggregation rules"
    ]
  },
  "assumptions": [
    "All expenses for a trip are provided in the input list (no partial trip data)",
    "trip_id is always present and valid for aggregation rules to work",
    "Expenses are not modified during evaluation (immutable input)",
    "Empty trip (no expenses) should not trigger violations",
    "Multiple aggregation rules can flag the same trip independently"
  ],
  "tradeoffs": [
    {
      "decision": "Separate AggregationRule interface vs extending ExpenseRule",
      "chosen": "Separate AggregationRule interface",
      "why": "Different method signatures (evaluate takes trip_id + List<Expense> vs single Expense). Cleaner separation of concerns.",
      "alternative": "Single interface with overloaded methods",
      "when_to_switch": "If rules need to be evaluated uniformly in a pipeline"
    },
    {
      "decision": "Pre-compute grouping vs on-demand grouping",
      "chosen": "Pre-compute grouping once before evaluation",
      "why": "Avoids O(n) grouping per rule; amortizes cost across all aggregation rules",
      "alternative": "Each rule groups expenses itself",
      "when_to_switch": "If rules need different grouping keys (not just trip_id)"
    },
    {
      "decision": "Separate violation types (Violation vs AggregationViolation)",
      "chosen": "Separate dataclasses",
      "why": "Different fields needed - expense_id vs trip_id + contributing_expenses",
      "alternative": "Single Violation class with optional fields",
      "when_to_switch": "If unified reporting format is required"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "AggregationRule interface signature",
      "AggregationViolation structure",
      "groupByTrip utility method"
    ],
    "what_to_change": [
      "New AggregationRule subclasses (e.g., VendorTypeAggregationRule)",
      "Additional fields in AggregationViolation if needed"
    ],
    "interfaces_and_boundaries": "The engine cleanly separates individual and aggregation rule evaluation. Part 3 can add time-based rules by introducing a new interface or extending aggregation with time-window logic.",
    "invariants": [
      "Aggregation rules always receive non-empty expense lists (trips with expenses)",
      "Contributing expenses list is never null (may be empty)",
      "Trip grouping is computed once per evaluate_aggregation_rules call"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Part 1): Evaluate each expense independently\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  E001  \u2502  E002  \u2502  E003  \u2502  E004  \u2502  E005       \u2502\n\u2502  $50   \u2502  $100  \u2502  $75   \u2502  $200  \u2502  $150       \u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502        \u2502        \u2502        \u2502        \u2502\n    \u25bc        \u25bc        \u25bc        \u25bc        \u25bc\n   Rule     Rule     Rule     Rule     Rule\n   Check    Check    Check    Check    Check\n\nAFTER (Part 2): Group by trip, then aggregate\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  E001  \u2502  E002  \u2502  E003  \u2502  E004  \u2502  E005       \u2502\n\u2502  T001  \u2502  T001  \u2502  T001  \u2502  T002  \u2502  T002       \u2502\n\u2502  $50   \u2502  $100  \u2502  $75   \u2502  $200  \u2502  $150       \u2502\n\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502        \u2502        \u2502        \u2502        \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502 Group by trip_id          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502    Trip T001    \u2502        \u2502    Trip T002    \u2502\n    \u2502 [E001,E002,E003]\u2502        \u2502  [E004, E005]   \u2502\n    \u2502  Total: $225    \u2502        \u2502   Total: $350   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502                          \u2502\n             \u25bc                          \u25bc\n      Aggregation Rules           Aggregation Rules\n```",
    "algorithm_flow": "```\nAlgorithm Flow for evaluate_aggregation_rules():\n\nStep 1: Group expenses by trip_id\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nInput: [E001-T001, E002-T001, E003-T002]\n              \u2502\n              \u25bc\n    HashMap<trip_id, List<Expense>>\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 T001 \u2192 [E001, E002]           \u2502\n    \u2502 T002 \u2192 [E003]                 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nStep 2: For each trip, evaluate all aggregation rules\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFor trip T001:\n    \u251c\u2500 TripTotalLimitRule: sum([50, 100]) = 150\n    \u2502   \u2514\u2500 150 > 100 limit? \u2192 VIOLATION\n    \u2502\n    \u2514\u2500 ExpenseTypeAggRule(meals): sum(meals) = 50\n        \u2514\u2500 50 > 75 limit? \u2192 PASS\n\nFor trip T002:\n    \u2514\u2500 TripTotalLimitRule: sum([75]) = 75\n        \u2514\u2500 75 > 100 limit? \u2192 PASS\n\nStep 3: Collect and return violations\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nReturn: [AggregationViolation(T001, TripTotalLimit, ...)]\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension - Re-scan for Each Rule",
      "description": "For each aggregation rule, iterate through ALL expenses, group them, then evaluate. Grouping is done repeatedly per rule.",
      "time_complexity": "O(n * r) for grouping alone",
      "space_complexity": "O(n)",
      "why_not_optimal": "Redundant work - we group expenses by trip_id multiple times (once per rule). If we have 5 aggregation rules, we scan and group 5 times."
    },
    {
      "name": "Optimal Approach - Pre-compute Trip Grouping",
      "description": "Group all expenses by trip_id ONCE upfront using a HashMap. Then iterate through each trip and evaluate all aggregation rules against that trip's expense list.",
      "time_complexity": "O(n + t*r) where n=expenses, t=trips, r=rules",
      "space_complexity": "O(n) for the trip grouping HashMap",
      "key_insight": "The grouping operation is rule-independent. Compute it once and reuse for all aggregation rules. This transforms redundant O(n*r) grouping into single O(n) preprocessing."
    }
  ],
  "optimal_solution": {
    "explanation_md": "### Optimal Solution: HashMap Pre-grouping + Strategy Pattern\n\n**Core Insight:** Aggregation rules all need expenses grouped by `trip_id`. Instead of each rule doing this independently, we **pre-compute the grouping once** and pass trip expense lists to each rule.\n\n**Architecture:**\n1. **AggregationRule Interface:** New abstract class with `evaluate(trip_id, expenses)` signature\n2. **TripTotalLimitRule:** Sums ALL expenses for a trip\n3. **ExpenseTypeAggregationRule:** Filters by type, then sums\n4. **Engine Enhancement:** Adds `_group_expenses_by_trip()` utility and `evaluate_aggregation_rules()` method\n\n**Key Design Decisions:**\n- **Separate violation type:** `AggregationViolation` has `trip_id` and `contributing_expenses` instead of single `expense_id`\n- **Pre-grouping:** O(n) preprocessing avoids repeated scans\n- **Interface segregation:** `ExpenseRule` vs `AggregationRule` - different evaluation contexts",
    "data_structures": [
      {
        "structure": "HashMap<String, List<Expense>>",
        "purpose": "Group expenses by trip_id for O(1) lookup per trip"
      },
      {
        "structure": "AggregationViolation dataclass",
        "purpose": "Capture trip-level violations with contributing expense IDs"
      },
      {
        "structure": "List<AggregationRule>",
        "purpose": "Store aggregation rules separately from individual rules"
      }
    ],
    "algorithm_steps": [
      "Step 1: Create HashMap<trip_id, List<Expense>> by iterating through all expenses once - O(n)",
      "Step 2: For each trip in the HashMap:",
      "  Step 2a: Get the list of expenses for this trip",
      "  Step 2b: For each aggregation rule, call rule.evaluate(trip_id, expenses)",
      "  Step 2c: If violation returned, add to violations list",
      "Step 3: Return collected violations",
      "Note: TripTotalLimitRule sums ALL expenses; ExpenseTypeAggregationRule filters first, then sums"
    ]
  },
  "solution_python_lines": [
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from decimal import Decimal",
    "from typing import List, Dict, Set, Optional",
    "from collections import defaultdict",
    "",
    "",
    "@dataclass",
    "class Expense:",
    "    \"\"\"Represents a corporate expense.\"\"\"",
    "    expense_id: str",
    "    trip_id: str",
    "    amount_usd: Decimal",
    "    expense_type: str",
    "    vendor_type: str",
    "    vendor_name: str",
    "    ",
    "    @classmethod",
    "    def from_dict(cls, data: dict) -> 'Expense':",
    "        return cls(",
    "            expense_id=data['expense_id'],",
    "            trip_id=data['trip_id'],",
    "            amount_usd=Decimal(data['amount_usd']),",
    "            expense_type=data['expense_type'],",
    "            vendor_type=data['vendor_type'],",
    "            vendor_name=data['vendor_name']",
    "        )",
    "",
    "",
    "@dataclass",
    "class Violation:",
    "    \"\"\"Represents a rule violation for individual expense.\"\"\"",
    "    expense_id: str",
    "    rule: str",
    "    reason: str",
    "",
    "",
    "@dataclass",
    "class AggregationViolation:",
    "    \"\"\"Represents a rule violation at trip level.\"\"\"",
    "    trip_id: str",
    "    rule: str",
    "    reason: str",
    "    contributing_expenses: List[str] = field(default_factory=list)",
    "",
    "",
    "# ============================================================",
    "# Part 1 Rules (preserved from previous part)",
    "# ============================================================",
    "",
    "class ExpenseRule(ABC):",
    "    \"\"\"Abstract base class for individual expense rules.\"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"Evaluate a single expense against this rule.\"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_rule_name(self) -> str:",
    "        \"\"\"Return the name of this rule.\"\"\"",
    "        pass",
    "",
    "",
    "class VendorDenylistRule(ExpenseRule):",
    "    \"\"\"Blocks specific vendors from being used.\"\"\"",
    "    ",
    "    def __init__(self, denied_vendors: Set[str]):",
    "        self.denied_vendors = {v.lower() for v in denied_vendors}",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        if expense.vendor_name.lower() in self.denied_vendors:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                rule=self.get_rule_name(),",
    "                reason=f\"vendor '{expense.vendor_name}' is not allowed\"",
    "            )",
    "        return None",
    "    ",
    "    def get_rule_name(self) -> str:",
    "        return \"VendorDenylistRule\"",
    "",
    "",
    "class ExpenseTypeLimitRule(ExpenseRule):",
    "    \"\"\"Limits spending per expense type.\"\"\"",
    "    ",
    "    def __init__(self, expense_type: str, max_amount: Decimal):",
    "        self.expense_type = expense_type",
    "        self.max_amount = max_amount",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        if expense.expense_type == self.expense_type:",
    "            if expense.amount_usd > self.max_amount:",
    "                return Violation(",
    "                    expense_id=expense.expense_id,",
    "                    rule=self.get_rule_name(),",
    "                    reason=f\"{self.expense_type} expense ${expense.amount_usd:.2f} exceeds limit ${self.max_amount:.2f}\"",
    "                )",
    "        return None",
    "    ",
    "    def get_rule_name(self) -> str:",
    "        return \"ExpenseTypeLimitRule\"",
    "",
    "",
    "# ============================================================",
    "# Part 2: Aggregation Rules (NEW)",
    "# ============================================================",
    "",
    "class AggregationRule(ABC):",
    "    \"\"\"",
    "    Abstract base class for trip-level aggregation rules.",
    "    ",
    "    Key difference from ExpenseRule:",
    "    - ExpenseRule evaluates ONE expense at a time",
    "    - AggregationRule evaluates ALL expenses for a trip together",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[AggregationViolation]:",
    "        \"\"\"",
    "        Evaluate all expenses for a single trip against this rule.",
    "        ",
    "        Args:",
    "            trip_id: The trip identifier",
    "            expenses: All expenses belonging to this trip",
    "            ",
    "        Returns:",
    "            AggregationViolation if rule is violated, None otherwise",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_rule_name(self) -> str:",
    "        \"\"\"Return the name of this rule.\"\"\"",
    "        pass",
    "",
    "",
    "class TripTotalLimitRule(AggregationRule):",
    "    \"\"\"",
    "    Limits total spending per trip.",
    "    ",
    "    Example: Trip total cannot exceed $2000",
    "    All expenses in the trip contribute to this total.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_trip_total: Decimal):",
    "        \"\"\"",
    "        Args:",
    "            max_trip_total: Maximum total amount allowed per trip",
    "        \"\"\"",
    "        self.max_trip_total = max_trip_total",
    "    ",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[AggregationViolation]:",
    "        # Sum ALL expenses for this trip",
    "        total = sum(exp.amount_usd for exp in expenses)",
    "        ",
    "        if total > self.max_trip_total:",
    "            return AggregationViolation(",
    "                trip_id=trip_id,",
    "                rule=self.get_rule_name(),",
    "                reason=f\"trip total ${total:.2f} exceeds limit ${self.max_trip_total:.2f}\",",
    "                # All expenses contribute to trip total",
    "                contributing_expenses=[exp.expense_id for exp in expenses]",
    "            )",
    "        return None",
    "    ",
    "    def get_rule_name(self) -> str:",
    "        return \"TripTotalLimitRule\"",
    "",
    "",
    "class ExpenseTypeAggregationRule(AggregationRule):",
    "    \"\"\"",
    "    Limits total spending per expense type per trip.",
    "    ",
    "    Example: Meal expenses per trip cannot exceed $200",
    "    Only expenses matching the specified type are counted.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, expense_type: str, max_amount: Decimal):",
    "        \"\"\"",
    "        Args:",
    "            expense_type: The type of expense to aggregate (e.g., 'meals')",
    "            max_amount: Maximum total amount allowed for this type per trip",
    "        \"\"\"",
    "        self.expense_type = expense_type",
    "        self.max_amount = max_amount",
    "    ",
    "    def evaluate(self, trip_id: str, expenses: List[Expense]) -> Optional[AggregationViolation]:",
    "        # Filter to only expenses matching our target type",
    "        matching_expenses = [",
    "            exp for exp in expenses ",
    "            if exp.expense_type == self.expense_type",
    "        ]",
    "        ",
    "        # No matching expenses = no violation possible",
    "        if not matching_expenses:",
    "            return None",
    "        ",
    "        # Sum only the matching expenses",
    "        total = sum(exp.amount_usd for exp in matching_expenses)",
    "        ",
    "        if total > self.max_amount:",
    "            return AggregationViolation(",
    "                trip_id=trip_id,",
    "                rule=self.get_rule_name(),",
    "                reason=f\"{self.expense_type} total ${total:.2f} exceeds limit ${self.max_amount:.2f}\",",
    "                # Only matching expenses contribute",
    "                contributing_expenses=[exp.expense_id for exp in matching_expenses]",
    "            )",
    "        return None",
    "    ",
    "    def get_rule_name(self) -> str:",
    "        return \"ExpenseTypeAggregationRule\"",
    "",
    "",
    "# ============================================================",
    "# Enhanced Rules Engine (supports both Part 1 and Part 2)",
    "# ============================================================",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"",
    "    Corporate expense rules engine that evaluates both individual ",
    "    expense rules and trip-level aggregation rules.",
    "    ",
    "    Design Pattern: Strategy Pattern for rules",
    "    - Rules are interchangeable strategies",
    "    - Engine orchestrates evaluation without knowing rule details",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        self.individual_rules: List[ExpenseRule] = []",
    "        self.aggregation_rules: List[AggregationRule] = []",
    "    ",
    "    def add_individual_rule(self, rule: ExpenseRule) -> None:",
    "        \"\"\"Add an individual expense rule.\"\"\"",
    "        self.individual_rules.append(rule)",
    "    ",
    "    def add_aggregation_rule(self, rule: AggregationRule) -> None:",
    "        \"\"\"Add a trip-level aggregation rule.\"\"\"",
    "        self.aggregation_rules.append(rule)",
    "    ",
    "    def evaluate_individual_rules(self, expenses: List[Expense]) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate all expenses against individual rules (Part 1).",
    "        ",
    "        Time Complexity: O(e * r) where e = expenses, r = rules",
    "        \"\"\"",
    "        violations = []",
    "        for expense in expenses:",
    "            for rule in self.individual_rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation:",
    "                    violations.append(violation)",
    "        return violations",
    "    ",
    "    def _group_expenses_by_trip(self, expenses: List[Expense]) -> Dict[str, List[Expense]]:",
    "        \"\"\"",
    "        Group expenses by trip_id.",
    "        ",
    "        This is the KEY OPTIMIZATION for Part 2:",
    "        - Computed ONCE regardless of number of aggregation rules",
    "        - Enables O(1) lookup of all expenses for any trip",
    "        ",
    "        Time Complexity: O(n) - single pass through expenses",
    "        Space Complexity: O(n) - storing references in new structure",
    "        \"\"\"",
    "        trip_expenses: Dict[str, List[Expense]] = defaultdict(list)",
    "        for expense in expenses:",
    "            trip_expenses[expense.trip_id].append(expense)",
    "        return trip_expenses",
    "    ",
    "    def evaluate_aggregation_rules(",
    "        self, ",
    "        expenses: List[Expense]",
    "    ) -> List[AggregationViolation]:",
    "        \"\"\"",
    "        Evaluate all expenses against aggregation rules (Part 2).",
    "        ",
    "        Key Insight: Group expenses by trip_id ONCE, then evaluate",
    "        each trip against all aggregation rules.",
    "        ",
    "        Time Complexity: O(n + t * r * e_avg) where:",
    "            n = total expenses (for grouping)",
    "            t = number of trips",
    "            r = number of aggregation rules",
    "            e_avg = average expenses per trip",
    "        ",
    "        In practice: O(n * r) since sum of all trip expenses = n",
    "        ",
    "        Space Complexity: O(n) for the grouping HashMap",
    "        \"\"\"",
    "        if not self.aggregation_rules:",
    "            return []",
    "        ",
    "        # Step 1: Group expenses by trip_id - O(n)",
    "        trip_expenses = self._group_expenses_by_trip(expenses)",
    "        ",
    "        # Step 2: Evaluate each trip against all aggregation rules",
    "        violations = []",
    "        for trip_id, trip_exps in trip_expenses.items():",
    "            for rule in self.aggregation_rules:",
    "                violation = rule.evaluate(trip_id, trip_exps)",
    "                if violation:",
    "                    violations.append(violation)",
    "        ",
    "        return violations",
    "    ",
    "    def evaluate_all(self, expenses: List[Expense]) -> Dict[str, List]:",
    "        \"\"\"",
    "        Evaluate all rules (both individual and aggregation).",
    "        ",
    "        Returns:",
    "            Dictionary with 'individual' and 'aggregation' violation lists",
    "        \"\"\"",
    "        return {",
    "            'individual': self.evaluate_individual_rules(expenses),",
    "            'aggregation': self.evaluate_aggregation_rules(expenses)",
    "        }",
    "",
    "",
    "# ============================================================",
    "# Demo and Testing",
    "# ============================================================",
    "",
    "def demo():",
    "    \"\"\"Demonstrate the expense rules engine with aggregation rules.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"Corporate Expense Rules Engine - Part 2 Demo\")",
    "    print(\"=\" * 60)",
    "    ",
    "    # --------------------------------------------------------",
    "    # Example 1: TripTotalLimitRule",
    "    # --------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"Example 1: Trip Total Limit Rule\")",
    "    print(\"-\" * 60)",
    "    ",
    "    engine_1 = ExpenseRulesEngine()",
    "    engine_1.add_aggregation_rule(TripTotalLimitRule(Decimal(\"300\")))",
    "    ",
    "    expenses_1 = [",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E001\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"150.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"A\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E002\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"200.00\", \"expense_type\": \"lodging\",",
    "            \"vendor_type\": \"hotel\", \"vendor_name\": \"B\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E003\", \"trip_id\": \"T002\",",
    "            \"amount_usd\": \"100.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"C\"",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for exp in expenses_1:",
    "        print(f\"  {exp.expense_id}: Trip={exp.trip_id}, ${exp.amount_usd}, {exp.expense_type}\")",
    "    ",
    "    print(\"\\nRule: Trip total <= $300.00\")",
    "    print(\"\\nExpected: T001 violates ($150 + $200 = $350 > $300)\")",
    "    print(\"          T002 passes ($100 <= $300)\")",
    "    ",
    "    violations_1 = engine_1.evaluate_aggregation_rules(expenses_1)",
    "    ",
    "    print(f\"\\nViolations found: {len(violations_1)}\")",
    "    for v in violations_1:",
    "        print(f\"  Trip: {v.trip_id}\")",
    "        print(f\"  Rule: {v.rule}\")",
    "        print(f\"  Reason: {v.reason}\")",
    "        print(f\"  Contributing: {v.contributing_expenses}\")",
    "    ",
    "    # --------------------------------------------------------",
    "    # Example 2: ExpenseTypeAggregationRule",
    "    # --------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"Example 2: Expense Type Aggregation Rule\")",
    "    print(\"-\" * 60)",
    "    ",
    "    engine_2 = ExpenseRulesEngine()",
    "    engine_2.add_aggregation_rule(",
    "        ExpenseTypeAggregationRule(\"meals\", Decimal(\"200\"))",
    "    )",
    "    ",
    "    expenses_2 = [",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E001\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"80.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"A\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E002\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"150.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"B\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E003\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"500.00\", \"expense_type\": \"lodging\",",
    "            \"vendor_type\": \"hotel\", \"vendor_name\": \"C\"",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for exp in expenses_2:",
    "        print(f\"  {exp.expense_id}: Trip={exp.trip_id}, ${exp.amount_usd}, {exp.expense_type}\")",
    "    ",
    "    print(\"\\nRule: Meals per trip <= $200.00\")",
    "    print(\"\\nExpected: T001 meals violate ($80 + $150 = $230 > $200)\")",
    "    print(\"          Lodging E003 is NOT counted\")",
    "    ",
    "    violations_2 = engine_2.evaluate_aggregation_rules(expenses_2)",
    "    ",
    "    print(f\"\\nViolations found: {len(violations_2)}\")",
    "    for v in violations_2:",
    "        print(f\"  Trip: {v.trip_id}\")",
    "        print(f\"  Rule: {v.rule}\")",
    "        print(f\"  Reason: {v.reason}\")",
    "        print(f\"  Contributing: {v.contributing_expenses}\")",
    "    ",
    "    # --------------------------------------------------------",
    "    # Example 3: Combined Individual + Aggregation Rules",
    "    # --------------------------------------------------------",
    "    print(\"\\n\" + \"-\" * 60)",
    "    print(\"Example 3: Combined Individual + Aggregation Rules\")",
    "    print(\"-\" * 60)",
    "    ",
    "    engine_3 = ExpenseRulesEngine()",
    "    # Individual rules from Part 1",
    "    engine_3.add_individual_rule(VendorDenylistRule({\"Sketchy Corp\"}))",
    "    engine_3.add_individual_rule(",
    "        ExpenseTypeLimitRule(\"entertainment\", Decimal(\"100\"))",
    "    )",
    "    # Aggregation rules from Part 2",
    "    engine_3.add_aggregation_rule(TripTotalLimitRule(Decimal(\"500\")))",
    "    engine_3.add_aggregation_rule(",
    "        ExpenseTypeAggregationRule(\"meals\", Decimal(\"150\"))",
    "    )",
    "    ",
    "    expenses_3 = [",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E001\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"100.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"Good Place\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E002\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"100.00\", \"expense_type\": \"meals\",",
    "            \"vendor_type\": \"restaurant\", \"vendor_name\": \"Sketchy Corp\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E003\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"200.00\", \"expense_type\": \"lodging\",",
    "            \"vendor_type\": \"hotel\", \"vendor_name\": \"Nice Hotel\"",
    "        }),",
    "        Expense.from_dict({",
    "            \"expense_id\": \"E004\", \"trip_id\": \"T001\",",
    "            \"amount_usd\": \"150.00\", \"expense_type\": \"entertainment\",",
    "            \"vendor_type\": \"venue\", \"vendor_name\": \"Fun Place\"",
    "        }),",
    "    ]",
    "    ",
    "    print(\"\\nExpenses:\")",
    "    for exp in expenses_3:",
    "        print(f\"  {exp.expense_id}: {exp.trip_id}, ${exp.amount_usd}, {exp.expense_type}, {exp.vendor_name}\")",
    "    ",
    "    print(\"\\nRules:\")",
    "    print(\"  Individual: Vendor denylist [Sketchy Corp]\")",
    "    print(\"  Individual: Entertainment limit $100\")",
    "    print(\"  Aggregation: Trip total <= $500\")",
    "    print(\"  Aggregation: Meals per trip <= $150\")",
    "    ",
    "    all_violations = engine_3.evaluate_all(expenses_3)",
    "    ",
    "    print(f\"\\nIndividual Violations: {len(all_violations['individual'])}\")",
    "    for v in all_violations['individual']:",
    "        print(f\"  {v.expense_id}: {v.rule} - {v.reason}\")",
    "    ",
    "    print(f\"\\nAggregation Violations: {len(all_violations['aggregation'])}\")",
    "    for v in all_violations['aggregation']:",
    "        print(f\"  {v.trip_id}: {v.rule}\")",
    "        print(f\"    {v.reason}\")",
    "        print(f\"    Contributing: {v.contributing_expenses}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(\"Demo Complete!\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    demo()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "import java.util.stream.Collectors;",
    "",
    "/**",
    " * Corporate Expense Rules Engine - Part 2: Trip-Level Aggregation Rules",
    " * ",
    " * Supports both individual expense rules and trip-level aggregation rules.",
    " */",
    "public class ExpenseRulesEngine {",
    "    ",
    "    // ============================================================",
    "    // Data Classes",
    "    // ============================================================",
    "    ",
    "    public static class Expense {",
    "        public final String expenseId;",
    "        public final String tripId;",
    "        public final BigDecimal amountUsd;",
    "        public final String expenseType;",
    "        public final String vendorType;",
    "        public final String vendorName;",
    "        ",
    "        public Expense(String expenseId, String tripId, String amountUsd,",
    "                       String expenseType, String vendorType, String vendorName) {",
    "            this.expenseId = expenseId;",
    "            this.tripId = tripId;",
    "            this.amountUsd = new BigDecimal(amountUsd);",
    "            this.expenseType = expenseType;",
    "            this.vendorType = vendorType;",
    "            this.vendorName = vendorName;",
    "        }",
    "    }",
    "    ",
    "    public static class Violation {",
    "        public final String expenseId;",
    "        public final String rule;",
    "        public final String reason;",
    "        ",
    "        public Violation(String expenseId, String rule, String reason) {",
    "            this.expenseId = expenseId;",
    "            this.rule = rule;",
    "            this.reason = reason;",
    "        }",
    "    }",
    "    ",
    "    public static class AggregationViolation {",
    "        public final String tripId;",
    "        public final String rule;",
    "        public final String reason;",
    "        public final List<String> contributingExpenses;",
    "        ",
    "        public AggregationViolation(String tripId, String rule, String reason,",
    "                                    List<String> contributingExpenses) {",
    "            this.tripId = tripId;",
    "            this.rule = rule;",
    "            this.reason = reason;",
    "            this.contributingExpenses = contributingExpenses;",
    "        }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // Part 1: Individual Expense Rules",
    "    // ============================================================",
    "    ",
    "    public interface ExpenseRule {",
    "        Violation evaluate(Expense expense);",
    "        String getRuleName();",
    "    }",
    "    ",
    "    public static class VendorDenylistRule implements ExpenseRule {",
    "        private final Set<String> deniedVendors;",
    "        ",
    "        public VendorDenylistRule(Set<String> deniedVendors) {",
    "            this.deniedVendors = deniedVendors.stream()",
    "                .map(String::toLowerCase)",
    "                .collect(Collectors.toSet());",
    "        }",
    "        ",
    "        @Override",
    "        public Violation evaluate(Expense expense) {",
    "            if (deniedVendors.contains(expense.vendorName.toLowerCase())) {",
    "                return new Violation(",
    "                    expense.expenseId,",
    "                    getRuleName(),",
    "                    String.format(\"vendor '%s' is not allowed\", expense.vendorName)",
    "                );",
    "            }",
    "            return null;",
    "        }",
    "        ",
    "        @Override",
    "        public String getRuleName() { return \"VendorDenylistRule\"; }",
    "    }",
    "    ",
    "    public static class ExpenseTypeLimitRule implements ExpenseRule {",
    "        private final String expenseType;",
    "        private final BigDecimal maxAmount;",
    "        ",
    "        public ExpenseTypeLimitRule(String expenseType, BigDecimal maxAmount) {",
    "            this.expenseType = expenseType;",
    "            this.maxAmount = maxAmount;",
    "        }",
    "        ",
    "        @Override",
    "        public Violation evaluate(Expense expense) {",
    "            if (expense.expenseType.equals(expenseType) &&",
    "                expense.amountUsd.compareTo(maxAmount) > 0) {",
    "                return new Violation(",
    "                    expense.expenseId,",
    "                    getRuleName(),",
    "                    String.format(\"%s expense $%.2f exceeds limit $%.2f\",",
    "                        expenseType, expense.amountUsd, maxAmount)",
    "                );",
    "            }",
    "            return null;",
    "        }",
    "        ",
    "        @Override",
    "        public String getRuleName() { return \"ExpenseTypeLimitRule\"; }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // Part 2: Aggregation Rules (NEW)",
    "    // ============================================================",
    "    ",
    "    public interface AggregationRule {",
    "        /**",
    "         * Evaluate all expenses for a single trip against this rule.",
    "         * ",
    "         * @param tripId The trip identifier",
    "         * @param expenses All expenses belonging to this trip",
    "         * @return AggregationViolation if rule is violated, null otherwise",
    "         */",
    "        AggregationViolation evaluate(String tripId, List<Expense> expenses);",
    "        String getRuleName();",
    "    }",
    "    ",
    "    /**",
    "     * Limits total spending per trip.",
    "     * All expenses in the trip contribute to this total.",
    "     */",
    "    public static class TripTotalLimitRule implements AggregationRule {",
    "        private final BigDecimal maxTripTotal;",
    "        ",
    "        public TripTotalLimitRule(BigDecimal maxTripTotal) {",
    "            this.maxTripTotal = maxTripTotal;",
    "        }",
    "        ",
    "        @Override",
    "        public AggregationViolation evaluate(String tripId, List<Expense> expenses) {",
    "            BigDecimal total = expenses.stream()",
    "                .map(e -> e.amountUsd)",
    "                .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "            ",
    "            if (total.compareTo(maxTripTotal) > 0) {",
    "                List<String> contributingIds = expenses.stream()",
    "                    .map(e -> e.expenseId)",
    "                    .collect(Collectors.toList());",
    "                    ",
    "                return new AggregationViolation(",
    "                    tripId,",
    "                    getRuleName(),",
    "                    String.format(\"trip total $%.2f exceeds limit $%.2f\",",
    "                        total, maxTripTotal),",
    "                    contributingIds",
    "                );",
    "            }",
    "            return null;",
    "        }",
    "        ",
    "        @Override",
    "        public String getRuleName() { return \"TripTotalLimitRule\"; }",
    "    }",
    "    ",
    "    /**",
    "     * Limits total spending per expense type per trip.",
    "     * Only expenses matching the specified type are counted.",
    "     */",
    "    public static class ExpenseTypeAggregationRule implements AggregationRule {",
    "        private final String expenseType;",
    "        private final BigDecimal maxAmount;",
    "        ",
    "        public ExpenseTypeAggregationRule(String expenseType, BigDecimal maxAmount) {",
    "            this.expenseType = expenseType;",
    "            this.maxAmount = maxAmount;",
    "        }",
    "        ",
    "        @Override",
    "        public AggregationViolation evaluate(String tripId, List<Expense> expenses) {",
    "            List<Expense> matching = expenses.stream()",
    "                .filter(e -> e.expenseType.equals(expenseType))",
    "                .collect(Collectors.toList());",
    "            ",
    "            if (matching.isEmpty()) {",
    "                return null;",
    "            }",
    "            ",
    "            BigDecimal total = matching.stream()",
    "                .map(e -> e.amountUsd)",
    "                .reduce(BigDecimal.ZERO, BigDecimal::add);",
    "            ",
    "            if (total.compareTo(maxAmount) > 0) {",
    "                List<String> contributingIds = matching.stream()",
    "                    .map(e -> e.expenseId)",
    "                    .collect(Collectors.toList());",
    "                    ",
    "                return new AggregationViolation(",
    "                    tripId,",
    "                    getRuleName(),",
    "                    String.format(\"%s total $%.2f exceeds limit $%.2f\",",
    "                        expenseType, total, maxAmount),",
    "                    contributingIds",
    "                );",
    "            }",
    "            return null;",
    "        }",
    "        ",
    "        @Override",
    "        public String getRuleName() { return \"ExpenseTypeAggregationRule\"; }",
    "    }",
    "    ",
    "    // ============================================================",
    "    // Rules Engine",
    "    // ============================================================",
    "    ",
    "    private final List<ExpenseRule> individualRules = new ArrayList<>();",
    "    private final List<AggregationRule> aggregationRules = new ArrayList<>();",
    "    ",
    "    public void addIndividualRule(ExpenseRule rule) {",
    "        individualRules.add(rule);",
    "    }",
    "    ",
    "    public void addAggregationRule(AggregationRule rule) {",
    "        aggregationRules.add(rule);",
    "    }",
    "    ",
    "    public List<Violation> evaluateIndividualRules(List<Expense> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        for (Expense expense : expenses) {",
    "            for (ExpenseRule rule : individualRules) {",
    "                Violation v = rule.evaluate(expense);",
    "                if (v != null) {",
    "                    violations.add(v);",
    "                }",
    "            }",
    "        }",
    "        return violations;",
    "    }",
    "    ",
    "    /**",
    "     * Group expenses by trip_id.",
    "     * Key optimization: Computed ONCE regardless of number of aggregation rules.",
    "     * ",
    "     * Time Complexity: O(n)",
    "     * Space Complexity: O(n)",
    "     */",
    "    private Map<String, List<Expense>> groupExpensesByTrip(List<Expense> expenses) {",
    "        Map<String, List<Expense>> tripExpenses = new HashMap<>();",
    "        for (Expense expense : expenses) {",
    "            tripExpenses",
    "                .computeIfAbsent(expense.tripId, k -> new ArrayList<>())",
    "                .add(expense);",
    "        }",
    "        return tripExpenses;",
    "    }",
    "    ",
    "    /**",
    "     * Evaluate all expenses against aggregation rules.",
    "     * ",
    "     * Time Complexity: O(n + t * r) where n=expenses, t=trips, r=rules",
    "     * Space Complexity: O(n) for the grouping HashMap",
    "     */",
    "    public List<AggregationViolation> evaluateAggregationRules(List<Expense> expenses) {",
    "        if (aggregationRules.isEmpty()) {",
    "            return Collections.emptyList();",
    "        }",
    "        ",
    "        // Step 1: Group expenses by trip_id - O(n)",
    "        Map<String, List<Expense>> tripExpenses = groupExpensesByTrip(expenses);",
    "        ",
    "        // Step 2: Evaluate each trip against all aggregation rules",
    "        List<AggregationViolation> violations = new ArrayList<>();",
    "        for (Map.Entry<String, List<Expense>> entry : tripExpenses.entrySet()) {",
    "            String tripId = entry.getKey();",
    "            List<Expense> tripExps = entry.getValue();",
    "            ",
    "            for (AggregationRule rule : aggregationRules) {",
    "                AggregationViolation v = rule.evaluate(tripId, tripExps);",
    "                if (v != null) {",
    "                    violations.add(v);",
    "                }",
    "            }",
    "        }",
    "        ",
    "        return violations;",
    "    }",
    "    ",
    "    // ============================================================",
    "    // Demo",
    "    // ============================================================",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(60));",
    "        System.out.println(\"Corporate Expense Rules Engine - Part 2 Demo\");",
    "        System.out.println(\"=\".repeat(60));",
    "        ",
    "        // Example 1: TripTotalLimitRule",
    "        System.out.println(\"\\nExample 1: Trip Total Limit Rule\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        ExpenseRulesEngine engine1 = new ExpenseRulesEngine();",
    "        engine1.addAggregationRule(",
    "            new TripTotalLimitRule(new BigDecimal(\"300\"))",
    "        );",
    "        ",
    "        List<Expense> expenses1 = Arrays.asList(",
    "            new Expense(\"E001\", \"T001\", \"150.00\", \"meals\", \"restaurant\", \"A\"),",
    "            new Expense(\"E002\", \"T001\", \"200.00\", \"lodging\", \"hotel\", \"B\"),",
    "            new Expense(\"E003\", \"T002\", \"100.00\", \"meals\", \"restaurant\", \"C\")",
    "        );",
    "        ",
    "        System.out.println(\"Rule: Trip total <= $300\");",
    "        List<AggregationViolation> v1 = engine1.evaluateAggregationRules(expenses1);",
    "        System.out.println(\"Violations: \" + v1.size());",
    "        for (AggregationViolation v : v1) {",
    "            System.out.printf(\"  Trip %s: %s%n\", v.tripId, v.reason);",
    "            System.out.println(\"  Contributing: \" + v.contributingExpenses);",
    "        }",
    "        ",
    "        // Example 2: ExpenseTypeAggregationRule",
    "        System.out.println(\"\\nExample 2: Expense Type Aggregation Rule\");",
    "        System.out.println(\"-\".repeat(40));",
    "        ",
    "        ExpenseRulesEngine engine2 = new ExpenseRulesEngine();",
    "        engine2.addAggregationRule(",
    "            new ExpenseTypeAggregationRule(\"meals\", new BigDecimal(\"200\"))",
    "        );",
    "        ",
    "        List<Expense> expenses2 = Arrays.asList(",
    "            new Expense(\"E001\", \"T001\", \"80.00\", \"meals\", \"restaurant\", \"A\"),",
    "            new Expense(\"E002\", \"T001\", \"150.00\", \"meals\", \"restaurant\", \"B\"),",
    "            new Expense(\"E003\", \"T001\", \"500.00\", \"lodging\", \"hotel\", \"C\")",
    "        );",
    "        ",
    "        System.out.println(\"Rule: Meals per trip <= $200\");",
    "        List<AggregationViolation> v2 = engine2.evaluateAggregationRules(expenses2);",
    "        System.out.println(\"Violations: \" + v2.size());",
    "        for (AggregationViolation v : v2) {",
    "            System.out.printf(\"  Trip %s: %s%n\", v.tripId, v.reason);",
    "            System.out.println(\"  Contributing: \" + v.contributingExpenses);",
    "        }",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(60));",
    "        System.out.println(\"Demo Complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-28",
      "explanation": "**Data classes**: Expense (with from_dict factory), Violation for individual rules, AggregationViolation for trip-level rules with contributing_expenses field"
    },
    {
      "lines": "45-85",
      "explanation": "**Part 1 Rules (preserved)**: ExpenseRule ABC, VendorDenylistRule, ExpenseTypeLimitRule - unchanged from Part 1"
    },
    {
      "lines": "90-110",
      "explanation": "**AggregationRule ABC**: New abstract class with different signature - evaluate(trip_id, expenses: List) instead of evaluate(expense). This is the KEY DESIGN DECISION separating individual and aggregate evaluation"
    },
    {
      "lines": "112-145",
      "explanation": "**TripTotalLimitRule**: Sums ALL expenses for a trip using sum(). Returns all expense_ids as contributing since they all count toward trip total"
    },
    {
      "lines": "148-190",
      "explanation": "**ExpenseTypeAggregationRule**: First FILTERS expenses by type, then sums. Only includes matching expenses in contributing_expenses - this is important for transparency"
    },
    {
      "lines": "195-240",
      "explanation": "**Engine Enhancement**: Separate lists for individual_rules and aggregation_rules. The _group_expenses_by_trip() helper uses defaultdict for O(n) grouping"
    },
    {
      "lines": "242-275",
      "explanation": "**evaluate_aggregation_rules()**: The core Part 2 method. Step 1: Group by trip_id ONCE. Step 2: For each trip, evaluate against ALL aggregation rules. This avoids redundant grouping"
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "_group_expenses_by_trip": {
          "complexity": "O(n)",
          "explanation": "Single pass through all expenses, HashMap insertion is O(1) amortized"
        },
        "evaluate_aggregation_rules": {
          "complexity": "O(n + t*r)",
          "explanation": "O(n) for grouping + O(t) trips \u00d7 O(r) rules. Since sum of expenses across all trips = n, this is effectively O(n*r)"
        },
        "TripTotalLimitRule.evaluate": {
          "complexity": "O(e)",
          "explanation": "Iterates through all expenses in the trip to sum them"
        },
        "ExpenseTypeAggregationRule.evaluate": {
          "complexity": "O(e)",
          "explanation": "Filters and sums - two passes through trip expenses"
        }
      },
      "overall_change": "Part 2 adds O(n + t*r) for aggregation. Combined with Part 1's O(n*r_individual), total is O(n * (r_ind + r_agg))"
    },
    "space": {
      "additional_space": "O(n)",
      "explanation": "The trip grouping HashMap stores references to all n expenses. Each expense is referenced once (in its trip's list)"
    }
  },
  "dry_run": {
    "example_input": "TripTotalLimitRule(max=300), Expenses: E001-T001-$150, E002-T001-$200, E003-T002-$100",
    "steps": [
      {
        "step": 1,
        "action": "Group expenses by trip_id",
        "state": "trip_expenses = {T001: [E001, E002], T002: [E003]}",
        "explanation": "Single pass O(n) creates HashMap grouping"
      },
      {
        "step": 2,
        "action": "Evaluate trip T001 against TripTotalLimitRule",
        "state": "total = 150 + 200 = 350",
        "explanation": "Sum all expenses in T001"
      },
      {
        "step": 3,
        "action": "Compare: 350 > 300?",
        "state": "YES - create violation",
        "explanation": "Trip total exceeds limit"
      },
      {
        "step": 4,
        "action": "Create AggregationViolation",
        "state": "violation = {trip_id: T001, rule: TripTotalLimitRule, reason: 'trip total $350.00 exceeds limit $300.00', contributing: [E001, E002]}",
        "explanation": "Both expenses contribute to violation"
      },
      {
        "step": 5,
        "action": "Evaluate trip T002 against TripTotalLimitRule",
        "state": "total = 100",
        "explanation": "Sum all expenses in T002"
      },
      {
        "step": 6,
        "action": "Compare: 100 > 300?",
        "state": "NO - no violation",
        "explanation": "Trip total under limit"
      }
    ],
    "final_output": "[AggregationViolation(trip_id='T001', rule='TripTotalLimitRule', reason='trip total $350.00 exceeds limit $300.00', contributing_expenses=['E001', 'E002'])]"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Single trip, single expense under limit \u2192 no violations",
      "Single trip, single expense over limit \u2192 one violation with that expense in contributing",
      "Two trips, one violating \u2192 only violating trip in results"
    ],
    "likely_bugs": [
      "Including ALL expenses in contributing_expenses for ExpenseTypeAggregationRule (should only include matching type)",
      "Not handling empty expense list for a type (should return None, not error)",
      "Re-grouping expenses inside each rule instead of once in engine",
      "Decimal precision issues when comparing (use compareTo() in Java)"
    ],
    "recommended_logs_or_asserts": [
      "assert len(trip_expenses) <= len(expenses), 'Should have at most as many trips as expenses'",
      "log: f'Evaluating trip {trip_id} with {len(expenses)} expenses'",
      "log: f'Rule {rule.get_rule_name()} returned {violation is not None}'"
    ],
    "how_to_localize": "1. Log the trip grouping result. 2. Log each rule evaluation input (trip_id, expense count). 3. Log computed totals before comparison. 4. Verify contributing_expenses list matches expectations."
  },
  "edge_cases": [
    {
      "case": "Empty expense list",
      "handling": "Return empty violations list - no trips to evaluate",
      "gotcha": "Don't throw exception on empty input"
    },
    {
      "case": "Trip with no expenses of target type",
      "handling": "ExpenseTypeAggregationRule returns None - no violation possible",
      "gotcha": "Check for empty matching list before summing"
    },
    {
      "case": "Exact limit match (total == limit)",
      "handling": "No violation - we use > not >=",
      "gotcha": "Clarify with interviewer if exact match should violate"
    },
    {
      "case": "Single expense exceeds trip total limit",
      "handling": "Violation with that single expense in contributing_expenses",
      "gotcha": "contributing_expenses should work for single expense too"
    },
    {
      "case": "Multiple aggregation rules on same trip",
      "handling": "Each rule evaluates independently - can have multiple violations for same trip",
      "gotcha": "Don't short-circuit after first violation"
    }
  ],
  "test_cases": [
    {
      "name": "TripTotalLimit - Basic violation",
      "input": "Rule: max=300, Expenses: T001-$150, T001-$200",
      "expected": "1 violation: T001 total $350 > $300",
      "explanation": "Sum exceeds limit"
    },
    {
      "name": "TripTotalLimit - Under limit",
      "input": "Rule: max=500, Expenses: T001-$150, T001-$200",
      "expected": "0 violations",
      "explanation": "$350 < $500"
    },
    {
      "name": "ExpenseTypeAggregation - Basic violation",
      "input": "Rule: meals max=200, Expenses: T001-meals-$80, T001-meals-$150, T001-lodging-$500",
      "expected": "1 violation: meals $230 > $200, contributing=[E001, E002]",
      "explanation": "Only meals count, lodging ignored"
    },
    {
      "name": "ExpenseTypeAggregation - No matching type",
      "input": "Rule: meals max=200, Expenses: T001-lodging-$500",
      "expected": "0 violations",
      "explanation": "No meals to sum"
    },
    {
      "name": "Multiple trips - only one violates",
      "input": "Rule: max=300, Expenses: T001-$350, T002-$100",
      "expected": "1 violation for T001 only",
      "explanation": "T002 under limit"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Re-grouping expenses inside each rule",
      "why_wrong": "Wastes O(n) time per rule instead of O(n) total",
      "correct_approach": "Group ONCE in engine, pass grouped lists to rules",
      "code_example_wrong": "# Inside TripTotalLimitRule.evaluate\\ntrip_expenses = [e for e in ALL_EXPENSES if e.trip_id == target_trip]",
      "code_example_correct": "# Engine does grouping\\nfor trip_id, expenses in grouped.items():\\n    rule.evaluate(trip_id, expenses)"
    },
    {
      "mistake": "Including all trip expenses in contributing_expenses for type-specific rules",
      "why_wrong": "Misleading - lodging expenses don't contribute to meals limit violation",
      "correct_approach": "Only include expenses that match the filter",
      "code_example_wrong": "contributing_expenses = [e.expense_id for e in expenses]  # ALL",
      "code_example_correct": "contributing_expenses = [e.expense_id for e in matching_expenses]  # FILTERED"
    },
    {
      "mistake": "Using float instead of Decimal for money",
      "why_wrong": "Floating point errors: 0.1 + 0.2 != 0.3",
      "correct_approach": "Use Decimal in Python, BigDecimal in Java",
      "code_example_wrong": "total = sum(float(e.amount) for e in expenses)",
      "code_example_correct": "total = sum(e.amount_usd for e in expenses)  # where amount_usd is Decimal"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start by explaining the KEY INSIGHT: 'Individual rules evaluate one expense at a time, but aggregation rules need ALL expenses for a trip. So I'll pre-group expenses by trip_id in O(n), then pass each trip's list to aggregation rules.'",
    "what_to_mention": [
      "Separate interface for AggregationRule - different method signature",
      "Pre-compute grouping ONCE to avoid redundant O(n) scans",
      "contributing_expenses provides transparency for violations",
      "Decimal/BigDecimal for money precision"
    ],
    "time_allocation": "2 min understand requirement, 3 min design/explain, 5-7 min implement, 2 min test",
    "if_stuck": [
      "Think about what data structure helps with 'group by' - HashMap",
      "Consider: What's different about evaluating a group vs one item?",
      "If confused about output format, ask interviewer about violation structure"
    ]
  },
  "connection_to_next_part": "Part 3 might add **time-based rules** (e.g., daily limits, spending velocity). The grouping pattern established here extends naturally - instead of just grouping by trip_id, we might group by (trip_id, date) or maintain time-sorted lists. The AggregationRule interface can be extended to accept additional context like time windows.",
  "communication_script": {
    "transition_from_previous": "Great, Part 1 is working for individual expenses. For Part 2, I need to add trip-level aggregation rules. The key challenge is that these rules need to see ALL expenses for a trip, not just one at a time.",
    "explaining_changes": "My approach is to create a separate AggregationRule interface with a different signature - it takes a trip_id and a LIST of expenses. I'll pre-compute the grouping by trip_id once, then evaluate each trip against all aggregation rules.",
    "while_extending_code": [
      "I'm adding a new AggregationViolation class with trip_id and contributing_expenses instead of single expense_id",
      "The _group_expenses_by_trip helper uses defaultdict for O(n) grouping",
      "TripTotalLimitRule sums ALL expenses; ExpenseTypeAggregationRule filters first, then sums"
    ],
    "after_completing": "This handles Part 2. Grouping is O(n), evaluation is O(t*r). The key is we group ONCE and reuse. Ready for Part 3?"
  },
  "time_milestones": {
    "time_budget": "10-12 minutes for this part",
    "by_2_min": "Understand aggregation requirement, identify need for grouping",
    "by_5_min": "Design explained, start implementing AggregationRule interface",
    "by_8_min": "Both rule classes implemented",
    "by_10_min": "Engine updated, testing examples",
    "warning_signs": "If still designing at 5 min, start coding immediately with basic approach"
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "If Part 1 has bugs, fix them first. Say: 'I notice the grouping is related to Part 2, let me ensure Part 1 is solid.'",
    "if_new_requirement_unclear": "Ask: 'For the aggregation violation, should I return all expense IDs that contributed, or just the trip ID?'",
    "if_running_behind": "Implement TripTotalLimitRule first (simpler), mention ExpenseTypeAggregationRule would be similar with a filter step"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Immediately recognizing the grouping pattern",
      "Separating interfaces for different evaluation contexts",
      "Mentioning O(n) preprocessing saves time across multiple rules",
      "Discussing how contributing_expenses provides audit trail"
    ]
  },
  "pattern_recognition": {
    "pattern": "Group By + Aggregation (MapReduce-style)",
    "indicators": [
      "Rules need to see 'multiple items together'",
      "Grouping key mentioned (trip_id)",
      "Aggregate operations (sum, count, max)"
    ],
    "similar_problems": [
      "LC 49 - Group Anagrams (grouping pattern)",
      "LC 560 - Subarray Sum Equals K (aggregation)",
      "Database GROUP BY operations"
    ],
    "template": "```python\\n# Generic group-by aggregation template\\nfrom collections import defaultdict\\n\\ndef group_and_aggregate(items, key_fn, agg_fn):\\n    groups = defaultdict(list)\\n    for item in items:\\n        groups[key_fn(item)].append(item)\\n    return {k: agg_fn(v) for k, v in groups.items()}\\n```"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'aggregate expenses per trip', I immediately think HashMap grouping",
      "why": "This is the canonical 'group by' pattern - collect items by key first, then process groups"
    },
    {
      "step": 2,
      "thought": "The key constraint is different method signature - one expense vs list of expenses",
      "why": "This tells me I need a SEPARATE interface, not overloading the existing ExpenseRule"
    },
    {
      "step": 3,
      "thought": "I should pre-compute grouping once, not per-rule",
      "why": "Avoid redundant O(n) work; grouping is rule-independent"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you recognize the group-by pattern quickly?",
      "Do you understand why a different interface is needed?",
      "Can you extend existing code cleanly without rewriting?",
      "Do you consider efficiency (pre-compute grouping)?"
    ],
    "bonus_points": [
      "Mentioning contributing_expenses for audit/transparency",
      "Discussing Decimal precision for money",
      "Recognizing this extends naturally to more aggregation types"
    ],
    "red_flags": [
      "Re-grouping inside each rule (missed optimization)",
      "Modifying Part 1 ExpenseRule interface unnecessarily",
      "Not understanding why aggregation needs different approach"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI for dataclass boilerplate",
      "Let it help with defaultdict syntax if unfamiliar",
      "Use for generating test cases"
    ],
    "what_not_to_do": [
      "Don't let AI decide the interface design",
      "Verify the grouping logic matches your mental model",
      "Ensure contributing_expenses is correctly filtered"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Not asking about violation output format",
      "Jumping to code without explaining grouping strategy"
    ],
    "technical": [
      "Using same interface for aggregation rules",
      "Grouping inside each rule instead of once",
      "Forgetting to filter for ExpenseTypeAggregationRule"
    ],
    "communication": [
      "Not explaining WHY pre-grouping is more efficient",
      "Not mentioning the contributing_expenses design decision"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Does _group_expenses_by_trip return correct grouping?",
      "Does TripTotalLimitRule sum ALL expenses?",
      "Does ExpenseTypeAggregationRule filter correctly?",
      "Are contributing_expenses correct for each rule type?",
      "Did I trace through the provided examples?"
    ],
    "quick_code_review": [
      "AggregationRule interface has correct signature",
      "Using Decimal not float for amounts",
      "Handling empty expense list gracefully",
      "Type hints on new methods"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Logging: 'Evaluating trip {trip_id} with {n} expenses'",
      "Metrics: Track aggregation rule evaluation time",
      "Caching: If same expense list evaluated multiple times",
      "Async: For large expense sets, parallel evaluation per trip"
    ],
    "why_not_in_interview": "Focus on core algorithm; premature optimization adds complexity",
    "how_to_mention": "Say: 'In production, I'd add logging for each trip evaluation and metrics to track rule performance.'"
  },
  "generated_at": "2026-01-18T18:37:43.030300",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": 2,
    "model": "claude-opus-4-5-20251101"
  }
}