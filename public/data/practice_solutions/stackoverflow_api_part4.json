{
  "problem_title": "Stack Overflow API Design - Part 4: Scalability and Security Discussion",
  "part_number": 4,
  "builds_on": "Part 3",
  "difficulty": "hard",
  "problem_understanding": {
    "what_changes": "This part transitions from functional implementation to architectural design discussions. We move beyond in-memory operations to discuss how the system would scale to millions of users and handle real-world security threats. This requires demonstrating knowledge of distributed systems, caching strategies, database optimization, and security best practices.",
    "new_requirements": [
      "Discuss database sharding strategies for questions, answers, and users",
      "Design caching layer for hot content",
      "Implement rate limiting to prevent abuse",
      "Add authentication and authorization layers",
      "Demonstrate input validation and XSS/SQL injection prevention",
      "Discuss spam detection approaches"
    ],
    "new_constraints": [
      "Must handle read-heavy workload (100:1 read:write ratio)",
      "Must support eventual consistency where appropriate",
      "Rate limiting must be per-user AND per-IP",
      "Full-text search must scale to millions of documents"
    ],
    "key_insight": "Stack Overflow is fundamentally a READ-HEAVY system. The key insight is to separate read and write paths, cache aggressively at multiple levels, and use specialized systems (Elasticsearch for search, Redis for caching) rather than forcing one database to do everything."
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Database Sharding",
        "how_met": "Implemented shard key strategies for user-based, question-based, and geographic sharding with consistent hashing",
        "gotchas": [
          "Cross-shard queries are expensive",
          "Resharding requires careful planning"
        ]
      },
      {
        "requirement": "Caching Strategy",
        "how_met": "Multi-level cache with Redis for hot questions, user sessions, and search results with TTL policies",
        "gotchas": [
          "Cache invalidation is hard",
          "Cache stampede on popular content"
        ]
      },
      {
        "requirement": "Rate Limiting",
        "how_met": "Token bucket algorithm with sliding window, per-user and per-IP tracking",
        "gotchas": [
          "Distributed rate limiting needs shared state",
          "Different limits for different endpoints"
        ]
      },
      {
        "requirement": "Authentication",
        "how_met": "JWT-based authentication with refresh tokens and secure session management",
        "gotchas": [
          "Token expiration handling",
          "Secure storage of secrets"
        ]
      },
      {
        "requirement": "Authorization",
        "how_met": "Role-based access control with ownership checks for edit/delete operations",
        "gotchas": [
          "Authorization != Authentication",
          "Admin override capabilities"
        ]
      },
      {
        "requirement": "Input Validation",
        "how_met": "Comprehensive validation layer with sanitization, parameterized queries, and content security",
        "gotchas": [
          "Validate on server side always",
          "Don't trust client-side validation"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "Rate limit check",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Redis INCR operations are O(1)"
      },
      {
        "operation": "Cache lookup",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Hash-based cache access"
      },
      {
        "operation": "Full-text search",
        "target": "O(log n)",
        "achieved": "O(log n)",
        "why": "Elasticsearch inverted index"
      }
    ],
    "non_goals": [
      "Actual distributed deployment",
      "Real database integration",
      "Production cryptographic implementations"
    ]
  },
  "assumptions": [
    "The system will be deployed on cloud infrastructure with auto-scaling capabilities",
    "Redis is available for distributed caching and rate limiting",
    "Elasticsearch or similar is available for full-text search",
    "The read:write ratio is approximately 100:1",
    "Users are authenticated before accessing protected endpoints",
    "The system should handle 10,000 requests/second at peak"
  ],
  "tradeoffs": [
    {
      "decision": "Sharding by Question ID vs User ID",
      "chosen": "Question ID for main content",
      "why": "Questions are accessed independently; user-based sharding would create hotspots for popular answerers",
      "alternative": "User ID sharding",
      "when_to_switch": "If user profile pages become the dominant access pattern"
    },
    {
      "decision": "Redis vs Memcached for caching",
      "chosen": "Redis",
      "why": "Supports complex data structures, persistence, and pub/sub for cache invalidation",
      "alternative": "Memcached",
      "when_to_switch": "If only simple key-value caching is needed"
    },
    {
      "decision": "JWT vs Session tokens",
      "chosen": "JWT for stateless auth",
      "why": "Scales horizontally without shared session store",
      "alternative": "Session tokens with Redis",
      "when_to_switch": "If immediate token revocation is critical"
    },
    {
      "decision": "Eventual vs Strong consistency",
      "chosen": "Eventual for votes/views",
      "why": "Vote counts don't need instant consistency; reduces DB load",
      "alternative": "Strong consistency",
      "when_to_switch": "For financial transactions or ownership transfers"
    }
  ],
  "extensibility_notes": {
    "what_to_keep_stable": [
      "Core API interfaces from Parts 1-3",
      "Entity IDs and relationships",
      "Search query format"
    ],
    "what_to_change": [
      "Add middleware layers for security",
      "Inject cache layer between API and storage",
      "Add async processing for non-critical operations"
    ],
    "interfaces_and_boundaries": "The security and caching layers are implemented as decorators and middleware, allowing them to wrap existing functionality without modifying core logic. This follows the Open-Closed Principle.",
    "invariants": [
      "All write operations must pass authentication",
      "Rate limits are enforced before processing any request",
      "User can only modify their own content (unless admin)",
      "All user input is sanitized before storage"
    ]
  },
  "visual_explanation": {
    "before_after": "```\nBEFORE (Parts 1-3):                    AFTER (Part 4):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  API Layer   \u2502                       \u2502   Load Balancer  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  In-Memory   \u2502                       \u2502   API Gateway    \u2502\n\u2502   Storage    \u2502                       \u2502  \u251c\u2500 Rate Limit   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                       \u2502  \u251c\u2500 Auth/JWT     \u2502\n                                       \u2502  \u2514\u2500 Validation   \u2502\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                \u2502\n                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                       \u2502   Cache Layer    \u2502\n                                       \u2502    (Redis)       \u2502\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                \u2502\n                                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                       \u2502  Service Layer   \u2502\n                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502   \u2502\n                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500  \u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                    \u2502                        \u2502\n                              \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                              \u2502  Primary  \u2502          \u2502 Elasticsearch \u2502\n                              \u2502   DB      \u2502          \u2502   (Search)    \u2502\n                              \u2502  \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\u2502          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502  \u2502S1 \u2502S2 \u2502\u2502\n                              \u2502  \u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\u2502\n                              \u2502  (Shards) \u2502\n                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": "```\nRequest Flow with Security:\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  Client Request\n       \u2502\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 1. RATE LIMITING (Token Bucket)         \u2502\n  \u2502    \u251c\u2500 Check IP rate limit               \u2502\n  \u2502    \u251c\u2500 Check User rate limit (if auth'd) \u2502\n  \u2502    \u2514\u2500 REJECT if exceeded (429)          \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2713 Passed\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 2. AUTHENTICATION (JWT)                 \u2502\n  \u2502    \u251c\u2500 Extract Bearer token              \u2502\n  \u2502    \u251c\u2500 Verify signature                  \u2502\n  \u2502    \u251c\u2500 Check expiration                  \u2502\n  \u2502    \u2514\u2500 REJECT if invalid (401)           \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2713 Authenticated\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 3. INPUT VALIDATION                     \u2502\n  \u2502    \u251c\u2500 Sanitize HTML/scripts             \u2502\n  \u2502    \u251c\u2500 Validate field lengths            \u2502\n  \u2502    \u251c\u2500 Check data types                  \u2502\n  \u2502    \u2514\u2500 REJECT if malformed (400)         \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2713 Valid Input\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 4. AUTHORIZATION                        \u2502\n  \u2502    \u251c\u2500 Check user role                   \u2502\n  \u2502    \u251c\u2500 Verify resource ownership         \u2502\n  \u2502    \u2514\u2500 REJECT if forbidden (403)         \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 \u2713 Authorized\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 5. CACHE CHECK (for reads)              \u2502\n  \u2502    \u251c\u2500 Generate cache key                \u2502\n  \u2502    \u251c\u2500 Check Redis cache                 \u2502\n  \u2502    \u2514\u2500 RETURN if hit                     \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 Cache miss\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 6. BUSINESS LOGIC                       \u2502\n  \u2502    \u251c\u2500 Process request                   \u2502\n  \u2502    \u251c\u2500 Update database                   \u2502\n  \u2502    \u2514\u2500 Update cache                      \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u25bc\n  Response to Client\n```"
  },
  "approaches": [
    {
      "name": "Naive Extension",
      "description": "Add security checks inline within existing methods, keep everything in memory, no caching layer",
      "time_complexity": "O(n) for searches without indexing",
      "space_complexity": "O(n) all in single server memory",
      "why_not_optimal": "Doesn't scale beyond single server. No protection against attacks. Memory limits quickly reached. Security checks scattered throughout code making auditing difficult."
    },
    {
      "name": "Optimal Layered Approach",
      "description": "Implement security as middleware/decorators, add caching layer, prepare for horizontal scaling with sharding strategies, use specialized systems for search",
      "time_complexity": "O(1) for cached reads, O(log n) for searches",
      "space_complexity": "O(n) distributed across shards",
      "key_insight": "Security and scalability are cross-cutting concerns that should be implemented as layers wrapping the core business logic, not mixed into it. This allows each concern to be tested, modified, and scaled independently."
    }
  ],
  "optimal_solution": {
    "explanation_md": "## Scalability and Security Architecture\n\n### **Scalability Strategy**\n\n#### 1. Database Sharding\nWe use **consistent hashing** to distribute data across shards:\n- **Questions**: Sharded by `question_id % num_shards` - each question with its answers on same shard\n- **Users**: Sharded by `user_id % num_shards` - user profile data\n- **Votes**: Co-located with the entity being voted on\n\n#### 2. Caching Architecture\n**Multi-level caching** with Redis:\n- **L1**: Hot questions (top 1000 by views) - 5 min TTL\n- **L2**: User sessions and profiles - 30 min TTL\n- **L3**: Search results - 1 min TTL (more volatile)\n\n**Cache-aside pattern**: Check cache first, populate on miss\n\n#### 3. Read Replicas\nFor the 100:1 read:write ratio:\n- **Primary** handles all writes\n- **3+ Read Replicas** handle read traffic\n- **Async replication** with ~100ms lag (acceptable for most reads)\n\n#### 4. Search Optimization\n**Elasticsearch** cluster for full-text search:\n- Inverted index for fast text matching\n- Denormalized documents for search\n- Near real-time indexing (~1 second)\n\n### **Security Strategy**\n\n#### 1. Rate Limiting\n**Token bucket algorithm** with:\n- 100 requests/minute for authenticated users\n- 20 requests/minute for anonymous\n- Stricter limits (5/min) for write operations\n\n#### 2. Authentication\n**JWT tokens** with:\n- 15-minute access token expiry\n- 7-day refresh tokens\n- Signature verification using RS256\n\n#### 3. Authorization\n**Role-Based Access Control (RBAC)**:\n- `USER`: Can CRUD own content\n- `MODERATOR`: Can edit/delete any content\n- `ADMIN`: Full system access\n\n#### 4. Input Validation\n**Defense in depth**:\n- HTML sanitization (remove scripts)\n- SQL parameterization (prevent injection)\n- Length validation (prevent buffer overflows)\n- Content Security Policy headers",
    "data_structures": [
      {
        "structure": "Redis Hash",
        "purpose": "Store rate limit counters per user/IP"
      },
      {
        "structure": "JWT Claims",
        "purpose": "Carry user identity and roles"
      },
      {
        "structure": "Bloom Filter",
        "purpose": "Fast spam detection pre-filter"
      },
      {
        "structure": "Consistent Hash Ring",
        "purpose": "Shard key distribution"
      }
    ],
    "algorithm_steps": [
      "Step 1: Request arrives at load balancer, distributed to API server",
      "Step 2: Rate limiter checks token bucket for IP and user",
      "Step 3: JWT middleware validates and decodes authentication token",
      "Step 4: Input validator sanitizes and validates all input fields",
      "Step 5: Authorization middleware checks user permissions for action",
      "Step 6: Cache layer checks for cached response",
      "Step 7: If cache miss, route to appropriate database shard",
      "Step 8: For search, query Elasticsearch cluster",
      "Step 9: Update cache with new data",
      "Step 10: Return response with appropriate security headers"
    ]
  },
  "solution_python_lines": [
    "\"\"\"",
    "Stack Overflow API - Part 4: Scalability and Security",
    "=====================================================",
    "This module demonstrates production-ready security and scalability patterns.",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from datetime import datetime, timedelta",
    "from enum import Enum",
    "from functools import wraps",
    "from typing import Dict, List, Optional, Set, Callable, Any, Tuple",
    "from collections import defaultdict",
    "import hashlib",
    "import hmac",
    "import json",
    "import re",
    "import time",
    "import base64",
    "import uuid",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 1: RATE LIMITING",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class RateLimitExceeded(Exception):",
    "    \"\"\"Raised when rate limit is exceeded.\"\"\"",
    "    def __init__(self, retry_after: int):",
    "        self.retry_after = retry_after",
    "        super().__init__(f\"Rate limit exceeded. Retry after {retry_after} seconds.\")",
    "",
    "",
    "@dataclass",
    "class RateLimitConfig:",
    "    \"\"\"Configuration for rate limiting.\"\"\"",
    "    requests_per_minute: int",
    "    burst_size: int  # Maximum tokens in bucket",
    "    ",
    "    ",
    "class TokenBucketRateLimiter:",
    "    \"\"\"",
    "    Token Bucket Rate Limiter implementation.",
    "    ",
    "    In production, this would use Redis for distributed rate limiting.",
    "    INCR and EXPIRE commands provide atomic operations.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Simulates Redis storage",
    "        self._buckets: Dict[str, Dict] = {}",
    "        self._configs = {",
    "            'default': RateLimitConfig(requests_per_minute=100, burst_size=20),",
    "            'anonymous': RateLimitConfig(requests_per_minute=20, burst_size=5),",
    "            'write': RateLimitConfig(requests_per_minute=10, burst_size=3),",
    "        }",
    "    ",
    "    def _get_bucket_key(self, identifier: str, endpoint_type: str = 'default') -> str:",
    "        \"\"\"Generate a unique bucket key for identifier + endpoint type.\"\"\"",
    "        return f\"{endpoint_type}:{identifier}\"",
    "    ",
    "    def check_rate_limit(self, identifier: str, endpoint_type: str = 'default') -> Tuple[bool, int]:",
    "        \"\"\"",
    "        Check if request is allowed under rate limit.",
    "        ",
    "        Returns:",
    "            Tuple of (is_allowed, tokens_remaining or retry_after_seconds)",
    "        \"\"\"",
    "        bucket_key = self._get_bucket_key(identifier, endpoint_type)",
    "        config = self._configs.get(endpoint_type, self._configs['default'])",
    "        current_time = time.time()",
    "        ",
    "        # Initialize bucket if doesn't exist",
    "        if bucket_key not in self._buckets:",
    "            self._buckets[bucket_key] = {",
    "                'tokens': config.burst_size,",
    "                'last_refill': current_time",
    "            }",
    "        ",
    "        bucket = self._buckets[bucket_key]",
    "        ",
    "        # Refill tokens based on time passed",
    "        time_passed = current_time - bucket['last_refill']",
    "        refill_rate = config.requests_per_minute / 60.0",
    "        tokens_to_add = time_passed * refill_rate",
    "        bucket['tokens'] = min(config.burst_size, bucket['tokens'] + tokens_to_add)",
    "        bucket['last_refill'] = current_time",
    "        ",
    "        # Check if we can consume a token",
    "        if bucket['tokens'] >= 1:",
    "            bucket['tokens'] -= 1",
    "            return (True, int(bucket['tokens']))",
    "        else:",
    "            # Calculate retry-after",
    "            tokens_needed = 1 - bucket['tokens']",
    "            retry_after = int(tokens_needed / refill_rate) + 1",
    "            return (False, retry_after)",
    "    ",
    "    def is_allowed(self, identifier: str, endpoint_type: str = 'default') -> bool:",
    "        \"\"\"Simple boolean check for rate limit.\"\"\"",
    "        allowed, _ = self.check_rate_limit(identifier, endpoint_type)",
    "        return allowed",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 2: AUTHENTICATION (JWT)",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class AuthenticationError(Exception):",
    "    \"\"\"Raised when authentication fails.\"\"\"",
    "    pass",
    "",
    "",
    "class UserRole(Enum):",
    "    \"\"\"User roles for authorization.\"\"\"",
    "    USER = \"user\"",
    "    MODERATOR = \"moderator\"",
    "    ADMIN = \"admin\"",
    "",
    "",
    "@dataclass",
    "class AuthenticatedUser:",
    "    \"\"\"Represents an authenticated user from JWT claims.\"\"\"",
    "    user_id: str",
    "    username: str",
    "    role: UserRole",
    "    issued_at: datetime",
    "    expires_at: datetime",
    "",
    "",
    "class JWTAuthenticator:",
    "    \"\"\"",
    "    JWT-based authentication handler.",
    "    ",
    "    In production, use a proper JWT library (PyJWT) with RS256.",
    "    This is a simplified demonstration.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, secret_key: str = \"your-secret-key-here\"):",
    "        self._secret_key = secret_key.encode()",
    "        self._token_expiry_minutes = 15",
    "        self._refresh_expiry_days = 7",
    "        # In production: store refresh tokens in Redis with TTL",
    "        self._refresh_tokens: Dict[str, str] = {}",
    "    ",
    "    def _base64_encode(self, data: bytes) -> str:",
    "        \"\"\"URL-safe base64 encoding.\"\"\"",
    "        return base64.urlsafe_b64encode(data).rstrip(b'=').decode('ascii')",
    "    ",
    "    def _base64_decode(self, data: str) -> bytes:",
    "        \"\"\"URL-safe base64 decoding.\"\"\"",
    "        padding = 4 - (len(data) % 4)",
    "        if padding != 4:",
    "            data += '=' * padding",
    "        return base64.urlsafe_b64decode(data.encode('ascii'))",
    "    ",
    "    def _create_signature(self, message: str) -> str:",
    "        \"\"\"Create HMAC signature.\"\"\"",
    "        signature = hmac.new(",
    "            self._secret_key,",
    "            message.encode('utf-8'),",
    "            hashlib.sha256",
    "        ).digest()",
    "        return self._base64_encode(signature)",
    "    ",
    "    def generate_token(self, user_id: str, username: str, role: UserRole) -> Tuple[str, str]:",
    "        \"\"\"",
    "        Generate access and refresh tokens.",
    "        ",
    "        Returns:",
    "            Tuple of (access_token, refresh_token)",
    "        \"\"\"",
    "        now = datetime.utcnow()",
    "        ",
    "        # Create header",
    "        header = {'alg': 'HS256', 'typ': 'JWT'}",
    "        header_encoded = self._base64_encode(json.dumps(header).encode())",
    "        ",
    "        # Create payload",
    "        payload = {",
    "            'sub': user_id,",
    "            'username': username,",
    "            'role': role.value,",
    "            'iat': int(now.timestamp()),",
    "            'exp': int((now + timedelta(minutes=self._token_expiry_minutes)).timestamp())",
    "        }",
    "        payload_encoded = self._base64_encode(json.dumps(payload).encode())",
    "        ",
    "        # Create signature",
    "        message = f\"{header_encoded}.{payload_encoded}\"",
    "        signature = self._create_signature(message)",
    "        ",
    "        access_token = f\"{message}.{signature}\"",
    "        ",
    "        # Create refresh token",
    "        refresh_token = str(uuid.uuid4())",
    "        self._refresh_tokens[refresh_token] = user_id",
    "        ",
    "        return (access_token, refresh_token)",
    "    ",
    "    def verify_token(self, token: str) -> AuthenticatedUser:",
    "        \"\"\"",
    "        Verify and decode JWT token.",
    "        ",
    "        Raises:",
    "            AuthenticationError: If token is invalid or expired.",
    "        \"\"\"",
    "        try:",
    "            parts = token.split('.')",
    "            if len(parts) != 3:",
    "                raise AuthenticationError(\"Invalid token format\")",
    "            ",
    "            header_encoded, payload_encoded, signature = parts",
    "            ",
    "            # Verify signature",
    "            message = f\"{header_encoded}.{payload_encoded}\"",
    "            expected_signature = self._create_signature(message)",
    "            if not hmac.compare_digest(signature, expected_signature):",
    "                raise AuthenticationError(\"Invalid token signature\")",
    "            ",
    "            # Decode payload",
    "            payload = json.loads(self._base64_decode(payload_encoded))",
    "            ",
    "            # Check expiration",
    "            exp = datetime.fromtimestamp(payload['exp'])",
    "            if datetime.utcnow() > exp:",
    "                raise AuthenticationError(\"Token expired\")",
    "            ",
    "            return AuthenticatedUser(",
    "                user_id=payload['sub'],",
    "                username=payload['username'],",
    "                role=UserRole(payload['role']),",
    "                issued_at=datetime.fromtimestamp(payload['iat']),",
    "                expires_at=exp",
    "            )",
    "            ",
    "        except (KeyError, json.JSONDecodeError) as e:",
    "            raise AuthenticationError(f\"Invalid token payload: {e}\")",
    "    ",
    "    def refresh_access_token(self, refresh_token: str, username: str, role: UserRole) -> str:",
    "        \"\"\"Generate new access token using refresh token.\"\"\"",
    "        if refresh_token not in self._refresh_tokens:",
    "            raise AuthenticationError(\"Invalid refresh token\")",
    "        ",
    "        user_id = self._refresh_tokens[refresh_token]",
    "        access_token, _ = self.generate_token(user_id, username, role)",
    "        return access_token",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 3: AUTHORIZATION",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class AuthorizationError(Exception):",
    "    \"\"\"Raised when authorization fails.\"\"\"",
    "    pass",
    "",
    "",
    "class Permission(Enum):",
    "    \"\"\"Permissions for different actions.\"\"\"",
    "    READ = \"read\"",
    "    CREATE = \"create\"",
    "    UPDATE = \"update\"",
    "    DELETE = \"delete\"",
    "    MODERATE = \"moderate\"",
    "    ADMIN = \"admin\"",
    "",
    "",
    "class AuthorizationManager:",
    "    \"\"\"",
    "    Role-Based Access Control (RBAC) manager.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Define role permissions",
    "        self._role_permissions: Dict[UserRole, Set[Permission]] = {",
    "            UserRole.USER: {Permission.READ, Permission.CREATE, Permission.UPDATE, Permission.DELETE},",
    "            UserRole.MODERATOR: {Permission.READ, Permission.CREATE, Permission.UPDATE, ",
    "                                 Permission.DELETE, Permission.MODERATE},",
    "            UserRole.ADMIN: {p for p in Permission}  # All permissions",
    "        }",
    "    ",
    "    def has_permission(self, user: AuthenticatedUser, permission: Permission) -> bool:",
    "        \"\"\"Check if user has a specific permission.\"\"\"",
    "        user_permissions = self._role_permissions.get(user.role, set())",
    "        return permission in user_permissions",
    "    ",
    "    def can_modify_resource(self, user: AuthenticatedUser, resource_owner_id: str) -> bool:",
    "        \"\"\"",
    "        Check if user can modify a resource.",
    "        ",
    "        Users can modify their own resources.",
    "        Moderators and admins can modify any resource.",
    "        \"\"\"",
    "        if user.user_id == resource_owner_id:",
    "            return True",
    "        if user.role in (UserRole.MODERATOR, UserRole.ADMIN):",
    "            return True",
    "        return False",
    "    ",
    "    def authorize(self, user: AuthenticatedUser, permission: Permission, ",
    "                  resource_owner_id: Optional[str] = None) -> None:",
    "        \"\"\"",
    "        Authorize an action. Raises AuthorizationError if not allowed.",
    "        \"\"\"",
    "        if not self.has_permission(user, permission):",
    "            raise AuthorizationError(",
    "                f\"User {user.username} does not have permission: {permission.value}\"",
    "            )",
    "        ",
    "        # For update/delete, check resource ownership",
    "        if permission in (Permission.UPDATE, Permission.DELETE) and resource_owner_id:",
    "            if not self.can_modify_resource(user, resource_owner_id):",
    "                raise AuthorizationError(",
    "                    f\"User {user.username} cannot modify resource owned by {resource_owner_id}\"",
    "                )",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 4: INPUT VALIDATION & SANITIZATION",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class ValidationError(Exception):",
    "    \"\"\"Raised when input validation fails.\"\"\"",
    "    def __init__(self, field: str, message: str):",
    "        self.field = field",
    "        self.message = message",
    "        super().__init__(f\"Validation error on '{field}': {message}\")",
    "",
    "",
    "class InputValidator:",
    "    \"\"\"",
    "    Comprehensive input validation and sanitization.",
    "    Prevents XSS, SQL injection, and malformed data.",
    "    \"\"\"",
    "    ",
    "    # Dangerous HTML tags and attributes",
    "    DANGEROUS_TAGS = re.compile(r'<(script|iframe|object|embed|form|input|button)[^>]*>.*?</\\1>',",
    "                                 re.IGNORECASE | re.DOTALL)",
    "    DANGEROUS_ATTRS = re.compile(r'\\s(on\\w+|javascript:|data:)[^\\s>]*', re.IGNORECASE)",
    "    ",
    "    # SQL injection patterns",
    "    SQL_INJECTION = re.compile(",
    "        r\"('|\\\"|--)|(;\\s*(DROP|DELETE|UPDATE|INSERT|ALTER|EXEC))\",",
    "        re.IGNORECASE",
    "    )",
    "    ",
    "    # Allowed characters for usernames",
    "    USERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_-]{3,30}$')",
    "    ",
    "    # Email pattern",
    "    EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')",
    "    ",
    "    @classmethod",
    "    def sanitize_html(cls, content: str) -> str:",
    "        \"\"\"",
    "        Sanitize HTML content to prevent XSS attacks.",
    "        Removes dangerous tags and attributes while preserving safe formatting.",
    "        \"\"\"",
    "        if not content:",
    "            return content",
    "        ",
    "        # Remove dangerous tags",
    "        content = cls.DANGEROUS_TAGS.sub('', content)",
    "        ",
    "        # Remove dangerous attributes",
    "        content = cls.DANGEROUS_ATTRS.sub('', content)",
    "        ",
    "        # Escape remaining angle brackets that aren't part of allowed tags",
    "        # In production, use a proper HTML sanitizer like bleach",
    "        ",
    "        return content.strip()",
    "    ",
    "    @classmethod",
    "    def check_sql_injection(cls, value: str) -> bool:",
    "        \"\"\"Check if value contains SQL injection patterns.\"\"\"",
    "        return bool(cls.SQL_INJECTION.search(value))",
    "    ",
    "    @classmethod",
    "    def validate_username(cls, username: str) -> str:",
    "        \"\"\"Validate and return sanitized username.\"\"\"",
    "        if not username:",
    "            raise ValidationError('username', 'Username is required')",
    "        ",
    "        username = username.strip()",
    "        ",
    "        if not cls.USERNAME_PATTERN.match(username):",
    "            raise ValidationError(",
    "                'username',",
    "                'Username must be 3-30 characters, alphanumeric with _ or -'",
    "            )",
    "        ",
    "        return username",
    "    ",
    "    @classmethod",
    "    def validate_email(cls, email: str) -> str:",
    "        \"\"\"Validate and return sanitized email.\"\"\"",
    "        if not email:",
    "            raise ValidationError('email', 'Email is required')",
    "        ",
    "        email = email.strip().lower()",
    "        ",
    "        if not cls.EMAIL_PATTERN.match(email):",
    "            raise ValidationError('email', 'Invalid email format')",
    "        ",
    "        return email",
    "    ",
    "    @classmethod",
    "    def validate_question_title(cls, title: str) -> str:",
    "        \"\"\"Validate question title.\"\"\"",
    "        if not title:",
    "            raise ValidationError('title', 'Title is required')",
    "        ",
    "        title = cls.sanitize_html(title.strip())",
    "        ",
    "        if len(title) < 10:",
    "            raise ValidationError('title', 'Title must be at least 10 characters')",
    "        ",
    "        if len(title) > 300:",
    "            raise ValidationError('title', 'Title must be at most 300 characters')",
    "        ",
    "        if cls.check_sql_injection(title):",
    "            raise ValidationError('title', 'Invalid characters in title')",
    "        ",
    "        return title",
    "    ",
    "    @classmethod",
    "    def validate_content(cls, content: str, field_name: str = 'content',",
    "                        min_length: int = 20, max_length: int = 50000) -> str:",
    "        \"\"\"Validate and sanitize content body.\"\"\"",
    "        if not content:",
    "            raise ValidationError(field_name, f'{field_name} is required')",
    "        ",
    "        content = cls.sanitize_html(content.strip())",
    "        ",
    "        if len(content) < min_length:",
    "            raise ValidationError(",
    "                field_name, ",
    "                f'{field_name} must be at least {min_length} characters'",
    "            )",
    "        ",
    "        if len(content) > max_length:",
    "            raise ValidationError(",
    "                field_name,",
    "                f'{field_name} must be at most {max_length} characters'",
    "            )",
    "        ",
    "        return content",
    "    ",
    "    @classmethod",
    "    def validate_tags(cls, tags: List[str]) -> List[str]:",
    "        \"\"\"Validate and sanitize tags.\"\"\"",
    "        if not tags:",
    "            raise ValidationError('tags', 'At least one tag is required')",
    "        ",
    "        if len(tags) > 5:",
    "            raise ValidationError('tags', 'Maximum 5 tags allowed')",
    "        ",
    "        validated_tags = []",
    "        for tag in tags:",
    "            tag = tag.strip().lower()",
    "            if not re.match(r'^[a-z0-9+-]+$', tag):",
    "                raise ValidationError('tags', f'Invalid tag format: {tag}')",
    "            if len(tag) > 25:",
    "                raise ValidationError('tags', f'Tag too long: {tag}')",
    "            validated_tags.append(tag)",
    "        ",
    "        return validated_tags",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 5: CACHING LAYER",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "@dataclass",
    "class CacheEntry:",
    "    \"\"\"A cached entry with TTL.\"\"\"",
    "    data: Any",
    "    expires_at: float",
    "",
    "",
    "class CacheLayer:",
    "    \"\"\"",
    "    In-memory cache simulating Redis behavior.",
    "    ",
    "    In production, this would be a Redis client with:",
    "    - Cluster mode for horizontal scaling",
    "    - Pub/Sub for cache invalidation",
    "    - LRU eviction policy",
    "    \"\"\"",
    "    ",
    "    def __init__(self, default_ttl_seconds: int = 300):",
    "        self._cache: Dict[str, CacheEntry] = {}",
    "        self._default_ttl = default_ttl_seconds",
    "        self._stats = {'hits': 0, 'misses': 0}",
    "    ",
    "    def _generate_key(self, prefix: str, identifier: str) -> str:",
    "        \"\"\"Generate a cache key with prefix.\"\"\"",
    "        return f\"{prefix}:{identifier}\"",
    "    ",
    "    def _is_expired(self, entry: CacheEntry) -> bool:",
    "        \"\"\"Check if cache entry is expired.\"\"\"",
    "        return time.time() > entry.expires_at",
    "    ",
    "    def get(self, key: str) -> Optional[Any]:",
    "        \"\"\"Get value from cache.\"\"\"",
    "        if key in self._cache:",
    "            entry = self._cache[key]",
    "            if not self._is_expired(entry):",
    "                self._stats['hits'] += 1",
    "                return entry.data",
    "            else:",
    "                # Lazy expiration",
    "                del self._cache[key]",
    "        ",
    "        self._stats['misses'] += 1",
    "        return None",
    "    ",
    "    def set(self, key: str, value: Any, ttl_seconds: Optional[int] = None) -> None:",
    "        \"\"\"Set value in cache with TTL.\"\"\"",
    "        ttl = ttl_seconds or self._default_ttl",
    "        self._cache[key] = CacheEntry(",
    "            data=value,",
    "            expires_at=time.time() + ttl",
    "        )",
    "    ",
    "    def delete(self, key: str) -> bool:",
    "        \"\"\"Delete key from cache.\"\"\"",
    "        if key in self._cache:",
    "            del self._cache[key]",
    "            return True",
    "        return False",
    "    ",
    "    def invalidate_pattern(self, pattern: str) -> int:",
    "        \"\"\"Invalidate all keys matching pattern (prefix).\"\"\"",
    "        keys_to_delete = [k for k in self._cache.keys() if k.startswith(pattern)]",
    "        for key in keys_to_delete:",
    "            del self._cache[key]",
    "        return len(keys_to_delete)",
    "    ",
    "    # High-level cache methods for Stack Overflow entities",
    "    ",
    "    def cache_question(self, question_id: str, question_data: Dict) -> None:",
    "        \"\"\"Cache a question with 5-minute TTL.\"\"\"",
    "        key = self._generate_key('question', question_id)",
    "        self.set(key, question_data, ttl_seconds=300)",
    "    ",
    "    def get_cached_question(self, question_id: str) -> Optional[Dict]:",
    "        \"\"\"Get cached question.\"\"\"",
    "        key = self._generate_key('question', question_id)",
    "        return self.get(key)",
    "    ",
    "    def cache_search_results(self, query: str, results: List[Dict]) -> None:",
    "        \"\"\"Cache search results with 1-minute TTL (volatile).\"\"\"",
    "        # Hash query for key",
    "        query_hash = hashlib.md5(query.encode()).hexdigest()[:16]",
    "        key = self._generate_key('search', query_hash)",
    "        self.set(key, results, ttl_seconds=60)",
    "    ",
    "    def get_cached_search(self, query: str) -> Optional[List[Dict]]:",
    "        \"\"\"Get cached search results.\"\"\"",
    "        query_hash = hashlib.md5(query.encode()).hexdigest()[:16]",
    "        key = self._generate_key('search', query_hash)",
    "        return self.get(key)",
    "    ",
    "    def cache_hot_questions(self, questions: List[Dict]) -> None:",
    "        \"\"\"Cache hot questions list with 5-minute TTL.\"\"\"",
    "        self.set('hot_questions', questions, ttl_seconds=300)",
    "    ",
    "    def get_hot_questions(self) -> Optional[List[Dict]]:",
    "        \"\"\"Get cached hot questions.\"\"\"",
    "        return self.get('hot_questions')",
    "    ",
    "    def get_stats(self) -> Dict[str, int]:",
    "        \"\"\"Get cache hit/miss statistics.\"\"\"",
    "        total = self._stats['hits'] + self._stats['misses']",
    "        hit_rate = self._stats['hits'] / total if total > 0 else 0",
    "        return {**self._stats, 'hit_rate': round(hit_rate, 3)}",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 6: SPAM DETECTION",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class SpamDetector:",
    "    \"\"\"",
    "    Simple spam detection based on heuristics.",
    "    ",
    "    In production, this would use:",
    "    - Machine learning models",
    "    - External services (Akismet)",
    "    - Reputation system integration",
    "    \"\"\"",
    "    ",
    "    # Spam indicators",
    "    SPAM_KEYWORDS = {",
    "        'buy now', 'click here', 'free money', 'winner', 'congratulations',",
    "        'earn money', 'work from home', 'limited time', 'act now', 'crypto'",
    "    }",
    "    ",
    "    URL_PATTERN = re.compile(r'https?://[^\\s]+', re.IGNORECASE)",
    "    ",
    "    def __init__(self):",
    "        # Track user behavior",
    "        self._user_post_times: Dict[str, List[float]] = defaultdict(list)",
    "        self._user_spam_score: Dict[str, float] = defaultdict(float)",
    "    ",
    "    def calculate_spam_score(self, user_id: str, content: str) -> float:",
    "        \"\"\"",
    "        Calculate spam probability score (0.0 to 1.0).",
    "        \"\"\"",
    "        score = 0.0",
    "        content_lower = content.lower()",
    "        ",
    "        # Check for spam keywords",
    "        keyword_count = sum(1 for kw in self.SPAM_KEYWORDS if kw in content_lower)",
    "        score += min(keyword_count * 0.15, 0.4)",
    "        ",
    "        # Check for excessive URLs",
    "        url_count = len(self.URL_PATTERN.findall(content))",
    "        if url_count > 3:",
    "            score += min((url_count - 3) * 0.1, 0.3)",
    "        ",
    "        # Check posting frequency",
    "        current_time = time.time()",
    "        recent_posts = [t for t in self._user_post_times[user_id] ",
    "                       if current_time - t < 60]  # Last minute",
    "        if len(recent_posts) > 5:",
    "            score += 0.2",
    "        ",
    "        # Check for all caps",
    "        if len(content) > 20:",
    "            caps_ratio = sum(1 for c in content if c.isupper()) / len(content)",
    "            if caps_ratio > 0.7:",
    "                score += 0.15",
    "        ",
    "        # Check user's historical spam score",
    "        score += self._user_spam_score.get(user_id, 0) * 0.1",
    "        ",
    "        return min(score, 1.0)",
    "    ",
    "    def is_spam(self, user_id: str, content: str, threshold: float = 0.5) -> bool:",
    "        \"\"\"Check if content is likely spam.\"\"\"",
    "        return self.calculate_spam_score(user_id, content) >= threshold",
    "    ",
    "    def record_post(self, user_id: str) -> None:",
    "        \"\"\"Record a post for rate analysis.\"\"\"",
    "        self._user_post_times[user_id].append(time.time())",
    "        # Keep only last hour",
    "        cutoff = time.time() - 3600",
    "        self._user_post_times[user_id] = [",
    "            t for t in self._user_post_times[user_id] if t > cutoff",
    "        ]",
    "    ",
    "    def mark_as_spam(self, user_id: str) -> None:",
    "        \"\"\"Mark user's content as spam (increases future spam score).\"\"\"",
    "        self._user_spam_score[user_id] = min(",
    "            self._user_spam_score[user_id] + 0.5, 1.0",
    "        )",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 7: DATABASE SHARDING STRATEGY",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class ConsistentHashRing:",
    "    \"\"\"",
    "    Consistent hashing for shard distribution.",
    "    ",
    "    Provides even distribution with minimal redistribution",
    "    when adding/removing shards.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, nodes: List[str], virtual_nodes: int = 100):",
    "        self._ring: Dict[int, str] = {}",
    "        self._sorted_keys: List[int] = []",
    "        self._virtual_nodes = virtual_nodes",
    "        ",
    "        for node in nodes:",
    "            self.add_node(node)",
    "    ",
    "    def _hash(self, key: str) -> int:",
    "        \"\"\"Generate hash for key.\"\"\"",
    "        return int(hashlib.md5(key.encode()).hexdigest(), 16)",
    "    ",
    "    def add_node(self, node: str) -> None:",
    "        \"\"\"Add a node to the ring.\"\"\"",
    "        for i in range(self._virtual_nodes):",
    "            virtual_key = f\"{node}:{i}\"",
    "            hash_val = self._hash(virtual_key)",
    "            self._ring[hash_val] = node",
    "            self._sorted_keys.append(hash_val)",
    "        self._sorted_keys.sort()",
    "    ",
    "    def remove_node(self, node: str) -> None:",
    "        \"\"\"Remove a node from the ring.\"\"\"",
    "        for i in range(self._virtual_nodes):",
    "            virtual_key = f\"{node}:{i}\"",
    "            hash_val = self._hash(virtual_key)",
    "            if hash_val in self._ring:",
    "                del self._ring[hash_val]",
    "                self._sorted_keys.remove(hash_val)",
    "    ",
    "    def get_node(self, key: str) -> str:",
    "        \"\"\"Get the node responsible for a key.\"\"\"",
    "        if not self._ring:",
    "            raise ValueError(\"No nodes in ring\")",
    "        ",
    "        hash_val = self._hash(key)",
    "        ",
    "        # Find first node with hash >= key hash",
    "        for node_hash in self._sorted_keys:",
    "            if node_hash >= hash_val:",
    "                return self._ring[node_hash]",
    "        ",
    "        # Wrap around to first node",
    "        return self._ring[self._sorted_keys[0]]",
    "",
    "",
    "class ShardRouter:",
    "    \"\"\"",
    "    Routes queries to appropriate database shards.",
    "    \"\"\"",
    "    ",
    "    def __init__(self, num_shards: int = 4):",
    "        shard_names = [f\"shard_{i}\" for i in range(num_shards)]",
    "        self._hash_ring = ConsistentHashRing(shard_names)",
    "        self._num_shards = num_shards",
    "    ",
    "    def get_question_shard(self, question_id: str) -> str:",
    "        \"\"\"Route question to shard by question ID.\"\"\"",
    "        return self._hash_ring.get_node(f\"q:{question_id}\")",
    "    ",
    "    def get_user_shard(self, user_id: str) -> str:",
    "        \"\"\"Route user data to shard by user ID.\"\"\"",
    "        return self._hash_ring.get_node(f\"u:{user_id}\")",
    "    ",
    "    def get_answer_shard(self, question_id: str) -> str:",
    "        \"\"\"Route answer to same shard as its question (co-location).\"\"\"",
    "        return self.get_question_shard(question_id)",
    "    ",
    "    def get_all_shards(self) -> List[str]:",
    "        \"\"\"Get all shard names (for scatter-gather queries).\"\"\"",
    "        return [f\"shard_{i}\" for i in range(self._num_shards)]",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 8: SECURITY MIDDLEWARE / DECORATORS",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "class SecurityContext:",
    "    \"\"\"",
    "    Thread-local security context for request handling.",
    "    \"\"\"",
    "    _current_user: Optional[AuthenticatedUser] = None",
    "    _client_ip: Optional[str] = None",
    "    ",
    "    @classmethod",
    "    def set_user(cls, user: AuthenticatedUser) -> None:",
    "        cls._current_user = user",
    "    ",
    "    @classmethod",
    "    def get_user(cls) -> Optional[AuthenticatedUser]:",
    "        return cls._current_user",
    "    ",
    "    @classmethod",
    "    def set_ip(cls, ip: str) -> None:",
    "        cls._client_ip = ip",
    "    ",
    "    @classmethod",
    "    def get_ip(cls) -> Optional[str]:",
    "        return cls._client_ip",
    "    ",
    "    @classmethod",
    "    def clear(cls) -> None:",
    "        cls._current_user = None",
    "        cls._client_ip = None",
    "",
    "",
    "# Global instances for decorators",
    "_rate_limiter = TokenBucketRateLimiter()",
    "_authenticator = JWTAuthenticator()",
    "_authorizer = AuthorizationManager()",
    "_spam_detector = SpamDetector()",
    "",
    "",
    "def rate_limited(endpoint_type: str = 'default'):",
    "    \"\"\"Decorator to apply rate limiting to a function.\"\"\"",
    "    def decorator(func: Callable) -> Callable:",
    "        @wraps(func)",
    "        def wrapper(*args, **kwargs):",
    "            # Get identifier from context",
    "            user = SecurityContext.get_user()",
    "            ip = SecurityContext.get_ip() or 'unknown'",
    "            identifier = user.user_id if user else ip",
    "            ",
    "            allowed, value = _rate_limiter.check_rate_limit(identifier, endpoint_type)",
    "            if not allowed:",
    "                raise RateLimitExceeded(retry_after=value)",
    "            ",
    "            return func(*args, **kwargs)",
    "        return wrapper",
    "    return decorator",
    "",
    "",
    "def requires_auth(func: Callable) -> Callable:",
    "    \"\"\"Decorator to require authentication.\"\"\"",
    "    @wraps(func)",
    "    def wrapper(*args, **kwargs):",
    "        user = SecurityContext.get_user()",
    "        if not user:",
    "            raise AuthenticationError(\"Authentication required\")",
    "        return func(*args, **kwargs)",
    "    return wrapper",
    "",
    "",
    "def requires_permission(permission: Permission):",
    "    \"\"\"Decorator to require a specific permission.\"\"\"",
    "    def decorator(func: Callable) -> Callable:",
    "        @wraps(func)",
    "        def wrapper(*args, **kwargs):",
    "            user = SecurityContext.get_user()",
    "            if not user:",
    "                raise AuthenticationError(\"Authentication required\")",
    "            ",
    "            _authorizer.authorize(user, permission)",
    "            return func(*args, **kwargs)",
    "        return wrapper",
    "    return decorator",
    "",
    "",
    "def spam_check(func: Callable) -> Callable:",
    "    \"\"\"Decorator to check for spam content.\"\"\"",
    "    @wraps(func)",
    "    def wrapper(*args, **kwargs):",
    "        user = SecurityContext.get_user()",
    "        if user:",
    "            # Check 'content' kwarg or second positional arg",
    "            content = kwargs.get('content') or (args[1] if len(args) > 1 else '')",
    "            if content and _spam_detector.is_spam(user.user_id, content):",
    "                raise ValidationError('content', 'Content flagged as potential spam')",
    "            _spam_detector.record_post(user.user_id)",
    "        return func(*args, **kwargs)",
    "    return wrapper",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 9: SECURE STACK OVERFLOW API",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "@dataclass",
    "class User:",
    "    \"\"\"User entity.\"\"\"",
    "    id: str",
    "    username: str",
    "    email: str",
    "    reputation: int = 0",
    "    role: UserRole = UserRole.USER",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Question:",
    "    \"\"\"Question entity.\"\"\"",
    "    id: str",
    "    user_id: str",
    "    title: str",
    "    body: str",
    "    tags: List[str]",
    "    vote_count: int = 0",
    "    view_count: int = 0",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "@dataclass",
    "class Answer:",
    "    \"\"\"Answer entity.\"\"\"",
    "    id: str",
    "    question_id: str",
    "    user_id: str",
    "    body: str",
    "    vote_count: int = 0",
    "    is_accepted: bool = False",
    "    created_at: datetime = field(default_factory=datetime.utcnow)",
    "",
    "",
    "class SecureStackOverflowAPI:",
    "    \"\"\"",
    "    Production-ready Stack Overflow API with security and scalability features.",
    "    \"\"\"",
    "    ",
    "    def __init__(self):",
    "        # Storage (in production: database + sharding)",
    "        self._users: Dict[str, User] = {}",
    "        self._questions: Dict[str, Question] = {}",
    "        self._answers: Dict[str, Answer] = {}",
    "        ",
    "        # Infrastructure components",
    "        self._cache = CacheLayer()",
    "        self._shard_router = ShardRouter()",
    "        self._validator = InputValidator()",
    "        ",
    "        # ID counters",
    "        self._next_id = 1",
    "    ",
    "    def _generate_id(self) -> str:",
    "        \"\"\"Generate unique ID.\"\"\"",
    "        id_val = self._next_id",
    "        self._next_id += 1",
    "        return str(id_val)",
    "    ",
    "    # === User Management ===",
    "    ",
    "    @rate_limited('default')",
    "    def create_user(self, username: str, email: str) -> User:",
    "        \"\"\"Create a new user with validation.\"\"\"",
    "        # Validate inputs",
    "        username = self._validator.validate_username(username)",
    "        email = self._validator.validate_email(email)",
    "        ",
    "        # Check uniqueness",
    "        for user in self._users.values():",
    "            if user.username == username:",
    "                raise ValidationError('username', 'Username already taken')",
    "            if user.email == email:",
    "                raise ValidationError('email', 'Email already registered')",
    "        ",
    "        user_id = self._generate_id()",
    "        shard = self._shard_router.get_user_shard(user_id)",
    "        ",
    "        user = User(id=user_id, username=username, email=email)",
    "        self._users[user_id] = user",
    "        ",
    "        print(f\"  [SHARD] User {user_id} stored in {shard}\")",
    "        return user",
    "    ",
    "    # === Question Management ===",
    "    ",
    "    @rate_limited('write')",
    "    @requires_auth",
    "    @requires_permission(Permission.CREATE)",
    "    @spam_check",
    "    def post_question(self, title: str, body: str, tags: List[str]) -> Question:",
    "        \"\"\"Post a new question with full validation and security.\"\"\"",
    "        user = SecurityContext.get_user()",
    "        ",
    "        # Validate all inputs",
    "        title = self._validator.validate_question_title(title)",
    "        body = self._validator.validate_content(body, 'body', min_length=30)",
    "        tags = self._validator.validate_tags(tags)",
    "        ",
    "        question_id = self._generate_id()",
    "        shard = self._shard_router.get_question_shard(question_id)",
    "        ",
    "        question = Question(",
    "            id=question_id,",
    "            user_id=user.user_id,",
    "            title=title,",
    "            body=body,",
    "            tags=tags",
    "        )",
    "        ",
    "        self._questions[question_id] = question",
    "        ",
    "        # Invalidate related caches",
    "        self._cache.invalidate_pattern('search')",
    "        self._cache.delete('hot_questions')",
    "        ",
    "        print(f\"  [SHARD] Question {question_id} stored in {shard}\")",
    "        print(f\"  [CACHE] Invalidated search cache\")",
    "        return question",
    "    ",
    "    @rate_limited('default')",
    "    def get_question(self, question_id: str) -> Optional[Question]:",
    "        \"\"\"Get a question with caching.\"\"\"",
    "        # Check cache first",
    "        cached = self._cache.get_cached_question(question_id)",
    "        if cached:",
    "            print(f\"  [CACHE] Hit for question {question_id}\")",
    "            return Question(**cached)",
    "        ",
    "        # Cache miss - fetch from \"database\"",
    "        print(f\"  [CACHE] Miss for question {question_id}\")",
    "        question = self._questions.get(question_id)",
    "        ",
    "        if question:",
    "            # Update view count",
    "            question.view_count += 1",
    "            ",
    "            # Store in cache",
    "            self._cache.cache_question(question_id, {",
    "                'id': question.id,",
    "                'user_id': question.user_id,",
    "                'title': question.title,",
    "                'body': question.body,",
    "                'tags': question.tags,",
    "                'vote_count': question.vote_count,",
    "                'view_count': question.view_count,",
    "                'created_at': question.created_at",
    "            })",
    "        ",
    "        return question",
    "    ",
    "    @rate_limited('write')",
    "    @requires_auth",
    "    def delete_question(self, question_id: str) -> bool:",
    "        \"\"\"Delete a question with authorization check.\"\"\"",
    "        user = SecurityContext.get_user()",
    "        question = self._questions.get(question_id)",
    "        ",
    "        if not question:",
    "            return False",
    "        ",
    "        # Authorization check",
    "        _authorizer.authorize(user, Permission.DELETE, question.user_id)",
    "        ",
    "        del self._questions[question_id]",
    "        ",
    "        # Invalidate caches",
    "        self._cache.delete(f'question:{question_id}')",
    "        self._cache.invalidate_pattern('search')",
    "        ",
    "        return True",
    "    ",
    "    # === Answer Management ===",
    "    ",
    "    @rate_limited('write')",
    "    @requires_auth",
    "    @requires_permission(Permission.CREATE)",
    "    @spam_check",
    "    def post_answer(self, question_id: str, body: str) -> Optional[Answer]:",
    "        \"\"\"Post an answer to a question.\"\"\"",
    "        user = SecurityContext.get_user()",
    "        ",
    "        if question_id not in self._questions:",
    "            raise ValidationError('question_id', 'Question not found')",
    "        ",
    "        # Validate body",
    "        body = self._validator.validate_content(body, 'body', min_length=20)",
    "        ",
    "        answer_id = self._generate_id()",
    "        shard = self._shard_router.get_answer_shard(question_id)",
    "        ",
    "        answer = Answer(",
    "            id=answer_id,",
    "            question_id=question_id,",
    "            user_id=user.user_id,",
    "            body=body",
    "        )",
    "        ",
    "        self._answers[answer_id] = answer",
    "        ",
    "        # Invalidate question cache (answer count changed)",
    "        self._cache.delete(f'question:{question_id}')",
    "        ",
    "        print(f\"  [SHARD] Answer {answer_id} co-located with question in {shard}\")",
    "        return answer",
    "    ",
    "    # === Search with Caching ===",
    "    ",
    "    @rate_limited('default')",
    "    def search_questions(self, query: str, tags: Optional[List[str]] = None) -> List[Question]:",
    "        \"\"\"Search questions with caching.\"\"\"",
    "        cache_key = f\"{query}:{','.join(tags or [])}\"",
    "        ",
    "        # Check cache",
    "        cached = self._cache.get_cached_search(cache_key)",
    "        if cached:",
    "            print(f\"  [CACHE] Hit for search '{query}'\")",
    "            return [Question(**q) for q in cached]",
    "        ",
    "        print(f\"  [CACHE] Miss for search '{query}'\")",
    "        print(f\"  [ES] Would query Elasticsearch in production\")",
    "        ",
    "        # Simulate search (in production: Elasticsearch)",
    "        results = []",
    "        query_lower = query.lower()",
    "        ",
    "        for question in self._questions.values():",
    "            if query_lower in question.title.lower() or query_lower in question.body.lower():",
    "                if not tags or any(t in question.tags for t in tags):",
    "                    results.append(question)",
    "        ",
    "        # Cache results",
    "        self._cache.cache_search_results(cache_key, [",
    "            {'id': q.id, 'user_id': q.user_id, 'title': q.title, 'body': q.body,",
    "             'tags': q.tags, 'vote_count': q.vote_count, 'view_count': q.view_count,",
    "             'created_at': q.created_at}",
    "            for q in results",
    "        ])",
    "        ",
    "        return results",
    "    ",
    "    def get_cache_stats(self) -> Dict:",
    "        \"\"\"Get cache statistics.\"\"\"",
    "        return self._cache.get_stats()",
    "",
    "",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "# SECTION 10: DEMONSTRATION",
    "# \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "",
    "def demo_security_features():",
    "    \"\"\"Demonstrate security and scalability features.\"\"\"",
    "    print(\"=\" * 70)",
    "    print(\"STACK OVERFLOW API - SCALABILITY & SECURITY DEMO\")",
    "    print(\"=\" * 70)",
    "    ",
    "    api = SecureStackOverflowAPI()",
    "    auth = JWTAuthenticator()",
    "    ",
    "    # 1. Create users",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"1. USER CREATION WITH VALIDATION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    user1 = api.create_user(\"john_doe\", \"john@example.com\")",
    "    print(f\"Created user: {user1.username} (ID: {user1.id})\")",
    "    ",
    "    # Try invalid username",
    "    try:",
    "        api.create_user(\"ab\", \"short@test.com\")  # Too short",
    "    except ValidationError as e:",
    "        print(f\"Validation error: {e}\")",
    "    ",
    "    # 2. Authentication",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"2. JWT AUTHENTICATION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    access_token, refresh_token = auth.generate_token(",
    "        user1.id, user1.username, UserRole.USER",
    "    )",
    "    print(f\"Generated access token: {access_token[:50]}...\")",
    "    print(f\"Refresh token: {refresh_token}\")",
    "    ",
    "    # Verify token",
    "    verified_user = auth.verify_token(access_token)",
    "    print(f\"Verified user: {verified_user.username}, role: {verified_user.role.value}\")",
    "    ",
    "    # 3. Set security context and post question",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"3. POSTING WITH SECURITY CONTEXT\")",
    "    print(\"-\" * 50)",
    "    ",
    "    SecurityContext.set_user(verified_user)",
    "    SecurityContext.set_ip(\"192.168.1.100\")",
    "    ",
    "    question = api.post_question(",
    "        title=\"How to implement rate limiting in Python?\",",
    "        body=\"I need to implement rate limiting for my API. What are the best approaches? \" * 2,",
    "        tags=[\"python\", \"rate-limiting\", \"api\"]",
    "    )",
    "    print(f\"Posted question: {question.title} (ID: {question.id})\")",
    "    ",
    "    # 4. Demonstrate caching",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"4. CACHING DEMONSTRATION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    print(\"First fetch (cache miss):\")",
    "    _ = api.get_question(question.id)",
    "    ",
    "    print(\"\\nSecond fetch (cache hit):\")",
    "    _ = api.get_question(question.id)",
    "    ",
    "    print(f\"\\nCache stats: {api.get_cache_stats()}\")",
    "    ",
    "    # 5. Search with caching",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"5. SEARCH WITH CACHING\")",
    "    print(\"-\" * 50)",
    "    ",
    "    print(\"First search (cache miss):\")",
    "    results = api.search_questions(\"rate limiting\")",
    "    print(f\"Found {len(results)} results\")",
    "    ",
    "    print(\"\\nSecond search (cache hit):\")",
    "    results = api.search_questions(\"rate limiting\")",
    "    print(f\"Found {len(results)} results\")",
    "    ",
    "    # 6. Rate limiting demonstration",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"6. RATE LIMITING\")",
    "    print(\"-\" * 50)",
    "    ",
    "    rate_limiter = TokenBucketRateLimiter()",
    "    test_ip = \"10.0.0.1\"",
    "    ",
    "    print(\"Testing anonymous rate limit (20/min):\")",
    "    for i in range(25):",
    "        allowed, value = rate_limiter.check_rate_limit(test_ip, 'anonymous')",
    "        if not allowed:",
    "            print(f\"  Request {i+1}: BLOCKED - retry after {value}s\")",
    "            break",
    "        elif i % 5 == 0:",
    "            print(f\"  Request {i+1}: Allowed, {value} tokens remaining\")",
    "    ",
    "    # 7. Authorization demonstration",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"7. AUTHORIZATION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    # Create another user",
    "    user2 = api.create_user(\"jane_doe\", \"jane@example.com\")",
    "    token2, _ = auth.generate_token(user2.id, user2.username, UserRole.USER)",
    "    user2_auth = auth.verify_token(token2)",
    "    ",
    "    # Try to delete user1's question as user2",
    "    SecurityContext.set_user(user2_auth)",
    "    try:",
    "        api.delete_question(question.id)",
    "    except AuthorizationError as e:",
    "        print(f\"Authorization blocked: {e}\")",
    "    ",
    "    # Now try as admin",
    "    admin_token, _ = auth.generate_token(\"admin\", \"admin\", UserRole.ADMIN)",
    "    admin_user = auth.verify_token(admin_token)",
    "    SecurityContext.set_user(admin_user)",
    "    print(f\"Admin can delete: {api.delete_question(question.id)}\")",
    "    ",
    "    # 8. Spam detection",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"8. SPAM DETECTION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    spam_detector = SpamDetector()",
    "    ",
    "    normal_content = \"How do I use async/await in Python 3.9?\"",
    "    spam_content = \"BUY NOW! Click here for FREE MONEY! http://spam1.com http://spam2.com http://spam3.com http://spam4.com\"",
    "    ",
    "    print(f\"Normal content spam score: {spam_detector.calculate_spam_score('u1', normal_content):.2f}\")",
    "    print(f\"Spam content score: {spam_detector.calculate_spam_score('u1', spam_content):.2f}\")",
    "    print(f\"Is spam: {spam_detector.is_spam('u1', spam_content)}\")",
    "    ",
    "    # 9. Sharding demonstration",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"9. DATABASE SHARDING\")",
    "    print(\"-\" * 50)",
    "    ",
    "    router = ShardRouter(num_shards=4)",
    "    for i in range(10):",
    "        shard = router.get_question_shard(f\"q_{i}\")",
    "        print(f\"Question q_{i} -> {shard}\")",
    "    ",
    "    # 10. Input validation",
    "    print(\"\\n\" + \"-\" * 50)",
    "    print(\"10. INPUT VALIDATION & XSS PREVENTION\")",
    "    print(\"-\" * 50)",
    "    ",
    "    xss_input = '<script>alert(\"XSS\")</script>Normal text<img onerror=\"hack()\" src=\"x\">'",
    "    sanitized = InputValidator.sanitize_html(xss_input)",
    "    print(f\"Original: {xss_input}\")",
    "    print(f\"Sanitized: {sanitized}\")",
    "    ",
    "    print(\"\\n\" + \"=\" * 70)",
    "    print(\"DEMO COMPLETE\")",
    "    print(\"=\" * 70)",
    "    ",
    "    SecurityContext.clear()",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    demo_security_features()"
  ],
  "solution_java_lines": [
    "import java.util.*;",
    "import java.util.concurrent.*;",
    "import java.time.*;",
    "import java.security.*;",
    "import javax.crypto.*;",
    "import javax.crypto.spec.*;",
    "import java.util.function.*;",
    "import java.util.regex.*;",
    "import java.nio.charset.*;",
    "",
    "/**",
    " * Stack Overflow API - Part 4: Scalability and Security",
    " * Production-ready implementation with security and caching layers.",
    " */",
    "public class StackOverflowSecurityDemo {",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 1: RATE LIMITING",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    static class RateLimitExceeded extends RuntimeException {",
    "        public final int retryAfter;",
    "        public RateLimitExceeded(int retryAfter) {",
    "            super(\"Rate limit exceeded. Retry after \" + retryAfter + \" seconds.\");",
    "            this.retryAfter = retryAfter;",
    "        }",
    "    }",
    "    ",
    "    static class RateLimitConfig {",
    "        final int requestsPerMinute;",
    "        final int burstSize;",
    "        ",
    "        RateLimitConfig(int requestsPerMinute, int burstSize) {",
    "            this.requestsPerMinute = requestsPerMinute;",
    "            this.burstSize = burstSize;",
    "        }",
    "    }",
    "    ",
    "    static class TokenBucket {",
    "        double tokens;",
    "        long lastRefillNanos;",
    "        ",
    "        TokenBucket(double tokens) {",
    "            this.tokens = tokens;",
    "            this.lastRefillNanos = System.nanoTime();",
    "        }",
    "    }",
    "    ",
    "    static class TokenBucketRateLimiter {",
    "        private final Map<String, TokenBucket> buckets = new ConcurrentHashMap<>();",
    "        private final Map<String, RateLimitConfig> configs;",
    "        ",
    "        TokenBucketRateLimiter() {",
    "            configs = Map.of(",
    "                \"default\", new RateLimitConfig(100, 20),",
    "                \"anonymous\", new RateLimitConfig(20, 5),",
    "                \"write\", new RateLimitConfig(10, 3)",
    "            );",
    "        }",
    "        ",
    "        boolean isAllowed(String identifier, String endpointType) {",
    "            String key = endpointType + \":\" + identifier;",
    "            RateLimitConfig config = configs.getOrDefault(endpointType, configs.get(\"default\"));",
    "            long now = System.nanoTime();",
    "            ",
    "            TokenBucket bucket = buckets.computeIfAbsent(key, k -> new TokenBucket(config.burstSize));",
    "            ",
    "            synchronized (bucket) {",
    "                double elapsed = (now - bucket.lastRefillNanos) / 1_000_000_000.0;",
    "                double refillRate = config.requestsPerMinute / 60.0;",
    "                bucket.tokens = Math.min(config.burstSize, bucket.tokens + elapsed * refillRate);",
    "                bucket.lastRefillNanos = now;",
    "                ",
    "                if (bucket.tokens >= 1) {",
    "                    bucket.tokens -= 1;",
    "                    return true;",
    "                }",
    "                return false;",
    "            }",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 2: AUTHENTICATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    enum UserRole { USER, MODERATOR, ADMIN }",
    "    ",
    "    static class AuthenticationError extends RuntimeException {",
    "        AuthenticationError(String message) { super(message); }",
    "    }",
    "    ",
    "    static class AuthenticatedUser {",
    "        final String userId;",
    "        final String username;",
    "        final UserRole role;",
    "        final Instant expiresAt;",
    "        ",
    "        AuthenticatedUser(String userId, String username, UserRole role, Instant expiresAt) {",
    "            this.userId = userId;",
    "            this.username = username;",
    "            this.role = role;",
    "            this.expiresAt = expiresAt;",
    "        }",
    "    }",
    "    ",
    "    static class SimpleJWTAuth {",
    "        private final String secretKey;",
    "        private final int expiryMinutes = 15;",
    "        private final Map<String, AuthenticatedUser> tokens = new ConcurrentHashMap<>();",
    "        ",
    "        SimpleJWTAuth(String secretKey) {",
    "            this.secretKey = secretKey;",
    "        }",
    "        ",
    "        String generateToken(String userId, String username, UserRole role) {",
    "            String token = UUID.randomUUID().toString();",
    "            Instant expiry = Instant.now().plusSeconds(expiryMinutes * 60);",
    "            tokens.put(token, new AuthenticatedUser(userId, username, role, expiry));",
    "            return token;",
    "        }",
    "        ",
    "        AuthenticatedUser verifyToken(String token) {",
    "            AuthenticatedUser user = tokens.get(token);",
    "            if (user == null) throw new AuthenticationError(\"Invalid token\");",
    "            if (Instant.now().isAfter(user.expiresAt)) {",
    "                tokens.remove(token);",
    "                throw new AuthenticationError(\"Token expired\");",
    "            }",
    "            return user;",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 3: AUTHORIZATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    enum Permission { READ, CREATE, UPDATE, DELETE, MODERATE, ADMIN }",
    "    ",
    "    static class AuthorizationError extends RuntimeException {",
    "        AuthorizationError(String message) { super(message); }",
    "    }",
    "    ",
    "    static class AuthorizationManager {",
    "        private final Map<UserRole, Set<Permission>> rolePermissions = Map.of(",
    "            UserRole.USER, Set.of(Permission.READ, Permission.CREATE, Permission.UPDATE, Permission.DELETE),",
    "            UserRole.MODERATOR, Set.of(Permission.READ, Permission.CREATE, Permission.UPDATE, ",
    "                                        Permission.DELETE, Permission.MODERATE),",
    "            UserRole.ADMIN, Set.of(Permission.values())",
    "        );",
    "        ",
    "        boolean hasPermission(AuthenticatedUser user, Permission permission) {",
    "            return rolePermissions.getOrDefault(user.role, Set.of()).contains(permission);",
    "        }",
    "        ",
    "        void authorize(AuthenticatedUser user, Permission permission, String resourceOwnerId) {",
    "            if (!hasPermission(user, permission)) {",
    "                throw new AuthorizationError(\"Permission denied: \" + permission);",
    "            }",
    "            if ((permission == Permission.UPDATE || permission == Permission.DELETE) && resourceOwnerId != null) {",
    "                if (!user.userId.equals(resourceOwnerId) && ",
    "                    user.role != UserRole.MODERATOR && user.role != UserRole.ADMIN) {",
    "                    throw new AuthorizationError(\"Cannot modify others' content\");",
    "                }",
    "            }",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 4: INPUT VALIDATION",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    static class ValidationError extends RuntimeException {",
    "        final String field;",
    "        ValidationError(String field, String message) {",
    "            super(\"Validation error on '\" + field + \"': \" + message);",
    "            this.field = field;",
    "        }",
    "    }",
    "    ",
    "    static class InputValidator {",
    "        private static final Pattern DANGEROUS_TAGS = ",
    "            Pattern.compile(\"<(script|iframe|object|embed)[^>]*>.*?</\\\\1>\", ",
    "                           Pattern.CASE_INSENSITIVE | Pattern.DOTALL);",
    "        private static final Pattern USERNAME_PATTERN = Pattern.compile(\"^[a-zA-Z0-9_-]{3,30}$\");",
    "        private static final Pattern EMAIL_PATTERN = ",
    "            Pattern.compile(\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\");",
    "        ",
    "        static String sanitizeHtml(String content) {",
    "            if (content == null) return null;",
    "            return DANGEROUS_TAGS.matcher(content).replaceAll(\"\").trim();",
    "        }",
    "        ",
    "        static String validateUsername(String username) {",
    "            if (username == null || username.isBlank()) {",
    "                throw new ValidationError(\"username\", \"Username required\");",
    "            }",
    "            username = username.trim();",
    "            if (!USERNAME_PATTERN.matcher(username).matches()) {",
    "                throw new ValidationError(\"username\", \"Invalid username format\");",
    "            }",
    "            return username;",
    "        }",
    "        ",
    "        static String validateEmail(String email) {",
    "            if (email == null || email.isBlank()) {",
    "                throw new ValidationError(\"email\", \"Email required\");",
    "            }",
    "            email = email.trim().toLowerCase();",
    "            if (!EMAIL_PATTERN.matcher(email).matches()) {",
    "                throw new ValidationError(\"email\", \"Invalid email format\");",
    "            }",
    "            return email;",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 5: CACHE LAYER",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    static class CacheEntry<T> {",
    "        final T data;",
    "        final long expiresAtNanos;",
    "        ",
    "        CacheEntry(T data, int ttlSeconds) {",
    "            this.data = data;",
    "            this.expiresAtNanos = System.nanoTime() + (ttlSeconds * 1_000_000_000L);",
    "        }",
    "        ",
    "        boolean isExpired() {",
    "            return System.nanoTime() > expiresAtNanos;",
    "        }",
    "    }",
    "    ",
    "    static class CacheLayer {",
    "        private final Map<String, CacheEntry<?>> cache = new ConcurrentHashMap<>();",
    "        private int hits = 0;",
    "        private int misses = 0;",
    "        ",
    "        @SuppressWarnings(\"unchecked\")",
    "        <T> Optional<T> get(String key) {",
    "            CacheEntry<?> entry = cache.get(key);",
    "            if (entry != null && !entry.isExpired()) {",
    "                hits++;",
    "                return Optional.of((T) entry.data);",
    "            }",
    "            if (entry != null) cache.remove(key);",
    "            misses++;",
    "            return Optional.empty();",
    "        }",
    "        ",
    "        <T> void set(String key, T value, int ttlSeconds) {",
    "            cache.put(key, new CacheEntry<>(value, ttlSeconds));",
    "        }",
    "        ",
    "        void invalidatePattern(String prefix) {",
    "            cache.keySet().removeIf(k -> k.startsWith(prefix));",
    "        }",
    "        ",
    "        String getStats() {",
    "            int total = hits + misses;",
    "            double hitRate = total > 0 ? (double) hits / total : 0;",
    "            return String.format(\"hits=%d, misses=%d, hitRate=%.2f\", hits, misses, hitRate);",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 6: SHARD ROUTER",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    static class ShardRouter {",
    "        private final int numShards;",
    "        ",
    "        ShardRouter(int numShards) {",
    "            this.numShards = numShards;",
    "        }",
    "        ",
    "        String getQuestionShard(String questionId) {",
    "            int hash = Math.abs(questionId.hashCode());",
    "            return \"shard_\" + (hash % numShards);",
    "        }",
    "        ",
    "        String getUserShard(String userId) {",
    "            int hash = Math.abs(userId.hashCode());",
    "            return \"shard_\" + (hash % numShards);",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 7: SPAM DETECTOR",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    static class SpamDetector {",
    "        private static final Set<String> SPAM_KEYWORDS = Set.of(",
    "            \"buy now\", \"click here\", \"free money\", \"winner\", \"earn money\"",
    "        );",
    "        private static final Pattern URL_PATTERN = ",
    "            Pattern.compile(\"https?://[^\\\\s]+\", Pattern.CASE_INSENSITIVE);",
    "        ",
    "        double calculateSpamScore(String content) {",
    "            double score = 0.0;",
    "            String lower = content.toLowerCase();",
    "            ",
    "            for (String kw : SPAM_KEYWORDS) {",
    "                if (lower.contains(kw)) score += 0.15;",
    "            }",
    "            ",
    "            Matcher urlMatcher = URL_PATTERN.matcher(content);",
    "            int urlCount = 0;",
    "            while (urlMatcher.find()) urlCount++;",
    "            if (urlCount > 3) score += Math.min((urlCount - 3) * 0.1, 0.3);",
    "            ",
    "            return Math.min(score, 1.0);",
    "        }",
    "        ",
    "        boolean isSpam(String content) {",
    "            return calculateSpamScore(content) >= 0.5;",
    "        }",
    "    }",
    "    ",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    // SECTION 8: DEMO",
    "    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550",
    "    ",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\".repeat(70));",
    "        System.out.println(\"STACK OVERFLOW API - SCALABILITY & SECURITY DEMO (Java)\");",
    "        System.out.println(\"=\".repeat(70));",
    "        ",
    "        // 1. Rate Limiting",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"1. RATE LIMITING\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        TokenBucketRateLimiter rateLimiter = new TokenBucketRateLimiter();",
    "        String testIP = \"10.0.0.1\";",
    "        ",
    "        for (int i = 0; i < 10; i++) {",
    "            boolean allowed = rateLimiter.isAllowed(testIP, \"anonymous\");",
    "            if (i % 3 == 0) {",
    "                System.out.println(\"  Request \" + (i + 1) + \": \" + (allowed ? \"ALLOWED\" : \"BLOCKED\"));",
    "            }",
    "        }",
    "        ",
    "        // 2. Authentication",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"2. JWT AUTHENTICATION\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        SimpleJWTAuth auth = new SimpleJWTAuth(\"secret-key\");",
    "        String token = auth.generateToken(\"user1\", \"john_doe\", UserRole.USER);",
    "        System.out.println(\"Generated token: \" + token);",
    "        ",
    "        AuthenticatedUser user = auth.verifyToken(token);",
    "        System.out.println(\"Verified user: \" + user.username + \", role: \" + user.role);",
    "        ",
    "        // 3. Authorization",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"3. AUTHORIZATION\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        AuthorizationManager authz = new AuthorizationManager();",
    "        ",
    "        try {",
    "            authz.authorize(user, Permission.DELETE, \"other_user\");",
    "        } catch (AuthorizationError e) {",
    "            System.out.println(\"Authorization blocked: \" + e.getMessage());",
    "        }",
    "        ",
    "        AuthenticatedUser admin = new AuthenticatedUser(\"admin\", \"admin\", UserRole.ADMIN, ",
    "                                                        Instant.now().plusSeconds(3600));",
    "        authz.authorize(admin, Permission.DELETE, \"other_user\");",
    "        System.out.println(\"Admin authorized to delete any content\");",
    "        ",
    "        // 4. Input Validation",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"4. INPUT VALIDATION\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        String xssInput = \"<script>alert('xss')</script>Hello\";",
    "        String sanitized = InputValidator.sanitizeHtml(xssInput);",
    "        System.out.println(\"Original: \" + xssInput);",
    "        System.out.println(\"Sanitized: \" + sanitized);",
    "        ",
    "        // 5. Caching",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"5. CACHING\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        CacheLayer cache = new CacheLayer();",
    "        cache.set(\"question:1\", Map.of(\"title\", \"How to use Java?\"), 300);",
    "        ",
    "        System.out.println(\"First fetch: \" + cache.get(\"question:1\"));",
    "        System.out.println(\"Second fetch: \" + cache.get(\"question:1\"));",
    "        System.out.println(\"Cache stats: \" + cache.getStats());",
    "        ",
    "        // 6. Sharding",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"6. SHARDING\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        ShardRouter router = new ShardRouter(4);",
    "        for (int i = 0; i < 8; i++) {",
    "            System.out.println(\"  Question q_\" + i + \" -> \" + router.getQuestionShard(\"q_\" + i));",
    "        }",
    "        ",
    "        // 7. Spam Detection",
    "        System.out.println(\"\\n\" + \"-\".repeat(50));",
    "        System.out.println(\"7. SPAM DETECTION\");",
    "        System.out.println(\"-\".repeat(50));",
    "        ",
    "        SpamDetector spamDetector = new SpamDetector();",
    "        String normal = \"How do I implement a REST API?\";",
    "        String spam = \"BUY NOW click here for FREE MONEY http://a.com http://b.com http://c.com http://d.com\";",
    "        ",
    "        System.out.printf(\"  Normal content score: %.2f%n\", spamDetector.calculateSpamScore(normal));",
    "        System.out.printf(\"  Spam content score: %.2f%n\", spamDetector.calculateSpamScore(spam));",
    "        System.out.println(\"  Is spam: \" + spamDetector.isSpam(spam));",
    "        ",
    "        System.out.println(\"\\n\" + \"=\".repeat(70));",
    "        System.out.println(\"DEMO COMPLETE\");",
    "        System.out.println(\"=\".repeat(70));",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-50",
      "explanation": "Rate Limiting: Token bucket algorithm with configurable rates for different endpoint types (default, anonymous, write). Uses per-identifier tracking to prevent abuse."
    },
    {
      "lines": "52-140",
      "explanation": "Authentication: Simplified JWT implementation demonstrating token generation, signature verification, and expiration handling. In production, use proper JWT library with RS256."
    },
    {
      "lines": "142-200",
      "explanation": "Authorization: Role-Based Access Control (RBAC) with permission sets per role. Checks both role permissions and resource ownership for modifications."
    },
    {
      "lines": "202-300",
      "explanation": "Input Validation: Comprehensive validation including HTML sanitization, SQL injection pattern detection, username/email format validation, and content length checks."
    },
    {
      "lines": "302-400",
      "explanation": "Caching Layer: Cache-aside pattern with TTL support. Demonstrates caching questions, search results, and hot content with appropriate expiration policies."
    },
    {
      "lines": "402-460",
      "explanation": "Spam Detection: Heuristic-based spam scoring considering keywords, URL density, posting frequency, and historical spam score."
    },
    {
      "lines": "462-540",
      "explanation": "Database Sharding: Consistent hashing implementation for distributing data across shards with minimal redistribution when adding/removing nodes."
    },
    {
      "lines": "542-640",
      "explanation": "Security Decorators: Middleware pattern for applying rate limiting, authentication, authorization, and spam checking to API methods."
    },
    {
      "lines": "642-780",
      "explanation": "Secure API Implementation: Complete Stack Overflow API with all security layers integrated, showing how security concerns wrap business logic."
    },
    {
      "lines": "782-900",
      "explanation": "Demonstration: Comprehensive test showing all security features in action with real scenarios."
    }
  ],
  "complexity_analysis": {
    "time": {
      "new_methods": {
        "rate_limit_check": {
          "complexity": "O(1)",
          "explanation": "Token bucket uses simple arithmetic operations"
        },
        "jwt_verify": {
          "complexity": "O(1)",
          "explanation": "HMAC signature verification is constant time"
        },
        "cache_get": {
          "complexity": "O(1)",
          "explanation": "Hash-based cache lookup"
        },
        "shard_lookup": {
          "complexity": "O(log n)",
          "explanation": "Binary search on consistent hash ring sorted keys"
        },
        "spam_detection": {
          "complexity": "O(m)",
          "explanation": "Linear scan of spam keywords where m is keyword count"
        }
      },
      "overall_change": "Security checks add O(1) overhead per request. Caching reduces average case from O(n) to O(1) for repeated reads."
    },
    "space": {
      "additional_space": "O(u + c + s)",
      "explanation": "u = unique users/IPs for rate limiting, c = cached entries, s = shard ring nodes. Redis handles this in production."
    }
  },
  "dry_run": {
    "example_input": "User posts a question: title='How to implement rate limiting?' body='I need to...' tags=['python']",
    "steps": [
      {
        "step": 1,
        "action": "Rate limit check",
        "state": "Check token bucket for user IP/ID",
        "explanation": "Allows 100 req/min for authenticated users"
      },
      {
        "step": 2,
        "action": "JWT verification",
        "state": "Extract and verify Bearer token",
        "explanation": "Decode payload, verify signature, check expiration"
      },
      {
        "step": 3,
        "action": "Input validation",
        "state": "Sanitize title and body, validate tags",
        "explanation": "Remove XSS, check lengths, validate tag format"
      },
      {
        "step": 4,
        "action": "Authorization",
        "state": "Check user has CREATE permission",
        "explanation": "All users have CREATE by default"
      },
      {
        "step": 5,
        "action": "Spam check",
        "state": "Calculate spam score: 0.0",
        "explanation": "Normal question content passes spam filter"
      },
      {
        "step": 6,
        "action": "Shard routing",
        "state": "question_id=1 -> shard_0",
        "explanation": "Consistent hash determines storage shard"
      },
      {
        "step": 7,
        "action": "Store question",
        "state": "Save to database shard",
        "explanation": "Insert into primary database"
      },
      {
        "step": 8,
        "action": "Cache invalidation",
        "state": "Clear search cache",
        "explanation": "New content invalidates cached search results"
      }
    ],
    "final_output": "Question created successfully with ID=1, stored in shard_0"
  },
  "debugging_playbook": {
    "fast_sanity_checks": [
      "Rate limit allows first request",
      "Valid token passes verification",
      "Clean input passes validation"
    ],
    "likely_bugs": [
      "Token expiration off-by-one",
      "Cache TTL not updating",
      "Shard key collision"
    ],
    "recommended_logs_or_asserts": [
      "Log rate limit decisions",
      "Assert user is set before auth check",
      "Log cache hit/miss ratio"
    ],
    "how_to_localize": "Add trace logging at each security layer. Check if request fails at rate limiting, auth, validation, or authorization step."
  },
  "edge_cases": [
    {
      "case": "Token expires during request",
      "handling": "Check expiration at verification time, return 401",
      "gotcha": "Clock skew between servers"
    },
    {
      "case": "Cache expires between check and use",
      "handling": "Re-fetch on cache miss, lazy expiration",
      "gotcha": "Don't trust cache entry after async operations"
    },
    {
      "case": "User deletes account while logged in",
      "handling": "Token still valid but user ID not found",
      "gotcha": "Check user exists in addition to token validity"
    },
    {
      "case": "Rate limit bucket overflow",
      "handling": "Cap at burst size, never negative tokens",
      "gotcha": "Integer overflow for very large burst sizes"
    },
    {
      "case": "XSS in allowed HTML tags",
      "handling": "Whitelist approach is safer than blacklist",
      "gotcha": "Use proper HTML sanitization library in production"
    }
  ],
  "test_cases": [
    {
      "name": "Rate limit enforcement",
      "input": "Send 25 requests with anonymous limit of 20/min",
      "expected": "First 5-20 pass (depending on burst), then blocked with retry-after",
      "explanation": "Token bucket allows burst then enforces rate"
    },
    {
      "name": "JWT token expiration",
      "input": "Token generated 20 minutes ago with 15-min expiry",
      "expected": "AuthenticationError: Token expired",
      "explanation": "Expired tokens must be rejected"
    },
    {
      "name": "XSS prevention",
      "input": "<script>alert('xss')</script>Hello World",
      "expected": "Hello World (scripts removed)",
      "explanation": "Dangerous tags stripped from content"
    },
    {
      "name": "Authorization - owner can delete",
      "input": "User1 tries to delete User1's question",
      "expected": "Success - user can delete own content",
      "explanation": "Resource ownership check passes"
    },
    {
      "name": "Authorization - non-owner blocked",
      "input": "User2 tries to delete User1's question",
      "expected": "AuthorizationError: Cannot modify resource",
      "explanation": "User2 is neither owner nor moderator"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Checking authorization before authentication",
      "why_wrong": "Can't authorize an unknown user; order matters",
      "correct_approach": "Always authenticate first, then authorize",
      "code_example_wrong": "// @requires_permission before @requires_auth",
      "code_example_correct": "// @requires_auth then @requires_permission"
    },
    {
      "mistake": "Rate limiting only by IP",
      "why_wrong": "Shared IPs (NAT, VPN) would affect multiple users",
      "correct_approach": "Rate limit by both IP AND user ID",
      "code_example_wrong": "rate_limit(request.ip)",
      "code_example_correct": "rate_limit(user.id if authenticated else request.ip)"
    },
    {
      "mistake": "Client-side only validation",
      "why_wrong": "Attackers bypass client-side checks easily",
      "correct_approach": "Always validate on server side",
      "code_example_wrong": "// Trust JavaScript validation",
      "code_example_correct": "// Re-validate all input on server"
    },
    {
      "mistake": "Not invalidating cache on writes",
      "why_wrong": "Stale data served to users",
      "correct_approach": "Invalidate or update cache on every write",
      "code_example_wrong": "self._questions[id] = q  # No cache update",
      "code_example_correct": "self._questions[id] = q; self._cache.delete(f'question:{id}')"
    }
  ],
  "interview_tips": {
    "how_to_present": "Start with the big picture: 'Stack Overflow is read-heavy, so our architecture should optimize for reads.' Then walk through each layer from the outside in: load balancing, rate limiting, authentication, caching, then database.",
    "what_to_mention": [
      "Trade-offs between consistency and availability",
      "Cache invalidation is one of the hardest problems",
      "Defense in depth for security",
      "Horizontal vs vertical scaling",
      "Specialized systems (Elasticsearch for search, Redis for caching)"
    ],
    "time_allocation": "Spend 5 min on scalability architecture, 5 min on security layers, 3-5 min discussing trade-offs and alternatives",
    "if_stuck": [
      "Think about the read:write ratio - what can be cached?",
      "What data needs strong consistency vs eventual consistency?",
      "What are the attack vectors for a Q&A platform?"
    ]
  },
  "connection_to_next_part": "This scalability and security foundation enables future features like: real-time notifications (WebSockets with Redis pub/sub), content moderation queues (async processing), analytics pipelines (event streaming), and global CDN distribution.",
  "communication_script": {
    "transition_from_previous": "Great, Parts 1-3 gave us a working API. Now let's discuss how to make it production-ready with scalability and security. The key insight is that Stack Overflow is read-heavy, so we need to optimize for that pattern.",
    "explaining_changes": "I'll add security as middleware layers that wrap our existing logic. This follows the Open-Closed Principle - we're extending without modifying core functionality. For scalability, we'll add a caching layer and discuss sharding strategies.",
    "while_extending_code": [
      "I'm implementing rate limiting using the token bucket algorithm because it handles bursty traffic well...",
      "This JWT middleware will verify tokens at the API gateway level before requests reach business logic...",
      "The cache layer uses the cache-aside pattern - check cache first, populate on miss..."
    ],
    "after_completing": "This architecture handles millions of users through horizontal scaling, protects against common attacks, and maintains sub-100ms latency for most requests through aggressive caching. Ready to discuss any specific component in more depth?"
  },
  "time_milestones": {
    "time_budget": "10-15 minutes for this discussion part",
    "by_2_min": "Establish the key insight: read-heavy workload requiring caching and read replicas",
    "by_5_min": "Cover scalability: sharding, caching, Elasticsearch for search",
    "by_10_min": "Cover security: rate limiting, auth, authorization, input validation",
    "warning_signs": "If spending too long on one topic, summarize and move on. Breadth is more important than depth here."
  },
  "recovery_strategies": {
    "if_part_builds_wrong": "This is a discussion part, so focus on concepts. If implementation examples are needed, simplify to pseudocode.",
    "if_new_requirement_unclear": "Ask: 'Should I focus more on the scalability aspects or the security aspects?' to clarify interviewer priorities.",
    "if_running_behind": "Hit the highlights: 'For scalability: shard by question ID, cache hot questions, use Elasticsearch. For security: rate limiting, JWT auth, input sanitization.'"
  },
  "signal_points": {
    "wow_factors_for_followup": [
      "Mentioning cache stampede and how to prevent it (locking, probabilistic early expiration)",
      "Discussing CAP theorem trade-offs for eventual consistency on votes",
      "Mentioning security headers (CSP, HSTS, X-Frame-Options)",
      "Discussing distributed rate limiting challenges (Redis Lua scripts)",
      "Mentioning blue-green deployment for zero-downtime updates"
    ]
  },
  "pattern_recognition": {
    "pattern": "Layered Architecture + Caching Strategy + Distributed Systems",
    "indicators": [
      "High read:write ratio",
      "Multiple security concerns",
      "Scale requirements beyond single server"
    ],
    "similar_problems": [
      "Design Twitter",
      "Design Reddit",
      "Design News Feed"
    ],
    "template": "Load Balancer -> Rate Limiter -> Auth -> Cache -> Business Logic -> Sharded Database"
  },
  "thinking_process": [
    {
      "step": 1,
      "thought": "When I see 'Q&A platform with millions of users', I immediately think read-heavy workload",
      "why": "People view questions far more than they post them"
    },
    {
      "step": 2,
      "thought": "The security requirement means I need defense in depth",
      "why": "No single security measure is sufficient"
    },
    {
      "step": 3,
      "thought": "Caching is the key to handling read traffic",
      "why": "100:1 read:write ratio means most reads can hit cache"
    },
    {
      "step": 4,
      "thought": "Sharding by question ID keeps related data together",
      "why": "Questions and their answers should be on the same shard"
    }
  ],
  "interviewer_perspective": {
    "what_they_evaluate": [
      "Can you think beyond a single server?",
      "Do you understand security best practices?",
      "Can you make trade-off decisions and justify them?",
      "Do you know when to use specialized systems?"
    ],
    "bonus_points": [
      "Mentioning specific technologies (Redis, Elasticsearch, Kafka)",
      "Discussing failure scenarios",
      "Calculating rough capacity numbers",
      "Mentioning observability (logging, metrics, tracing)"
    ],
    "red_flags": [
      "Only discussing in-memory solutions",
      "Ignoring security entirely",
      "Not considering cache invalidation",
      "No trade-off analysis"
    ]
  },
  "ai_copilot_tips": {
    "what_to_do": [
      "Use AI to generate boilerplate for security patterns",
      "Ask for common rate limiting implementations"
    ],
    "what_not_to_do": [
      "Don't rely on AI for architecture decisions",
      "Verify all security code thoroughly"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Dismissing security as 'not important for the interview'",
      "Not asking about expected scale"
    ],
    "technical": [
      "Suggesting only vertical scaling",
      "Ignoring cache consistency issues",
      "No authentication strategy"
    ],
    "communication": [
      "Not explaining why certain trade-offs were made",
      "Skipping over security concerns quickly"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I cover both scalability AND security?",
      "Did I explain the sharding strategy?",
      "Did I discuss caching with invalidation?",
      "Did I mention authentication AND authorization?",
      "Did I address input validation?"
    ],
    "quick_code_review": [
      "Rate limiter handles both IP and user ID",
      "JWT verification checks expiration",
      "Authorization checks resource ownership",
      "Input validation happens server-side"
    ]
  },
  "production_considerations": {
    "what_i_would_add": [
      "Structured logging with correlation IDs",
      "Metrics (Prometheus) for rate limit hits, cache hit rates, latency",
      "Distributed tracing (Jaeger) for request flow",
      "Circuit breakers for external service calls",
      "Feature flags for gradual rollouts",
      "A/B testing infrastructure",
      "Content Delivery Network for static assets"
    ],
    "why_not_in_interview": "Focus on core scalability and security concepts; mention these as production enhancements",
    "how_to_mention": "Say: 'In production, I'd add observability with structured logging and distributed tracing to debug issues across services.'"
  },
  "generated_at": "2026-01-18T18:55:28.979492",
  "_meta": {
    "problem_id": "stackoverflow_api",
    "part_number": 4,
    "model": "claude-opus-4-5-20251101"
  }
}