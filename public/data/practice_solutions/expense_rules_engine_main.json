{
  "problem_title": "Corporate Expense Rules Engine",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a classic **Rules Engine / Strategy Pattern** problem. The core challenge is designing a flexible, extensible system where new rule types can be added without modifying existing code. The problem tests OOP fundamentals, interface design, and the candidate's understanding of SOLID principles\u2014particularly Open/Closed Principle.",
    "pattern_recognition": "**Strategy Pattern** (each rule is a strategy) + **HashMap** for field lookups + **Polymorphism** for rule evaluation. This is similar to validation frameworks, policy engines, and filter chains in real systems.",
    "key_constraints": [
      "Amounts are STRINGS - must parse to Decimal for accurate currency math",
      "One expense can violate MULTIPLE rules - must check all rules, not short-circuit",
      "Up to 50 rules \u00d7 1000 expenses = 50,000 evaluations max - O(R\u00d7E) is acceptable",
      "Boundary conditions matter - $75.00 exactly should PASS a $75 limit"
    ],
    "clarifying_questions": [
      "**Q1: Are amounts always valid decimal strings?** - Determines if we need try/catch for parsing. In interview, assume yes but mention validation in production.",
      "**Q2: Is $75.00 within a $75.00 limit (inclusive)?** - Critical for boundary handling. Example 3 shows it IS inclusive (\u2264 not <).",
      "**Q3: Should violations be ordered?** - Ask if order matters (by expense, by rule, etc.). Typically doesn't matter.",
      "**Q4: Can fields be missing from expenses?** - Determines if we need null checks. Assume all fields present unless told otherwise.",
      "**Q5: How should the rule configuration come in?** - JSON/dict vs constructor. For interview, use constructor parameters.",
      "**Q6: Should BanRule support regex/partial matches?** - Scope clarification. Start with exact match, mention extensibility."
    ],
    "edge_cases_to_consider": [
      "Expense at exactly the limit ($75.00 when limit is $75.00) - should PASS",
      "Expense just over limit ($75.01 when limit is $75.00) - should FAIL",
      "Expense violates multiple rules simultaneously",
      "Empty rules list - return empty violations",
      "Empty expenses list - return empty violations",
      "BanRule field doesn't exist on expense (defensive programming)",
      "Very small amounts ($0.01) and very large amounts ($100,000.00)"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "Design a flexible Rule interface/base class",
        "how_met": "Abstract `Rule` class with `evaluate(expense) -> Optional[Violation]` method. Each rule type extends this.",
        "gotchas": [
          "Don't forget `get_name()` or similar for identifying rule in violations"
        ]
      },
      {
        "requirement": "Each rule type should be its own class",
        "how_met": "`BanRule`, `MaxAmountRule`, `VendorTypeLimitRule` are separate classes implementing `Rule`",
        "gotchas": [
          "Keep logic self-contained within each rule - no cross-rule dependencies"
        ]
      },
      {
        "requirement": "Must be easy to add new rule types",
        "how_met": "New rules just implement `Rule` interface - no changes to engine or existing rules",
        "gotchas": [
          "Don't use if/else or switch on rule type in engine - violates Open/Closed"
        ]
      },
      {
        "requirement": "evaluateRules returns detailed violations",
        "how_met": "`Violation` dataclass with `expense_id`, `rule_name`, `reason`",
        "gotchas": [
          "Return ALL violations, not just first one per expense"
        ]
      },
      {
        "requirement": "BanRule blocks by field value",
        "how_met": "Uses `getattr()` to dynamically access field by name",
        "gotchas": [
          "Handle missing field gracefully - don't crash"
        ]
      },
      {
        "requirement": "MaxAmountRule caps individual expense",
        "how_met": "Simple comparison: `expense.amount_usd > self.max_amount`",
        "gotchas": [
          "Use Decimal not float for currency comparison"
        ]
      },
      {
        "requirement": "VendorTypeLimitRule caps by vendor type",
        "how_met": "Check vendor_type matches AND amount exceeds limit",
        "gotchas": [
          "Both conditions must be true - don't forget the vendor type check"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "evaluate_rules",
        "target": "O(R \u00d7 E)",
        "achieved": "O(R \u00d7 E)",
        "why": "Must check each rule against each expense - no way around this"
      },
      {
        "operation": "Single rule evaluation",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "Each rule does constant-time field access and comparison"
      }
    ],
    "non_goals": [
      "Persisting rules/expenses to database",
      "Rule priority/ordering (all rules are equal)",
      "Rule composition (AND/OR of multiple rules)",
      "Async/parallel evaluation (keep it simple)"
    ]
  },
  "assumptions": [
    "All expense fields are always present (no null checks needed)",
    "Amount strings are always valid decimal numbers",
    "Expense IDs are unique across the input",
    "Rules are applied independently (no rule depends on another)",
    "Limits are inclusive (\u2264 passes, > fails) - confirmed by Example 3"
  ],
  "tradeoffs": [
    {
      "decision": "Each rule returns Optional[Violation] vs boolean + separate violation builder",
      "chosen": "Return Optional[Violation] directly from rule",
      "why": "Keeps violation logic with the rule that understands the context. Easier to create meaningful error messages.",
      "alternative": "Return boolean, let engine build violations",
      "when_to_switch": "If violations need aggregation or transformation before returning"
    },
    {
      "decision": "Use getattr() for BanRule vs separate rule classes per field",
      "chosen": "Single BanRule with dynamic field access",
      "why": "More flexible, less code duplication. One class handles expense_type, vendor_type, vendor_name.",
      "alternative": "BanExpenseTypeRule, BanVendorTypeRule, BanVendorNameRule",
      "when_to_switch": "If field-specific logic differs significantly between fields"
    },
    {
      "decision": "Decimal vs float for currency",
      "chosen": "Decimal (Python) / BigDecimal (Java)",
      "why": "Precise currency math. 0.1 + 0.1 + 0.1 = 0.3 with Decimal, but 0.30000000000000004 with float.",
      "alternative": "Store cents as integers (4999 instead of $49.99)",
      "when_to_switch": "If performance is critical and you can guarantee integer representation"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Open/Closed Principle**: Add new rules by creating new classes, not modifying engine",
      "**Single Responsibility**: Each rule handles exactly one type of validation",
      "**Dependency Inversion**: Engine depends on abstract Rule interface, not concrete implementations",
      "**Liskov Substitution**: Any Rule subclass can be used wherever Rule is expected"
    ],
    "why_this_design_scales": "The engine's `evaluate_rules` method never changes. New rule types like `TripTotalLimitRule` (Part 2) just implement the same `evaluate()` interface. The data structures (HashMap for aggregation) can be added inside new rule classes without affecting existing code.",
    "expected_followup_hooks": [
      "`evaluate()` method is the extension point for new rules",
      "Expense class might need additional fields for future rules",
      "Engine might need pre-processing hooks for aggregation-based rules (Part 2)",
      "Violation class might need severity levels or correction suggestions"
    ],
    "invariants": [
      "Every expense is evaluated against every rule (no filtering/optimization)",
      "A violation always includes expense_id, rule_name, and reason",
      "Rules are stateless - same expense always produces same result"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    EXPENSE RULES ENGINE FLOW                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                     \u2502\n\u2502   RULES (Configured by Manager)          EXPENSES (Submitted)       \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502   \u2502 1. BanRule              \u2502           \u2502 E001: $49.99        \u2502     \u2502\n\u2502   \u2502    field: expense_type  \u2502           \u2502   restaurant        \u2502     \u2502\n\u2502   \u2502    value: entertainment \u2502           \u2502   client_hosting    \u2502     \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2502\n\u2502   \u2502 2. MaxAmountRule        \u2502           \u2502 E002: $350.00       \u2502     \u2502\n\u2502   \u2502    max: $250            \u2502           \u2502   airline           \u2502     \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524           \u2502   airfare           \u2502     \u2502\n\u2502   \u2502 3. VendorTypeLimitRule  \u2502           \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u2502\n\u2502   \u2502    vendor_type:         \u2502           \u2502 E003: $85.00        \u2502     \u2502\n\u2502   \u2502    restaurant           \u2502           \u2502   restaurant        \u2502     \u2502\n\u2502   \u2502    max: $75             \u2502           \u2502   meals             \u2502     \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502               \u2502                                    \u2502                \u2502\n\u2502               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                \u2502\n\u2502                            \u2502                                        \u2502\n\u2502                            \u25bc                                        \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502              \u2502     RULES ENGINE            \u2502                        \u2502\n\u2502              \u2502  for expense in expenses:   \u2502                        \u2502\n\u2502              \u2502    for rule in rules:       \u2502                        \u2502\n\u2502              \u2502      if rule.evaluate(exp): \u2502                        \u2502\n\u2502              \u2502        violations.add(...)  \u2502                        \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2502                             \u2502                                       \u2502\n\u2502                             \u25bc                                       \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502              \u2502       VIOLATIONS            \u2502                        \u2502\n\u2502              \u2502 E002: BanRule - airfare     \u2502                        \u2502\n\u2502              \u2502 E002: MaxAmount - $350>$250 \u2502                        \u2502\n\u2502              \u2502 E003: VendorLimit - $85>$75 \u2502                        \u2502\n\u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    CLASS HIERARCHY                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                        \u2502\n\u2502                    \u2502   <<abstract>>   \u2502                        \u2502\n\u2502                    \u2502      Rule        \u2502                        \u2502\n\u2502                    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u2502\n\u2502                    \u2502 +evaluate(exp)   \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502                    \u2502 +get_name()      \u2502      \u2502 Returns         \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502                 \u2502\n\u2502                             \u2502                \u25bc                 \u2502\n\u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                \u2502\n\u2502           \u2502                 \u2502                 \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502           \u25bc                 \u25bc                 \u25bc    \u2502Violation\u2502 \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 \u2502\n\u2502   \u2502   BanRule     \u2502 \u2502MaxAmountRule  \u2502 \u2502VendorType \u2502\u2502exp_id   \u2502 \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502LimitRule  \u2502\u2502rule_name\u2502 \u2502\n\u2502   \u2502 -field: str   \u2502 \u2502 -max_amount   \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u2502reason   \u2502 \u2502\n\u2502   \u2502 -value: str   \u2502 \u2502               \u2502 \u2502-vendor_typ\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502-max_amount\u2502            \u2502\n\u2502                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502                                                                \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502                  ExpenseRulesEngine                    \u2502   \u2502\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   \u2502\n\u2502   \u2502 +evaluate_rules(rules, expenses) -> List[Violation]    \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "Parse expenses from dict to Expense objects",
        "visualization": "```\nDict: {'expense_id': 'E001', 'amount_usd': '49.99', ...}\n                        \u2502\n                        \u25bc\nExpense(expense_id='E001', amount_usd=Decimal('49.99'), ...)\n```",
        "key_point": "Convert amount string to Decimal immediately for safe comparisons"
      },
      {
        "step": 2,
        "description": "For each expense, apply all rules",
        "visualization": "```\n     E001 \u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u25ba Rule 1 (BanRule)      \u2500\u2500\u2500\u25ba None (passes)\n              \u2502\n              \u251c\u2500\u2500\u2500\u2500\u25ba Rule 2 (MaxAmount)    \u2500\u2500\u2500\u25ba None (passes)\n              \u2502\n              \u2514\u2500\u2500\u2500\u2500\u25ba Rule 3 (VendorLimit)  \u2500\u2500\u2500\u25ba None (passes)\n```",
        "key_point": "Even if one rule fails, continue checking ALL rules"
      },
      {
        "step": 3,
        "description": "Collect violations from failed rule checks",
        "visualization": "```\n     E002 \u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u25ba Rule 1 (BanRule)      \u2500\u2500\u2500\u25ba Violation!\n              \u2502                                    \u2502\n              \u251c\u2500\u2500\u2500\u2500\u25ba Rule 2 (MaxAmount)    \u2500\u2500\u2500\u25ba Violation!\n              \u2502                                    \u2502\n              \u2514\u2500\u2500\u2500\u2500\u25ba Rule 3 (VendorLimit)  \u2500\u2500\u2500\u25ba None       \n                                                   \u2502\n     violations.extend([...])  \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "One expense can generate multiple violations"
      },
      {
        "step": 4,
        "description": "Return all collected violations",
        "visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Return: [                                       \u2502\n\u2502   Violation('E002', 'BanRule', 'airfare...'),   \u2502\n\u2502   Violation('E002', 'MaxAmount', '$350...'),    \u2502\n\u2502   Violation('E003', 'VendorLimit', '$85...')    \u2502\n\u2502 ]                                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
        "key_point": "Violations contain all info needed to understand the failure"
      }
    ],
    "dry_run_table": "| Expense | Rule | Field/Condition Check | Amount Check | Result |\n|---------|------|----------------------|--------------|--------|\n| E001 $49.99 restaurant | BanRule(entertainment) | expense_type='client_hosting' \u2260 'entertainment' | - | \u2713 PASS |\n| E001 $49.99 restaurant | MaxAmountRule($250) | - | $49.99 \u2264 $250 | \u2713 PASS |\n| E001 $49.99 restaurant | VendorTypeLimit(restaurant, $75) | vendor_type='restaurant' \u2713 | $49.99 \u2264 $75 | \u2713 PASS |\n| E002 $350 airfare | BanRule(airfare) | expense_type='airfare' = 'airfare' | - | \u2717 FAIL |\n| E002 $350 airfare | MaxAmountRule($250) | - | $350 > $250 | \u2717 FAIL |\n| E002 $350 airfare | VendorTypeLimit(restaurant, $75) | vendor_type='airline' \u2260 'restaurant' | - | \u2713 PASS |\n| E003 $85 restaurant | BanRule(airfare) | expense_type='meals' \u2260 'airfare' | - | \u2713 PASS |\n| E003 $85 restaurant | MaxAmountRule($250) | - | $85 \u2264 $250 | \u2713 PASS |\n| E003 $85 restaurant | VendorTypeLimit(restaurant, $75) | vendor_type='restaurant' \u2713 | $85 > $75 | \u2717 FAIL |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'rules engine'**, I immediately think Strategy Pattern - each rule is a strategy with a common interface",
      "**When I see 'easy to add new rule types'**, I know I need Open/Closed Principle - new rules shouldn't require modifying existing code",
      "**When I see 'expense can violate multiple rules'**, I know I need to check ALL rules, not short-circuit on first failure",
      "**When I see 'amounts as strings'**, I think currency precision - must use Decimal/BigDecimal, not float",
      "**When I see 'detailed violation information'**, I need a proper return type with expense_id, rule_name, reason",
      "**When I see 'BanRule with field parameter'**, I think dynamic attribute access - getattr() in Python or reflection in Java"
    ],
    "key_insight": "The **core insight** is that each rule is completely self-contained. A rule doesn't know or care about other rules. It takes an expense, checks its specific condition, and returns either a Violation or None. The engine is just a simple nested loop that applies this abstraction. This separation of concerns makes the system infinitely extensible.",
    "why_this_works": "The Strategy Pattern works because:\n1. **Polymorphism**: All rules implement the same interface, so the engine can treat them uniformly\n2. **Encapsulation**: Each rule's logic is hidden inside its class\n3. **Open/Closed**: Adding `TripTotalLimitRule` later just means creating a new class - nothing else changes\n4. **Single Responsibility**: Engine handles iteration, rules handle validation"
  },
  "approaches": [
    {
      "name": "Naive Approach - Switch/Case in Engine",
      "description": "Put all rule logic in the engine using if/else or switch/case based on rule type",
      "pseudocode": "for expense in expenses:\n  for rule in rules:\n    if rule.type == 'ban':\n      if expense[rule.field] == rule.value:\n        violations.append(...)\n    elif rule.type == 'max_amount':\n      if expense.amount > rule.max:\n        violations.append(...)\n    elif rule.type == 'vendor_limit':\n      ...",
      "time_complexity": "O(R \u00d7 E)",
      "space_complexity": "O(V) where V = violations",
      "pros": [
        "Quick to implement",
        "All logic in one place"
      ],
      "cons": [
        "Violates Open/Closed - adding rule requires modifying engine",
        "Switch/case grows unbounded",
        "Hard to test individual rules",
        "Violates Single Responsibility"
      ],
      "when_to_use": "Never in a real interview - this is the anti-pattern they're testing against"
    },
    {
      "name": "Optimal: Strategy Pattern with Polymorphism",
      "description": "Each rule is its own class implementing a common interface. Engine just iterates and delegates.",
      "pseudocode": "class Rule:\n  def evaluate(expense) -> Violation|None\n\nclass BanRule(Rule):\n  def evaluate(expense):\n    if expense[field] == banned_value:\n      return Violation(...)\n    return None\n\nclass Engine:\n  def evaluate(rules, expenses):\n    for expense in expenses:\n      for rule in rules:\n        v = rule.evaluate(expense)\n        if v: violations.append(v)\n    return violations",
      "time_complexity": "O(R \u00d7 E) - same as naive",
      "space_complexity": "O(V) where V = violations",
      "pros": [
        "Open/Closed compliant",
        "Each rule is independently testable",
        "Clean separation of concerns",
        "Infinitely extensible"
      ],
      "cons": [
        "Slightly more classes to write initially",
        "Need to understand polymorphism"
      ],
      "key_insight": "The time complexity is the same, but the **code complexity** is dramatically lower. Real interviews value maintainable, extensible code over micro-optimizations."
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern with Decimal Precision",
    "explanation_md": "## Approach\n\nThe solution uses the **Strategy Pattern** where each rule type is a concrete implementation of an abstract `Rule` interface.\n\n### Key Components\n\n1. **`Rule` (Abstract Base Class)**\n   - Defines `evaluate(expense) -> Optional[Violation]`\n   - Each concrete rule implements its own validation logic\n\n2. **`Violation` (Data Class)**\n   - Immutable container for violation details\n   - Contains: `expense_id`, `rule_name`, `reason`\n\n3. **Concrete Rules**\n   - `BanRule`: Uses `getattr()` for dynamic field access\n   - `MaxAmountRule`: Simple comparison against limit\n   - `VendorTypeLimitRule`: Checks vendor type AND amount\n\n4. **`ExpenseRulesEngine`**\n   - Simple nested loop: for each expense, for each rule\n   - Collects all violations (doesn't short-circuit)\n\n### Why Decimal?\n```python\n# Float is dangerous for currency!\n>>> 0.1 + 0.1 + 0.1\n0.30000000000000004  # WRONG!\n\n# Decimal is precise\n>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1')\nDecimal('0.3')  # CORRECT!\n```",
    "data_structures": [
      {
        "structure": "Abstract Rule class",
        "purpose": "Common interface for all rules - enables polymorphism"
      },
      {
        "structure": "Violation dataclass",
        "purpose": "Structured return type with expense_id, rule_name, reason"
      },
      {
        "structure": "Expense dataclass",
        "purpose": "Type-safe expense object with Decimal amount"
      },
      {
        "structure": "List[Violation]",
        "purpose": "Collect all violations across all expense-rule pairs"
      }
    ],
    "algorithm_steps": [
      "1. **Parse expenses**: Convert dict to Expense objects, parsing amount strings to Decimal",
      "2. **Iterate expenses**: For each expense in the list",
      "3. **Apply all rules**: For each rule, call `rule.evaluate(expense)`",
      "4. **Collect violations**: If evaluate returns a Violation, add it to the list",
      "5. **Return all violations**: Return the complete list (may be empty)"
    ],
    "why_decimal": "Financial calculations require exact precision. Using `float` for $0.10 + $0.10 + $0.10 gives `0.30000000000000004`, not `0.30`. This causes incorrect comparisons at boundaries (e.g., $75.00 vs $75.00 limit). `Decimal` guarantees exact decimal arithmetic."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Corporate Expense Rules Engine - Strategy Pattern Implementation",
    "",
    "This module implements a flexible rules engine for validating corporate expenses.",
    "Uses the Strategy Pattern to allow easy addition of new rule types.",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass",
    "from decimal import Decimal",
    "from typing import List, Dict, Optional",
    "",
    "",
    "@dataclass(frozen=True)",
    "class Expense:",
    "    \"\"\"",
    "    Represents a corporate expense with all relevant fields.",
    "    ",
    "    Attributes:",
    "        expense_id: Unique identifier for the expense",
    "        trip_id: Associated business trip ID",
    "        amount_usd: Expense amount in USD (Decimal for precision)",
    "        expense_type: Category like 'meals', 'airfare', 'entertainment'",
    "        vendor_type: Type of vendor like 'restaurant', 'airline'",
    "        vendor_name: Specific vendor name",
    "    \"\"\"",
    "    expense_id: str",
    "    trip_id: str",
    "    amount_usd: Decimal",
    "    expense_type: str",
    "    vendor_type: str",
    "    vendor_name: str",
    "    ",
    "    @classmethod",
    "    def from_dict(cls, data: Dict[str, str]) -> 'Expense':",
    "        \"\"\"Factory method to create Expense from dictionary.\"\"\"",
    "        return cls(",
    "            expense_id=data['expense_id'],",
    "            trip_id=data['trip_id'],",
    "            amount_usd=Decimal(data['amount_usd']),",
    "            expense_type=data['expense_type'],",
    "            vendor_type=data['vendor_type'],",
    "            vendor_name=data['vendor_name']",
    "        )",
    "",
    "",
    "@dataclass(frozen=True)",
    "class Violation:",
    "    \"\"\"",
    "    Represents a rule violation for an expense.",
    "    ",
    "    Attributes:",
    "        expense_id: ID of the expense that violated the rule",
    "        rule_name: Name of the rule that was violated",
    "        reason: Human-readable explanation of the violation",
    "    \"\"\"",
    "    expense_id: str",
    "    rule_name: str",
    "    reason: str",
    "",
    "",
    "class Rule(ABC):",
    "    \"\"\"",
    "    Abstract base class for all expense validation rules.",
    "    ",
    "    Each concrete rule implements evaluate() to check a specific condition.",
    "    This enables the Strategy Pattern - rules are interchangeable strategies.",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"",
    "        Evaluate the expense against this rule.",
    "        ",
    "        Args:",
    "            expense: The expense to validate",
    "            ",
    "        Returns:",
    "            Violation if the expense violates this rule, None otherwise",
    "        \"\"\"",
    "        pass",
    "    ",
    "    @abstractmethod",
    "    def get_name(self) -> str:",
    "        \"\"\"Return the name of this rule for violation reporting.\"\"\"",
    "        pass",
    "",
    "",
    "class BanRule(Rule):",
    "    \"\"\"",
    "    Rule that bans expenses with a specific field value.",
    "    ",
    "    Can ban by expense_type, vendor_type, or vendor_name.",
    "    ",
    "    Example:",
    "        >>> rule = BanRule('expense_type', 'entertainment')",
    "        >>> # Blocks all entertainment expenses",
    "    \"\"\"",
    "    ",
    "    def __init__(self, field: str, banned_value: str):",
    "        \"\"\"",
    "        Initialize BanRule.",
    "        ",
    "        Args:",
    "            field: The expense field to check ('expense_type', 'vendor_type', 'vendor_name')",
    "            banned_value: The value that is not allowed",
    "        \"\"\"",
    "        self.field = field",
    "        self.banned_value = banned_value",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"Check if expense has banned field value.\"\"\"",
    "        actual_value = getattr(expense, self.field, None)",
    "        if actual_value == self.banned_value:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.field} '{self.banned_value}' is not allowed\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"BanRule\"",
    "",
    "",
    "class MaxAmountRule(Rule):",
    "    \"\"\"",
    "    Rule that limits the maximum amount for any single expense.",
    "    ",
    "    Example:",
    "        >>> rule = MaxAmountRule(Decimal('250.00'))",
    "        >>> # No expense can exceed $250",
    "    \"\"\"",
    "    ",
    "    def __init__(self, max_amount: Decimal):",
    "        \"\"\"",
    "        Initialize MaxAmountRule.",
    "        ",
    "        Args:",
    "            max_amount: Maximum allowed amount for a single expense",
    "        \"\"\"",
    "        self.max_amount = max_amount",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"Check if expense exceeds maximum amount.\"\"\"",
    "        if expense.amount_usd > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                rule_name=self.get_name(),",
    "                reason=f\"amount ${expense.amount_usd} exceeds maximum ${self.max_amount}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"MaxAmountRule\"",
    "",
    "",
    "class VendorTypeLimitRule(Rule):",
    "    \"\"\"",
    "    Rule that limits spending at a specific vendor type.",
    "    ",
    "    Only applies to expenses matching the specified vendor_type.",
    "    ",
    "    Example:",
    "        >>> rule = VendorTypeLimitRule('restaurant', Decimal('75.00'))",
    "        >>> # Restaurant expenses cannot exceed $75",
    "    \"\"\"",
    "    ",
    "    def __init__(self, vendor_type: str, max_amount: Decimal):",
    "        \"\"\"",
    "        Initialize VendorTypeLimitRule.",
    "        ",
    "        Args:",
    "            vendor_type: The vendor type this limit applies to",
    "            max_amount: Maximum allowed amount for this vendor type",
    "        \"\"\"",
    "        self.vendor_type = vendor_type",
    "        self.max_amount = max_amount",
    "    ",
    "    def evaluate(self, expense: Expense) -> Optional[Violation]:",
    "        \"\"\"Check if expense at matching vendor type exceeds limit.\"\"\"",
    "        # Only check if vendor type matches",
    "        if expense.vendor_type != self.vendor_type:",
    "            return None",
    "        ",
    "        if expense.amount_usd > self.max_amount:",
    "            return Violation(",
    "                expense_id=expense.expense_id,",
    "                rule_name=self.get_name(),",
    "                reason=f\"{self.vendor_type} expense ${expense.amount_usd} exceeds limit ${self.max_amount}\"",
    "            )",
    "        return None",
    "    ",
    "    def get_name(self) -> str:",
    "        return \"VendorTypeLimitRule\"",
    "",
    "",
    "class ExpenseRulesEngine:",
    "    \"\"\"",
    "    Engine that evaluates expenses against a set of rules.",
    "    ",
    "    Applies all rules to all expenses and collects violations.",
    "    An expense can violate multiple rules.",
    "    ",
    "    Example:",
    "        >>> engine = ExpenseRulesEngine()",
    "        >>> violations = engine.evaluate_rules(rules, expenses)",
    "    \"\"\"",
    "    ",
    "    def evaluate_rules(",
    "        self,",
    "        rules: List[Rule],",
    "        expenses: List[Dict[str, str]]",
    "    ) -> List[Violation]:",
    "        \"\"\"",
    "        Evaluate all expenses against all rules.",
    "        ",
    "        Args:",
    "            rules: List of Rule objects to apply",
    "            expenses: List of expense dictionaries",
    "            ",
    "        Returns:",
    "            List of all violations found",
    "        \"\"\"",
    "        violations: List[Violation] = []",
    "        ",
    "        # Convert expenses from dicts to Expense objects",
    "        expense_objects = [Expense.from_dict(e) for e in expenses]",
    "        ",
    "        # Check each expense against each rule",
    "        for expense in expense_objects:",
    "            for rule in rules:",
    "                violation = rule.evaluate(expense)",
    "                if violation is not None:",
    "                    violations.append(violation)",
    "        ",
    "        return violations",
    "",
    "",
    "# ============================================================================",
    "# DEMO AND TESTS",
    "# ============================================================================",
    "",
    "def print_separator(title: str) -> None:",
    "    \"\"\"Print a formatted section separator.\"\"\"",
    "    print(\"\\n\" + \"=\" * 60)",
    "    print(f\"  {title}\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "def run_demo() -> None:",
    "    \"\"\"Run demonstration of the expense rules engine.\"\"\"",
    "    print_separator(\"CORPORATE EXPENSE RULES ENGINE DEMO\")",
    "    ",
    "    # Create rules",
    "    rules: List[Rule] = [",
    "        BanRule('expense_type', 'entertainment'),",
    "        BanRule('expense_type', 'airfare'),",
    "        MaxAmountRule(Decimal('250.00')),",
    "        VendorTypeLimitRule('restaurant', Decimal('75.00'))",
    "    ]",
    "    ",
    "    print(\"\\n\ud83d\udccb Rules Configured:\")",
    "    print(\"  1. BanRule: No 'entertainment' expenses\")",
    "    print(\"  2. BanRule: No 'airfare' expenses\")",
    "    print(\"  3. MaxAmountRule: No expense over $250\")",
    "    print(\"  4. VendorTypeLimitRule: Restaurant expenses \u2264 $75\")",
    "    ",
    "    # Create expenses",
    "    expenses = [",
    "        {",
    "            'expense_id': 'E001',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '49.99',",
    "            'expense_type': 'client_hosting',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Outback Roadhouse'",
    "        },",
    "        {",
    "            'expense_id': 'E002',",
    "            'trip_id': 'T001',",
    "            'amount_usd': '350.00',",
    "            'expense_type': 'airfare',",
    "            'vendor_type': 'airline',",
    "            'vendor_name': 'Delta Airlines'",
    "        },",
    "        {",
    "            'expense_id': 'E003',",
    "            'trip_id': 'T002',",
    "            'amount_usd': '85.00',",
    "            'expense_type': 'meals',",
    "            'vendor_type': 'restaurant',",
    "            'vendor_name': 'Cheesecake Factory'",
    "        },",
    "        {",
    "            'expense_id': 'E004',",
    "            'trip_id': 'T002',",
    "            'amount_usd': '150.00',",
    "            'expense_type': 'entertainment',",
    "            'vendor_type': 'theater',",
    "            'vendor_name': 'AMC Theaters'",
    "        }",
    "    ]",
    "    ",
    "    print(\"\\n\ud83d\udcb3 Expenses Submitted:\")",
    "    for exp in expenses:",
    "        print(f\"  {exp['expense_id']}: ${exp['amount_usd']} - {exp['expense_type']} at {exp['vendor_name']}\")",
    "    ",
    "    # Evaluate rules",
    "    engine = ExpenseRulesEngine()",
    "    violations = engine.evaluate_rules(rules, expenses)",
    "    ",
    "    print(\"\\n\ud83d\udea8 Violations Found:\")",
    "    if not violations:",
    "        print(\"  None - all expenses comply with policy!\")",
    "    else:",
    "        for v in violations:",
    "            print(f\"  \u274c {v.expense_id} | {v.rule_name} | {v.reason}\")",
    "    ",
    "    # Run boundary test",
    "    print_separator(\"BOUNDARY TEST: $75.00 LIMIT\")",
    "    ",
    "    boundary_rules = [VendorTypeLimitRule('restaurant', Decimal('75.00'))]",
    "    boundary_expenses = [",
    "        {'expense_id': 'B1', 'trip_id': 'T', 'amount_usd': '74.99',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant', 'vendor_name': 'A'},",
    "        {'expense_id': 'B2', 'trip_id': 'T', 'amount_usd': '75.00',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant', 'vendor_name': 'B'},",
    "        {'expense_id': 'B3', 'trip_id': 'T', 'amount_usd': '75.01',",
    "         'expense_type': 'meals', 'vendor_type': 'restaurant', 'vendor_name': 'C'}",
    "    ]",
    "    ",
    "    boundary_violations = engine.evaluate_rules(boundary_rules, boundary_expenses)",
    "    ",
    "    print(\"\\n$75.00 limit test:\")",
    "    print(\"  B1 ($74.99): \u2713 PASS\" if 'B1' not in [v.expense_id for v in boundary_violations] else \"  B1 ($74.99): \u2717 FAIL\")",
    "    print(\"  B2 ($75.00): \u2713 PASS\" if 'B2' not in [v.expense_id for v in boundary_violations] else \"  B2 ($75.00): \u2717 FAIL\")",
    "    print(\"  B3 ($75.01): \u2717 FAIL\" if 'B3' in [v.expense_id for v in boundary_violations] else \"  B3 ($75.01): \u2713 PASS\")",
    "    ",
    "    print_separator(\"DEMO COMPLETE\")",
    "",
    "",
    "if __name__ == '__main__':",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.util.*;",
    "",
    "/**",
    " * Corporate Expense Rules Engine - Strategy Pattern Implementation",
    " * ",
    " * This implementation demonstrates clean OOP design with the Strategy Pattern",
    " * for flexible, extensible rule evaluation.",
    " */",
    "",
    "// ============================================================================",
    "// DATA CLASSES",
    "// ============================================================================",
    "",
    "/**",
    " * Represents a corporate expense record.",
    " */",
    "class Expense {",
    "    private final String expenseId;",
    "    private final String tripId;",
    "    private final BigDecimal amountUsd;",
    "    private final String expenseType;",
    "    private final String vendorType;",
    "    private final String vendorName;",
    "    ",
    "    public Expense(String expenseId, String tripId, String amountUsd,",
    "                   String expenseType, String vendorType, String vendorName) {",
    "        this.expenseId = expenseId;",
    "        this.tripId = tripId;",
    "        this.amountUsd = new BigDecimal(amountUsd);",
    "        this.expenseType = expenseType;",
    "        this.vendorType = vendorType;",
    "        this.vendorName = vendorName;",
    "    }",
    "    ",
    "    public String getExpenseId() { return expenseId; }",
    "    public String getTripId() { return tripId; }",
    "    public BigDecimal getAmountUsd() { return amountUsd; }",
    "    public String getExpenseType() { return expenseType; }",
    "    public String getVendorType() { return vendorType; }",
    "    public String getVendorName() { return vendorName; }",
    "    ",
    "    /**",
    "     * Get field value by name (for dynamic field access in BanRule).",
    "     */",
    "    public String getFieldValue(String fieldName) {",
    "        switch (fieldName) {",
    "            case \"expense_type\": return expenseType;",
    "            case \"vendor_type\": return vendorType;",
    "            case \"vendor_name\": return vendorName;",
    "            default: return null;",
    "        }",
    "    }",
    "}",
    "",
    "/**",
    " * Represents a rule violation.",
    " */",
    "class Violation {",
    "    private final String expenseId;",
    "    private final String ruleName;",
    "    private final String reason;",
    "    ",
    "    public Violation(String expenseId, String ruleName, String reason) {",
    "        this.expenseId = expenseId;",
    "        this.ruleName = ruleName;",
    "        this.reason = reason;",
    "    }",
    "    ",
    "    public String getExpenseId() { return expenseId; }",
    "    public String getRuleName() { return ruleName; }",
    "    public String getReason() { return reason; }",
    "    ",
    "    @Override",
    "    public String toString() {",
    "        return String.format(\"%s | %s | %s\", expenseId, ruleName, reason);",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// RULE INTERFACE AND IMPLEMENTATIONS",
    "// ============================================================================",
    "",
    "/**",
    " * Abstract base class for all expense validation rules.",
    " * Implements the Strategy Pattern - each rule is a validation strategy.",
    " */",
    "abstract class Rule {",
    "    /**",
    "     * Evaluate the expense against this rule.",
    "     * @param expense The expense to validate",
    "     * @return Optional containing Violation if rule is violated, empty otherwise",
    "     */",
    "    public abstract Optional<Violation> evaluate(Expense expense);",
    "    ",
    "    /**",
    "     * Get the name of this rule for violation reporting.",
    "     */",
    "    public abstract String getName();",
    "}",
    "",
    "/**",
    " * Rule that bans expenses with a specific field value.",
    " */",
    "class BanRule extends Rule {",
    "    private final String field;",
    "    private final String bannedValue;",
    "    ",
    "    public BanRule(String field, String bannedValue) {",
    "        this.field = field;",
    "        this.bannedValue = bannedValue;",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Expense expense) {",
    "        String actualValue = expense.getFieldValue(field);",
    "        if (bannedValue.equals(actualValue)) {",
    "            return Optional.of(new Violation(",
    "                expense.getExpenseId(),",
    "                getName(),",
    "                String.format(\"%s '%s' is not allowed\", field, bannedValue)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"BanRule\"; }",
    "}",
    "",
    "/**",
    " * Rule that limits the maximum amount for any single expense.",
    " */",
    "class MaxAmountRule extends Rule {",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public MaxAmountRule(BigDecimal maxAmount) {",
    "        this.maxAmount = maxAmount;",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Expense expense) {",
    "        if (expense.getAmountUsd().compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.getExpenseId(),",
    "                getName(),",
    "                String.format(\"amount $%s exceeds maximum $%s\",",
    "                    expense.getAmountUsd(), maxAmount)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"MaxAmountRule\"; }",
    "}",
    "",
    "/**",
    " * Rule that limits spending at a specific vendor type.",
    " */",
    "class VendorTypeLimitRule extends Rule {",
    "    private final String vendorType;",
    "    private final BigDecimal maxAmount;",
    "    ",
    "    public VendorTypeLimitRule(String vendorType, BigDecimal maxAmount) {",
    "        this.vendorType = vendorType;",
    "        this.maxAmount = maxAmount;",
    "    }",
    "    ",
    "    @Override",
    "    public Optional<Violation> evaluate(Expense expense) {",
    "        // Only check if vendor type matches",
    "        if (!vendorType.equals(expense.getVendorType())) {",
    "            return Optional.empty();",
    "        }",
    "        ",
    "        if (expense.getAmountUsd().compareTo(maxAmount) > 0) {",
    "            return Optional.of(new Violation(",
    "                expense.getExpenseId(),",
    "                getName(),",
    "                String.format(\"%s expense $%s exceeds limit $%s\",",
    "                    vendorType, expense.getAmountUsd(), maxAmount)",
    "            ));",
    "        }",
    "        return Optional.empty();",
    "    }",
    "    ",
    "    @Override",
    "    public String getName() { return \"VendorTypeLimitRule\"; }",
    "}",
    "",
    "// ============================================================================",
    "// RULES ENGINE",
    "// ============================================================================",
    "",
    "/**",
    " * Engine that evaluates expenses against a set of rules.",
    " */",
    "class ExpenseRulesEngine {",
    "    /**",
    "     * Evaluate all expenses against all rules.",
    "     * @param rules List of rules to apply",
    "     * @param expenses List of expenses to validate",
    "     * @return List of all violations found",
    "     */",
    "    public List<Violation> evaluateRules(List<Rule> rules, List<Expense> expenses) {",
    "        List<Violation> violations = new ArrayList<>();",
    "        ",
    "        for (Expense expense : expenses) {",
    "            for (Rule rule : rules) {",
    "                Optional<Violation> violation = rule.evaluate(expense);",
    "                violation.ifPresent(violations::add);",
    "            }",
    "        }",
    "        ",
    "        return violations;",
    "    }",
    "}",
    "",
    "// ============================================================================",
    "// DEMO",
    "// ============================================================================",
    "",
    "public class ExpenseRulesDemo {",
    "    public static void main(String[] args) {",
    "        System.out.println(\"============================================================\");",
    "        System.out.println(\"  CORPORATE EXPENSE RULES ENGINE DEMO\");",
    "        System.out.println(\"============================================================\");",
    "        ",
    "        // Create rules",
    "        List<Rule> rules = Arrays.asList(",
    "            new BanRule(\"expense_type\", \"entertainment\"),",
    "            new BanRule(\"expense_type\", \"airfare\"),",
    "            new MaxAmountRule(new BigDecimal(\"250.00\")),",
    "            new VendorTypeLimitRule(\"restaurant\", new BigDecimal(\"75.00\"))",
    "        );",
    "        ",
    "        System.out.println(\"\\nRules Configured:\");",
    "        System.out.println(\"  1. BanRule: No 'entertainment' expenses\");",
    "        System.out.println(\"  2. BanRule: No 'airfare' expenses\");",
    "        System.out.println(\"  3. MaxAmountRule: No expense over $250\");",
    "        System.out.println(\"  4. VendorTypeLimitRule: Restaurant expenses <= $75\");",
    "        ",
    "        // Create expenses",
    "        List<Expense> expenses = Arrays.asList(",
    "            new Expense(\"E001\", \"T001\", \"49.99\", \"client_hosting\", \"restaurant\", \"Outback\"),",
    "            new Expense(\"E002\", \"T001\", \"350.00\", \"airfare\", \"airline\", \"Delta\"),",
    "            new Expense(\"E003\", \"T002\", \"85.00\", \"meals\", \"restaurant\", \"Cheesecake Factory\"),",
    "            new Expense(\"E004\", \"T002\", \"150.00\", \"entertainment\", \"theater\", \"AMC\")",
    "        );",
    "        ",
    "        System.out.println(\"\\nExpenses Submitted:\");",
    "        for (Expense exp : expenses) {",
    "            System.out.printf(\"  %s: $%s - %s at %s%n\",",
    "                exp.getExpenseId(), exp.getAmountUsd(),",
    "                exp.getExpenseType(), exp.getVendorName());",
    "        }",
    "        ",
    "        // Evaluate rules",
    "        ExpenseRulesEngine engine = new ExpenseRulesEngine();",
    "        List<Violation> violations = engine.evaluateRules(rules, expenses);",
    "        ",
    "        System.out.println(\"\\nViolations Found:\");",
    "        if (violations.isEmpty()) {",
    "            System.out.println(\"  None - all expenses comply with policy!\");",
    "        } else {",
    "            for (Violation v : violations) {",
    "                System.out.println(\"  X \" + v);",
    "            }",
    "        }",
    "        ",
    "        System.out.println(\"\\n============================================================\");",
    "        System.out.println(\"  DEMO COMPLETE\");",
    "        System.out.println(\"============================================================\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-11",
      "section": "Module Docstring and Imports",
      "explanation": "We import `ABC` and `abstractmethod` for abstract base classes, `dataclass` for clean data structures, `Decimal` for precise currency math, and typing for type hints. This sets up a properly typed, production-quality module."
    },
    {
      "lines": "14-43",
      "section": "Expense Dataclass",
      "explanation": "The `Expense` class uses `@dataclass(frozen=True)` for immutability. Key feature: `amount_usd` is stored as `Decimal`, not string. The `from_dict()` factory method handles the string-to-Decimal conversion, centralizing this logic."
    },
    {
      "lines": "46-59",
      "section": "Violation Dataclass",
      "explanation": "The `Violation` class captures three key pieces: which expense failed (`expense_id`), what rule it violated (`rule_name`), and why (`reason`). Using `frozen=True` ensures violations are immutable once created."
    },
    {
      "lines": "62-83",
      "section": "Abstract Rule Base Class",
      "explanation": "This is the Strategy Pattern interface. The `@abstractmethod` decorator ensures every concrete rule implements `evaluate()` and `get_name()`. The docstrings clarify the contract: return `Violation` or `None`."
    },
    {
      "lines": "86-115",
      "section": "BanRule Implementation",
      "explanation": "The BanRule uses `getattr(expense, self.field, None)` for dynamic field access. This single class handles banning by `expense_type`, `vendor_type`, or `vendor_name` - no need for three separate classes."
    },
    {
      "lines": "118-145",
      "section": "MaxAmountRule Implementation",
      "explanation": "Simple comparison: `expense.amount_usd > self.max_amount`. Using `>` (not `>=`) means exactly-at-limit expenses PASS. The violation message includes both the actual amount and the limit for clarity."
    },
    {
      "lines": "148-183",
      "section": "VendorTypeLimitRule Implementation",
      "explanation": "This rule has TWO conditions: vendor type must match AND amount must exceed limit. Note the early return if vendor type doesn't match - this is cleaner than nested if statements."
    },
    {
      "lines": "186-217",
      "section": "ExpenseRulesEngine",
      "explanation": "The engine is deliberately simple: convert expenses, then nested loop over expenses and rules. The key insight is that we DON'T short-circuit - we check ALL rules for ALL expenses to catch multiple violations."
    },
    {
      "lines": "220-280",
      "section": "Demo and Tests",
      "explanation": "The demo creates realistic test data including an expense that violates multiple rules (E002: airfare + over $250) and boundary tests (exactly $75.00 should pass). This proves the solution handles edge cases."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. First test with single rule, single expense\n2. Add second expense that should fail\n3. Add second rule, verify both rules checked\n4. Add expense that fails multiple rules\n5. Test boundary conditions ($75.00 exactly)",
    "what_to_print_or_assert": [
      "print(f'Checking expense {expense.expense_id} against {rule.get_name()}')",
      "print(f'Amount: {expense.amount_usd}, Limit: {self.max_amount}, Exceeds: {expense.amount_usd > self.max_amount}')",
      "assert len(violations) == 3, f'Expected 3 violations, got {len(violations)}'"
    ],
    "common_failure_modes": [
      "**Forgetting to parse string amounts**: Comparing '350' > '250' as strings gives wrong result",
      "**Using float instead of Decimal**: Boundary conditions fail due to precision errors",
      "**Short-circuiting on first violation**: Missing multiple violations per expense",
      "**Wrong comparison operator**: Using >= instead of > for limit checks",
      "**Typo in field name**: 'expense_type' vs 'expenseType'"
    ],
    "how_to_fix_fast": "1. Add print statement right before the comparison that's failing\n2. Print the types: `print(type(amount), type(limit))`\n3. For boundary issues, test with exact limit value\n4. Count violations and compare to expected"
  },
  "complexity_analysis": {
    "time": {
      "evaluate_rules": {
        "complexity": "O(R \u00d7 E)",
        "explanation": "For each expense (E), we check each rule (R). Each rule evaluation is O(1)."
      },
      "individual_rule_evaluate": {
        "complexity": "O(1)",
        "explanation": "Field access, comparison, and Violation creation are all constant time"
      },
      "overall": "O(R \u00d7 E) where R = number of rules, E = number of expenses. With R \u2264 50 and E \u2264 1000, this is 50,000 operations - very fast."
    },
    "space": {
      "complexity": "O(V) where V = number of violations",
      "breakdown": "- Expense objects: O(E) - we create Expense from each dict\n- Rules storage: O(R) - passed in, not duplicated\n- Violations list: O(V) - worst case V = R \u00d7 E\n- Working memory: O(1) per rule evaluation",
      "note": "In the worst case (every expense violates every rule), V = R \u00d7 E = 50,000 violations."
    },
    "can_we_do_better": "For Part 1, O(R \u00d7 E) is optimal - we must check every expense against every rule. Part 2 (aggregation) might need additional data structures, but the core complexity remains the same."
  },
  "dry_run": {
    "example": "Rules: [BanRule(airfare), MaxAmount($250), VendorLimit(restaurant, $75)]\nExpenses: [E002: $350 airfare at airline]",
    "trace_table": "| Step | Expense | Rule | Check | Result |\n|------|---------|------|-------|--------|\n| 1 | E002 ($350, airfare, airline) | BanRule(expense_type=airfare) | 'airfare' == 'airfare'? YES | **VIOLATION** |\n| 2 | E002 ($350, airfare, airline) | MaxAmountRule($250) | $350 > $250? YES | **VIOLATION** |\n| 3 | E002 ($350, airfare, airline) | VendorTypeLimitRule(restaurant, $75) | vendor_type='airline' != 'restaurant' | PASS (not applicable) |\n\n**Final violations list: 2 violations for E002**",
    "final_answer": "[Violation(E002, BanRule, airfare not allowed), Violation(E002, MaxAmountRule, $350 exceeds $250)]"
  },
  "test_cases": [
    {
      "name": "Basic - Single expense passes all rules",
      "category": "Happy Path",
      "input": "BanRule(entertainment), MaxAmount($250), VendorLimit(restaurant, $75)\nE001: $49.99 client_hosting at restaurant",
      "expected": "[] (empty - no violations)",
      "explanation": "Not entertainment, under $250, restaurant amount under $75"
    },
    {
      "name": "Single expense violates BanRule",
      "category": "Basic Failure",
      "input": "BanRule(entertainment)\nE001: $50 entertainment at theater",
      "expected": "[Violation(E001, BanRule, entertainment not allowed)]",
      "explanation": "expense_type matches banned value"
    },
    {
      "name": "Multiple violations on single expense",
      "category": "Multiple Failures",
      "input": "BanRule(airfare), MaxAmount($250)\nE001: $350 airfare at airline",
      "expected": "2 violations: BanRule and MaxAmountRule",
      "explanation": "Expense is banned type AND exceeds max amount"
    },
    {
      "name": "Boundary: exactly at limit",
      "category": "Edge Case",
      "input": "VendorLimit(restaurant, $75)\nE001: $75.00 at restaurant",
      "expected": "[] (empty - passes)",
      "explanation": "$75.00 \u2264 $75.00 limit (limit is inclusive)"
    },
    {
      "name": "Boundary: just over limit",
      "category": "Edge Case",
      "input": "VendorLimit(restaurant, $75)\nE001: $75.01 at restaurant",
      "expected": "[Violation(E001, VendorTypeLimitRule, ...)]",
      "explanation": "$75.01 > $75.00 limit"
    },
    {
      "name": "VendorLimit doesn't apply to wrong vendor type",
      "category": "Conditional Rule",
      "input": "VendorLimit(restaurant, $75)\nE001: $500 at airline",
      "expected": "[] (empty - vendor type doesn't match)",
      "explanation": "Rule only applies to restaurant vendor type"
    },
    {
      "name": "Empty expenses list",
      "category": "Edge Case",
      "input": "BanRule(entertainment)\nNo expenses",
      "expected": "[] (empty)",
      "explanation": "No expenses to check means no violations"
    },
    {
      "name": "Empty rules list",
      "category": "Edge Case",
      "input": "No rules\nE001: $1000 gambling at casino",
      "expected": "[] (empty)",
      "explanation": "No rules means nothing can be violated"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Not parsing string amounts to numeric",
      "why_wrong": "String comparison: '9' > '10' is True (lexicographic). '$99.99' > '$100' gives wrong result.",
      "correct_approach": "Always convert to Decimal before comparison",
      "code_wrong": "if expense['amount_usd'] > self.max_amount:  # string comparison!",
      "code_correct": "if Decimal(expense['amount_usd']) > self.max_amount:  # numeric comparison"
    },
    {
      "mistake": "Using float for currency",
      "why_wrong": "0.1 + 0.1 + 0.1 = 0.30000000000000004, not 0.3. Boundary tests fail.",
      "correct_approach": "Use Decimal (Python) or BigDecimal (Java)",
      "code_wrong": "amount = float(expense['amount_usd'])",
      "code_correct": "amount = Decimal(expense['amount_usd'])"
    },
    {
      "mistake": "Short-circuiting on first violation",
      "why_wrong": "Problem states one expense can violate multiple rules. Must check ALL rules.",
      "correct_approach": "Continue iterating even after finding a violation",
      "code_wrong": "if violation:\n    violations.append(violation)\n    break  # WRONG - stops checking other rules",
      "code_correct": "if violation:\n    violations.append(violation)\n# Continue to next rule"
    },
    {
      "mistake": "Switch/case on rule type in engine",
      "why_wrong": "Violates Open/Closed Principle. Adding new rule requires modifying engine.",
      "correct_approach": "Use polymorphism - call rule.evaluate() regardless of type",
      "code_wrong": "if isinstance(rule, BanRule):\n    check_ban(expense, rule)\nelif isinstance(rule, MaxAmountRule):\n    check_max(expense, rule)",
      "code_correct": "violation = rule.evaluate(expense)  # Polymorphism handles the rest"
    },
    {
      "mistake": "Using >= instead of > for limit comparison",
      "why_wrong": "Example 3 shows $75.00 exactly should PASS a $75 limit. Using >= would fail it.",
      "correct_approach": "Use > for exceeds limit (violation occurs when amount > limit)",
      "code_wrong": "if expense.amount_usd >= self.max_amount:",
      "code_correct": "if expense.amount_usd > self.max_amount:"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things about the requirements and share my initial design thoughts.",
    "clarifying_questions_to_ask": [
      "Are amounts always valid decimal strings, or should I handle parsing errors?",
      "For the VendorTypeLimitRule, is $75.00 at the limit a pass or fail? (Clarify boundary behavior)",
      "Should violations be in any particular order, or is any order acceptable?",
      "For BanRule, should I support only exact matches, or also partial/regex matches?",
      "Can the same expense appear multiple times in the input, or are expense IDs unique?"
    ],
    "what_to_mention_proactively": [
      "I'll use the Strategy Pattern - each rule is a self-contained strategy implementing a common interface",
      "I'll use Decimal for currency to avoid floating-point precision issues",
      "The design will follow Open/Closed Principle - new rules won't require engine changes",
      "I'll check ALL rules for each expense since one expense can have multiple violations"
    ],
    "communication_during_coding": [
      "I'm creating an abstract Rule class that defines the evaluate() interface",
      "Each concrete rule will implement its own validation logic",
      "Using getattr() here lets one BanRule class handle multiple field types",
      "The engine is just a simple nested loop - the rules do all the work"
    ],
    "if_stuck": [
      "Step back: What's the core pattern here? \u2192 Strategy Pattern",
      "Think about the interface: What does every rule need to do? \u2192 Take expense, return violation or none",
      "Draw it: Sketch the class hierarchy on paper/whiteboard",
      "Start simple: Implement one rule first, get it working, then generalize"
    ],
    "time_management": "0-5min: Understand & clarify | 5-12min: Design & explain approach | 12-30min: Implement core | 30-40min: Test & edge cases | 40-45min: Discuss follow-ups"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Rules Engine",
    "indicators": [
      "Multiple algorithms/rules that need to be interchangeable",
      "Need to add new rules without modifying existing code",
      "Each rule has same interface but different implementation",
      "Open/Closed Principle mentioned in requirements"
    ],
    "similar_problems": [
      "Validation frameworks (form validation, input sanitization)",
      "Policy engines (access control, rate limiting)",
      "Filter chains (request/response filters)",
      "Payment processing (different payment method handlers)",
      "Discount engines (different discount rules)"
    ],
    "template": "```\nabstract class Strategy {\n  abstract Result execute(Input input);\n}\n\nclass ConcreteStrategyA extends Strategy {...}\nclass ConcreteStrategyB extends Strategy {...}\n\nclass Context {\n  List<Result> applyAll(List<Strategy> strategies, List<Input> inputs) {\n    for input in inputs:\n      for strategy in strategies:\n        result = strategy.execute(input)\n        if result: collect(result)\n    return collected\n  }\n}\n```"
  },
  "follow_up_preparation": {
    "part_2_hint": "Part 2 adds **Trip-Level Aggregation Rules** (e.g., 'total trip expenses cannot exceed $1000'). You'll need to:\n- Pre-aggregate expenses by trip_id before evaluation\n- Rules might need access to aggregated data, not just individual expenses\n- Consider adding a pre-processing step in the engine",
    "part_3_hint": "Part 3 adds a **Rule Creation API** - parsing rule definitions from JSON/config. You'll need:\n- Factory pattern to create rules from config\n- Validation of rule configurations\n- Possibly a RuleBuilder or RuleFactory class",
    "data_structure_evolution": "Part 1: Simple Rule interface, no aggregation needed\nPart 2: Add HashMap<trip_id, List<Expense>> for aggregation\nPart 3: Add RuleFactory, RuleConfig, validation logic"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. This looks like a classic rules engine design problem. Before I dive into implementation, I'd like to clarify a few requirements and then walk you through my design approach. Is that okay?",
    "after_clarification": "Great, so to summarize: I need to design a flexible rules engine using OOP principles, support three rule types initially, and make it easy to add new rules later. I'll use the Strategy Pattern where each rule implements a common interface. The engine will check all rules against all expenses. Sound good?",
    "while_coding": [
      "I'm starting with the data classes - Expense and Violation. Using Decimal for amounts to avoid precision issues.",
      "Now I'm creating the abstract Rule class - this is the Strategy interface. Every rule will implement evaluate().",
      "For BanRule, I'm using getattr() for dynamic field access - this lets one class handle multiple field types.",
      "The engine is intentionally simple - just a nested loop. The rules do all the complex work.",
      "Notice I'm not short-circuiting - I check ALL rules because one expense can have multiple violations."
    ],
    "after_coding": "Let me trace through this with Example 2 to verify it works. E001 is $350 airfare. BanRule checks expense_type... 'airfare' equals 'airfare', so that's a violation. MaxAmountRule checks $350 > $250, that's also a violation. VendorTypeLimitRule checks vendor_type... 'airline' doesn't equal 'restaurant', so that passes. We get two violations for E001.",
    "when_stuck_verbatim": "I'm thinking about how to handle this... Let me step back and think about what the rule needs to return. It should either return a violation or nothing, so Optional makes sense here.",
    "after_mistake": "Actually, I see an issue - I was using >= for the comparison, but the examples show that $75.00 exactly should pass a $75 limit. Let me fix that to use > instead.",
    "before_moving_on": "This handles Part 1. The time complexity is O(R \u00d7 E) where R is rules and E is expenses. Space is O(V) for violations. The design follows Open/Closed Principle - adding new rules just means creating new classes. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**Problem Decomposition**: Can you break down a complex system into clean components?",
      "**OOP Fundamentals**: Do you understand interfaces, polymorphism, encapsulation?",
      "**Design Patterns**: Do you recognize and apply Strategy Pattern appropriately?",
      "**Code Quality**: Clean naming, proper types, good structure?",
      "**Edge Case Handling**: Do you think about boundaries and special cases?",
      "**Communication**: Can you explain your thinking clearly?"
    ],
    "bonus_points": [
      "Mentioning Decimal/BigDecimal for currency without being prompted",
      "Drawing a class diagram before coding",
      "Explicitly stating you're using Strategy Pattern and why",
      "Asking about boundary behavior ($75 vs $75.00 limit)",
      "Testing with boundary values unprompted",
      "Mentioning SOLID principles by name"
    ],
    "red_flags": [
      "Using if/else or switch on rule type in the engine",
      "Using float for currency amounts",
      "Only returning first violation per expense",
      "Not asking any clarifying questions",
      "Starting to code without explaining approach",
      "Hardcoding rule logic instead of using polymorphism"
    ],
    "what_differentiates_strong_candidates": "Strong candidates immediately recognize this as a Strategy Pattern problem. They ask about boundary conditions (is $75 at limit a pass?). They use proper types (Decimal for money). They write clean, well-structured code with good naming. They test with edge cases and explain their thinking throughout. They mention extensibility and SOLID principles naturally, not as buzzwords."
  },
  "time_milestones": {
    "by_5_min": "Understood problem, asked 3-4 clarifying questions, confirmed boundary behavior",
    "by_10_min": "Explained Strategy Pattern approach, sketched class hierarchy, got interviewer buy-in",
    "by_15_min": "Expense and Violation classes done, Rule interface defined",
    "by_25_min": "All three concrete rules implemented",
    "by_30_min": "Engine implemented, basic testing started",
    "by_35_min": "Edge cases tested, complexity discussed",
    "by_40_min": "Part 1 complete, discussing design decisions and extensibility",
    "warning_signs": "If still clarifying at 10 min, or still implementing rules at 35 min, you're behind. If stuck, simplify - get one rule working first."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see an issue here - I'm comparing strings instead of Decimals. Let me fix that.' Fix it, explain briefly, move on. Bugs are expected; recovery matters.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact decorator syntax for abstract methods in Python. It's something like @abstractmethod. Let me write it and we can verify.' This is fine - concepts matter more than syntax.",
    "when_approach_is_wrong": "Say: 'Actually, I realize putting all rule logic in the engine violates Open/Closed. Let me refactor to use polymorphism.' Catching your own mistakes shows senior thinking.",
    "when_completely_stuck": "Say: 'I'm stuck on how to dynamically access fields by name. In Python, I think there's a getattr function - could you confirm?' Asking for help is better than wasting time.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me finish the core implementation and explain what I'd add for the remaining edge cases.' Prioritize working code over complete code."
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically but demonstrate YOUR understanding.",
    "what_to_do": [
      "Use AI for boilerplate (dataclass definitions, imports)",
      "Let it autocomplete obvious patterns (getters, __init__)",
      "Use for generating test data",
      "Ask for syntax you forgot"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for solution",
      "Don't accept suggestions without understanding them",
      "Don't let AI decide your architecture - YOU choose Strategy Pattern",
      "Don't use AI-generated code you can't explain"
    ],
    "how_to_demonstrate_understanding": "When AI suggests something, explain it: 'The AI suggested using getattr here, which is right because it lets us access fields dynamically by name. I could also use a switch statement, but getattr is more Pythonic.'",
    "expectation_adjustment": "With AI, you're expected to complete MORE parts and have MORE polished code. If you're slower with AI than without, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing a class hierarchy diagram before coding",
      "Saying 'I'll use Decimal for currency precision' unprompted",
      "Asking 'Is the limit inclusive or exclusive?' for boundary clarification",
      "Mentioning Open/Closed Principle by name and explaining why it matters",
      "Adding meaningful docstrings and type hints naturally",
      "Testing with $75.00 exactly to verify boundary behavior"
    ],
    "subtle_signals_of_experience": [
      "Using `@dataclass(frozen=True)` for immutability",
      "Using `Optional[Violation]` return type instead of null checks",
      "Creating a `from_dict` factory method for parsing",
      "Separating the engine from the rules cleanly",
      "Writing `if expense.vendor_type != self.vendor_type: return None` (early return pattern)"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Staying silent for more than 30 seconds without explaining your thinking",
      "Getting defensive when interviewer points out an issue",
      "Not asking any clarifying questions",
      "Rushing to code without discussing approach"
    ],
    "technical": [
      "Using if/else or switch on rule type in the engine (violates Open/Closed)",
      "Using float for currency (precision errors)",
      "Hardcoding rule logic instead of using polymorphism",
      "Only checking first rule that fails (missing multiple violations)",
      "String comparison for amounts ('350' > '100' works, but '9' > '10' doesn't)"
    ],
    "communication": [
      "Using jargon without explaining (assuming interviewer knows Strategy Pattern)",
      "Not summarizing approach before coding",
      "Forgetting to trace through an example after coding",
      "Not discussing complexity at the end"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "Did I implement all three rule types (Ban, MaxAmount, VendorTypeLimit)?",
      "Did I use Decimal/BigDecimal for currency?",
      "Does my engine check ALL rules for each expense?",
      "Did I trace through at least one example?",
      "Did I test a boundary case ($75.00 at $75 limit)?",
      "Did I mention time and space complexity?",
      "Is my code clean with good variable names?"
    ],
    "quick_code_review": [
      "No magic numbers (limits should be parameters)",
      "Consistent naming (snake_case in Python, camelCase in Java)",
      "Type hints on all methods",
      "No unused imports or variables",
      "Error messages include relevant values (actual amount, limit)"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation**: Check for missing fields, invalid amounts, null values",
      "**Logging**: Log each rule evaluation for audit trail",
      "**Metrics**: Track violation rates by rule type",
      "**Configuration**: Load rules from database or config file, not hardcoded",
      "**Caching**: If same rules applied repeatedly, consider caching compiled rules",
      "**Thread safety**: If rules engine is shared across threads",
      "**Rule versioning**: Track which version of rules approved an expense"
    ],
    "why_not_in_interview": "Interview code should focus on the core algorithm and design. Mention these verbally to show senior thinking, but don't over-engineer the solution.",
    "how_to_mention": "Say: 'In production, I'd add input validation, logging for audit purposes, and probably load rules from a database. But for this interview, I'll focus on the core logic to stay within time.'"
  },
  "generated_at": "2026-01-18T18:34:46.399256",
  "_meta": {
    "problem_id": "expense_rules_engine",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}