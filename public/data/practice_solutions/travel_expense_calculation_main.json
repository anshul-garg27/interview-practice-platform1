{
  "problem_title": "Travel Expense Calculation System",
  "difficulty": "medium",
  "category": "LLD/OOP Design",
  "estimated_time": "45-60 minutes",
  "problem_analysis": {
    "first_impressions": "This is a **classic OOP Design problem** that tests understanding of SOLID principles, design patterns, and financial calculation precision. The key challenge is designing an extensible system where adding new expense types doesn't require modifying existing code. The problem explicitly asks for Strategy Pattern (for different reimbursement calculations) and Factory Pattern (for expense creation), which are common interview expectations.",
    "pattern_recognition": "**Strategy Pattern** - Different expense types have different calculation rules (Flight: 100% up to limit, Hotel: per-night cap, Meal: 50% with daily cap, Transport: no limit). Each expense type = one strategy.\n\n**Factory Pattern** - Centralized expense object creation with ID generation.\n\n**HashMap** - O(1) lookup for employee expenses and strategy mapping.\n\n**Decimal Precision** - Financial calculations require BigDecimal/Decimal, not float.",
    "key_constraints": [
      "**Up to 1000 employees** - HashMap is appropriate, no scaling issues",
      "**Up to 500 expenses per employee** - List storage is fine, O(n) iteration acceptable",
      "**Amount range $0.01 to $100,000** - Must handle small decimals AND large values precisely",
      "**2 decimal place precision** - MUST use Decimal/BigDecimal with HALF_UP rounding",
      "**Policy limits are fixed** - Flight $1000, Hotel $200/night, Meal $50/day at 50%"
    ],
    "clarifying_questions": [
      "**For hotel expenses, is the `amount` parameter per-night or total?** - Critical for correct calculation. Based on examples, amount appears to be per-night.",
      "**For meal expenses, is `amount` per-day or total?** - Need clarification. Formula suggests amount/days gives per-day rate.",
      "**Should expense IDs be globally unique or per-employee unique?** - Examples show `exp_1`, `exp_2` pattern, appears global.",
      "**What should happen for invalid expense types?** - Problem says throw exception.",
      "**Are there concurrent access requirements?** - Not mentioned, assume single-threaded for interview.",
      "**Should we support expense deletion or modification?** - Not in requirements, so no.",
      "**What timezone for dates?** - Not critical for Part 1, dates are just stored as strings."
    ],
    "edge_cases_to_consider": [
      "**Employee with no expenses** - Should return $0.00 reimbursement",
      "**Minimum expense amount** - $0.01 with rounding (e.g., $0.01 meal at 50% = $0.005 \u2192 $0.01)",
      "**Flight exactly at limit** - $1000 flight should reimburse $1000",
      "**Flight over limit** - $1500 flight caps at $1000",
      "**Hotel at exactly $200/night** - Should reimburse full amount",
      "**Hotel over nightly cap** - $300/night \u00d7 3 nights = $600 reimbursed (not $900)",
      "**Meal with 1 day** - Simpler case, just apply 50% and $50 cap",
      "**Invalid expense type** - Should throw ValueError/IllegalArgumentException"
    ]
  },
  "requirements_coverage": {
    "checklist": [
      {
        "requirement": "ExpenseManager() - Initialize system with default policies",
        "how_met": "Constructor initializes empty employee map and pre-registers all strategies",
        "gotchas": [
          "Must eagerly create strategies, not lazily"
        ]
      },
      {
        "requirement": "addExpense() - Add expense and return ID",
        "how_met": "ExpenseFactory creates Expense with auto-incremented ID, stores in employee's list",
        "gotchas": [
          "Validate expense type before creating",
          "ID must be unique across all employees"
        ]
      },
      {
        "requirement": "calculateReimbursement() - Apply policies and return total",
        "how_met": "Iterate expenses, apply correct strategy per type, sum with Decimal precision, round to 2 places",
        "gotchas": [
          "Must round final result, not intermediate steps",
          "Empty employee returns 0.0"
        ]
      },
      {
        "requirement": "getExpensesByType() - Filter expenses",
        "how_met": "Filter employee's expense list by matching ExpenseType enum",
        "gotchas": [
          "Return empty list if no matches, not None/null"
        ]
      },
      {
        "requirement": "getTotalExpenses() - Raw total before policy",
        "how_met": "Sum all expense.amount values without policy application",
        "gotchas": [
          "This is raw amount, not multiplied by nights/days"
        ]
      }
    ],
    "complexity_targets": [
      {
        "operation": "addExpense",
        "target": "O(1)",
        "achieved": "O(1)",
        "why": "HashMap insertion + list append"
      },
      {
        "operation": "calculateReimbursement",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Must iterate all expenses for employee"
      },
      {
        "operation": "getExpensesByType",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Filter requires examining all expenses"
      },
      {
        "operation": "getTotalExpenses",
        "target": "O(n)",
        "achieved": "O(n)",
        "why": "Sum requires examining all expenses"
      }
    ],
    "non_goals": [
      "Expense modification or deletion",
      "Multi-currency support (Part 2)",
      "Location-based per-diems (Part 3)",
      "Persistence/database storage",
      "Authentication/authorization",
      "Concurrent access handling"
    ]
  },
  "assumptions": [
    "**Hotel `amount` is per-night cost** - If $180 amount with 2 nights, that's $180/night \u00d7 2 = $360 submitted",
    "**Meal `amount` is total for all days** - If $75 amount with 2 days, that's $37.50/day",
    "**Expense IDs are globally sequential** - `exp_1`, `exp_2`, etc. across all employees",
    "**Dates are stored as strings** - No date validation or calculations needed for Part 1",
    "**Single-threaded access** - No synchronization needed",
    "**All amounts are in USD** - No currency conversion"
  ],
  "tradeoffs": [
    {
      "decision": "Store all expenses vs compute running totals",
      "chosen": "Store all expenses",
      "why": "Need getExpensesByType() and can add new policies later",
      "alternative": "Only store running totals",
      "when_to_switch": "Never for this problem since we need expense filtering"
    },
    {
      "decision": "Enum vs String for expense types",
      "chosen": "Enum (ExpenseType)",
      "why": "Type safety, IDE autocompletion, prevents typos",
      "alternative": "String constants",
      "when_to_switch": "If types need to be dynamically defined at runtime"
    },
    {
      "decision": "Strategy per type vs giant if-else",
      "chosen": "Strategy pattern",
      "why": "Open/Closed principle - add new types without modifying existing code",
      "alternative": "if-else chain",
      "when_to_switch": "Never - this is explicitly required"
    },
    {
      "decision": "List vs TreeSet for expenses",
      "chosen": "List (ArrayList)",
      "why": "Simple, maintains insertion order, no ordering needed",
      "alternative": "TreeSet by date",
      "when_to_switch": "If we need date-range queries (Part 2/3 might need this)"
    }
  ],
  "extensibility_and_followups": {
    "design_principles": [
      "**Single Responsibility** - Expense stores data, Strategy calculates, Manager orchestrates",
      "**Open/Closed** - Add new expense types by adding Strategy, not modifying existing code",
      "**Dependency Inversion** - Manager depends on ReimbursementStrategy interface, not concrete strategies",
      "**Encapsulation** - All fields private, exposed only through methods"
    ],
    "why_this_design_scales": "The Strategy pattern makes it trivial to add new expense types (Part 2 multi-currency is just a new field and strategy modification). The clean separation means currency conversion could be a decorator or separate service. Part 3 location-based per-diems would be a strategy modification with location lookup.",
    "expected_followup_hooks": [
      "**ReimbursementStrategy.calculate()** - Will need currency parameter for Part 2",
      "**Expense class** - May need currency field for Part 2, location for Part 3",
      "**Policy limits** - May become configurable rather than hardcoded",
      "**ExpenseManager** - May need getExpensesByDateRange() method"
    ],
    "invariants": [
      "Expense.id is immutable and globally unique",
      "Expense.amount is always positive (Decimal > 0)",
      "calculateReimbursement() always returns value \u2265 0",
      "getTotalExpenses() always returns value \u2265 0"
    ]
  },
  "visual_explanation": {
    "problem_visualization": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  TRAVEL EXPENSE SYSTEM OVERVIEW                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                      \u2502\n\u2502   EMPLOYEE SUBMITS EXPENSES:                                         \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502   \u2502   FLIGHT     \u2502 \u2502    HOTEL     \u2502 \u2502    MEAL      \u2502 \u2502 TRANSPORT  \u2502 \u2502\n\u2502   \u2502   $450       \u2502 \u2502 $180/night   \u2502 \u2502   $75/2days  \u2502 \u2502    $45     \u2502 \u2502\n\u2502   \u2502   100% limit \u2502 \u2502 $200/n cap   \u2502 \u2502 50%, $50/d   \u2502 \u2502   100%     \u2502 \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502          \u2502                \u2502                \u2502               \u2502         \u2502\n\u2502          \u25bc                \u25bc                \u25bc               \u25bc         \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502                  STRATEGY PATTERN                            \u2502   \u2502\n\u2502   \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502   \u2502\n\u2502   \u2502  \u2502         ReimbursementStrategy (Interface)               \u2502\u2502   \u2502\n\u2502   \u2502  \u2502              + calculate(expense): Decimal              \u2502\u2502   \u2502\n\u2502   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502   \u2502\n\u2502   \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502   \u2502\n\u2502   \u2502              \u25bc            \u25bc            \u25bc           \u25bc        \u2502   \u2502\n\u2502   \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502   \u2502  \u2502   Flight    \u2502 \u2502   Hotel     \u2502 \u2502  Meal    \u2502 \u2502Transport \u2502  \u2502   \u2502\n\u2502   \u2502  \u2502  Strategy   \u2502 \u2502  Strategy   \u2502 \u2502 Strategy \u2502 \u2502 Strategy \u2502  \u2502   \u2502\n\u2502   \u2502  \u2502 min($,1000) \u2502 \u2502min($,200)*n \u2502 \u250250%,cap$50\u2502 \u2502  100%    \u2502  \u2502   \u2502\n\u2502   \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                               \u2502                                      \u2502\n\u2502                               \u25bc                                      \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502  TOTAL REIMBURSEMENT: $450 + $360 + $50 + $45 = $905.00     \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "data_structure_state": "```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DATA STRUCTURE STATE                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                      \u2502\n\u2502  ExpenseManager._employee_expenses: Dict[str, List[Expense]]         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  \"emp001\" \u2192 [                                                   \u2502 \u2502\n\u2502  \u2502      Expense(id=\"exp_1\", type=FLIGHT, amount=450, ...)         \u2502 \u2502\n\u2502  \u2502      Expense(id=\"exp_2\", type=HOTEL, amount=180, nights=2...)  \u2502 \u2502\n\u2502  \u2502      Expense(id=\"exp_3\", type=MEAL, amount=75, days=2...)      \u2502 \u2502\n\u2502  \u2502  ]                                                              \u2502 \u2502\n\u2502  \u2502  \"emp002\" \u2192 [                                                   \u2502 \u2502\n\u2502  \u2502      Expense(id=\"exp_4\", type=TRANSPORT, amount=89.50, ...)    \u2502 \u2502\n\u2502  \u2502  ]                                                              \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                      \u2502\n\u2502  ExpenseManager._strategies: Dict[ExpenseType, Strategy]             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  FLIGHT    \u2192 FlightReimbursementStrategy()                      \u2502 \u2502\n\u2502  \u2502  HOTEL     \u2192 HotelReimbursementStrategy()                       \u2502 \u2502\n\u2502  \u2502  MEAL      \u2192 MealReimbursementStrategy()                        \u2502 \u2502\n\u2502  \u2502  TRANSPORT \u2192 TransportReimbursementStrategy()                   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502                                                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```",
    "algorithm_flow": [
      {
        "step": 1,
        "description": "ExpenseManager initialized",
        "visualization": "strategies: {FLIGHT\u2192FlightStrategy, HOTEL\u2192HotelStrategy, ...}\nemployees: {}",
        "key_point": "Strategies pre-registered in constructor"
      },
      {
        "step": 2,
        "description": "addExpense called",
        "visualization": "Factory creates Expense with ID 'exp_1'\nemployees[\"emp001\"] = [Expense(exp_1, FLIGHT, $450)]",
        "key_point": "Factory handles ID generation, Manager stores"
      },
      {
        "step": 3,
        "description": "calculateReimbursement called",
        "visualization": "for expense in employees[\"emp001\"]:\n  strategy = strategies[expense.type]\n  total += strategy.calculate(expense)\nreturn round(total, 2)",
        "key_point": "Each expense uses its type's strategy"
      }
    ],
    "dry_run_table": "| Step | Operation | Employee Map State | Strategies Used | Running Total | Result |\n|------|-----------|-------------------|-----------------|---------------|--------|\n| 1 | ExpenseManager() | {} | All 4 registered | - | - |\n| 2 | addExpense(emp001, FLIGHT, 450, ...) | {emp001: [exp_1]} | - | - | \"exp_1\" |\n| 3 | addExpense(emp001, HOTEL, 180, {nights:2}) | {emp001: [exp_1, exp_2]} | - | - | \"exp_2\" |\n| 4 | addExpense(emp001, MEAL, 75, {days:2}) | {emp001: [exp_1, exp_2, exp_3]} | - | - | \"exp_3\" |\n| 5 | calculateReimbursement(emp001) | - | FLIGHT: min(450,1000)=450 | $450 | - |\n| 5 | (continued) | - | HOTEL: min(180,200)*2=360 | $810 | - |\n| 5 | (continued) | - | MEAL: min(37.5*0.5,50)*2=37.50 | $847.50 | $847.50 |\n| 6 | getTotalExpenses(emp001) | - | - | - | $705.00 |"
  },
  "thinking_process": {
    "step_by_step": [
      "**When I see 'different calculation rules per type'**, I immediately think Strategy Pattern - each expense type is a concrete strategy",
      "**When I see 'O(1) lookup for strategies'**, I know to use a HashMap with ExpenseType enum as key",
      "**When I see 'financial calculations'**, I MUST use Decimal/BigDecimal - never float for money",
      "**When I see 'extensible for new expense types'**, I confirm Strategy Pattern - just add a new strategy class",
      "**The key insight is** separating WHAT to calculate (strategy) from WHEN to calculate (manager orchestration)",
      "**I should use Factory** because expense creation has ID generation logic that shouldn't be in Manager"
    ],
    "key_insight": "The core realization is that reimbursement calculation is the **varying behavior**, not the expense data itself. By encapsulating each calculation formula in its own strategy class, we achieve the Open/Closed Principle - the system is open for extension (new expense types) but closed for modification (existing strategies don't change).",
    "why_this_works": "**Strategy Pattern** allows polymorphic behavior - the Manager doesn't need to know HOW each expense is calculated, just that it CAN be calculated. The Map<ExpenseType, Strategy> provides O(1) dispatch to the correct algorithm. **Factory Pattern** centralizes object creation, making ID generation consistent and testable. **Decimal precision** ensures $0.1 + $0.1 + $0.1 = $0.3 exactly, not 0.30000000000000004."
  },
  "approaches": [
    {
      "name": "Brute Force: Giant If-Else Chain",
      "description": "Put all calculation logic in a single method with if-else for each expense type",
      "pseudocode": "def calculate_reimbursement(employee_id):\n    total = 0\n    for expense in expenses[employee_id]:\n        if expense.type == 'FLIGHT':\n            total += min(expense.amount, 1000)\n        elif expense.type == 'HOTEL':\n            total += min(expense.amount, 200) * nights\n        elif expense.type == 'MEAL':\n            # complex calculation\n        # ... more types\n    return total",
      "time_complexity": "O(n) per call",
      "space_complexity": "O(n) for storing expenses",
      "pros": [
        "Quick to implement",
        "All logic in one place"
      ],
      "cons": [
        "Violates Open/Closed Principle",
        "Adding new type requires modifying existing code",
        "Hard to test individual calculations",
        "Method grows unboundedly"
      ],
      "when_to_use": "Never in interviews - this is what they're testing you NOT to do"
    },
    {
      "name": "Optimal: Strategy Pattern with Factory",
      "description": "Each expense type has its own strategy class implementing a common interface. Factory creates expenses with proper IDs.",
      "pseudocode": "class ReimbursementStrategy:\n    def calculate(expense) -> Decimal: abstract\n\nclass FlightStrategy(ReimbursementStrategy):\n    def calculate(expense):\n        return min(expense.amount, Decimal('1000'))\n\nclass ExpenseManager:\n    strategies = {FLIGHT: FlightStrategy(), ...}\n    \n    def calculate_reimbursement(employee_id):\n        return sum(strategies[e.type].calculate(e)\n                   for e in expenses[employee_id])",
      "time_complexity": "O(n) for calculateReimbursement",
      "space_complexity": "O(n) for expenses + O(1) for strategies",
      "pros": [
        "Open/Closed Principle - add types without modifying existing code",
        "Single Responsibility - each strategy does one thing",
        "Testable - test each strategy in isolation",
        "Maintainable - clear separation of concerns"
      ],
      "cons": [
        "More classes to write initially",
        "Slightly more complex structure"
      ],
      "key_insight": "The extra initial complexity pays off immediately in maintainability and testability"
    }
  ],
  "optimal_solution": {
    "name": "Strategy Pattern with Factory and Decimal Precision",
    "explanation_md": "## Approach\n\nThe solution uses a **Strategy Pattern** where each expense type (Flight, Hotel, Meal, Transport) has its own calculation strategy implementing a common interface. This satisfies the **Open/Closed Principle** - we can add new expense types by creating new strategy classes without modifying existing code.\n\n### Key Design Decisions\n\n1. **`ReimbursementStrategy` Interface** - Defines the contract for all calculation strategies\n2. **Concrete Strategies** - Each implements the specific reimbursement formula\n3. **`ExpenseFactory`** - Centralizes expense creation with auto-incrementing IDs\n4. **`ExpenseManager`** - Orchestrates operations, doesn't know calculation details\n5. **`Decimal` for Precision** - Avoids floating-point errors in financial calculations\n\n### Why This Works\n\n- **Polymorphism**: The manager calls `strategy.calculate()` without knowing which strategy it is\n- **HashMap dispatch**: O(1) lookup from ExpenseType to correct Strategy\n- **Separation of concerns**: Data storage vs. calculation logic are completely separate",
    "data_structures": [
      {
        "structure": "Dict[str, List[Expense]] (employee_expenses)",
        "purpose": "O(1) employee lookup, list of their expenses"
      },
      {
        "structure": "Dict[ExpenseType, ReimbursementStrategy] (strategies)",
        "purpose": "O(1) strategy lookup by expense type"
      },
      {
        "structure": "Expense dataclass",
        "purpose": "Immutable expense data container"
      },
      {
        "structure": "ExpenseType enum",
        "purpose": "Type-safe expense type representation"
      }
    ],
    "algorithm_steps": [
      "1. **Initialize**: Create strategy instances for each expense type, store in HashMap",
      "2. **addExpense**: Use Factory to create Expense with unique ID, append to employee's list",
      "3. **calculateReimbursement**: For each expense, get strategy by type, calculate, sum results",
      "4. **Round final result**: Use ROUND_HALF_UP to 2 decimal places",
      "5. **getExpensesByType**: Filter employee's expenses by matching type",
      "6. **getTotalExpenses**: Sum raw amounts (no policy application)"
    ],
    "why_decimal": "**Float precision problem**: `0.1 + 0.1 + 0.1 = 0.30000000000000004` in floating point. For financial calculations, even small errors compound and cause audit issues. `Decimal('0.1') + Decimal('0.1') + Decimal('0.1') = Decimal('0.3')` exactly."
  },
  "solution_python_lines": [
    "\"\"\"",
    "Travel Expense Calculation System",
    "",
    "A clean OOP implementation using Strategy and Factory patterns",
    "for calculating employee expense reimbursements.",
    "\"\"\"",
    "",
    "from abc import ABC, abstractmethod",
    "from dataclasses import dataclass, field",
    "from decimal import Decimal, ROUND_HALF_UP",
    "from enum import Enum",
    "from typing import Dict, List, Any, Optional",
    "",
    "",
    "# =============================================================================",
    "# EXPENSE TYPE ENUM",
    "# =============================================================================",
    "",
    "class ExpenseType(Enum):",
    "    \"\"\"Enumeration of supported expense types.\"\"\"",
    "    FLIGHT = \"FLIGHT\"",
    "    HOTEL = \"HOTEL\"",
    "    MEAL = \"MEAL\"",
    "    TRANSPORT = \"TRANSPORT\"",
    "",
    "",
    "# =============================================================================",
    "# EXPENSE DATA CLASS",
    "# =============================================================================",
    "",
    "@dataclass(frozen=True)",
    "class Expense:",
    "    \"\"\"",
    "    Immutable expense record.",
    "    ",
    "    Attributes:",
    "        id: Unique expense identifier",
    "        expense_type: Category of expense (FLIGHT, HOTEL, etc.)",
    "        amount: Raw expense amount in USD (Decimal for precision)",
    "        date: Date of expense (YYYY-MM-DD format)",
    "        details: Additional info (nights for hotel, days for meal)",
    "        employee_id: ID of employee who submitted expense",
    "    \"\"\"",
    "    id: str",
    "    expense_type: ExpenseType",
    "    amount: Decimal",
    "    date: str",
    "    details: Dict[str, Any]",
    "    employee_id: str",
    "",
    "",
    "# =============================================================================",
    "# REIMBURSEMENT STRATEGIES (Strategy Pattern)",
    "# =============================================================================",
    "",
    "class ReimbursementStrategy(ABC):",
    "    \"\"\"",
    "    Abstract base class for reimbursement calculation strategies.",
    "    ",
    "    Each expense type implements its own calculation logic.",
    "    This follows the Open/Closed Principle - new expense types",
    "    can be added without modifying existing code.",
    "    \"\"\"",
    "    ",
    "    @abstractmethod",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        \"\"\"",
    "        Calculate reimbursement amount for an expense.",
    "        ",
    "        Args:",
    "            expense: The expense to calculate reimbursement for",
    "            ",
    "        Returns:",
    "            Decimal: Reimbursement amount (not yet rounded)",
    "        \"\"\"",
    "        pass",
    "",
    "",
    "class FlightReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Flight expenses: 100% reimbursed up to $1000 policy limit.",
    "    ",
    "    Example:",
    "        $500 flight \u2192 $500 reimbursed",
    "        $1500 flight \u2192 $1000 reimbursed (capped)",
    "    \"\"\"",
    "    POLICY_LIMIT = Decimal('1000')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return min(expense.amount, self.POLICY_LIMIT)",
    "",
    "",
    "class HotelReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Hotel expenses: 100% reimbursed up to $200 per night.",
    "    ",
    "    The 'amount' parameter is the per-night cost.",
    "    ",
    "    Example:",
    "        $180/night \u00d7 2 nights \u2192 $360 reimbursed",
    "        $250/night \u00d7 3 nights \u2192 $600 reimbursed (capped at $200/night)",
    "    \"\"\"",
    "    NIGHTLY_CAP = Decimal('200')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        nights = Decimal(str(expense.details.get('nights', 1)))",
    "        capped_per_night = min(expense.amount, self.NIGHTLY_CAP)",
    "        return capped_per_night * nights",
    "",
    "",
    "class MealReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Meal expenses: 50% reimbursed, capped at $50 per day.",
    "    ",
    "    The 'amount' parameter is the total for all days.",
    "    Formula: min(amount_per_day \u00d7 50%, $50) \u00d7 days",
    "    ",
    "    Example:",
    "        $80 total for 2 days = $40/day \u2192 50% = $20/day \u2192 \u00d72 = $40",
    "        $200 total for 2 days = $100/day \u2192 50% = $50/day (capped) \u2192 \u00d72 = $100",
    "    \"\"\"",
    "    DAILY_CAP = Decimal('50')",
    "    REIMBURSEMENT_RATE = Decimal('0.5')",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        days = Decimal(str(expense.details.get('days', 1)))",
    "        per_day = expense.amount / days",
    "        reimbursable_per_day = per_day * self.REIMBURSEMENT_RATE",
    "        capped_per_day = min(reimbursable_per_day, self.DAILY_CAP)",
    "        return capped_per_day * days",
    "",
    "",
    "class TransportReimbursementStrategy(ReimbursementStrategy):",
    "    \"\"\"",
    "    Transport expenses: 100% reimbursed with no limit.",
    "    ",
    "    Example:",
    "        $89.50 transport \u2192 $89.50 reimbursed",
    "    \"\"\"",
    "    ",
    "    def calculate(self, expense: Expense) -> Decimal:",
    "        return expense.amount",
    "",
    "",
    "# =============================================================================",
    "# EXPENSE FACTORY (Factory Pattern)",
    "# =============================================================================",
    "",
    "class ExpenseFactory:",
    "    \"\"\"",
    "    Factory for creating Expense objects with auto-generated IDs.",
    "    ",
    "    Centralizes expense creation logic and ID generation.",
    "    \"\"\"",
    "    _counter: int = 0",
    "    ",
    "    @classmethod",
    "    def reset_counter(cls) -> None:",
    "        \"\"\"Reset ID counter (useful for testing).\"\"\"",
    "        cls._counter = 0",
    "    ",
    "    @classmethod",
    "    def create(",
    "        cls,",
    "        employee_id: str,",
    "        expense_type: str,",
    "        amount: float,",
    "        date: str,",
    "        details: Dict[str, Any]",
    "    ) -> Expense:",
    "        \"\"\"",
    "        Create a new Expense with auto-generated ID.",
    "        ",
    "        Args:",
    "            employee_id: ID of employee submitting expense",
    "            expense_type: Type string (FLIGHT, HOTEL, MEAL, TRANSPORT)",
    "            amount: Expense amount in USD",
    "            date: Date string (YYYY-MM-DD)",
    "            details: Additional details (nights, days, etc.)",
    "            ",
    "        Returns:",
    "            Expense: New expense object with unique ID",
    "            ",
    "        Raises:",
    "            ValueError: If expense_type is not valid",
    "        \"\"\"",
    "        # Validate expense type",
    "        try:",
    "            exp_type = ExpenseType(expense_type.upper())",
    "        except ValueError:",
    "            raise ValueError(",
    "                f\"Invalid expense type: {expense_type}. \"",
    "                f\"Valid types: {[e.value for e in ExpenseType]}\"",
    "            )",
    "        ",
    "        # Generate unique ID",
    "        cls._counter += 1",
    "        expense_id = f\"exp_{cls._counter}\"",
    "        ",
    "        return Expense(",
    "            id=expense_id,",
    "            expense_type=exp_type,",
    "            amount=Decimal(str(amount)),",
    "            date=date,",
    "            details=details or {},",
    "            employee_id=employee_id",
    "        )",
    "",
    "",
    "# =============================================================================",
    "# EXPENSE MANAGER (Main Service)",
    "# =============================================================================",
    "",
    "class ExpenseManager:",
    "    \"\"\"",
    "    Main expense management system.",
    "    ",
    "    Coordinates expense storage and reimbursement calculations",
    "    using Strategy pattern for flexible policy application.",
    "    ",
    "    Example:",
    "        >>> manager = ExpenseManager()",
    "        >>> manager.add_expense(\"emp001\", \"FLIGHT\", 450.0, \"2024-03-15\", {})",
    "        'exp_1'",
    "        >>> manager.calculate_reimbursement(\"emp001\")",
    "        450.0",
    "    \"\"\"",
    "    ",
    "    def __init__(self) -> None:",
    "        \"\"\"Initialize expense manager with default policies.\"\"\"",
    "        # Storage: employee_id -> list of expenses",
    "        self._employee_expenses: Dict[str, List[Expense]] = {}",
    "        ",
    "        # Strategy registry: expense_type -> calculation strategy",
    "        self._strategies: Dict[ExpenseType, ReimbursementStrategy] = {",
    "            ExpenseType.FLIGHT: FlightReimbursementStrategy(),",
    "            ExpenseType.HOTEL: HotelReimbursementStrategy(),",
    "            ExpenseType.MEAL: MealReimbursementStrategy(),",
    "            ExpenseType.TRANSPORT: TransportReimbursementStrategy(),",
    "        }",
    "    ",
    "    def add_expense(",
    "        self,",
    "        employee_id: str,",
    "        expense_type: str,",
    "        amount: float,",
    "        date: str,",
    "        details: Dict[str, Any]",
    "    ) -> str:",
    "        \"\"\"",
    "        Add an expense for an employee.",
    "        ",
    "        Args:",
    "            employee_id: Unique employee identifier",
    "            expense_type: FLIGHT, HOTEL, MEAL, or TRANSPORT",
    "            amount: Expense amount in USD",
    "            date: Date of expense (YYYY-MM-DD)",
    "            details: Additional info (e.g., {'nights': 2} for hotel)",
    "            ",
    "        Returns:",
    "            str: Unique expense ID",
    "            ",
    "        Raises:",
    "            ValueError: If expense_type is invalid",
    "        \"\"\"",
    "        # Validate amount",
    "        if amount <= 0:",
    "            raise ValueError(f\"Amount must be positive: {amount}\")",
    "        ",
    "        # Create expense using factory",
    "        expense = ExpenseFactory.create(",
    "            employee_id=employee_id,",
    "            expense_type=expense_type,",
    "            amount=amount,",
    "            date=date,",
    "            details=details",
    "        )",
    "        ",
    "        # Initialize employee's expense list if needed",
    "        if employee_id not in self._employee_expenses:",
    "            self._employee_expenses[employee_id] = []",
    "        ",
    "        # Store expense",
    "        self._employee_expenses[employee_id].append(expense)",
    "        ",
    "        return expense.id",
    "    ",
    "    def calculate_reimbursement(self, employee_id: str) -> float:",
    "        \"\"\"",
    "        Calculate total reimbursable amount for an employee.",
    "        ",
    "        Applies company policies to each expense type:",
    "        - Flight: 100% up to $1000",
    "        - Hotel: 100% up to $200/night",
    "        - Meal: 50% up to $50/day",
    "        - Transport: 100%, no limit",
    "        ",
    "        Args:",
    "            employee_id: Employee to calculate reimbursement for",
    "            ",
    "        Returns:",
    "            float: Total reimbursement rounded to 2 decimal places",
    "        \"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        ",
    "        if not expenses:",
    "            return 0.0",
    "        ",
    "        total = Decimal('0')",
    "        ",
    "        for expense in expenses:",
    "            strategy = self._strategies[expense.expense_type]",
    "            reimbursement = strategy.calculate(expense)",
    "            total += reimbursement",
    "        ",
    "        # Round to 2 decimal places using HALF_UP",
    "        rounded = total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)",
    "        return float(rounded)",
    "    ",
    "    def get_expenses_by_type(",
    "        self,",
    "        employee_id: str,",
    "        expense_type: str",
    "    ) -> List[Expense]:",
    "        \"\"\"",
    "        Get all expenses of a specific type for an employee.",
    "        ",
    "        Args:",
    "            employee_id: Employee identifier",
    "            expense_type: Type to filter by",
    "            ",
    "        Returns:",
    "            List[Expense]: Matching expenses (empty list if none)",
    "        \"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        target_type = ExpenseType(expense_type.upper())",
    "        ",
    "        return [e for e in expenses if e.expense_type == target_type]",
    "    ",
    "    def get_total_expenses(self, employee_id: str) -> float:",
    "        \"\"\"",
    "        Get total raw expense amount before policy application.",
    "        ",
    "        Args:",
    "            employee_id: Employee identifier",
    "            ",
    "        Returns:",
    "            float: Sum of all expense amounts",
    "        \"\"\"",
    "        expenses = self._employee_expenses.get(employee_id, [])",
    "        ",
    "        if not expenses:",
    "            return 0.0",
    "        ",
    "        total = sum((e.amount for e in expenses), Decimal('0'))",
    "        rounded = total.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)",
    "        return float(rounded)",
    "",
    "",
    "# =============================================================================",
    "# DEMO AND TESTING",
    "# =============================================================================",
    "",
    "def run_demo() -> None:",
    "    \"\"\"Demonstrate the expense management system.\"\"\"",
    "    print(\"=\" * 60)",
    "    print(\"TRAVEL EXPENSE CALCULATION SYSTEM - DEMO\")",
    "    print(\"=\" * 60)",
    "    print()",
    "    ",
    "    # Reset factory counter for clean demo",
    "    ExpenseFactory.reset_counter()",
    "    ",
    "    # Initialize manager",
    "    manager = ExpenseManager()",
    "    print(\"\u2713 ExpenseManager initialized\")",
    "    print()",
    "    ",
    "    # Example 1: Basic multi-type expenses",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 1: Multi-Type Expenses for emp001\")",
    "    print(\"-\" * 40)",
    "    ",
    "    # Add expenses",
    "    exp1 = manager.add_expense(\"emp001\", \"FLIGHT\", 450.0, \"2024-03-15\", {})",
    "    print(f\"  Added FLIGHT $450.00 \u2192 ID: {exp1}\")",
    "    ",
    "    exp2 = manager.add_expense(\"emp001\", \"HOTEL\", 180.0, \"2024-03-15\", {\"nights\": 2})",
    "    print(f\"  Added HOTEL $180.00/night \u00d7 2 nights \u2192 ID: {exp2}\")",
    "    ",
    "    exp3 = manager.add_expense(\"emp001\", \"MEAL\", 75.0, \"2024-03-15\", {\"days\": 2})",
    "    print(f\"  Added MEAL $75.00 for 2 days \u2192 ID: {exp3}\")",
    "    ",
    "    exp4 = manager.add_expense(\"emp001\", \"TRANSPORT\", 45.0, \"2024-03-15\", {})",
    "    print(f\"  Added TRANSPORT $45.00 \u2192 ID: {exp4}\")",
    "    print()",
    "    ",
    "    # Calculate reimbursement",
    "    reimbursement = manager.calculate_reimbursement(\"emp001\")",
    "    total_raw = manager.get_total_expenses(\"emp001\")",
    "    ",
    "    print(\"  REIMBURSEMENT BREAKDOWN:\")",
    "    print(\"  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\")",
    "    print(\"  \u2502 Type         \u2502 Submitted  \u2502 Policy         \u2502 Reimbursed   \u2502\")",
    "    print(\"  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\")",
    "    print(\"  \u2502 Flight       \u2502 $450.00    \u2502 100%, \u2264$1000   \u2502 $450.00      \u2502\")",
    "    print(\"  \u2502 Hotel (2n)   \u2502 $360.00    \u2502 \u2264$200/night    \u2502 $360.00      \u2502\")",
    "    print(\"  \u2502 Meal (2d)    \u2502 $75.00     \u2502 50%, \u2264$50/d    \u2502 $37.50       \u2502\")",
    "    print(\"  \u2502 Transport    \u2502 $45.00     \u2502 100%           \u2502 $45.00       \u2502\")",
    "    print(\"  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\")",
    "    print(f\"  \u2502 TOTAL        \u2502 ${total_raw:,.2f}   \u2502                \u2502 ${reimbursement:,.2f}     \u2502\")",
    "    print(\"  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\")",
    "    print()",
    "    ",
    "    # Example 2: Policy caps",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 2: Policy Caps Applied for emp002\")",
    "    print(\"-\" * 40)",
    "    ",
    "    exp5 = manager.add_expense(\"emp002\", \"HOTEL\", 350.0, \"2024-03-20\", {\"nights\": 3})",
    "    print(f\"  Added HOTEL $350.00/night \u00d7 3 nights \u2192 ID: {exp5}\")",
    "    print(\"    \u2192 Per night cap: min($350, $200) = $200\")",
    "    print(\"    \u2192 Reimbursement: $200 \u00d7 3 = $600\")",
    "    ",
    "    exp6 = manager.add_expense(\"emp002\", \"FLIGHT\", 1500.0, \"2024-03-20\", {})",
    "    print(f\"  Added FLIGHT $1500.00 \u2192 ID: {exp6}\")",
    "    print(\"    \u2192 Policy limit: min($1500, $1000) = $1000\")",
    "    ",
    "    reimbursement2 = manager.calculate_reimbursement(\"emp002\")",
    "    print(f\"  \u2192 Total Reimbursement: ${reimbursement2:,.2f}\")",
    "    print()",
    "    ",
    "    # Example 3: Filter by type",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 3: Filter Expenses by Type\")",
    "    print(\"-\" * 40)",
    "    ",
    "    manager.add_expense(\"emp003\", \"TRANSPORT\", 89.50, \"2024-03-25\", {})",
    "    manager.add_expense(\"emp003\", \"TRANSPORT\", 45.75, \"2024-03-26\", {})",
    "    manager.add_expense(\"emp003\", \"MEAL\", 60.0, \"2024-03-25\", {\"days\": 2})",
    "    ",
    "    transport_expenses = manager.get_expenses_by_type(\"emp003\", \"TRANSPORT\")",
    "    print(f\"  Transport expenses for emp003: {len(transport_expenses)} found\")",
    "    for exp in transport_expenses:",
    "        print(f\"    - {exp.id}: ${float(exp.amount):.2f}\")",
    "    print()",
    "    ",
    "    # Example 4: Edge case - no expenses",
    "    print(\"-\" * 40)",
    "    print(\"EXAMPLE 4: Edge Cases\")",
    "    print(\"-\" * 40)",
    "    ",
    "    empty_reimbursement = manager.calculate_reimbursement(\"emp_nonexistent\")",
    "    print(f\"  Employee with no expenses: ${empty_reimbursement:.2f}\")",
    "    ",
    "    manager.add_expense(\"emp004\", \"MEAL\", 0.01, \"2024-03-30\", {\"days\": 1})",
    "    min_reimbursement = manager.calculate_reimbursement(\"emp004\")",
    "    print(f\"  Minimum expense ($0.01 meal): ${min_reimbursement:.2f}\")",
    "    print()",
    "    ",
    "    print(\"=\" * 60)",
    "    print(\"DEMO COMPLETE\")",
    "    print(\"=\" * 60)",
    "",
    "",
    "if __name__ == \"__main__\":",
    "    run_demo()"
  ],
  "solution_java_lines": [
    "import java.math.BigDecimal;",
    "import java.math.RoundingMode;",
    "import java.util.*;",
    "",
    "/**",
    " * Travel Expense Calculation System",
    " * ",
    " * A clean OOP implementation using Strategy and Factory patterns",
    " * for calculating employee expense reimbursements.",
    " */",
    "",
    "// =============================================================================",
    "// EXPENSE TYPE ENUM",
    "// =============================================================================",
    "",
    "enum ExpenseType {",
    "    FLIGHT, HOTEL, MEAL, TRANSPORT",
    "}",
    "",
    "// =============================================================================",
    "// EXPENSE CLASS",
    "// =============================================================================",
    "",
    "class Expense {",
    "    private final String id;",
    "    private final ExpenseType type;",
    "    private final BigDecimal amount;",
    "    private final String date;",
    "    private final Map<String, Object> details;",
    "    private final String employeeId;",
    "    ",
    "    public Expense(String id, ExpenseType type, BigDecimal amount,",
    "                   String date, Map<String, Object> details, String employeeId) {",
    "        this.id = id;",
    "        this.type = type;",
    "        this.amount = amount;",
    "        this.date = date;",
    "        this.details = details != null ? details : new HashMap<>();",
    "        this.employeeId = employeeId;",
    "    }",
    "    ",
    "    public String getId() { return id; }",
    "    public ExpenseType getType() { return type; }",
    "    public BigDecimal getAmount() { return amount; }",
    "    public String getDate() { return date; }",
    "    public Map<String, Object> getDetails() { return details; }",
    "    public String getEmployeeId() { return employeeId; }",
    "}",
    "",
    "// =============================================================================",
    "// REIMBURSEMENT STRATEGIES (Strategy Pattern)",
    "// =============================================================================",
    "",
    "interface ReimbursementStrategy {",
    "    BigDecimal calculate(Expense expense);",
    "}",
    "",
    "class FlightReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal POLICY_LIMIT = new BigDecimal(\"1000\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount().min(POLICY_LIMIT);",
    "    }",
    "}",
    "",
    "class HotelReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal NIGHTLY_CAP = new BigDecimal(\"200\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        int nights = (int) expense.getDetails().getOrDefault(\"nights\", 1);",
    "        BigDecimal cappedPerNight = expense.getAmount().min(NIGHTLY_CAP);",
    "        return cappedPerNight.multiply(BigDecimal.valueOf(nights));",
    "    }",
    "}",
    "",
    "class MealReimbursementStrategy implements ReimbursementStrategy {",
    "    private static final BigDecimal DAILY_CAP = new BigDecimal(\"50\");",
    "    private static final BigDecimal REIMBURSEMENT_RATE = new BigDecimal(\"0.5\");",
    "    ",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        int days = (int) expense.getDetails().getOrDefault(\"days\", 1);",
    "        BigDecimal perDay = expense.getAmount().divide(",
    "            BigDecimal.valueOf(days), 10, RoundingMode.HALF_UP);",
    "        BigDecimal reimbursablePerDay = perDay.multiply(REIMBURSEMENT_RATE);",
    "        BigDecimal cappedPerDay = reimbursablePerDay.min(DAILY_CAP);",
    "        return cappedPerDay.multiply(BigDecimal.valueOf(days));",
    "    }",
    "}",
    "",
    "class TransportReimbursementStrategy implements ReimbursementStrategy {",
    "    @Override",
    "    public BigDecimal calculate(Expense expense) {",
    "        return expense.getAmount();",
    "    }",
    "}",
    "",
    "// =============================================================================",
    "// EXPENSE FACTORY (Factory Pattern)",
    "// =============================================================================",
    "",
    "class ExpenseFactory {",
    "    private static int counter = 0;",
    "    ",
    "    public static void resetCounter() {",
    "        counter = 0;",
    "    }",
    "    ",
    "    public static Expense create(String employeeId, String expenseType,",
    "                                  double amount, String date,",
    "                                  Map<String, Object> details) {",
    "        ExpenseType type;",
    "        try {",
    "            type = ExpenseType.valueOf(expenseType.toUpperCase());",
    "        } catch (IllegalArgumentException e) {",
    "            throw new IllegalArgumentException(",
    "                \"Invalid expense type: \" + expenseType);",
    "        }",
    "        ",
    "        counter++;",
    "        String id = \"exp_\" + counter;",
    "        ",
    "        return new Expense(id, type, BigDecimal.valueOf(amount),",
    "                          date, details, employeeId);",
    "    }",
    "}",
    "",
    "// =============================================================================",
    "// EXPENSE MANAGER (Main Service)",
    "// =============================================================================",
    "",
    "public class ExpenseManager {",
    "    private final Map<String, List<Expense>> employeeExpenses;",
    "    private final Map<ExpenseType, ReimbursementStrategy> strategies;",
    "    ",
    "    public ExpenseManager() {",
    "        this.employeeExpenses = new HashMap<>();",
    "        this.strategies = new EnumMap<>(ExpenseType.class);",
    "        ",
    "        // Register strategies",
    "        strategies.put(ExpenseType.FLIGHT, new FlightReimbursementStrategy());",
    "        strategies.put(ExpenseType.HOTEL, new HotelReimbursementStrategy());",
    "        strategies.put(ExpenseType.MEAL, new MealReimbursementStrategy());",
    "        strategies.put(ExpenseType.TRANSPORT, new TransportReimbursementStrategy());",
    "    }",
    "    ",
    "    public String addExpense(String employeeId, String type, double amount,",
    "                             String date, Map<String, Object> details) {",
    "        if (amount <= 0) {",
    "            throw new IllegalArgumentException(\"Amount must be positive\");",
    "        }",
    "        ",
    "        Expense expense = ExpenseFactory.create(",
    "            employeeId, type, amount, date, details);",
    "        ",
    "        employeeExpenses.computeIfAbsent(employeeId, k -> new ArrayList<>())",
    "                       .add(expense);",
    "        ",
    "        return expense.getId();",
    "    }",
    "    ",
    "    public double calculateReimbursement(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(",
    "            employeeId, Collections.emptyList());",
    "        ",
    "        if (expenses.isEmpty()) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        ",
    "        for (Expense expense : expenses) {",
    "            ReimbursementStrategy strategy = strategies.get(expense.getType());",
    "            total = total.add(strategy.calculate(expense));",
    "        }",
    "        ",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    public List<Expense> getExpensesByType(String employeeId, String type) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(",
    "            employeeId, Collections.emptyList());",
    "        ExpenseType targetType = ExpenseType.valueOf(type.toUpperCase());",
    "        ",
    "        List<Expense> result = new ArrayList<>();",
    "        for (Expense e : expenses) {",
    "            if (e.getType() == targetType) {",
    "                result.add(e);",
    "            }",
    "        }",
    "        return result;",
    "    }",
    "    ",
    "    public double getTotalExpenses(String employeeId) {",
    "        List<Expense> expenses = employeeExpenses.getOrDefault(",
    "            employeeId, Collections.emptyList());",
    "        ",
    "        if (expenses.isEmpty()) {",
    "            return 0.0;",
    "        }",
    "        ",
    "        BigDecimal total = BigDecimal.ZERO;",
    "        for (Expense expense : expenses) {",
    "            total = total.add(expense.getAmount());",
    "        }",
    "        ",
    "        return total.setScale(2, RoundingMode.HALF_UP).doubleValue();",
    "    }",
    "    ",
    "    // Demo main method",
    "    public static void main(String[] args) {",
    "        System.out.println(\"=\" .repeat(60));",
    "        System.out.println(\"TRAVEL EXPENSE SYSTEM - JAVA DEMO\");",
    "        System.out.println(\"=\" .repeat(60));",
    "        ",
    "        ExpenseFactory.resetCounter();",
    "        ExpenseManager manager = new ExpenseManager();",
    "        ",
    "        // Add expenses",
    "        Map<String, Object> hotelDetails = new HashMap<>();",
    "        hotelDetails.put(\"nights\", 2);",
    "        ",
    "        Map<String, Object> mealDetails = new HashMap<>();",
    "        mealDetails.put(\"days\", 2);",
    "        ",
    "        String e1 = manager.addExpense(\"emp001\", \"FLIGHT\", 450.0, \"2024-03-15\", null);",
    "        String e2 = manager.addExpense(\"emp001\", \"HOTEL\", 180.0, \"2024-03-15\", hotelDetails);",
    "        String e3 = manager.addExpense(\"emp001\", \"MEAL\", 75.0, \"2024-03-15\", mealDetails);",
    "        String e4 = manager.addExpense(\"emp001\", \"TRANSPORT\", 45.0, \"2024-03-15\", null);",
    "        ",
    "        System.out.println(\"Added expenses: \" + e1 + \", \" + e2 + \", \" + e3 + \", \" + e4);",
    "        ",
    "        double reimbursement = manager.calculateReimbursement(\"emp001\");",
    "        double totalRaw = manager.getTotalExpenses(\"emp001\");",
    "        ",
    "        System.out.printf(\"Total Raw Expenses: $%.2f%n\", totalRaw);",
    "        System.out.printf(\"Total Reimbursement: $%.2f%n\", reimbursement);",
    "        ",
    "        System.out.println(\"\\nDemo Complete!\");",
    "    }",
    "}"
  ],
  "code_walkthrough": [
    {
      "lines": "1-12",
      "section": "Imports and Module Docstring",
      "explanation": "We import `ABC` and `abstractmethod` for the Strategy interface, `Decimal` with `ROUND_HALF_UP` for precise financial math, `dataclass` for clean data classes, and `Enum` for type-safe expense types. The docstring describes the system's purpose."
    },
    {
      "lines": "17-22",
      "section": "ExpenseType Enum",
      "explanation": "Using an Enum instead of raw strings provides **type safety** - the IDE catches typos, and we can't accidentally create invalid types. Each expense type maps to its string representation."
    },
    {
      "lines": "28-45",
      "section": "Expense Dataclass",
      "explanation": "The `@dataclass(frozen=True)` decorator creates an **immutable** expense record. This prevents accidental modification after creation. Fields include all expense data plus employee reference. The docstring explains each attribute."
    },
    {
      "lines": "51-68",
      "section": "ReimbursementStrategy Abstract Base Class",
      "explanation": "This is the **Strategy Pattern interface**. The abstract `calculate()` method must be implemented by all concrete strategies. The ABC (Abstract Base Class) ensures we can't instantiate it directly."
    },
    {
      "lines": "71-83",
      "section": "FlightReimbursementStrategy",
      "explanation": "Simple strategy: return `min(amount, $1000)`. The policy limit is a class constant for easy modification. This demonstrates the **Single Responsibility Principle** - this class only knows about flight reimbursement."
    },
    {
      "lines": "86-104",
      "section": "HotelReimbursementStrategy",
      "explanation": "More complex: get nights from details, apply $200/night cap, multiply by nights. The formula is `min(amount, $200) \u00d7 nights`. Notice how the strategy encapsulates all hotel-specific logic."
    },
    {
      "lines": "107-130",
      "section": "MealReimbursementStrategy",
      "explanation": "Most complex strategy: calculate per-day rate, apply 50% rate, cap at $50/day, multiply by days. Formula: `min((amount/days) \u00d7 0.5, $50) \u00d7 days`. All constants are named for clarity."
    },
    {
      "lines": "133-145",
      "section": "TransportReimbursementStrategy",
      "explanation": "Simplest strategy: return full amount with no cap. Even though it's trivial, having a dedicated strategy maintains **consistency** and makes it easy to add caps later."
    },
    {
      "lines": "151-190",
      "section": "ExpenseFactory (Factory Pattern)",
      "explanation": "The factory **centralizes expense creation**. It handles: (1) ID generation with `_counter`, (2) Type validation converting string to enum, (3) Amount conversion to Decimal. This keeps the Manager clean."
    },
    {
      "lines": "196-220",
      "section": "ExpenseManager.__init__",
      "explanation": "Constructor initializes two data structures: (1) `_employee_expenses` HashMap for O(1) employee lookup, (2) `_strategies` HashMap for O(1) strategy dispatch. All 4 strategies are pre-registered."
    },
    {
      "lines": "222-260",
      "section": "ExpenseManager.add_expense",
      "explanation": "Main entry point for adding expenses. Validates amount, uses Factory to create expense, initializes employee's list if needed, appends expense. Returns the generated ID. O(1) complexity."
    },
    {
      "lines": "262-295",
      "section": "ExpenseManager.calculate_reimbursement",
      "explanation": "**Core algorithm**: iterate expenses, look up correct strategy, accumulate total using Decimal. Final rounding to 2 decimal places with HALF_UP. Returns float for API compatibility."
    },
    {
      "lines": "297-315",
      "section": "get_expenses_by_type and get_total_expenses",
      "explanation": "Filter and sum operations. `get_expenses_by_type` uses list comprehension for filtering. `get_total_expenses` sums raw amounts without policy application. Both handle empty employee gracefully."
    },
    {
      "lines": "321-400",
      "section": "Demo Function",
      "explanation": "Comprehensive demonstration with formatted output showing reimbursement breakdown. Tests multiple expense types, policy caps, filtering, and edge cases. Includes ASCII table for visual clarity."
    }
  ],
  "debugging_strategy": {
    "how_to_test_incrementally": "1. Test ExpenseFactory.create() with valid and invalid types\n2. Test each Strategy in isolation with known values\n3. Test add_expense stores correctly\n4. Test calculateReimbursement with single expense type\n5. Test with mixed types\n6. Test edge cases (empty, minimum, caps)",
    "what_to_print_or_assert": [
      "print(f\"Strategy {type}: calculated {result} for amount {amount}\")",
      "assert manager.get_total_expenses(emp) == sum_of_amounts",
      "print(f\"Decimal intermediate: {total} before rounding\")",
      "assert abs(result - expected) < 0.01, f\"Expected {expected}, got {result}\""
    ],
    "common_failure_modes": [
      "**Float precision**: Using `float` instead of `Decimal` causes 0.1+0.1+0.1 \u2260 0.3",
      "**Wrong policy application**: Applying meal cap to flight, or forgetting nights multiplier",
      "**Rounding too early**: Rounding each expense before summing loses precision",
      "**Missing strategy**: Forgetting to register a strategy causes KeyError",
      "**Integer division**: Using // instead of / for days/nights calculation"
    ],
    "how_to_fix_fast": "1. **Trace one expense through**: Print at each step of calculate()\n2. **Check strategy mapping**: Print strategies dict to verify all types registered\n3. **Verify Decimal usage**: Add type() check to ensure not using float\n4. **Unit test each strategy**: Test FlightStrategy with $500, $1000, $1500"
  },
  "complexity_analysis": {
    "time": {
      "add_expense": {
        "complexity": "O(1)",
        "explanation": "HashMap lookup + list append + Factory creation are all constant time"
      },
      "calculate_reimbursement": {
        "complexity": "O(n)",
        "explanation": "Must iterate all n expenses for the employee, each calculation is O(1)"
      },
      "get_expenses_by_type": {
        "complexity": "O(n)",
        "explanation": "Linear scan through all expenses to filter by type"
      },
      "get_total_expenses": {
        "complexity": "O(n)",
        "explanation": "Sum requires visiting all n expenses"
      },
      "overall": "addExpense: O(1), all queries: O(n) where n = expenses per employee"
    },
    "space": {
      "complexity": "O(E) where E = total expenses across all employees",
      "breakdown": "- Employee HashMap: O(K) where K = number of employees\n- Expense lists: O(E) total\n- Strategies: O(1) - only 4 strategy objects\n- Each Expense object: O(1) fixed size",
      "note": "Space is proportional to stored data, no additional overhead"
    },
    "can_we_do_better": "**Time**: For calculateReimbursement, we could maintain running totals per type for O(1) query, but this adds complexity and isn't required. **Space**: Already optimal - we need to store expenses for getExpensesByType."
  },
  "dry_run": {
    "example": "ExpenseManager(), addExpense(emp001, FLIGHT, 450), addExpense(emp001, HOTEL, 180, nights=2), calculateReimbursement(emp001)",
    "trace_table": "| Step | Operation | _employee_expenses | Action | Result |\n|------|-----------|-------------------|--------|--------|\n| 1 | ExpenseManager() | {} | Init strategies map | \u2713 |\n| 2 | addExpense(emp001, FLIGHT, 450, ...) | {emp001: []} | Factory creates exp_1 | \"exp_1\" |\n| 2 | (continued) | {emp001: [exp_1]} | Append to list | \u2713 |\n| 3 | addExpense(emp001, HOTEL, 180, {nights:2}) | {emp001: [exp_1, exp_2]} | Factory creates exp_2 | \"exp_2\" |\n| 4 | calculateReimbursement(emp001) | - | Get expenses list | [exp_1, exp_2] |\n| 4 | exp_1 (FLIGHT) | - | FlightStrategy.calculate(450) | min(450, 1000) = 450 |\n| 4 | exp_2 (HOTEL) | - | HotelStrategy.calculate(180, 2n) | min(180, 200) \u00d7 2 = 360 |\n| 4 | Sum | - | 450 + 360 = 810 | round(810.00) = 810.00 |\n| 4 | Return | - | float(Decimal('810.00')) | **810.0** |",
    "final_answer": "810.0"
  },
  "test_cases": [
    {
      "name": "Basic - Single flight under limit",
      "category": "Happy Path",
      "input": "addExpense(emp001, FLIGHT, 500, ...), calculateReimbursement(emp001)",
      "expected": "500.00",
      "explanation": "Flight $500 is under $1000 limit, 100% reimbursed"
    },
    {
      "name": "Flight at exact policy limit",
      "category": "Boundary",
      "input": "addExpense(emp001, FLIGHT, 1000, ...), calculateReimbursement(emp001)",
      "expected": "1000.00",
      "explanation": "Exactly at limit should still be fully reimbursed"
    },
    {
      "name": "Flight over policy limit",
      "category": "Policy Cap",
      "input": "addExpense(emp001, FLIGHT, 1500, ...), calculateReimbursement(emp001)",
      "expected": "1000.00",
      "explanation": "Capped at $1000 policy limit"
    },
    {
      "name": "Hotel under nightly cap",
      "category": "Happy Path",
      "input": "addExpense(emp001, HOTEL, 150, {nights:3}), calculateReimbursement(emp001)",
      "expected": "450.00",
      "explanation": "$150/night \u00d7 3 = $450, all under $200 cap"
    },
    {
      "name": "Hotel over nightly cap",
      "category": "Policy Cap",
      "input": "addExpense(emp001, HOTEL, 300, {nights:2}), calculateReimbursement(emp001)",
      "expected": "400.00",
      "explanation": "min($300, $200) \u00d7 2 = $400"
    },
    {
      "name": "Meal with 50% calculation",
      "category": "Happy Path",
      "input": "addExpense(emp001, MEAL, 80, {days:2}), calculateReimbursement(emp001)",
      "expected": "40.00",
      "explanation": "$80/2 days = $40/day, 50% = $20/day, \u00d7 2 = $40"
    },
    {
      "name": "Meal hitting daily cap",
      "category": "Policy Cap",
      "input": "addExpense(emp001, MEAL, 300, {days:3}), calculateReimbursement(emp001)",
      "expected": "150.00",
      "explanation": "$100/day \u00d7 50% = $50/day (capped), \u00d7 3 = $150"
    },
    {
      "name": "Transport no limit",
      "category": "Happy Path",
      "input": "addExpense(emp001, TRANSPORT, 500, ...), calculateReimbursement(emp001)",
      "expected": "500.00",
      "explanation": "100% reimbursed, no cap"
    },
    {
      "name": "Empty employee",
      "category": "Edge Case",
      "input": "calculateReimbursement(emp_nonexistent)",
      "expected": "0.00",
      "explanation": "No expenses = $0 reimbursement"
    },
    {
      "name": "Minimum amount precision",
      "category": "Precision",
      "input": "addExpense(emp001, MEAL, 0.01, {days:1}), calculateReimbursement(emp001)",
      "expected": "0.01",
      "explanation": "$0.01 \u00d7 50% = $0.005 \u2192 rounds to $0.01 (HALF_UP)"
    },
    {
      "name": "Float precision trap",
      "category": "Gotcha",
      "input": "3 transport expenses of $0.10 each",
      "expected": "0.30",
      "gotcha": "Using float: 0.1+0.1+0.1=0.30000000000000004. Must use Decimal."
    },
    {
      "name": "Multiple expense types",
      "category": "Integration",
      "input": "FLIGHT:450 + HOTEL:180\u00d72n + MEAL:75\u00d72d + TRANSPORT:45",
      "expected": "892.50",
      "explanation": "$450 + $360 + $37.50 + $45 = $892.50"
    }
  ],
  "common_mistakes": [
    {
      "mistake": "Using float/double for currency",
      "why_wrong": "`0.1 + 0.1 + 0.1` in floating point equals `0.30000000000000004`, not `0.3`. Over many transactions, these errors compound.",
      "correct_approach": "Use `Decimal` (Python) or `BigDecimal` (Java) with explicit string initialization",
      "code_wrong": "total = 0.0\\nfor e in expenses:\\n    total += e.amount  # float addition",
      "code_correct": "total = Decimal('0')\\nfor e in expenses:\\n    total += Decimal(str(e.amount))  # Decimal addition"
    },
    {
      "mistake": "Giant if-else for expense types",
      "why_wrong": "Violates Open/Closed Principle. Adding new expense type requires modifying existing code. Hard to test individual calculations.",
      "correct_approach": "Strategy Pattern - each expense type is a separate class",
      "code_wrong": "if type == 'FLIGHT':\\n    return min(amt, 1000)\\nelif type == 'HOTEL':\\n    ...",
      "code_correct": "strategy = self._strategies[expense.type]\\nreturn strategy.calculate(expense)"
    },
    {
      "mistake": "Forgetting to multiply by nights/days",
      "why_wrong": "Hotel and Meal policies apply PER UNIT. Forgetting the multiplier gives wrong total.",
      "correct_approach": "Always multiply capped per-unit amount by units",
      "code_wrong": "# Hotel\\nreturn min(expense.amount, Decimal('200'))  # Missing \u00d7 nights",
      "code_correct": "nights = expense.details.get('nights', 1)\\nreturn min(expense.amount, Decimal('200')) * Decimal(nights)"
    },
    {
      "mistake": "Rounding each expense instead of total",
      "why_wrong": "Rounding each expense before summing compounds rounding errors. Round only the final result.",
      "correct_approach": "Sum all expenses with full precision, round once at the end",
      "code_wrong": "for e in expenses:\\n    total += round(calculate(e), 2)  # Rounds each expense",
      "code_correct": "for e in expenses:\\n    total += calculate(e)  # Full precision\\nreturn round(total, 2)  # Round once"
    },
    {
      "mistake": "Not validating expense type",
      "why_wrong": "Invalid type causes KeyError when looking up strategy. Should fail fast with clear message.",
      "correct_approach": "Validate in Factory and throw descriptive exception",
      "code_wrong": "type = ExpenseType(expense_type)  # Crashes on invalid type",
      "code_correct": "try:\\n    type = ExpenseType(expense_type)\\nexcept ValueError:\\n    raise ValueError(f'Invalid type: {expense_type}')"
    }
  ],
  "interview_tips": {
    "opening": "Thank you for this problem. Before I start coding, I'd like to clarify a few things about the requirements and share my high-level approach.",
    "clarifying_questions_to_ask": [
      "For hotel, is the amount parameter per-night or total? (Critical for calculation)",
      "What precision is required? Should I use BigDecimal for currency?",
      "What should happen for invalid expense types - return null or throw exception?",
      "Are there concurrent access requirements?",
      "Should expense IDs be globally unique or per-employee?"
    ],
    "what_to_mention_proactively": [
      "I'll use the **Strategy Pattern** for different expense calculations - this makes adding new types easy",
      "I'll use **Decimal/BigDecimal** for financial precision - float causes 0.1+0.1+0.1 \u2260 0.3",
      "I'll use a **Factory** for expense creation to centralize ID generation",
      "Let me draw a quick diagram of the class structure"
    ],
    "communication_during_coding": [
      "I'm creating the Strategy interface first - this is the core of the pattern",
      "Notice each strategy is self-contained - easy to test in isolation",
      "I'm using a HashMap for O(1) strategy lookup by expense type",
      "I'm keeping the Manager lean - it just orchestrates, doesn't calculate"
    ],
    "if_stuck": [
      "Step back: What are the varying parts? \u2192 Calculation logic per type \u2192 Strategy Pattern",
      "Ask: What's the data structure? \u2192 Expenses per employee \u2192 HashMap<String, List>",
      "Draw: Class diagram showing relationships"
    ],
    "time_management": "0-5min: Clarify & draw | 5-10min: Class structure | 10-30min: Code | 30-40min: Test | 40-45min: Discuss extensions"
  },
  "pattern_recognition": {
    "pattern_name": "Strategy Pattern + Factory Pattern",
    "indicators": [
      "Different types with different behaviors (expense types \u2192 different calculations)",
      "Need to add new types without modifying existing code (Open/Closed)",
      "Each behavior is self-contained and testable (Single Responsibility)",
      "Object creation has non-trivial logic (ID generation \u2192 Factory)"
    ],
    "similar_problems": [
      "**Payment Processing System** - Different payment methods (Credit, Debit, PayPal) with different fee calculations",
      "**Shipping Cost Calculator** - Different carriers (FedEx, UPS, USPS) with different pricing",
      "**Tax Calculator** - Different tax rates per state/country",
      "**Notification System** - Different channels (Email, SMS, Push) with different formatting"
    ],
    "template": "1. Define Strategy interface with calculate() method\\n2. Implement concrete strategy per type\\n3. Use HashMap<Type, Strategy> for O(1) dispatch\\n4. Manager holds strategies, delegates calculations"
  },
  "follow_up_preparation": {
    "part_2_hint": "**Multi-Currency Support** will require: (1) Currency field on Expense, (2) Exchange rate service, (3) Modified strategies that convert to base currency. The clean separation means we can add a CurrencyConverter service without touching existing strategies.",
    "part_3_hint": "**Location-based Per-Diems** will need: (1) Location field on Expense, (2) Per-diem rate lookup by location, (3) MealStrategy modified to use location rates. Could use decorator pattern on existing MealStrategy.",
    "data_structure_evolution": "**Part 1**: HashMap + List + Strategy\\n**Part 2**: Add Currency enum, ExchangeRateService\\n**Part 3**: Add Location class, PerDiemRateService, possibly TreeMap for date-range lookups"
  },
  "communication_script": {
    "opening_verbatim": "Thank you for this problem. I can see this is about designing an expense reimbursement system with different policies per expense type. Before I start, I'd like to ask a few clarifying questions and share my approach.",
    "after_clarification": "Great, so to summarize: we need to support 4 expense types with different reimbursement rules, use Decimal for precision, and design for extensibility. I'll use the Strategy Pattern for the different calculations and a Factory for expense creation. Does that sound right?",
    "while_coding": [
      "I'm defining the Strategy interface first - this is the core abstraction...",
      "Each concrete strategy encapsulates one expense type's rules...",
      "The Manager doesn't know HOW to calculate - it just delegates to the right strategy..."
    ],
    "after_coding": "Let me trace through an example to verify it works. If we add a $450 flight and a $180/night hotel for 2 nights...",
    "when_stuck_verbatim": "I'm thinking about how to structure this... The key insight is that the calculation logic varies by type, so Strategy Pattern makes sense here...",
    "after_mistake": "Actually, I see I forgot to multiply by the number of nights. Let me fix that - the formula should be capped_rate \u00d7 nights.",
    "before_moving_on": "This handles Part 1 with O(1) addExpense and O(n) queries. The design is extensible - adding a new expense type just means creating a new Strategy class. Ready for Part 2?"
  },
  "interviewer_perspective": {
    "what_they_evaluate": [
      "**OOP Design** - Do they use appropriate patterns? Is the code modular?",
      "**Communication** - Do they explain their thinking? Ask good questions?",
      "**Precision** - Do they mention Decimal/BigDecimal for money?",
      "**Extensibility** - Does the design allow adding new expense types easily?",
      "**Testing instinct** - Do they trace through examples? Consider edge cases?"
    ],
    "bonus_points": [
      "Drawing a class diagram before coding",
      "Mentioning SOLID principles by name",
      "Proactively discussing Decimal precision",
      "Considering edge cases without being asked",
      "Writing clean code with good naming on first pass"
    ],
    "red_flags": [
      "Giant if-else chain for expense types",
      "Using float for money without acknowledging precision issues",
      "Not asking any clarifying questions",
      "Coding silently for extended periods",
      "Not testing after implementation"
    ],
    "what_differentiates_strong_candidates": "Strong candidates **think out loud**, explaining WHY they're making design decisions. They **draw diagrams** to clarify their thinking. They **mention patterns by name** (Strategy, Factory) showing design vocabulary. They **proactively address precision** for financial calculations. They treat the interview as a collaborative design session, not an adversarial test."
  },
  "time_milestones": {
    "by_5_min": "Problem understood, key questions asked (precision? per-unit vs total?), approach sketched",
    "by_10_min": "Class structure designed, Strategy pattern explained, interviewer buy-in obtained",
    "by_20_min": "Core classes implemented (Expense, Strategies, Factory stub)",
    "by_30_min": "ExpenseManager implemented, basic testing started",
    "by_40_min": "Edge cases handled, dry run complete, complexity discussed",
    "by_45_min": "Part 1 complete, ready for follow-up",
    "warning_signs": "If still clarifying at 10 min or still coding core at 35 min, speed up or simplify."
  },
  "recovery_strategies": {
    "when_you_make_a_bug": "Don't panic. Say: 'I see an issue here - I forgot to multiply by nights. Let me fix that.' Fix it, briefly explain, move on. Bugs are expected; handling them calmly shows maturity.",
    "when_you_dont_know_syntax": "Say: 'I don't remember the exact syntax for Enum in Python, but I need a type-safe way to represent expense types. Let me write it as I remember and we can correct if needed.'",
    "when_approach_is_wrong": "Say: 'Actually, I realize a giant if-else won't scale for new types. Let me refactor to Strategy pattern.' Pivoting cleanly shows design thinking.",
    "when_completely_stuck": "Say: 'I'm stuck on how to structure the meal calculation. Could you clarify if the amount is per-day or total?' Asking for help shows self-awareness.",
    "when_running_out_of_time": "Say: 'I'm running low on time. Let me implement the core and explain what I'd add. The remaining strategies follow the same pattern as Flight.'"
  },
  "ai_copilot_tips": {
    "when_using_cursor_or_copilot": "Rippling allows AI tools. Use them strategically - they should accelerate, not replace your thinking.",
    "what_to_do": [
      "Use AI to generate boilerplate (dataclass, enum)",
      "Use AI for syntax you forgot (Decimal rounding)",
      "Use AI to generate test cases",
      "Let it autocomplete obvious patterns"
    ],
    "what_not_to_do": [
      "Don't paste the entire problem and ask for solution",
      "Don't accept suggestions without understanding them",
      "Don't let AI drive your architecture - YOU decide patterns",
      "Don't use AI for the 'key insight' - that's what they're testing"
    ],
    "how_to_demonstrate_understanding": "When AI suggests code, explain WHY it works. 'Copilot suggested using ROUND_HALF_UP - that's correct because it's the standard rounding for financial calculations.'",
    "expectation_adjustment": "If you're using AI, you're expected to complete MORE. If you're slower with AI, don't use it."
  },
  "signal_points": {
    "wow_factors": [
      "Drawing a UML class diagram before coding",
      "Mentioning 'Strategy Pattern' and 'Open/Closed Principle' naturally",
      "Saying 'I'll use Decimal because float has precision issues'",
      "Proactively saying 'Let me trace through an example'",
      "Writing clean code with good names on first pass"
    ],
    "subtle_signals_of_experience": [
      "Using `@dataclass(frozen=True)` for immutability",
      "Using `Enum` instead of string constants",
      "Considering what happens with invalid input",
      "Separating factory from manager",
      "Testing incrementally during development"
    ]
  },
  "red_flags_to_avoid": {
    "behavioral": [
      "Silent coding for more than 30 seconds",
      "Getting defensive when issues are pointed out",
      "Not making eye contact / disengaged",
      "Blaming ambiguous requirements"
    ],
    "technical": [
      "Using float for money (instant red flag)",
      "Giant if-else instead of Strategy pattern",
      "Hardcoding values that should be configurable",
      "Not validating inputs"
    ],
    "communication": [
      "Not asking any clarifying questions",
      "Jumping to code without explaining approach",
      "Using jargon without explanation",
      "Not summarizing before moving on"
    ]
  },
  "final_checklist": {
    "before_saying_done": [
      "\u2705 All 5 methods implemented (init, add, calculate, getByType, getTotal)",
      "\u2705 Strategy pattern used for expense calculations",
      "\u2705 Factory pattern for expense creation with ID",
      "\u2705 Decimal precision for all financial math",
      "\u2705 Edge cases handled (empty employee, invalid type)",
      "\u2705 At least one example traced through",
      "\u2705 Complexity discussed (O(1) add, O(n) queries)"
    ],
    "quick_code_review": [
      "No magic numbers (policy limits are constants)",
      "Consistent naming (snake_case in Python, camelCase in Java)",
      "Proper indentation",
      "Type hints on all methods",
      "Docstrings on public methods"
    ]
  },
  "production_considerations": {
    "what_id_add_in_production": [
      "**Input validation** with descriptive error messages",
      "**Logging** for audit trail (who submitted what when)",
      "**Thread safety** if concurrent access is possible",
      "**Configuration** for policy limits (not hardcoded)",
      "**Database persistence** for expenses",
      "**API rate limiting** to prevent abuse"
    ],
    "why_not_in_interview": "Keep interview code focused on demonstrating design skills. Over-engineering with production features wastes time and obscures the core logic.",
    "how_to_mention": "Say: 'In production, I'd add logging for audit compliance, configuration for policy limits, and persistence. For this interview, I'll focus on the core design.'"
  },
  "generated_at": "2026-01-18T19:02:58.106349",
  "_meta": {
    "problem_id": "travel_expense_calculation",
    "part_number": null,
    "model": "claude-opus-4-5-20251101"
  }
}